{
    "spiral-matrix": [
        {
            "task_id": "spiral-matrix",
            "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1\n        res = []\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n                \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n                \n        return res"
        },
        {
            "task_id": "spiral-matrix",
            "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n        result = []\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n                \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n                \n        return result"
        },
        {
            "task_id": "spiral-matrix",
            "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1\n        res = []\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n                \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n                \n        return res"
        },
        {
            "task_id": "spiral-matrix",
            "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n        result = []\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n                \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n                \n        return result"
        },
        {
            "task_id": "spiral-matrix",
            "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n        result = []\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n                \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n                \n        return result"
        }
    ],
    "summary-ranges": [
        {
            "task_id": "summary-ranges",
            "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        res = []\n        start = nums[0]\n        for i in range(len(nums)-1):\n            if nums[i+1] != nums[i]+1:\n                if start == nums[i]:\n                    res.append(str(start))\n                else:\n                    res.append(str(start)+\"->\"+str(nums[i]))\n                start = nums[i+1]\n        if start == nums[-1]:\n            res.append(str(start))\n        else:\n            res.append(str(start)+\"->\"+str(nums[-1]))\n        return res"
        },
        {
            "task_id": "summary-ranges",
            "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"
        },
        {
            "task_id": "summary-ranges",
            "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + '->' + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + '->' + str(end))\n        \n        return res"
        },
        {
            "task_id": "summary-ranges",
            "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + '->' + str(end))\n                start = nums[i]\n                end = nums[i]\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + '->' + str(end))\n        return res"
        },
        {
            "task_id": "summary-ranges",
            "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + '->' + str(end))\n                start = nums[i]\n                end = nums[i]\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + '->' + str(end))\n        return res"
        }
    ],
    "distinct-subsequences": [
        {
            "task_id": "distinct-subsequences",
            "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [[0 for i in range(len(t)+1)] for j in range(len(s)+1)]\n        \n        # Initialize the first row and column with 1\n        for i in range(len(s)+1):\n            dp[i][0] = 1\n            \n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j]\n                    \n        return dp[len(s)][len(t)]"
        },
        {
            "task_id": "distinct-subsequences",
            "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for i in range(len(t)+1)] for j in range(len(s)+1)]\n        \n        for i in range(len(s)+1):\n            dp[i][0] = 1\n            \n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j]\n                    \n        return dp[len(s)][len(t)]"
        },
        {
            "task_id": "distinct-subsequences",
            "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [[0 for i in range(len(t)+1)] for j in range(len(s)+1)]\n        \n        # Initialize the first row and column\n        for i in range(len(s)+1):\n            dp[i][0] = 1\n            \n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j]\n                    \n        return dp[len(s)][len(t)]"
        },
        {
            "task_id": "distinct-subsequences",
            "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [[0 for i in range(len(t)+1)] for j in range(len(s)+1)]\n        \n        # Initialize the first row and column with 1\n        for i in range(len(s)+1):\n            dp[i][0] = 1\n            \n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j]\n                    \n        return dp[len(s)][len(t)]"
        },
        {
            "task_id": "distinct-subsequences",
            "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for i in range(len(t)+1)] for j in range(len(s)+1)]\n        \n        for i in range(len(s)+1):\n            dp[i][0] = 1\n            \n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j]\n                    \n        return dp[len(s)][len(t)]"
        }
    ],
    "first-missing-positive": [
        {
            "task_id": "first-missing-positive",
            "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Check if the first element is not 1\n        if nums[0] != 1:\n            return 1\n        \n        # 3. Check if the last element is not equal to the length of the array\n        if nums[-1] != len(nums):\n            return len(nums)\n        \n        # 4. Check if the array is sorted\n        for i in range(1, len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        # 5. If the array is sorted and the last element is equal to the length of the array, return the length of the array + 1\n        return len(nums) + 1"
        },
        {
            "task_id": "first-missing-positive",
            "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # O(n) time and O(1) space\n        \n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[i] != nums[nums[i]-1]:\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n                \n        for i in range(n):\n            if i+1 != nums[i]:\n                return i+1\n        return n+1"
        },
        {
            "task_id": "first-missing-positive",
            "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Check if the first element is not 1\n        if nums[0] != 1:\n            return 1\n        \n        # 3. Check if the last element is not equal to the length of the array\n        if nums[-1] != len(nums):\n            return len(nums)\n        \n        # 4. Check if the array is sorted\n        for i in range(1, len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        # 5. If the array is sorted and the last element is equal to the length of the array, return the length of the array + 1\n        return len(nums) + 1"
        },
        {
            "task_id": "first-missing-positive",
            "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # O(n) time and O(1) space\n        \n        # 1. if the length of the array is 0, return 1\n        if len(nums) == 0:\n            return 1\n        \n        # 2. if the length of the array is 1, return 2\n        if len(nums) == 1:\n            return 2\n        \n        # 3. if the length of the array is 2, return 3\n        if len(nums) == 2:\n            return 3\n        \n        # 4. if the length of the array is 3, return 4\n        if len(nums) == 3:\n            return 4\n        \n        # 5. if the length of the array is 4, return 5\n        if len(nums) == 4:\n            return 5\n        \n        # 6. if the length of the array is 5, return 6\n        if len(nums) == 5:\n            return 6\n        \n        # 7. if the length of the array is 6, return 7\n        if len(nums) == 6:\n            return 7\n        \n        # 8. if the length of the array is 7, return 8\n        if len(nums) == 7:\n            return 8\n        \n        # 9. if the length of the array is 8, return 9\n        if len(nums) == 8:\n            return 9\n        \n        # 10. if the length of the array is 9, return 10\n        if len(nums) == 9:\n            return 10\n        \n        # 11. if the length of the array is 10, return 11\n        if len(nums) == 10:\n            return 11\n        \n        # 12. if the length of the array is 11, return 12\n        if len(nums) == 11:\n            return 12\n        \n        # 13. if the length of the array is 12, return 13\n        if len(nums) == 12:\n            return 13\n        \n        # 14. if the length of the array is 13, return 14\n        if len(nums) == 13:\n            return 14\n        \n        # 15. if the length of the array is 14, return 15\n        if len(nums) == 14:\n            return 15\n        \n        # 16. if the length of the array is 15, return 16\n        if len(nums) == 15:\n            return 16\n        \n        # 17. if the length of the array is 16, return 17\n        if len(nums) == 16:\n            return 17\n        \n        # 18. if the length of the array is 17, return 18\n        if len(nums) == 17:\n            return 18\n        \n        # 19. if the length of the array is 18, return 19\n        if len(nums) == 18:\n            return 19\n        \n        # 20. if the length of the array is 19, return 20\n        if len(nums) == 19:\n            return 20\n        \n        # 21. if the length of the array is 20, return 21\n        if len(nums) == 20:\n            return 21\n        \n        # 22. if the length of the array is 21, return 22\n        if len(nums) == 21:\n            return 22\n        \n        # 23. if the length of the array is 22, return 23\n        if len(nums) == 22:\n            return 23\n        \n        # 24. if the length of the array is 23, return 24\n        if len(nums) == 23:\n            return 24\n        \n        # 25. if the length of the array is 24, return 25"
        },
        {
            "task_id": "first-missing-positive",
            "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Check if the first element is not 1\n        if nums[0] != 1:\n            return 1\n        \n        # 3. Check if the last element is not equal to the length of the array\n        if nums[-1] != len(nums):\n            return len(nums)\n        \n        # 4. Check if there is any missing positive integer\n        for i in range(1, len(nums)):\n            if nums[i] - nums[i-1] != 1:\n                return nums[i-1] + 1\n        \n        # 5. If the array is sorted and there is no missing positive integer, return the length of the array + 1\n        return len(nums) + 1"
        }
    ],
    "permutation-sequence": [
        {
            "task_id": "permutation-sequence",
            "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        def factorial(n):\n            if n == 0:\n                return 1\n            else:\n                return n * factorial(n-1)\n        \n        def get_permutation(n, k):\n            if n == 1:\n                return str(k)\n            else:\n                f = factorial(n-1)\n                index = (k-1) // f\n                rem = (k-1) % f\n                return str(index+1) + get_permutation(n-1, rem+1)\n        \n        return get_permutation(n, k)"
        },
        {
            "task_id": "permutation-sequence",
            "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        def factorial(n):\n            if n == 0:\n                return 1\n            else:\n                return n * factorial(n-1)\n        \n        def get_permutation(n, k):\n            if n == 1:\n                return '1'\n            else:\n                f = factorial(n-1)\n                index = (k-1) // f\n                digit = str(index+1)\n                rest = k - index * f\n                return digit + get_permutation(n-1, rest)\n        \n        return get_permutation(n, k)"
        },
        {
            "task_id": "permutation-sequence",
            "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        def factorial(n):\n            if n == 0:\n                return 1\n            else:\n                return n * factorial(n-1)\n        \n        def get_permutation(n, k):\n            if n == 1:\n                return '1'\n            else:\n                f = factorial(n-1)\n                index = (k-1) // f\n                digit = str(index+1)\n                rest = k - index * f\n                return digit + get_permutation(n-1, rest)\n        \n        return get_permutation(n, k)"
        },
        {
            "task_id": "permutation-sequence",
            "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the list with numbers from 1 to n\n        nums = list(range(1, n+1))\n        \n        # Initialize the result string\n        result = \"\"\n        \n        # Loop until all numbers are used up\n        while nums:\n            \n            # Get the factorial of the remaining numbers\n            fact = math.factorial(len(nums)-1)\n            \n            # If k is greater than the current factorial\n            if k > fact:\n                \n                # Subtract the current factorial from k\n                k -= fact\n                \n            # If k is equal to the current factorial\n            else:\n                \n                # Add the first number to the result\n                result += str(nums[0])\n                \n                # Remove the first number\n                nums.pop(0)\n                \n                # Reset k to 1\n                k = 1\n        \n        # Return the result\n        return result"
        },
        {
            "task_id": "permutation-sequence",
            "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        def factorial(n):\n            if n == 0:\n                return 1\n            else:\n                return n * factorial(n-1)\n        \n        def get_permutation(n, k):\n            if n == 1:\n                return str(k)\n            else:\n                f = factorial(n-1)\n                index = (k-1) // f\n                rem = (k-1) % f\n                return str(index+1) + get_permutation(n-1, rem+1)\n        \n        return get_permutation(n, k)"
        }
    ],
    "two-sum-ii-input-array-is-sorted": [
        {
            "task_id": "two-sum-ii-input-array-is-sorted",
            "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize two pointers\n        left = 0\n        right = len(numbers) - 1\n        \n        # Loop until the pointers meet\n        while left < right:\n            \n            # Sum of the two elements at the pointers\n            current_sum = numbers[left] + numbers[right]\n            \n            # If the sum is equal to the target\n            if current_sum == target:\n                \n                # Return the indices of the elements\n                return [left + 1, right + 1]\n            \n            # If the sum is less than the target\n            elif current_sum < target:\n                \n                # Increment the left pointer\n                left += 1\n            \n            # If the sum is greater than the target\n            else:\n                \n                # Decrement the right pointer\n                right -= 1"
        },
        {
            "task_id": "two-sum-ii-input-array-is-sorted",
            "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize two pointers\n        left = 0\n        right = len(numbers) - 1\n        \n        # Loop until the pointers meet\n        while left < right:\n            \n            # Sum of the two elements at the pointers\n            current_sum = numbers[left] + numbers[right]\n            \n            # If the sum is equal to the target\n            if current_sum == target:\n                return [left + 1, right + 1]\n            \n            # If the sum is less than the target\n            elif current_sum < target:\n                left += 1\n            \n            # If the sum is greater than the target\n            else:\n                right -= 1"
        },
        {
            "task_id": "two-sum-ii-input-array-is-sorted",
            "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize two pointers\n        left = 0\n        right = len(numbers) - 1\n        \n        # Loop until the pointers meet\n        while left < right:\n            \n            # Sum of the two elements at the pointers\n            current_sum = numbers[left] + numbers[right]\n            \n            # If the sum is equal to the target\n            if current_sum == target:\n                \n                # Return the indices of the elements\n                return [left + 1, right + 1]\n            \n            # If the sum is less than the target\n            elif current_sum < target:\n                \n                # Increment the left pointer\n                left += 1\n            \n            # If the sum is greater than the target\n            else:\n                \n                # Decrement the right pointer\n                right -= 1"
        },
        {
            "task_id": "two-sum-ii-input-array-is-sorted",
            "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize two pointers\n        left = 0\n        right = len(numbers) - 1\n        \n        # Loop until the pointers meet\n        while left < right:\n            \n            # Sum of the two elements at the pointers\n            current_sum = numbers[left] + numbers[right]\n            \n            # If the sum is equal to the target\n            if current_sum == target:\n                \n                # Return the indices of the elements\n                return [left + 1, right + 1]\n            \n            # If the sum is less than the target\n            elif current_sum < target:\n                \n                # Increment the left pointer\n                left += 1\n            \n            # If the sum is greater than the target\n            else:\n                \n                # Decrement the right pointer\n                right -= 1"
        },
        {
            "task_id": "two-sum-ii-input-array-is-sorted",
            "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize two pointers\n        left = 0\n        right = len(numbers) - 1\n        \n        # Loop until the pointers meet\n        while left < right:\n            \n            # Sum of the two elements at the pointers\n            current_sum = numbers[left] + numbers[right]\n            \n            # If the sum is equal to the target\n            if current_sum == target:\n                \n                # Return the indices of the elements\n                return [left + 1, right + 1]\n            \n            # If the sum is less than the target\n            elif current_sum < target:\n                \n                # Increment the left pointer\n                left += 1\n            \n            # If the sum is greater than the target\n            else:\n                \n                # Decrement the right pointer\n                right -= 1"
        }
    ],
    "expression-add-operators": [
        {
            "task_id": "expression-add-operators",
            "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, prev, res, path, idx):\n            if idx == len(num):\n                if prev == target:\n                    res.append(path)\n                return\n            \n            for i in range(idx, len(num)):\n                if i != idx and num[idx] == '0':\n                    break\n                val = int(num[idx:i+1])\n                if idx == 0:\n                    dfs(num, target, val, res, str(val), i+1)\n                else:\n                    dfs(num, target, prev+val, res, path + '+' + str(val), i+1)\n                    dfs(num, target, prev-val, res, path + '-' + str(val), i+1)\n                    dfs(num, target, prev*val, res, path + '*' + str(val), i+1)\n        \n        res = []\n        dfs(num, target, 0, res, \"\", 0)\n        return res"
        },
        {
            "task_id": "expression-add-operators",
            "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, prev, res, path, idx):\n            if idx == len(num):\n                if prev == target:\n                    res.append(path)\n                return\n            \n            for i in range(idx, len(num)):\n                if i != idx and num[idx] == '0':\n                    break\n                val = int(num[idx:i+1])\n                if idx == 0:\n                    dfs(num, target, val, res, str(val), i+1)\n                else:\n                    dfs(num, target, prev+val, res, path + '+' + str(val), i+1)\n                    dfs(num, target, prev-val, res, path + '-' + str(val), i+1)\n                    dfs(num, target, prev*val, res, path + '*' + str(val), i+1)\n        \n        res = []\n        dfs(num, target, 0, res, \"\", 0)\n        return res"
        },
        {
            "task_id": "expression-add-operators",
            "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, prev, res, path, idx):\n            if idx == len(num):\n                if prev == target:\n                    res.append(path)\n                return\n            \n            for i in range(idx, len(num)):\n                if i != idx and num[idx] == '0':\n                    break\n                val = int(num[idx:i+1])\n                if idx == 0:\n                    dfs(num, target, val, res, str(val), i+1)\n                else:\n                    dfs(num, target, prev+val, res, path + '+' + str(val), i+1)\n                    dfs(num, target, prev-val, res, path + '-' + str(val), i+1)\n                    dfs(num, target, prev*val, res, path + '*' + str(val), i+1)\n        \n        res = []\n        dfs(num, target, 0, res, \"\", 0)\n        return res"
        },
        {
            "task_id": "expression-add-operators",
            "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, prev, res, path, idx):\n            if idx == len(num):\n                if prev == target:\n                    res.append(path)\n                return\n            \n            for i in range(idx, len(num)):\n                if i != idx and num[idx] == '0':\n                    break\n                val = int(num[idx:i+1])\n                if idx == 0:\n                    dfs(num, target, val, res, str(val), i+1)\n                else:\n                    dfs(num, target, prev+val, res, path + '+' + str(val), i+1)\n                    dfs(num, target, prev-val, res, path + '-' + str(val), i+1)\n                    dfs(num, target, prev*val, res, path + '*' + str(val), i+1)\n        \n        res = []\n        dfs(num, target, 0, res, \"\", 0)\n        return res"
        },
        {
            "task_id": "expression-add-operators",
            "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, prev, res, path, idx):\n            if idx == len(num):\n                if prev == target:\n                    res.append(path)\n                return\n            \n            for i in range(idx, len(num)):\n                if i != idx and num[idx] == '0':\n                    break\n                val = int(num[idx:i+1])\n                if idx == 0:\n                    dfs(num, target, val, res, str(val), i+1)\n                else:\n                    dfs(num, target, prev+val, res, path + '+' + str(val), i+1)\n                    dfs(num, target, prev-val, res, path + '-' + str(val), i+1)\n                    dfs(num, target, prev*val, res, path + '*' + str(val), i+1)\n        \n        res = []\n        dfs(num, target, 0, res, \"\", 0)\n        return res"
        }
    ],
    "sum-root-to-leaf-numbers": [
        {
            "task_id": "sum-root-to-leaf-numbers",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, path):\n            if node is None:\n                return 0\n            path = path * 10 + node.val\n            if node.left is None and node.right is None:\n                return path\n            return dfs(node.left, path) + dfs(node.right, path)\n        \n        return dfs(root, 0)"
        },
        {
            "task_id": "sum-root-to-leaf-numbers",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return self.sumNumbersHelper(root, 0)\n        \n    def sumNumbersHelper(self, root, curr_sum):\n        if root is None:\n            return 0\n        \n        curr_sum = curr_sum * 10 + root.val\n        \n        if root.left is None and root.right is None:\n            return curr_sum\n        \n        return self.sumNumbersHelper(root.left, curr_sum) + self.sumNumbersHelper(root.right, curr_sum)"
        },
        {
            "task_id": "sum-root-to-leaf-numbers",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return self.sumNumbersHelper(root, 0)\n    \n    def sumNumbersHelper(self, root, curr_sum):\n        if root is None:\n            return 0\n        \n        curr_sum = curr_sum * 10 + root.val\n        \n        if root.left is None and root.right is None:\n            return curr_sum\n        \n        return self.sumNumbersHelper(root.left, curr_sum) + self.sumNumbersHelper(root.right, curr_sum)"
        },
        {
            "task_id": "sum-root-to-leaf-numbers",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return self.sumNumbersHelper(root, 0)\n        \n    def sumNumbersHelper(self, root, curr_sum):\n        if root is None:\n            return 0\n        \n        curr_sum = curr_sum * 10 + root.val\n        \n        if root.left is None and root.right is None:\n            return curr_sum\n        \n        return self.sumNumbersHelper(root.left, curr_sum) + self.sumNumbersHelper(root.right, curr_sum)"
        },
        {
            "task_id": "sum-root-to-leaf-numbers",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return self.sumNumbersHelper(root, 0)\n    \n    def sumNumbersHelper(self, root, num):\n        if root is None:\n            return 0\n        \n        num = num * 10 + root.val\n        \n        if root.left is None and root.right is None:\n            return num\n        \n        return self.sumNumbersHelper(root.left, num) + self.sumNumbersHelper(root.right, num)"
        }
    ],
    "license-key-formatting": [
        {
            "task_id": "license-key-formatting",
            "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s"
        },
        {
            "task_id": "license-key-formatting",
            "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = '-'.join(s[i:i+k] for i in range(0, len(s), k))\n        return s[::-1]"
        },
        {
            "task_id": "license-key-formatting",
            "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = s[::-1]\n        s = \"-\".join(s[i:i+k] for i in range(0, len(s), k))\n        return s[::-1]"
        },
        {
            "task_id": "license-key-formatting",
            "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = '-'.join(s[i:i+k] for i in range(0, len(s), k))\n        return s[::-1]"
        },
        {
            "task_id": "license-key-formatting",
            "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = s[::-1]\n        s = \"-\".join(s[i:i+k] for i in range(0, len(s), k))\n        return s[::-1]"
        }
    ],
    "gas-station": [
        {
            "task_id": "gas-station",
            "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        total_tank = 0\n        curr_tank = 0\n        starting_index = 0\n        \n        # Iterate through the list\n        for i in range(len(gas)):\n            total_tank += gas[i] - cost[i]\n            curr_tank += gas[i] - cost[i]\n            \n            # If the current tank dips below 0, then we need to reset the starting index\n            if curr_tank < 0:\n                starting_index = i + 1\n                curr_tank = 0\n                \n        # If the total tank is less than 0, then we cannot travel around the circuit\n        if total_tank < 0:\n            return -1\n        else:\n            return starting_index"
        },
        {
            "task_id": "gas-station",
            "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        total_tank = 0\n        curr_tank = 0\n        starting_index = 0\n        \n        # Iterate through the list\n        for i in range(len(gas)):\n            total_tank += gas[i] - cost[i]\n            curr_tank += gas[i] - cost[i]\n            \n            # If the current tank dips below 0, then we need to reset the starting index\n            if curr_tank < 0:\n                starting_index = i + 1\n                curr_tank = 0\n                \n        # If the total tank is less than 0, then we cannot travel around the circuit\n        if total_tank < 0:\n            return -1\n        else:\n            return starting_index"
        },
        {
            "task_id": "gas-station",
            "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Find the total amount of gas and cost\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        \n        # If the total amount of gas is less than the total cost, then it is not possible to complete the circuit\n        if total_gas < total_cost:\n            return -1\n        \n        # Find the starting index\n        for i in range(len(gas)):\n            if gas[i] >= cost[i]:\n                start = i\n                break\n        \n        # Calculate the remaining gas\n        remaining_gas = total_gas - gas[start]\n        \n        # Calculate the remaining cost\n        remaining_cost = total_cost - cost[start]\n        \n        # Check if the remaining gas is greater than the remaining cost\n        if remaining_gas >= remaining_cost:\n            return start\n        else:\n            return -1"
        },
        {
            "task_id": "gas-station",
            "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        total_tank = 0\n        curr_tank = 0\n        starting_index = 0\n        \n        # Iterate through the list\n        for i in range(len(gas)):\n            total_tank += gas[i] - cost[i]\n            curr_tank += gas[i] - cost[i]\n            \n            # If the current tank dips below 0, then we need to reset the starting index\n            if curr_tank < 0:\n                starting_index = i + 1\n                curr_tank = 0\n                \n        # If the total tank is less than 0, then we cannot travel around the circuit\n        if total_tank < 0:\n            return -1\n        else:\n            return starting_index"
        },
        {
            "task_id": "gas-station",
            "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Find the total amount of gas and cost\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        \n        # If the total amount of gas is less than the total cost, then it is not possible to complete the circuit\n        if total_gas < total_cost:\n            return -1\n        \n        # Find the starting index\n        for i in range(len(gas)):\n            if gas[i] >= cost[i]:\n                start = i\n                break\n        \n        # Calculate the remaining gas\n        remaining_gas = total_gas - gas[start]\n        \n        # Calculate the remaining cost\n        remaining_cost = total_cost - cost[start]\n        \n        # Check if the remaining gas is less than the remaining cost\n        if remaining_gas < remaining_cost:\n            return -1\n        \n        # Check if the remaining gas is greater than or equal to the remaining cost\n        if remaining_gas >= remaining_cost:\n            return start\n        \n        # If the remaining gas is less than the remaining cost, then it is not possible to complete the circuit\n        return -1"
        }
    ],
    "burst-balloons": [
        {
            "task_id": "burst-balloons",
            "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + [0] + nums\n        dp = [[0] * (len(nums)) for _ in range(len(nums))]\n        \n        for i in range(2, len(nums)):\n            for left in range(len(nums) - i):\n                right = left + i\n                for last in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right], dp[left][last] + dp[last][right] + nums[left] * nums[last] * nums[right])\n                    \n        return dp[0][len(nums) - 1]"
        },
        {
            "task_id": "burst-balloons",
            "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + [0] + nums\n        n = len(nums)\n        dp = [[0] * (n) for _ in range(n)]\n        \n        for i in range(2, n):\n            for left in range(n - i, -1, -1):\n                right = left + i\n                for k in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right], dp[left][k] + dp[k][right] + nums[left] * nums[k] * nums[right])\n                    \n        return dp[0][n - 1]"
        },
        {
            "task_id": "burst-balloons",
            "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + [0] + nums\n        dp = [[0] * (len(nums)) for _ in range(len(nums))]\n        for i in range(2, len(nums)):\n            for left in range(len(nums) - i):\n                right = left + i\n                for last in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right], dp[left][last] + dp[last][right] + nums[left] * nums[last] * nums[right])\n        return dp[0][len(nums) - 1]"
        },
        {
            "task_id": "burst-balloons",
            "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + [0] + nums\n        n = len(nums)\n        dp = [[0] * (n) for _ in range(n)]\n        \n        for i in range(2, n):\n            for left in range(n - i, -1, -1):\n                right = left + i\n                for k in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right], dp[left][k] + dp[k][right] + nums[left] * nums[k] * nums[right])\n                    \n        return dp[0][n - 1]"
        },
        {
            "task_id": "burst-balloons",
            "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + [0] + nums\n        n = len(nums)\n        dp = [[0] * (n) for _ in range(n)]\n        \n        for i in range(2, n):\n            for left in range(n - i, -1, -1):\n                right = left + i\n                for k in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right], dp[left][k] + dp[k][right] + nums[left] * nums[k] * nums[right])\n                    \n        return dp[0][n - 1]"
        }
    ],
    "plus-one": [
        {
            "task_id": "plus-one",
            "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize a carry variable\n        carry = 1\n        \n        # Traverse the list from right to left\n        for i in range(len(digits)-1, -1, -1):\n            \n            # Add the carry and the current element\n            # and take the modulo 10\n            digits[i] = (digits[i] + carry) % 10\n            \n            # If the sum is greater than 10,\n            # set the carry to 1 else 0\n            carry = (digits[i] + carry) // 10\n            \n        # If the carry is 1, then we need to\n        # insert a 1 at the beginning\n        if carry == 1:\n            digits.insert(0, 1)\n            \n        return digits"
        },
        {
            "task_id": "plus-one",
            "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize a carry variable\n        carry = 1\n        \n        # Traverse the list from right to left\n        for i in range(len(digits)-1, -1, -1):\n            \n            # Add the carry and the current element\n            # and take the modulo 10\n            digits[i] = (digits[i] + carry) % 10\n            \n            # If the sum is greater than 10,\n            # set the carry to 1\n            if digits[i] > 9:\n                carry = 1\n            else:\n                carry = 0\n                \n        # If the carry is 1, we need to insert\n        # a new element at the beginning\n        if carry == 1:\n            digits.insert(0, 1)\n            \n        return digits"
        },
        {
            "task_id": "plus-one",
            "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Convert the list to a string\n        num = ''.join(map(str, digits))\n        \n        # Convert the string to an integer\n        num = int(num)\n        \n        # Increment the integer by 1\n        num += 1\n        \n        # Convert the integer to a string\n        num = str(num)\n        \n        # Convert the string to a list\n        num = list(map(int, num))\n        \n        return num"
        },
        {
            "task_id": "plus-one",
            "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize a carry variable\n        carry = 1\n        \n        # Traverse the list from right to left\n        for i in range(len(digits)-1, -1, -1):\n            \n            # Add the carry and the current element\n            # and take the modulo 10\n            digits[i] = (digits[i] + carry) % 10\n            \n            # If the sum is greater than 10,\n            # set the carry to 1 else 0\n            carry = (digits[i] + carry) // 10\n            \n        # If the carry is 1, then we need to\n        # insert a 1 at the beginning\n        if carry == 1:\n            digits.insert(0, 1)\n            \n        return digits"
        },
        {
            "task_id": "plus-one",
            "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Convert list to string\n        num = ''.join(map(str, digits))\n        \n        # Convert string to int\n        num = int(num)\n        \n        # Increment by 1\n        num += 1\n        \n        # Convert int to string\n        num = str(num)\n        \n        # Convert string to list\n        return list(map(int, num))"
        }
    ],
    "regular-expression-matching": [
        {
            "task_id": "regular-expression-matching",
            "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i][j] represents whether s[:i] matches p[:j]\n        dp = [[False for _ in range(len(p) + 1)] for _ in range(len(s) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(p) + 1):\n            if p[i - 1] == '*':\n                dp[0][i] = dp[0][i - 2]\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.')\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1])\n        \n        return dp[-1][-1]"
        },
        {
            "task_id": "regular-expression-matching",
            "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i][j] represents whether s[:i] matches p[:j]\n        dp = [[False for _ in range(len(p)+1)] for _ in range(len(s)+1)]\n        \n        # initialization\n        dp[0][0] = True\n        for i in range(1, len(p)+1):\n            if p[i-1] == '*':\n                dp[0][i] = dp[0][i-2]\n        \n        for i in range(1, len(s)+1):\n            for j in range(1, len(p)+1):\n                if p[j-1] == '.':\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[j-1] == '*':\n                    dp[i][j] = dp[i][j-2] or dp[i-1][j] and (s[i-1] == p[j-2] or p[j-2] == '.')\n                else:\n                    dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1])\n        \n        return dp[-1][-1]"
        },
        {
            "task_id": "regular-expression-matching",
            "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i][j] represents whether s[:i] matches p[:j]\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(p) + 1):\n            if p[i - 1] == '*':\n                dp[0][i] = dp[0][i - 2]\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or dp[i - 1][j]\n                elif p[j - 1] == '.' or p[j - 1] == s[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n        \n        return dp[-1][-1]"
        },
        {
            "task_id": "regular-expression-matching",
            "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if pattern is empty, return False\n        if p == '':\n            return False\n        \n        # if pattern is '*', return True\n        if p == '*':\n            return True\n        \n        # if pattern is '.'\n        if p == '.':\n            return True\n        \n        # if pattern is '.*'\n        if p == '.*':\n            return True\n        \n        # if pattern is 'a*'\n        if p == 'a*':\n            return True\n        \n        # if pattern is 'a.*'\n        if p == 'a.*':\n            return True\n        \n        # if pattern is 'a*b'\n        if p == 'a*b':\n            return True\n        \n        # if pattern is 'a*b*'\n        if p == 'a*b*':\n            return True\n        \n        # if pattern is 'a*b*c'\n        if p == 'a*b*c':\n            return True\n        \n        # if pattern is 'a*b*c*'\n        if p == 'a*b*c*':\n            return True\n        \n        # if pattern is 'a*b*c*d'\n        if p == 'a*b*c*d':\n            return True\n        \n        # if pattern is 'a*b*c*d*'\n        if p == 'a*b*c*d*':\n            return True\n        \n        # if pattern is 'a*b*c*d*e'\n        if p == 'a*b*c*d*e':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*'\n        if p == 'a*b*c*d*e*':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f'\n        if p == 'a*b*c*d*e*f':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*'\n        if p == 'a*b*c*d*e*f*':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*g'\n        if p == 'a*b*c*d*e*f*g':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*g*'\n        if p == 'a*b*c*d*e*f*g*':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*g*h'\n        if p == 'a*b*c*d*e*f*g*h':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*g*h*'\n        if p == 'a*b*c*d*e*f*g*h*':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*g*h*i'\n        if p == 'a*b*c*d*e*f*g*h*i':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*g*h*i*'\n        if p == 'a*b*c*d*e*f*g*h*i*':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*g*h*i*j'\n        if p == 'a*b*c*d*e*f*g*h*i*j':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*g*h*i*j*'\n        if p == 'a*b*c*d*e*f*g*h*i*j*':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*g*h*i*j*k'\n        if p == 'a*b*c*d*e*f*g*h*i*j*k':\n            return True\n        \n        # if pattern is 'a*b*c*d*e*f*g*h*i*j*k"
        },
        {
            "task_id": "regular-expression-matching",
            "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i][j] represents whether s[:i] matches p[:j]\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(p) + 1):\n            if p[i - 1] == '*':\n                dp[0][i] = dp[0][i - 2]\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.')\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1])\n        \n        return dp[-1][-1]"
        }
    ],
    "create-maximum-number": [
        {
            "task_id": "create-maximum-number",
            "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def compare(a, b):\n            return [int(x) for x in str(int(a)) + str(int(b))]\n        \n        def max_merge(nums1, nums2, k):\n            res = []\n            for i in range(k):\n                a = nums1[i] if i < len(nums1) else 0\n                b = nums2[i] if i < len(nums2) else 0\n                res = compare(a, b) + res\n            return res\n        \n        def merge(nums1, nums2, k):\n            res = []\n            for i in range(k):\n                a = nums1[i] if i < len(nums1) else 0\n                b = nums2[i] if i < len(nums2) else 0\n                res.append(max(a, b))\n            return res\n        \n        def max_merge_k(nums1, nums2, k):\n            if len(nums1) + len(nums2) < k:\n                return []\n            if len(nums1) == 0:\n                return nums2[:k]\n            if len(nums2) == 0:\n                return nums1[:k]\n            for i in range(k, 0, -1):\n                merged = merge(nums1, nums2, i)\n                if merged == max_merge(nums1, nums2, i):\n                    return merged\n        \n        max_nums1 = []\n        for i in range(len(nums1)):\n            merged = max_merge_k(nums1[i:], nums2, k - i)\n            if merged:\n                max_nums1 = compare(merged[0], nums1[i]) + merged[1:]\n        return max_nums1 if max_nums1 else nums2[:k]"
        },
        {
            "task_id": "create-maximum-number",
            "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def compare(a, b):\n            return [int(x) for x in str(int(a)) + str(int(b))]\n        \n        def max_merge(nums1, nums2, k):\n            res = []\n            for i in range(k):\n                a = nums1[i] if i < len(nums1) else 0\n                b = nums2[i] if i < len(nums2) else 0\n                res = compare(a, b) + res\n            return res\n        \n        def merge(nums1, nums2, k):\n            res = []\n            for i in range(k):\n                a = nums1[i] if i < len(nums1) else 0\n                b = nums2[i] if i < len(nums2) else 0\n                res.append(max(a, b))\n            return res\n        \n        def max_merge_k(nums1, nums2, k):\n            if len(nums1) + len(nums2) < k:\n                return []\n            if len(nums1) == 0:\n                return nums2[:k]\n            if len(nums2) == 0:\n                return nums1[:k]\n            for i in range(k, -1, -1):\n                merged = merge(nums1, nums2, i)\n                if merged == max_merge(nums1, nums2, i):\n                    return merged\n        \n        max_nums1 = []\n        for i in range(len(nums1)):\n            merged = max_merge_k(nums1[i:], nums2, k - i)\n            if merged:\n                max_nums1.append(merged)\n        \n        max_nums2 = []\n        for i in range(len(nums2)):\n            merged = max_merge_k(nums1, nums2[i:], k - i)\n            if merged:\n                max_nums2.append(merged)\n        \n        max_nums1 = max(max_nums1, key=lambda x: (str(x)[::-1]))\n        max_nums2 = max(max_nums2, key=lambda x: (str(x)[::-1]))\n        return max(max_nums1, max_nums2) if max_nums1 and max_nums2 else max_nums1 or max_nums2"
        },
        {
            "task_id": "create-maximum-number",
            "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def compare(a, b):\n            return [int(x) for x in str(int(a)) + str(int(b))]\n        \n        def max_merge(nums1, nums2, k):\n            res = []\n            for i in range(k):\n                a = b = 0\n                if len(nums1) > i:\n                    a = nums1[i]\n                if len(nums2) > i:\n                    b = nums2[i]\n                if a > b:\n                    res.append(a)\n                    nums2 = compare(b, a)\n                else:\n                    res.append(b)\n                    nums1 = compare(a, b)\n            return res\n        \n        def merge(nums1, nums2, k):\n            if len(nums1) + len(nums2) < k:\n                return []\n            if len(nums1) > len(nums2):\n                nums1, nums2 = nums2, nums1\n            res = []\n            for i in range(k):\n                if not nums1:\n                    return res + nums2[i:]\n                if not nums2:\n                    return res + nums1[i:]\n                if nums1[0] > nums2[0]:\n                    res.append(nums1[0])\n                    nums1 = nums1[1:]\n                else:\n                    res.append(nums2[0])\n                    nums2 = nums2[1:]\n            return res\n        \n        def max_merge_k(nums1, nums2, k):\n            if not nums1 or not nums2:\n                return []\n            if len(nums1) + len(nums2) == k:\n                return max(nums1, nums2)\n            if len(nums1) + len(nums2) < k:\n                return []\n            left = max_merge_k(nums1, nums2[1:], k)\n            right = max_merge_k(nums1[1:], nums2, k)\n            return max(left, right, key=lambda x: (x[0], -len(x)))\n        \n        def merge_k(nums1, nums2, k):\n            if not nums1 or not nums2:\n                return []\n            if len(nums1) + len(nums2) == k:\n                return merge(nums1, nums2, k)\n            if len(nums1) + len(nums2) < k:\n                return []\n            left = merge_k(nums1, nums2[1:], k)\n            right = merge_k(nums1[1:], nums2, k)\n            return max(left, right, key=lambda x: (x[0], -len(x)))\n        \n        return merge_k(nums1, nums2, k)"
        },
        {
            "task_id": "create-maximum-number",
            "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def compare(a, b):\n            return [int(x) for x in str(int(a)) + str(int(b))]\n        \n        def max_merge(nums1, nums2, k):\n            res = []\n            for i in range(k):\n                a = b = 0\n                if len(nums1) > i: a = nums1[i]\n                if len(nums2) > i: b = nums2[i]\n                if a > b:\n                    res.append(a)\n                    nums2 = compare(b, a)\n                else:\n                    res.append(b)\n                    nums1 = compare(a, b)\n            return res\n        \n        def merge(nums1, nums2, k):\n            if len(nums1) + len(nums2) < k: return []\n            if len(nums1) == 0: return nums2[:k]\n            if len(nums2) == 0: return nums1[:k]\n            if k == 1: return [nums1[0], nums2[0]]\n            if nums1[0] > nums2[0]:\n                return [nums1[0]] + merge(nums1[1:], nums2, k-1)\n            else:\n                return [nums2[0]] + merge(nums1, nums2[1:], k-1)\n        \n        def max_merge_k(nums1, nums2, k):\n            if k == 1: return [max(nums1[0], nums2[0])]\n            if len(nums1) == 0: return nums2[:k]\n            if len(nums2) == 0: return nums1[:k]\n            a = max_merge_k(nums1, nums2[1:], k-1)\n            b = max_merge_k(nums1[1:], nums2, k-1)\n            if a[0] > b[0]: return a\n            else: return b\n        \n        def max_merge_k_2(nums1, nums2, k):\n            if k == 1: return [max(nums1[0], nums2[0])]\n            if len(nums1) == 0: return nums2[:k]\n            if len(nums2) == 0: return nums1[:k]\n            a = max_merge_k_2(nums1, nums2[1:], k-1)\n            b = max_merge_k_2(nums1[1:], nums2, k-1)\n            if a[0] > b[0]: return a\n            else: return b\n        \n        def max_merge_k_3(nums1, nums2, k):\n            if k == 1: return [max(nums1[0], nums2[0])]\n            if len(nums1) == 0: return nums2[:k]\n            if len(nums2) == 0: return nums1[:k]\n            a = max_merge_k_3(nums1, nums2[1:], k-1)\n            b = max_merge_k_3(nums1[1:], nums2, k-1)\n            if a[0] > b[0]: return a\n            else: return b\n        \n        def max_merge_k_4(nums1, nums2, k):\n            if k == 1: return [max(nums1[0], nums2[0])]\n            if len(nums1) == 0: return nums2[:k]\n            if len(nums2) == 0: return nums1[:k]\n            a = max_merge_k_4(nums1, nums2[1:], k-1)\n            b = max_merge_k_4(nums1[1:], nums2, k-1)\n            if a[0] > b[0]: return a\n            else: return b\n        \n        def max_merge_k_5(nums1, nums2, k):\n            if k == 1: return [max"
        },
        {
            "task_id": "create-maximum-number",
            "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def compare(a, b):\n            return [int(x) for x in str(int(a)) + str(int(b))]\n        \n        def max_merge(nums1, nums2, k):\n            res = []\n            for i in range(k):\n                a = b = 0\n                if len(nums1) > i: a = nums1[i]\n                if len(nums2) > i: b = nums2[i]\n                if a > b:\n                    res.append(a)\n                    nums2 = compare(b, a)\n                else:\n                    res.append(b)\n                    nums1 = compare(a, b)\n            return res\n        \n        def max_merge_k(nums1, nums2, k):\n            if k == 0: return []\n            if len(nums1) == 0: return nums2[:k]\n            if len(nums2) == 0: return nums1[:k]\n            if nums1[-1] > nums2[-1]:\n                return max_merge_k(nums1, nums2[:-1], k-1) + [nums2[-1]]\n            else:\n                return max_merge_k(nums1[:-1], nums2, k-1) + [nums1[-1]]\n        \n        m, n = len(nums1), len(nums2)\n        if k > m + n: return []\n        if k == m + n: return max_merge(nums1, nums2, k)\n        if k == 1: return [max(nums1[0], nums2[0])]\n        start = 1\n        end = min(m, n)\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if max_merge_k(nums1, nums2, mid)[-1] < max_merge_k(nums1, nums2, mid+1)[-1]:\n                start = mid\n            else:\n                end = mid\n        return max_merge_k(nums1, nums2, end)"
        }
    ],
    "perfect-number": [
        {
            "task_id": "perfect-number",
            "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        sum = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                sum += i\n                sum += num/i\n        if sum == num:\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "perfect-number",
            "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        sum = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                sum += i\n                sum += num/i\n        if sum == num:\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "perfect-number",
            "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = []\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if i * i != num:\n                    divisors.append(num // i)\n        \n        return sum(divisors) - num == num"
        },
        {
            "task_id": "perfect-number",
            "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        sum = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                sum += i\n                sum += num/i\n        if sum == num:\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "perfect-number",
            "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = []\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if i * i != num:\n                    divisors.append(num // i)\n        \n        return sum(divisors) - num == num"
        }
    ],
    "fibonacci-number": [
        {
            "task_id": "fibonacci-number",
            "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n-1) + self.fib(n-2)"
        },
        {
            "task_id": "fibonacci-number",
            "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n-1) + self.fib(n-2)"
        },
        {
            "task_id": "fibonacci-number",
            "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n-1) + self.fib(n-2)"
        },
        {
            "task_id": "fibonacci-number",
            "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n-1) + self.fib(n-2)"
        },
        {
            "task_id": "fibonacci-number",
            "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n-1) + self.fib(n-2)"
        }
    ],
    "dungeon-game": [
        {
            "task_id": "dungeon-game",
            "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\n        \n        dp[m][n-1] = 1\n        dp[m-1][n] = 1\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j])\n                \n        return dp[0][0]"
        },
        {
            "task_id": "dungeon-game",
            "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        \n        dp[m][n-1] = 1\n        dp[m-1][n] = 1\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j])\n                \n        return dp[0][0]"
        },
        {
            "task_id": "dungeon-game",
            "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        \n        dp[m][n-1] = 1\n        dp[m-1][n] = 1\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j])\n                \n        return dp[0][0]"
        },
        {
            "task_id": "dungeon-game",
            "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        \n        dp[m][n-1] = 1\n        dp[m-1][n] = 1\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j])\n                \n        return dp[0][0]"
        },
        {
            "task_id": "dungeon-game",
            "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        \n        dp[m][n-1] = 1\n        dp[m-1][n] = 1\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j])\n                \n        return dp[0][0]"
        }
    ],
    "find-k-th-smallest-pair-distance": [
        {
            "task_id": "find-k-th-smallest-pair-distance",
            "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        d = [nums[i+1] - nums[i] for i in range(n-1)]\n        d.append(10**6)\n        d.sort()\n        for i in range(k):\n            if d[i] < d[i+1] - d[i]:\n                return d[i]\n        return d[k]"
        },
        {
            "task_id": "find-k-th-smallest-pair-distance",
            "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        d = [nums[i+1] - nums[i] for i in range(n-1)]\n        d.append(10**6)\n        d = sorted(d)\n        for i in range(k):\n            if d[i] >= nums[i+1] - nums[i]:\n                return i\n        return k-1"
        },
        {
            "task_id": "find-k-th-smallest-pair-distance",
            "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        d = [nums[i+1] - nums[i] for i in range(n-1)]\n        d.append(10**6)\n        d = sorted(d)\n        for i in range(k):\n            if d[i] >= nums[i+1] - nums[i]:\n                return i\n        return k-1"
        },
        {
            "task_id": "find-k-th-smallest-pair-distance",
            "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        dp = [[0] * (k+1) for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = nums[i]\n        for j in range(1, n):\n            dp[j][0] = nums[j] - nums[j-1]\n        for i in range(1, n):\n            for j in range(1, min(k, i*(n-i))):\n                dp[i][j] = min(dp[i-1][j-1], dp[i][j-1])\n                if i < n-1:\n                    dp[i][j] = min(dp[i][j], nums[i+1] - nums[i-j+1])\n        return dp[n-1][k-1]"
        },
        {
            "task_id": "find-k-th-smallest-pair-distance",
            "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        d = [nums[i+1] - nums[i] for i in range(n-1)]\n        d.append(10**6)\n        d.sort()\n        for i in range(k):\n            if d[i] < d[i+1] - d[i]:\n                return d[i]\n        return d[k]"
        }
    ],
    "number-of-segments-in-a-string": [
        {
            "task_id": "number-of-segments-in-a-string",
            "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # return the length of the list\n        return len(words)"
        },
        {
            "task_id": "number-of-segments-in-a-string",
            "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # split the string by space\n        # and count the number of non-empty strings\n        return len(list(filter(None, s.split(' '))))"
        },
        {
            "task_id": "number-of-segments-in-a-string",
            "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # split the string by space\n        # and count the number of non-empty strings\n        return len(list(filter(None, s.split(' '))))"
        },
        {
            "task_id": "number-of-segments-in-a-string",
            "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n            elif i > 0 and s[i-1] != ' ':\n                count += 1\n        return count"
        },
        {
            "task_id": "number-of-segments-in-a-string",
            "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # return the length of the list\n        return len(words)"
        }
    ],
    "reverse-vowels-of-a-string": [
        {
            "task_id": "reverse-vowels-of-a-string",
            "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u']\n        vowels_upper = ['A', 'E', 'I', 'O', 'U']\n        vowels.extend(vowels_upper)\n        s = list(s)\n        left = 0\n        right = len(s) - 1\n        while left < right:\n            if s[left] in vowels and s[right] in vowels:\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n            elif s[left] not in vowels:\n                left += 1\n            elif s[right] not in vowels:\n                right -= 1\n        return ''.join(s)"
        },
        {
            "task_id": "reverse-vowels-of-a-string",
            "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u']\n        vowels_upper = ['A', 'E', 'I', 'O', 'U']\n        vowels.extend(vowels_upper)\n        vowels_index = []\n        vowels_index_upper = []\n        vowels_index_lower = []\n        vowels_index_upper_lower = []\n        vowels_index_lower_upper = []\n        vowels_index_upper_upper = []\n        vowels_index_lower_lower = []\n        vowels_index_upper_lower.extend(vowels_index_upper)\n        vowels_index_upper_lower.extend(vowels_index_lower)\n        vowels_index_lower_upper.extend(vowels_index_lower)\n        vowels_index_lower_upper.extend(vowels_index_upper)\n        vowels_index_upper_upper.extend(vowels_index_upper)\n        vowels_index_lower_lower.extend(vowels_index_lower)\n        vowels_index_upper_upper.extend(vowels_index_upper)\n        vowels_index_upper_upper.extend(vowels_index_lower)\n        vowels_index_lower_lower.extend(vowels_index_lower)\n        vowels_index_lower_lower.extend(vowels_index_upper)\n        vowels_index_upper_lower.extend(vowels_index_upper_upper)\n        vowels_index_upper_lower.extend(vowels_index_lower_lower)\n        vowels_index_lower_upper.extend(vowels_index_lower_lower)\n        vowels_index_lower_upper.extend(vowels_index_upper_upper)\n        vowels_index_upper_lower.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(vowels_index_upper_lower)\n        vowowels_index_upper_lower.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(vowels_index_lower_upper)\n        vowels_index_lower_upper.extend(vowels_index_upper_lower)\n        vowels_index_upper_lower.extend(v"
        },
        {
            "task_id": "reverse-vowels-of-a-string",
            "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u']\n        vowels_upper = ['A', 'E', 'I', 'O', 'U']\n        vowels.extend(vowels_upper)\n        vowels_index = []\n        vowels_index_upper = []\n        for i in range(len(s)):\n            if s[i] in vowels:\n                vowels_index.append(i)\n            if s[i] in vowels_upper:\n                vowels_index_upper.append(i)\n        vowels_index.extend(vowels_index_upper)\n        vowels_index.sort()\n        vowels_index.reverse()\n        new_s = ''\n        for i in range(len(s)):\n            if i in vowels_index:\n                new_s += s[vowels_index.pop()]\n            else:\n                new_s += s[i]\n        return new_s"
        },
        {
            "task_id": "reverse-vowels-of-a-string",
            "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u']\n        vowels_upper = ['A', 'E', 'I', 'O', 'U']\n        vowels.extend(vowels_upper)\n        s = list(s)\n        left = 0\n        right = len(s) - 1\n        while left < right:\n            if s[left] in vowels and s[right] in vowels:\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n            elif s[left] not in vowels:\n                left += 1\n            elif s[right] not in vowels:\n                right -= 1\n        return ''.join(s)"
        },
        {
            "task_id": "reverse-vowels-of-a-string",
            "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u']\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i].lower() in vowels:\n                if s[j].lower() in vowels:\n                    s[i], s[j] = s[j], s[i]\n                    i += 1\n                    j -= 1\n                else:\n                    j -= 1\n            else:\n                i += 1\n        return ''.join(s)"
        }
    ],
    "longest-consecutive-sequence": [
        {
            "task_id": "longest-consecutive-sequence",
            "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # create a set of nums\n        nums_set = set(nums)\n        max_len = 0\n        \n        # loop through each number in nums\n        for num in nums_set:\n            \n            # if num-1 not in nums_set, then it is the start of a sequence\n            if num-1 not in nums_set:\n                \n                # set current_num to num\n                current_num = num\n                \n                # loop until current_num+1 not in nums_set\n                while current_num+1 in nums_set:\n                    current_num += 1\n                \n                # update max_len\n                max_len = max(max_len, current_num-num+1)\n                \n        return max_len"
        },
        {
            "task_id": "longest-consecutive-sequence",
            "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # create a set of nums\n        nums_set = set(nums)\n        max_len = 0\n        \n        # loop through each number in nums\n        for num in nums_set:\n            \n            # if num-1 not in nums_set, then it is the start of a sequence\n            if num-1 not in nums_set:\n                \n                # set current_num to num\n                current_num = num\n                \n                # loop until current_num+1 not in nums_set\n                while current_num+1 in nums_set:\n                    current_num += 1\n                \n                # update max_len\n                max_len = max(max_len, current_num-num+1)\n                \n        return max_len"
        },
        {
            "task_id": "longest-consecutive-sequence",
            "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                max_len = max(max_len, curr_len)\n                \n        return max_len"
        },
        {
            "task_id": "longest-consecutive-sequence",
            "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                current_num = num\n                current_len = 1\n                \n                while current_num + 1 in nums:\n                    current_num += 1\n                    current_len += 1\n                    \n                max_len = max(max_len, current_len)\n                \n        return max_len"
        },
        {
            "task_id": "longest-consecutive-sequence",
            "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a hash table to map each element to its index.\n        table = {}\n        for i, num in enumerate(nums):\n            table[num] = i\n        \n        # Initialize the longest sequence so far.\n        longest = 0\n        \n        # Iterate over each number.\n        for i, num in enumerate(nums):\n            \n            # If the number is already part of a sequence, skip it.\n            if i != table[num]:\n                continue\n            \n            # Try to extend the sequence forward.\n            while num + 1 in table:\n                num += 1\n            \n            # Try to extend the sequence backward.\n            while num - 1 in table:\n                num -= 1\n            \n            # Update the longest sequence found so far.\n            longest = max(longest, num - nums[i] + 1)\n        \n        return longest"
        }
    ],
    "missing-number": [
        {
            "task_id": "missing-number",
            "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all numbers from 0 to n\n        # XOR of all numbers in the array\n        # The result will be the missing number\n        \n        n = len(nums)\n        total = 0\n        for i in range(n+1):\n            total ^= i\n            \n        for i in nums:\n            total ^= i\n            \n        return total"
        },
        {
            "task_id": "missing-number",
            "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all numbers from 0 to n\n        # XOR of all numbers in the array\n        # The result will be the missing number\n        \n        n = len(nums)\n        total = 0\n        for i in range(n+1):\n            total ^= i\n            \n        for i in nums:\n            total ^= i\n            \n        return total"
        },
        {
            "task_id": "missing-number",
            "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all numbers from 0 to n\n        # XOR of all numbers in the array\n        # The result will be the missing number\n        \n        n = len(nums)\n        total = 0\n        for i in range(n+1):\n            total ^= i\n            \n        for i in nums:\n            total ^= i\n            \n        return total"
        },
        {
            "task_id": "missing-number",
            "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all numbers from 0 to n\n        # XOR of all numbers in the array\n        # XOR of both will give the missing number\n        \n        n = len(nums)\n        xor = n\n        for i in range(n):\n            xor = xor ^ i ^ nums[i]\n        return xor"
        },
        {
            "task_id": "missing-number",
            "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all numbers from 0 to n\n        # XOR of all numbers in the array\n        # The result will be the missing number\n        \n        n = len(nums)\n        total = 0\n        for i in range(n+1):\n            total ^= i\n            \n        for i in nums:\n            total ^= i\n            \n        return total"
        }
    ],
    "word-ladder": [
        {
            "task_id": "word-ladder",
            "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time O(N)\n        # Space O(N)\n        \n        # Step 1: Create a set of words from wordList\n        wordSet = set(wordList)\n        \n        # Step 2: Check if endWord is in wordSet\n        if endWord not in wordSet:\n            return 0\n        \n        # Step 3: Create a queue and add beginWord to it\n        queue = collections.deque([beginWord])\n        \n        # Step 4: Create a distance dictionary\n        distance = {}\n        distance[beginWord] = 0\n        \n        # Step 5: Loop until queue is empty\n        while queue:\n            \n            # Step 6: Get the first word from the queue\n            word = queue.popleft()\n            \n            # Step 7: Get the distance of the word\n            wordDistance = distance[word]\n            \n            # Step 8: Loop through each character of the word\n            for i in range(len(word)):\n                \n                # Step 9: Get the new word\n                newWord = word[:i] + '*' + word[i+1:]\n                \n                # Step 10: Check if newWord is in wordSet\n                if newWord in wordSet:\n                    \n                    # Step 11: Check if newWord is the endWord\n                    if newWord == endWord:\n                        return wordDistance + 1\n                    \n                    # Step 12: Check if newWord is already in distance\n                    if newWord not in distance:\n                        distance[newWord] = wordDistance + 1\n                        queue.append(newWord)\n                        \n        return 0"
        },
        {
            "task_id": "word-ladder",
            "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time O(N)\n        # Space O(N)\n        \n        wordList = set(wordList)\n        queue = collections.deque([beginWord])\n        wordList.add(endWord)\n        distance = 0\n        \n        while queue:\n            for i in range(len(queue)):\n                word = queue.popleft()\n                if word == endWord:\n                    return distance + 1\n                for j in range(len(word)):\n                    for k in range(26):\n                        new_word = word[:j] + chr(ord('a') + k) + word[j+1:]\n                        if new_word in wordList:\n                            queue.append(new_word)\n                            wordList.remove(new_word)\n            distance += 1\n        return 0"
        },
        {
            "task_id": "word-ladder",
            "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time O(N)\n        # Space O(N)\n        \n        # Step 1: Create a set of words from wordList\n        wordSet = set(wordList)\n        \n        # Step 2: Check if endWord is in wordSet\n        if endWord not in wordSet:\n            return 0\n        \n        # Step 3: Create a queue and add beginWord to it\n        queue = collections.deque([beginWord])\n        \n        # Step 4: Create a distance dictionary\n        distance = {}\n        distance[beginWord] = 1\n        \n        # Step 5: Loop until queue is empty\n        while queue:\n            \n            # Step 5.1: Get the first word from the queue\n            word = queue.popleft()\n            \n            # Step 5.2: Loop through all the possible words\n            for i in range(len(word)):\n                \n                # Step 5.2.1: Create a new word\n                newWord = word[:i] + '*' + word[i+1:]\n                \n                # Step 5.2.2: Check if newWord is in wordSet\n                if newWord in wordSet:\n                    \n                    # Step 5.2.3: Check if newWord is the endWord\n                    if newWord == endWord:\n                        return distance[word] + 1\n                    \n                    # Step 5.2.4: Check if newWord is already visited\n                    if newWord not in distance:\n                        distance[newWord] = distance[word] + 1\n                        queue.append(newWord)\n                        \n        return 0"
        },
        {
            "task_id": "word-ladder",
            "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        queue = collections.deque([beginWord])\n        wordList = set(wordList)\n        wordList.add(endWord)\n        distance = 0\n        \n        while queue:\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                if word == endWord:\n                    return distance + 1\n                for i in range(len(word)):\n                    for c in string.ascii_lowercase:\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in wordList:\n                            queue.append(new_word)\n                            wordList.remove(new_word)\n            distance += 1\n        return 0"
        },
        {
            "task_id": "word-ladder",
            "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the words as key and their index as value\n        word_index = {word:index for index, word in enumerate(wordList)}\n        \n        # Create a queue and enqueue the beginWord with level 1\n        queue = collections.deque([(beginWord, 1)])\n        \n        # Loop until the queue is empty\n        while queue:\n            \n            # Dequeue the first word and its level from the queue\n            word, level = queue.popleft()\n            \n            # If the dequeued word is same as endWord, return its level\n            if word == endWord:\n                return level\n            \n            # Iterate through each letter of the dequeued word\n            for i in range(len(word)):\n                \n                # Word to compare the characters\n                compare_word = word\n                \n                # Iterate through the alphabet\n                for char in string.ascii_lowercase:\n                    \n                    # Replace the ith character with the current character from the alphabet\n                    compare_word = compare_word[:i] + char + compare_word[i+1:]\n                    \n                    # If the new word is in the wordList, enqueue it with level+1\n                    if compare_word in word_index and compare_word != word:\n                        queue.append((compare_word, level+1))\n                        \n                        # Mark the index of new word as visited\n                        word_index[compare_word] = -1\n                        \n        # If the queue is empty and endWord is not found, return 0\n        return 0"
        }
    ],
    "add-binary": [
        {
            "task_id": "add-binary",
            "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # Convert the binary strings to integers\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # Add the integers\n        c = a + b\n        \n        # Convert the result back to a binary string\n        return bin(c)[2:]"
        },
        {
            "task_id": "add-binary",
            "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # Convert the binary strings to integers\n        a_int = int(a, 2)\n        b_int = int(b, 2)\n        \n        # Add the integers\n        sum_int = a_int + b_int\n        \n        # Convert the sum back to a binary string\n        return bin(sum_int)[2:]"
        },
        {
            "task_id": "add-binary",
            "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # Convert the binary strings to integers\n        a_int = int(a, 2)\n        b_int = int(b, 2)\n        \n        # Add the integers\n        sum_int = a_int + b_int\n        \n        # Convert the sum back to a binary string\n        sum_binary = bin(sum_int)[2:]\n        \n        return sum_binary"
        },
        {
            "task_id": "add-binary",
            "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # Convert the binary strings to integers\n        a_int = int(a, 2)\n        b_int = int(b, 2)\n        \n        # Add the integers\n        sum_int = a_int + b_int\n        \n        # Convert the sum back to a binary string\n        sum_binary = bin(sum_int)[2:]\n        \n        return sum_binary"
        },
        {
            "task_id": "add-binary",
            "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert the binary strings to integers\n        a_int = int(a, 2)\n        b_int = int(b, 2)\n        \n        # add the integers\n        sum_int = a_int + b_int\n        \n        # convert the sum back to a binary string\n        sum_binary = bin(sum_int)[2:]\n        \n        return sum_binary"
        }
    ],
    "find-first-and-last-position-of-element-in-sorted-array": [
        {
            "task_id": "find-first-and-last-position-of-element-in-sorted-array",
            "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [-1, -1]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                break\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        if left > right or nums[mid] != target:\n            return [-1, -1]\n        \n        left = mid\n        right = mid\n        \n        while left - 1 >= 0 and nums[left - 1] == target:\n            left -= 1\n            \n        while right + 1 < len(nums) and nums[right + 1] == target:\n            right += 1\n            \n        return [left, right]"
        },
        {
            "task_id": "find-first-and-last-position-of-element-in-sorted-array",
            "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Find the index of first occurrence of target in nums\n        first_occurence = self.find_first_occurence(nums, target)\n        \n        # If first occurence is not found\n        if first_occurence == -1:\n            return [-1, -1]\n        \n        # Find the index of last occurrence of target in nums\n        last_occurence = self.find_last_occurence(nums, target)\n        \n        return [first_occurence, last_occurence]\n    \n    def find_first_occurence(self, nums, target):\n        \"\"\"\n        Find the index of first occurrence of target in nums\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                # Check if mid is first occurence of target\n                if mid == 0 or nums[mid - 1] != target:\n                    return mid\n                else:\n                    right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1\n    \n    def find_last_occurence(self, nums, target):\n        \"\"\"\n        Find the index of last occurrence of target in nums\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                # Check if mid is last occurence of target\n                if mid == len(nums) - 1 or nums[mid + 1] != target:\n                    return mid\n                else:\n                    left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1"
        },
        {
            "task_id": "find-first-and-last-position-of-element-in-sorted-array",
            "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [-1, -1]\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                break\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if left > right or nums[mid] != target:\n            return [-1, -1]\n        left = mid\n        right = mid\n        while left - 1 >= 0 and nums[left - 1] == target:\n            left -= 1\n        while right + 1 < len(nums) and nums[right + 1] == target:\n            right += 1\n        return [left, right]"
        },
        {
            "task_id": "find-first-and-last-position-of-element-in-sorted-array",
            "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [-1, -1]\n        \n        start = 0\n        end = len(nums) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            if nums[mid] == target:\n                break\n            elif nums[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        if start > end:\n            return [-1, -1]\n        left = mid\n        right = mid\n        while left - 1 >= 0 and nums[left - 1] == target:\n            left -= 1\n        while right + 1 < len(nums) and nums[right + 1] == target:\n            right += 1\n        return [left, right]"
        },
        {
            "task_id": "find-first-and-last-position-of-element-in-sorted-array",
            "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Find the index of first occurrence of target in nums\n        first_occurence = self.find_first_occurence(nums, target)\n        \n        # If the first occurence is not found\n        if first_occurence == -1:\n            return [-1, -1]\n        \n        # Find the index of last occurrence of target in nums\n        last_occurence = self.find_last_occurence(nums, target)\n        \n        return [first_occurence, last_occurence]\n    \n    def find_first_occurence(self, nums, target):\n        \"\"\"\n        Find the index of first occurrence of target in nums\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                # Check if mid is the first occurence of target\n                if mid == 0 or nums[mid - 1] != target:\n                    return mid\n                else:\n                    right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1\n    \n    def find_last_occurence(self, nums, target):\n        \"\"\"\n        Find the index of last occurrence of target in nums\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                # Check if mid is the last occurence of target\n                if mid == len(nums) - 1 or nums[mid + 1] != target:\n                    return mid\n                else:\n                    left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1"
        }
    ],
    "remove-duplicates-from-sorted-array": [
        {
            "task_id": "remove-duplicates-from-sorted-array",
            "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        else:\n            i = 0\n            while i < len(nums) - 1:\n                if nums[i] == nums[i + 1]:\n                    nums.pop(i + 1)\n                else:\n                    i += 1\n            return len(nums)"
        },
        {
            "task_id": "remove-duplicates-from-sorted-array",
            "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        else:\n            i = 0\n            while i < len(nums) - 1:\n                if nums[i] == nums[i + 1]:\n                    nums.pop(i + 1)\n                else:\n                    i += 1\n            return len(nums)"
        },
        {
            "task_id": "remove-duplicates-from-sorted-array",
            "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        else:\n            i = 0\n            while i < len(nums) - 1:\n                if nums[i] == nums[i + 1]:\n                    nums.pop(i + 1)\n                else:\n                    i += 1\n            return len(nums)"
        },
        {
            "task_id": "remove-duplicates-from-sorted-array",
            "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1"
        },
        {
            "task_id": "remove-duplicates-from-sorted-array",
            "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        else:\n            i = 0\n            while i < len(nums) - 1:\n                if nums[i] == nums[i + 1]:\n                    nums.pop(i + 1)\n                else:\n                    i += 1\n            return len(nums)"
        }
    ],
    "jump-game-ii": [
        {
            "task_id": "jump-game-ii",
            "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        n = len(nums)\n        jumps = 0\n        max_reach = 0\n        i = 0\n        \n        # Iterate through the array\n        while i < n-1:\n            jumps += 1\n            max_reach = max(max_reach, i+nums[i])\n            if i == max_reach:\n                return -1\n            while i <= max_reach and i+1 <= n-1 and nums[i] == 0:\n                i += 1\n        return jumps"
        },
        {
            "task_id": "jump-game-ii",
            "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        n = len(nums)\n        jumps = 0\n        max_reach = 0\n        i = 0\n        \n        # Iterate through the array\n        while i < n-1:\n            jumps += 1\n            max_reach = max(max_reach, i+nums[i])\n            if i == max_reach:\n                return -1\n            while i <= max_reach and i+1 <= n-1 and nums[i] == 0:\n                i += 1\n        return jumps"
        },
        {
            "task_id": "jump-game-ii",
            "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        n = len(nums)\n        jumps = 0\n        max_reach = 0\n        i = 0\n        \n        # Iterate through the array\n        while i < n-1:\n            jumps += 1\n            max_reach = max(max_reach, i+nums[i])\n            if i == max_reach:\n                return -1\n            while i <= max_reach and i+1 <= n-1 and nums[i] == 0:\n                i += 1\n        return jumps"
        },
        {
            "task_id": "jump-game-ii",
            "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        n = len(nums)\n        jumps = 0\n        max_reach = 0\n        i = 0\n        \n        # Iterate through the array\n        while i < n-1:\n            jumps += 1\n            max_reach = max(max_reach, i+nums[i])\n            if i == max_reach:\n                return -1\n            while i <= max_reach and i+1 <= n-1 and nums[i] == 0:\n                i += 1\n        return jumps"
        },
        {
            "task_id": "jump-game-ii",
            "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        n = len(nums)\n        jumps = 0\n        max_reach = 0\n        i = 0\n        \n        # Iterate through the array\n        while i < n-1:\n            jumps += 1\n            max_reach = max(max_reach, i+nums[i])\n            if i == max_reach:\n                return -1\n            while i <= max_reach and i+1 <= n-1 and nums[i] == 0:\n                i += 1\n        return jumps"
        }
    ],
    "best-time-to-buy-and-sell-stock-iv": [
        {
            "task_id": "best-time-to-buy-and-sell-stock-iv",
            "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        n = len(prices)\n        if k >= n//2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i-1]:\n                    profit += prices[i] - prices[i-1]\n            return profit\n        \n        dp = [[0] * (k+1) for _ in range(n)]\n        \n        for i in range(1, n):\n            diff = prices[i] - prices[i-1]\n            for j in range(1, k+1):\n                dp[i][j] = max(dp[i-1][j-1] + max(diff, 0), dp[i-1][j] + diff)\n        \n        return dp[-1][-1]"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-iv",
            "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        n = len(prices)\n        if k >= n//2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i-1]:\n                    profit += prices[i] - prices[i-1]\n            return profit\n        \n        dp = [[0] * (k+1) for _ in range(n)]\n        \n        for i in range(1, n):\n            for j in range(1, k+1):\n                dp[i][j] = max(dp[i-1][j-1] + prices[i] - prices[i-1], dp[i-1][j] + max(prices[i] - prices[i-1], 0))\n        \n        return dp[-1][-1]"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-iv",
            "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        n = len(prices)\n        if k >= n//2:\n            return sum(max(prices[i+1:]-prices[i]) for i in range(n-1))\n        \n        dp = [[0]*(k+1) for _ in range(n)]\n        \n        for i in range(1, n):\n            for j in range(1, k+1):\n                dp[i][j] = max(dp[i-1][j-1] + prices[i] - prices[i-1], dp[i-1][j] + max(prices[i] - prices[i-1], 0))\n        \n        return dp[-1][-1]"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-iv",
            "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        n = len(prices)\n        if k >= n//2:\n            return sum(max(prices[i+1:]-prices[i]) for i in range(n-1))\n        \n        dp = [[0]*(k+1) for _ in range(n)]\n        for i in range(1, n):\n            for j in range(1, k+1):\n                dp[i][j] = max(dp[i-1][j-1] + prices[i] - prices[i-1], dp[i-1][j] + max(prices[i] - prices[i-1], 0))\n        return dp[-1][-1]"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-iv",
            "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        n = len(prices)\n        if k >= n//2:\n            return sum(max(prices[i+1:]-prices[i]) for i in range(n-1))\n        \n        dp = [[0]*(k+1) for _ in range(n)]\n        for i in range(1, n):\n            for j in range(1, k+1):\n                dp[i][j] = max(dp[i-1][j-1]+prices[i]-prices[i-1], dp[i-1][j]+max(prices[i]-prices[i-1], 0))\n        return dp[-1][-1]"
        }
    ],
    "convert-a-number-to-hexadecimal": [
        {
            "task_id": "convert-a-number-to-hexadecimal",
            "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            num = 2**32 + num\n        hex_string = \"\"\n        hex_digits = \"0123456789abcdef\"\n        while num:\n            hex_string = hex_digits[num % 16] + hex_string\n            num //= 16\n        return hex_string"
        },
        {
            "task_id": "convert-a-number-to-hexadecimal",
            "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            num = 2**32 + num\n        hex_string = \"\"\n        hex_digits = \"0123456789abcdef\"\n        while num:\n            hex_string = hex_digits[num % 16] + hex_string\n            num //= 16\n        return hex_string"
        },
        {
            "task_id": "convert-a-number-to-hexadecimal",
            "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            num = 2**32 + num\n        hex_string = \"\"\n        hex_digits = \"0123456789abcdef\"\n        while num:\n            hex_string = hex_digits[num % 16] + hex_string\n            num //= 16\n        return hex_string"
        },
        {
            "task_id": "convert-a-number-to-hexadecimal",
            "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            num = 2**32 + num\n        hex_string = \"\"\n        hex_digits = \"0123456789abcdef\"\n        while num > 0:\n            hex_string = hex_digits[num % 16] + hex_string\n            num //= 16\n        return hex_string"
        },
        {
            "task_id": "convert-a-number-to-hexadecimal",
            "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            num = 2**32 + num\n        hex_string = \"\"\n        hex_digits = \"0123456789abcdef\"\n        while num > 0:\n            hex_string = hex_digits[num % 16] + hex_string\n            num //= 16\n        return hex_string"
        }
    ],
    "first-unique-character-in-a-string": [
        {
            "task_id": "first-unique-character-in-a-string",
            "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the count of each character\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 1\n            else:\n                char_count[char] += 1\n        \n        # Iterate through the string and find the first character with count 1\n        for i in range(len(s)):\n            if char_count[s[i]] == 1:\n                return i\n        \n        # If no character with count 1 is found, return -1\n        return -1"
        },
        {
            "task_id": "first-unique-character-in-a-string",
            "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the count of each character\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 1\n            else:\n                char_count[char] += 1\n        \n        # Iterate through the string and find the first character with count 1\n        for i in range(len(s)):\n            if char_count[s[i]] == 1:\n                return i\n        \n        return -1"
        },
        {
            "task_id": "first-unique-character-in-a-string",
            "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the count of each character\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 1\n            else:\n                char_count[char] += 1\n        \n        # Iterate through the string and find the first character with count 1\n        for i in range(len(s)):\n            if char_count[s[i]] == 1:\n                return i\n        \n        # If no character with count 1 is found, return -1\n        return -1"
        },
        {
            "task_id": "first-unique-character-in-a-string",
            "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the count of each character\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 1\n            else:\n                char_count[char] += 1\n        \n        # Iterate through the string and find the first character with count 1\n        for i in range(len(s)):\n            if char_count[s[i]] == 1:\n                return i\n        \n        # If no character with count 1 is found, return -1\n        return -1"
        },
        {
            "task_id": "first-unique-character-in-a-string",
            "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the count of each character\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 1\n            else:\n                char_count[char] += 1\n        \n        # Iterate through the string and find the first character with count 1\n        for i in range(len(s)):\n            if char_count[s[i]] == 1:\n                return i\n        \n        # If no character with count 1 is found, return -1\n        return -1"
        }
    ],
    "contains-duplicate-iii": [
        {
            "task_id": "contains-duplicate-iii",
            "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0 or indexDiff == 0:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, min(len(nums), i+indexDiff+1)):\n                if abs(nums[i] - nums[j]) <= valueDiff:\n                    return True\n        return False"
        },
        {
            "task_id": "contains-duplicate-iii",
            "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0 or len(nums) == 1:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n                    return True\n        return False"
        },
        {
            "task_id": "contains-duplicate-iii",
            "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0 or indexDiff == 0:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, min(len(nums), i+indexDiff+1)):\n                if abs(nums[i] - nums[j]) <= valueDiff:\n                    return True\n        return False"
        },
        {
            "task_id": "contains-duplicate-iii",
            "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0 or indexDiff == 0:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, min(len(nums), i+indexDiff+1)):\n                if abs(nums[i] - nums[j]) <= valueDiff:\n                    return True\n        return False"
        },
        {
            "task_id": "contains-duplicate-iii",
            "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0 or indexDiff == 0:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, min(len(nums), i+indexDiff+1)):\n                if abs(nums[i] - nums[j]) <= valueDiff:\n                    return True\n        return False"
        }
    ],
    "sort-colors": [
        {
            "task_id": "sort-colors",
            "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1"
        },
        {
            "task_id": "sort-colors",
            "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1"
        },
        {
            "task_id": "sort-colors",
            "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1"
        },
        {
            "task_id": "sort-colors",
            "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"
        },
        {
            "task_id": "sort-colors",
            "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1"
        }
    ],
    "max-consecutive-ones": [
        {
            "task_id": "max-consecutive-ones",
            "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        max_count = 0\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n                if count > max_count:\n                    max_count = count\n            else:\n                count = 0\n        return max_count"
        },
        {
            "task_id": "max-consecutive-ones",
            "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        max_count = 0\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n                max_count = max(count, max_count)\n            else:\n                count = 0\n        return max_count"
        },
        {
            "task_id": "max-consecutive-ones",
            "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        max_count = 0\n        \n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n                if count > max_count:\n                    max_count = count\n            else:\n                count = 0\n        return max_count"
        },
        {
            "task_id": "max-consecutive-ones",
            "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        max_count = 0\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n                max_count = max(count, max_count)\n            else:\n                count = 0\n        return max_count"
        },
        {
            "task_id": "max-consecutive-ones",
            "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        max_count = 0\n        \n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            else:\n                max_count = max(max_count, count)\n                count = 0\n                \n        return max(max_count, count)"
        }
    ],
    "count-complete-tree-nodes": [
        {
            "task_id": "count-complete-tree-nodes",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        if left == right:\n            return 2**left - 1\n        else:\n            return 1 + left + right"
        },
        {
            "task_id": "count-complete-tree-nodes",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        if left == right:\n            return 2**left - 1\n        else:\n            return 1 + left + right"
        },
        {
            "task_id": "count-complete-tree-nodes",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        if left == right:\n            return 2**left - 1\n        else:\n            return 1 + left + right"
        },
        {
            "task_id": "count-complete-tree-nodes",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)"
        },
        {
            "task_id": "count-complete-tree-nodes",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)"
        }
    ],
    "add-strings": [
        {
            "task_id": "add-strings",
            "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the result string\n        result = \"\"\n        \n        # Initialize the carry\n        carry = 0\n        \n        # Traverse the strings from last characters\n        i = len(num1) - 1\n        j = len(num2) - 1\n        \n        # Loop until we traverse both strings\n        while i >= 0 or j >= 0 or carry:\n            \n            # Compute the sum of the two digits\n            # and add the carry\n            sum_ = carry\n            if i >= 0:\n                sum_ += int(num1[i])\n            if j >= 0:\n                sum_ += int(num2[j])\n                \n            # Update the carry\n            carry = sum_ // 10\n            \n            # Update the result\n            result = str(sum_ % 10) + result\n            \n            # Move to the next characters\n            i -= 1\n            j -= 1\n            \n        return result"
        },
        {
            "task_id": "add-strings",
            "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the carry\n        carry = 0\n        \n        # Initialize the result\n        result = \"\"\n        \n        # Traverse both strings\n        for i in range(max(len(num1), len(num2))):\n            \n            # Calculate the sum of the two digits\n            # and add the carry\n            sum = carry\n            if i < len(num1):\n                sum += int(num1[i])\n            if i < len(num2):\n                sum += int(num2[i])\n                \n            # Calculate the carry\n            carry = sum // 10\n            \n            # Calculate the current digit\n            sum = sum % 10\n            \n            # Append the current digit to the result\n            result += str(sum)\n            \n        # If there is still a carry\n        # append it to the result\n        if carry:\n            result += str(carry)\n            \n        return result[::-1]"
        },
        {
            "task_id": "add-strings",
            "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize variables\n        result = \"\"\n        carry = 0\n        i = len(num1) - 1\n        j = len(num2) - 1\n        \n        # Loop until both strings are empty\n        while i >= 0 or j >= 0 or carry:\n            \n            # Get the value of the current digit\n            value1 = int(num1[i]) if i >= 0 else 0\n            value2 = int(num2[j]) if j >= 0 else 0\n            \n            # Calculate the sum of the current digit\n            sum = value1 + value2 + carry\n            \n            # Calculate the carry\n            carry = sum // 10\n            \n            # Add the current digit to the result\n            result = str(sum % 10) + result\n            \n            # Move to the next digit\n            i -= 1\n            j -= 1\n            \n        return result"
        },
        {
            "task_id": "add-strings",
            "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize variables\n        result = \"\"\n        carry = 0\n        i = len(num1) - 1\n        j = len(num2) - 1\n        \n        # Loop until both strings are empty\n        while i >= 0 or j >= 0 or carry:\n            \n            # Get the value of the current digit\n            value1 = int(num1[i]) if i >= 0 else 0\n            value2 = int(num2[j]) if j >= 0 else 0\n            \n            # Calculate the sum of the current digit\n            sum = value1 + value2 + carry\n            carry = sum // 10\n            sum = sum % 10\n            \n            # Add the current digit to the result\n            result = str(sum) + result\n            \n            # Move to the next digit\n            i -= 1\n            j -= 1\n            \n        return result"
        },
        {
            "task_id": "add-strings",
            "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize variables\n        result = \"\"\n        carry = 0\n        i = len(num1) - 1\n        j = len(num2) - 1\n        \n        # Loop until both strings are empty\n        while i >= 0 or j >= 0 or carry:\n            \n            # Get the value of the current digit\n            value1 = int(num1[i]) if i >= 0 else 0\n            value2 = int(num2[j]) if j >= 0 else 0\n            \n            # Calculate the sum of the current digit\n            sum_ = value1 + value2 + carry\n            carry = sum_ // 10\n            sum_ = sum_ % 10\n            \n            # Add the current digit to the result\n            result = str(sum_) + result\n            \n            # Move to the next digit\n            i -= 1\n            j -= 1\n            \n        return result"
        }
    ],
    "basic-calculator": [
        {
            "task_id": "basic-calculator",
            "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = 1 if s[i] == '+' else -1\n            elif s[i] == '(':\n                stack.append(num)\n                stack.append(sign)\n                num = 0\n                sign = 1\n            elif s[i] == ')':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = stack.pop()\n                num = sum(stack.pop() for _ in range(stack.pop()))\n        num *= sign\n        stack.append(num)\n        return sum(stack.pop() for _ in range(len(stack)))"
        },
        {
            "task_id": "basic-calculator",
            "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = 1 if s[i] == '+' else -1\n            elif s[i] == '(':\n                stack.append(num)\n                stack.append(sign)\n                num = 0\n                sign = 1\n            elif s[i] == ')':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = stack.pop()\n                num = sum(stack.pop() for _ in range(stack.pop()))\n        num *= sign\n        stack.append(num)\n        return sum(stack.pop() for _ in range(len(stack)))"
        },
        {
            "task_id": "basic-calculator",
            "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = 1 if s[i] == '+' else -1\n            elif s[i] == '(':\n                stack.append(num * sign)\n                num = 0\n                sign = 1\n            elif s[i] == ')':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = 1\n                while stack and stack[-1] != '(':\n                    num += stack.pop()\n                stack.pop()\n        num *= sign\n        stack.append(num)\n        while stack:\n            num += stack.pop()\n        return num"
        },
        {
            "task_id": "basic-calculator",
            "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = 1 if s[i] == '+' else -1\n            elif s[i] == '(':\n                stack.append(num * sign)\n                num = 0\n                sign = 1\n            elif s[i] == ')':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = 1\n                while stack and stack[-1] != '(':\n                    num += stack.pop()\n                stack.pop()\n        num *= sign\n        stack.append(num)\n        while stack:\n            num += stack.pop()\n        return num"
        },
        {
            "task_id": "basic-calculator",
            "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = 1 if s[i] == '+' else -1\n            elif s[i] == '(':\n                stack.append(num * sign)\n                num = 0\n                sign = 1\n            elif s[i] == ')':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = 1\n                while stack and stack[-1] != '(':\n                    num += stack.pop()\n                stack.pop()\n        num *= sign\n        stack.append(num)\n        while stack:\n            num += stack.pop()\n        return num"
        }
    ],
    "ipo": [
        {
            "task_id": "ipo",
            "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the projects by capital\n        projects = sorted(zip(capital, profits))\n        \n        # Initialize the max heap\n        heap = []\n        \n        # Initialize the total capital\n        total = w\n        \n        # Initialize the number of projects\n        count = 0\n        \n        # Loop through the projects\n        for i in range(len(projects)):\n            \n            # If the capital is less than the total capital\n            if projects[i][0] <= total:\n                \n                # Add the profit to the heap\n                heapq.heappush(heap, -projects[i][1])\n                \n                # Increment the count\n                count += 1\n                \n                # If the count is equal to k\n                if count == k:\n                    \n                    # Get the profit\n                    profit = -heapq.heappop(heap)\n                    \n                    # Add the profit to the total capital\n                    total += profit\n                    \n                    # Decrement the count\n                    count -= 1\n                    \n        # Return the total capital\n        return total"
        },
        {
            "task_id": "ipo",
            "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the projects by capital\n        projects = sorted(zip(capital, profits))\n        \n        # Initialize the max heap\n        heap = []\n        \n        # Initialize the total capital\n        total = w\n        \n        # Initialize the number of projects\n        count = 0\n        \n        # Loop through the projects\n        for i in range(len(projects)):\n            \n            # Check if the project is feasible\n            if projects[i][0] <= total:\n                \n                # Add the project to the heap\n                heapq.heappush(heap, -projects[i][1])\n                \n                # Increment the number of projects\n                count += 1\n                \n                # Check if the number of projects is equal to k\n                if count == k:\n                    \n                    # Pop the project with the maximum profit\n                    total -= heapq.heappop(heap)\n                    \n                    # Decrement the number of projects\n                    count -= 1\n                    \n        # Return the total capital\n        return total"
        },
        {
            "task_id": "ipo",
            "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the projects by capital\n        projects = sorted(zip(capital, profits))\n        \n        # Initialize the max heap\n        heap = []\n        \n        # Initialize the total capital\n        total = w\n        \n        # Initialize the number of projects\n        count = 0\n        \n        # Loop through the projects\n        for i in range(len(projects)):\n            \n            # If the current project is feasible\n            if projects[i][0] <= total:\n                \n                # Add the project to the heap\n                heapq.heappush(heap, -projects[i][1])\n                \n                # Increment the number of projects\n                count += 1\n                \n                # If the number of projects is greater than k\n                if count > k:\n                    \n                    # Get the maximum profit\n                    profit = -heapq.heappop(heap)\n                    \n                    # Increment the total capital\n                    total += profit\n                    \n                    # Decrement the number of projects\n                    count -= 1\n                    \n        # While the heap is not empty\n        while heap:\n            \n            # Get the maximum profit\n            profit = -heapq.heappop(heap)\n            \n            # Increment the total capital\n            total += profit\n            \n        # Return the total capital\n        return total"
        },
        {
            "task_id": "ipo",
            "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the projects by capital\n        projects = sorted(zip(capital, profits))\n        \n        # Initialize the max heap\n        heap = []\n        \n        # Initialize the total capital\n        total = w\n        \n        # Initialize the number of projects\n        count = 0\n        \n        # Loop through the projects\n        for i in range(len(projects)):\n            \n            # Check if the project can be started\n            if projects[i][0] <= total:\n                \n                # Add the project to the heap\n                heapq.heappush(heap, -projects[i][1])\n                \n                # Increment the number of projects\n                count += 1\n                \n                # Check if the number of projects is equal to k\n                if count == k:\n                    break\n                \n            # Check if the heap is empty\n            elif len(heap) == 0:\n                continue\n            \n            # Get the maximum profit\n            profit = -heapq.heappop(heap)\n            \n            # Add the profit to the total capital\n            total += profit\n            \n        # Return the total capital\n        return total"
        },
        {
            "task_id": "ipo",
            "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the projects by capital\n        projects = sorted(zip(capital, profits))\n        \n        # Initialize the max heap\n        heap = []\n        \n        # Initialize the total capital\n        total = w\n        \n        # Initialize the number of projects done\n        count = 0\n        \n        # Loop through the projects\n        for i in range(len(projects)):\n            \n            # If the project is feasible\n            if projects[i][0] <= total:\n                \n                # Add the project to the heap\n                heapq.heappush(heap, -projects[i][1])\n                \n                # Increment the number of projects done\n                count += 1\n                \n                # If the number of projects done is equal to k\n                if count == k:\n                    \n                    # While the heap is not empty\n                    while heap:\n                        \n                        # Get the project with the maximum profit\n                        profit = -heapq.heappop(heap)\n                        \n                        # Add the profit to the total capital\n                        total += profit\n                        \n                    # Break out of the loop\n                    break\n                \n            # If the project is not feasible\n            else:\n                \n                # Add the project to the heap\n                heapq.heappush(heap, projects[i][1])\n                \n        # Return the total capital\n        return total"
        }
    ],
    "valid-parentheses": [
        {
            "task_id": "valid-parentheses",
            "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '[' or i == '{':\n                stack.append(i)\n            elif i == ')' or i == ']' or i == '}':\n                if len(stack) == 0:\n                    return False\n                else:\n                    top = stack.pop()\n                    if i == ')' and top != '(':\n                        return False\n                    elif i == ']' and top != '[':\n                        return False\n                    elif i == '}' and top != '{':\n                        return False\n        if len(stack) != 0:\n            return False\n        return True"
        },
        {
            "task_id": "valid-parentheses",
            "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '[' or i == '{':\n                stack.append(i)\n            elif i == ')' or i == ']' or i == '}':\n                if len(stack) == 0:\n                    return False\n                else:\n                    top = stack.pop()\n                    if i == ')' and top != '(':\n                        return False\n                    elif i == ']' and top != '[':\n                        return False\n                    elif i == '}' and top != '{':\n                        return False\n        if len(stack) != 0:\n            return False\n        return True"
        },
        {
            "task_id": "valid-parentheses",
            "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '[' or i == '{':\n                stack.append(i)\n            elif i == ')' or i == ']' or i == '}':\n                if len(stack) == 0:\n                    return False\n                else:\n                    top = stack.pop()\n                    if i == ')' and top != '(':\n                        return False\n                    elif i == ']' and top != '[':\n                        return False\n                    elif i == '}' and top != '{':\n                        return False\n        if len(stack) != 0:\n            return False\n        return True"
        },
        {
            "task_id": "valid-parentheses",
            "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '[' or i == '{':\n                stack.append(i)\n            elif i == ')' or i == ']' or i == '}':\n                if len(stack) == 0:\n                    return False\n                else:\n                    top = stack.pop()\n                    if i == ')' and top != '(':\n                        return False\n                    elif i == ']' and top != '[':\n                        return False\n                    elif i == '}' and top != '{':\n                        return False\n        if len(stack) != 0:\n            return False\n        return True"
        },
        {
            "task_id": "valid-parentheses",
            "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '[' or i == '{':\n                stack.append(i)\n            elif i == ')' or i == ']' or i == '}':\n                if len(stack) == 0:\n                    return False\n                else:\n                    top = stack.pop()\n                    if i == ')' and top != '(':\n                        return False\n                    elif i == ']' and top != '[':\n                        return False\n                    elif i == '}' and top != '{':\n                        return False\n        if len(stack) != 0:\n            return False\n        return True"
        }
    ],
    "next-permutation": [
        {
            "task_id": "next-permutation",
            "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first element from the right which is not in the correct position\n        # If no such element is found, then the array is sorted in descending order\n        # and we need to reverse it to get the next permutation\n        # If such element is found, then find the smallest element on the right\n        # which is greater than the element at first_element_not_in_position\n        # Swap the two elements\n        # Now sort the elements on the right of first_element_not_in_position\n        # in ascending order\n        \n        n = len(nums)\n        if n == 1:\n            return\n        \n        first_element_not_in_position = -1\n        for i in range(n-2, -1, -1):\n            if nums[i] < nums[i+1]:\n                first_element_not_in_position = i\n                break\n        \n        if first_element_not_in_position == -1:\n            nums.reverse()\n            return\n        \n        smallest_greater_element = -1\n        for i in range(n-1, first_element_not_in_position, -1):\n            if nums[i] > nums[first_element_not_in_position]:\n                smallest_greater_element = i\n                break\n        \n        nums[first_element_not_in_position], nums[smallest_greater_element] = nums[smallest_greater_element], nums[first_element_not_in_position]\n        nums[first_element_not_in_position+1:] = sorted(nums[first_element_not_in_position+1:])"
        },
        {
            "task_id": "next-permutation",
            "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first element from the right which is not in the correct position\n        # If no such element is found, then the array is sorted in descending order\n        # and we need to reverse it to get the next permutation\n        # If such element is found, then find the smallest element on the right\n        # which is greater than the found element\n        # Swap the two elements\n        # Now sort the elements on the right of the found element\n        # in ascending order\n        \n        n = len(nums)\n        if n == 1:\n            return\n        \n        i = n-2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        if i == -1:\n            nums.reverse()\n            return\n        \n        j = n-1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        nums[i], nums[j] = nums[j], nums[i]\n        nums[i+1:] = sorted(nums[i+1:])"
        },
        {
            "task_id": "next-permutation",
            "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first element from the right which is not in the correct position\n        # If no such element is found, then the array is sorted in descending order\n        # and the next permutation is the lowest order\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # If such element is found, find the next element which is greater than this element\n        # Swap this element with the next greater element\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the elements from the position after the element which was swapped\n        # till the end of the array\n        nums[i+1:] = nums[i+1:][::-1]"
        },
        {
            "task_id": "next-permutation",
            "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first element from the right which is not in the correct position\n        # If no such element is found, then the array is sorted in descending order\n        # and we need to reverse it to get the next permutation\n        # If such element is found, then find the smallest element on the right\n        # which is greater than the element at first_element_not_in_position\n        # Swap the two elements\n        # Now sort the elements on the right of first_element_not_in_position\n        # in ascending order\n        \n        # Find the first element from the right which is not in the correct position\n        first_element_not_in_position = -1\n        for i in range(len(nums)-2, -1, -1):\n            if nums[i] < nums[i+1]:\n                first_element_not_in_position = i\n                break\n        \n        # If no such element is found, then the array is sorted in descending order\n        # and we need to reverse it to get the next permutation\n        if first_element_not_in_position == -1:\n            nums.reverse()\n            return\n        \n        # Find the smallest element on the right which is greater than the element at first_element_not_in_position\n        smallest_greater_element = float('inf')\n        smallest_greater_element_index = -1\n        for i in range(first_element_not_in_position+1, len(nums)):\n            if nums[i] > nums[first_element_not_in_position] and nums[i] < smallest_greater_element:\n                smallest_greater_element = nums[i]\n                smallest_greater_element_index = i\n        \n        # Swap the two elements\n        nums[first_element_not_in_position], nums[smallest_greater_element_index] = nums[smallest_greater_element_index], nums[first_element_not_in_position]\n        \n        # Now sort the elements on the right of first_element_not_in_position\n        # in ascending order\n        nums[first_element_not_in_position+1:] = sorted(nums[first_element_not_in_position+1:])"
        },
        {
            "task_id": "next-permutation",
            "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first element from the right that is not in the correct position\n        # If no such element is found, then the array is sorted in descending order\n        # and the next permutation is the lowest possible order (sorted in ascending order)\n        # which is the original array\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # If such element is found, find the first element from the right that is greater\n        # than the element at index i\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            \n            # Swap the two elements\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the sequence from the element at index i + 1 to the end\n        # This is done to arrange the elements in the ascending order\n        # For example, if the input is [1, 2, 3, 4], the sequence after reversing\n        # the elements from index 2 to 4 is [1, 4, 3, 2]\n        # The final step is to reverse the sequence from index 2 to 4 again\n        # to get the next permutation [1, 3, 2, 4]\n        nums[i+1:] = nums[i+1:][::-1]"
        }
    ],
    "contains-duplicate-ii": [
        {
            "task_id": "contains-duplicate-ii",
            "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Create a dictionary to map the elements of the list to their indices\n        # If the element is already present in the dictionary, then we have found a pair of indices whose\n        # absolute difference is less than or equal to k\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        \n        my_dict = {}\n        for i in range(len(nums)):\n            if nums[i] in my_dict and i - my_dict[nums[i]] <= k:\n                return True\n            my_dict[nums[i]] = i\n        return False"
        },
        {
            "task_id": "contains-duplicate-ii",
            "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Create a dictionary to map the elements of the list to their indices\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        dict = {}\n        for i in range(len(nums)):\n            dict[nums[i]] = i\n        \n        # Iterate through the list\n        # Time complexity: O(n)\n        for i in range(len(nums)):\n            \n            # If the element is already in the dictionary\n            # Time complexity: O(1)\n            if nums[i] in dict and abs(dict[nums[i]] - i) <= k:\n                return True\n        \n        # If no duplicate is found\n        # Time complexity: O(1)\n        return False"
        },
        {
            "task_id": "contains-duplicate-ii",
            "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Create a dictionary to map the elements of the list to their indices\n        # If the element is already present in the dictionary, then we have found a pair of indices whose\n        # absolute difference is less than or equal to k\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        \n        my_dict = {}\n        for i in range(len(nums)):\n            if nums[i] in my_dict and i - my_dict[nums[i]] <= k:\n                return True\n            my_dict[nums[i]] = i\n        return False"
        },
        {
            "task_id": "contains-duplicate-ii",
            "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Create a dictionary to map the elements of the list to their indices\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        dict = {}\n        for i in range(len(nums)):\n            dict[nums[i]] = i\n        \n        # Iterate through the list\n        # Time complexity: O(n)\n        for i in range(len(nums)):\n            # Check if the element is already in the dictionary\n            # Time complexity: O(1)\n            if nums[i] in dict and abs(dict[nums[i]] - i) <= k:\n                return True\n        return False"
        },
        {
            "task_id": "contains-duplicate-ii",
            "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Create a dictionary to map the elements of the list to their indices\n        # If the element is already present in the dictionary, then we have found a pair of indices whose\n        # absolute difference is less than or equal to k\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        \n        my_dict = {}\n        for i in range(len(nums)):\n            if nums[i] in my_dict and i - my_dict[nums[i]] <= k:\n                return True\n            my_dict[nums[i]] = i\n        return False"
        }
    ],
    "maximum-gap": [
        {
            "task_id": "maximum-gap",
            "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        \n        max_diff = 0\n        for i in range(len(nums)-1):\n            max_diff = max(max_diff, nums[i+1] - nums[i])\n            \n        return max_diff"
        },
        {
            "task_id": "maximum-gap",
            "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        \n        max_diff = 0\n        for i in range(len(nums)-1):\n            max_diff = max(max_diff, nums[i+1]-nums[i])\n            \n        return max_diff"
        },
        {
            "task_id": "maximum-gap",
            "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        \n        max_diff = 0\n        for i in range(len(nums)-1):\n            max_diff = max(max_diff, nums[i+1]-nums[i])\n            \n        return max_diff"
        },
        {
            "task_id": "maximum-gap",
            "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(len(nums)-1):\n            max_diff = max(max_diff, nums[i+1]-nums[i])\n        return max_diff"
        },
        {
            "task_id": "maximum-gap",
            "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        \n        max_diff = 0\n        for i in range(len(nums)-1):\n            max_diff = max(max_diff, nums[i+1]-nums[i])\n            \n        return max_diff"
        }
    ],
    "binary-tree-level-order-traversal": [
        {
            "task_id": "binary-tree-level-order-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                \n            result.append(level)\n            \n        return result"
        },
        {
            "task_id": "binary-tree-level-order-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                \n            result.append(level)\n            \n        return result"
        },
        {
            "task_id": "binary-tree-level-order-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"
        },
        {
            "task_id": "binary-tree-level-order-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                \n            result.append(level)\n            \n        return result"
        },
        {
            "task_id": "binary-tree-level-order-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"
        }
    ],
    "couples-holding-hands": [
        {
            "task_id": "couples-holding-hands",
            "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to keep track of couples\n        couple = {}\n        for i in range(0, len(row), 2):\n            couple[row[i]] = row[i+1]\n            couple[row[i+1]] = row[i]\n        \n        # Initialize a list to keep track of all the swaps\n        swaps = []\n        \n        # Iterate through the row\n        for i in range(len(row)):\n            \n            # If the current person is not seated with his/her couple, then swap them\n            if row[i] != couple[row[i]]:\n                swaps.append(i)\n                row[i], row[swaps[-1]] = row[swaps[-1]], row[i]\n                \n        return len(swaps)"
        },
        {
            "task_id": "couples-holding-hands",
            "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize an empty dictionary to store the couples\n        couples = {}\n        \n        # Iterate over the row\n        for i in range(0, len(row), 2):\n            # If the current element is not present in the dictionary\n            if row[i] not in couples:\n                # Add the current element and its pair to the dictionary\n                couples[row[i]] = row[i+1]\n        \n        # Initialize the number of swaps\n        swaps = 0\n        \n        # Iterate over the row\n        for i in range(0, len(row), 2):\n            # If the current element is not seated with its pair\n            if row[i] != couples[row[i+1]]:\n                # Increment the number of swaps\n                swaps += 1\n                \n                # Swap the current element with its pair\n                row[i], row[row.index(couples[row[i+1]])] = row[row.index(couples[row[i+1]])], row[i]\n                \n        # Return the number of swaps\n        return swaps"
        },
        {
            "task_id": "couples-holding-hands",
            "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize an empty dictionary to store the couples\n        couples = {}\n        \n        # Iterate over the row and add the couples to the dictionary\n        for i in range(0, len(row), 2):\n            couples[row[i]] = row[i+1]\n            couples[row[i+1]] = row[i]\n        \n        # Initialize the number of swaps\n        swaps = 0\n        \n        # Iterate over the row\n        for i in range(0, len(row), 2):\n            \n            # If the current person is not sitting with their partner\n            if row[i] != couples[row[i+1]]:\n                \n                # Swap the current person with their partner\n                row[i], row[row.index(couples[row[i+1]])] = row[row.index(couples[row[i+1]])], row[i]\n                \n                # Increment the number of swaps\n                swaps += 1\n        \n        # Return the number of swaps\n        return swaps"
        },
        {
            "task_id": "couples-holding-hands",
            "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to keep track of couples\n        couple = {}\n        for i in range(0, len(row), 2):\n            couple[row[i]] = row[i+1]\n            couple[row[i+1]] = row[i]\n        \n        # Initialize a list to keep track of all swaps\n        swaps = []\n        \n        # Iterate through the row\n        for i in range(len(row)):\n            \n            # If the current person is not seated with their couple\n            if row[i] != couple[i]:\n                \n                # Find the index of the couple\n                couple_index = row.index(couple[i])\n                \n                # Swap the current person with their couple\n                row[i], row[couple_index] = row[couple_index], row[i]\n                \n                # Add the swap to the list of swaps\n                swaps.append(i)\n                \n                # Since only consecutive swaps are allowed,\n                # the swapped person cannot be seated with their couple now.\n                # So, they have to swap again.\n                # Add the index of the swapped person to the list of swaps.\n                swaps.append(couple_index)\n        \n        # Return the number of swaps\n        return len(swaps) // 2"
        },
        {
            "task_id": "couples-holding-hands",
            "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize an empty dictionary to store the couples\n        couples = {}\n        \n        # Iterate over the row and add the couples to the dictionary\n        for i in range(0, len(row), 2):\n            couples[row[i]] = row[i+1]\n            couples[row[i+1]] = row[i]\n            \n        # Initialize the number of swaps\n        swaps = 0\n        \n        # Iterate over the row\n        for i in range(0, len(row), 2):\n            \n            # If the current person is not sitting with their partner\n            if row[i] != couples[row[i+1]]:\n                \n                # Swap the current person with their partner\n                row[i], row[row.index(couples[row[i+1]])] = row[row.index(couples[row[i+1]])], row[i]\n                \n                # Increment the number of swaps\n                swaps += 1\n                \n        # Return the number of swaps\n        return swaps"
        }
    ],
    "interleaving-string": [
        {
            "task_id": "interleaving-string",
            "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s1) + len(s2) != len(s3):\n        #     return False\n        \n        # dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        # dp[0][0] = True\n        \n        # for i in range(1, len(s1) + 1):\n        #     dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        # for j in range(1, len(s2) + 1):\n        #     dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        # for i in range(1, len(s1) + 1):\n        #     for j in range(1, len(s2) + 1):\n        #         dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        # return dp[len(s1)][len(s2)]\n\n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [False for _ in range(len(s2) + 1)]\n        \n        dp[0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s2)]"
        },
        {
            "task_id": "interleaving-string",
            "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s1) + len(s2) != len(s3):\n        #     return False\n        \n        # dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        # dp[0][0] = True\n        \n        # for i in range(1, len(s1) + 1):\n        #     dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        # for j in range(1, len(s2) + 1):\n        #     dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        # for i in range(1, len(s1) + 1):\n        #     for j in range(1, len(s2) + 1):\n        #         dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        # return dp[len(s1)][len(s2)]\n\n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [False for _ in range(len(s2) + 1)]\n        \n        dp[0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s2)]"
        },
        {
            "task_id": "interleaving-string",
            "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s1) + len(s2) != len(s3):\n        #     return False\n        \n        # dp = [[False for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\n        \n        # dp[0][0] = True\n        \n        # for i in range(1, len(s1)+1):\n        #     dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\n        \n        # for j in range(1, len(s2)+1):\n        #     dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\n        \n        # for i in range(1, len(s1)+1):\n        #     for j in range(1, len(s2)+1):\n        #         dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\n        \n        # return dp[len(s1)][len(s2)]\n\n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [False for _ in range(len(s2)+1)]\n        \n        dp[0] = True\n        \n        for i in range(1, len(s1)+1):\n            dp[0] = dp[0] and s1[i-1] == s3[i-1]\n        \n        for j in range(1, len(s2)+1):\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\n        \n        for i in range(1, len(s1)+1):\n            for j in range(1, len(s2)+1):\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\n        \n        return dp[len(s2)]"
        },
        {
            "task_id": "interleaving-string",
            "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s1) + len(s2) != len(s3):\n        #     return False\n        \n        # dp = [[False for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\n        \n        # dp[0][0] = True\n        \n        # for i in range(1, len(s1)+1):\n        #     dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\n        \n        # for j in range(1, len(s2)+1):\n        #     dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\n        \n        # for i in range(1, len(s1)+1):\n        #     for j in range(1, len(s2)+1):\n        #         dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\n        \n        # return dp[len(s1)][len(s2)]\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [False for _ in range(len(s2)+1)]\n        \n        dp[0] = True\n        \n        for i in range(1, len(s1)+1):\n            dp[0] = dp[0] and s1[i-1] == s3[i-1]\n        \n        for j in range(1, len(s2)+1):\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\n        \n        for i in range(1, len(s1)+1):\n            for j in range(1, len(s2)+1):\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\n        \n        return dp[len(s2)]"
        },
        {
            "task_id": "interleaving-string",
            "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s1) + len(s2) != len(s3):\n        #     return False\n        \n        # dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        # dp[0][0] = True\n        \n        # for i in range(1, len(s1) + 1):\n        #     dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        # for j in range(1, len(s2) + 1):\n        #     dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        # for i in range(1, len(s1) + 1):\n        #     for j in range(1, len(s2) + 1):\n        #         dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        # return dp[len(s1)][len(s2)]\n\n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [False for _ in range(len(s2) + 1)]\n        \n        dp[0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s2)]"
        }
    ],
    "assign-cookies": [
        {
            "task_id": "assign-cookies",
            "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"
        },
        {
            "task_id": "assign-cookies",
            "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"
        },
        {
            "task_id": "assign-cookies",
            "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"
        },
        {
            "task_id": "assign-cookies",
            "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"
        },
        {
            "task_id": "assign-cookies",
            "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"
        }
    ],
    "keyboard-row": [
        {
            "task_id": "keyboard-row",
            "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first_row = ['q','w','e','r','t','y','u','i','o','p']\n        second_row = ['a','s','d','f','g','h','j','k','l']\n        third_row = ['z','x','c','v','b','n','m']\n        \n        result = []\n        \n        for word in words:\n            word = word.lower()\n            flag = 0\n            for letter in word:\n                if letter in first_row:\n                    flag = 1\n                    break\n                elif letter in second_row:\n                    flag = 2\n                    break\n                elif letter in third_row:\n                    flag = 3\n                    break\n                \n            if flag == 1:\n                if all(letter in first_row for letter in word):\n                    result.append(word)\n            elif flag == 2:\n                if all(letter in second_row for letter in word):\n                    result.append(word)\n            elif flag == 3:\n                if all(letter in third_row for letter in word):\n                    result.append(word)\n                    \n        return result"
        },
        {
            "task_id": "keyboard-row",
            "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first_row = ['q','w','e','r','t','y','u','i','o','p']\n        second_row = ['a','s','d','f','g','h','j','k','l']\n        third_row = ['z','x','c','v','b','n','m']\n        \n        result = []\n        \n        for word in words:\n            word = word.lower()\n            flag = 0\n            for letter in word:\n                if letter in first_row:\n                    flag = 1\n                    break\n                elif letter in second_row:\n                    flag = 2\n                    break\n                elif letter in third_row:\n                    flag = 3\n                    break\n            if flag == 1:\n                if all(letter in first_row for letter in word):\n                    result.append(word)\n            elif flag == 2:\n                if all(letter in second_row for letter in word):\n                    result.append(word)\n            elif flag == 3:\n                if all(letter in third_row for letter in word):\n                    result.append(word)\n                    \n        return result"
        },
        {
            "task_id": "keyboard-row",
            "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first_row = \"qwertyuiop\"\n        second_row = \"asdfghjkl\"\n        third_row = \"zxcvbnm\"\n        \n        result = []\n        \n        for word in words:\n            word = word.lower()\n            if word[0] in first_row:\n                for i in range(1, len(word)):\n                    if word[i] not in first_row:\n                        break\n                else:\n                    result.append(word)\n            elif word[0] in second_row:\n                for i in range(1, len(word)):\n                    if word[i] not in second_row:\n                        break\n                else:\n                    result.append(word)\n            elif word[0] in third_row:\n                for i in range(1, len(word)):\n                    if word[i] not in third_row:\n                        break\n                else:\n                    result.append(word)\n                    \n        return result"
        },
        {
            "task_id": "keyboard-row",
            "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first_row = \"qwertyuiop\"\n        second_row = \"asdfghjkl\"\n        third_row = \"zxcvbnm\"\n        \n        result = []\n        \n        for word in words:\n            word = word.lower()\n            if word[0] in first_row:\n                for i in range(1, len(word)):\n                    if word[i] not in first_row:\n                        break\n                else:\n                    result.append(word)\n            elif word[0] in second_row:\n                for i in range(1, len(word)):\n                    if word[i] not in second_row:\n                        break\n                else:\n                    result.append(word)\n            elif word[0] in third_row:\n                for i in range(1, len(word)):\n                    if word[i] not in third_row:\n                        break\n                else:\n                    result.append(word)\n                    \n        return result"
        },
        {
            "task_id": "keyboard-row",
            "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first_row = ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p']\n        second_row = ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l']\n        third_row = ['z', 'x', 'c', 'v', 'b', 'n', 'm']\n        \n        result = []\n        \n        for word in words:\n            word = word.lower()\n            if word[0] in first_row:\n                for i in range(1, len(word)):\n                    if word[i] not in first_row:\n                        break\n                else:\n                    result.append(word)\n            elif word[0] in second_row:\n                for i in range(1, len(word)):\n                    if word[i] not in second_row:\n                        break\n                else:\n                    result.append(word)\n            elif word[0] in third_row:\n                for i in range(1, len(word)):\n                    if word[i] not in third_row:\n                        break\n                else:\n                    result.append(word)\n                    \n        return result"
        }
    ],
    "reverse-linked-list-ii": [
        {
            "task_id": "reverse-linked-list-ii",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        \n        for i in range(left-1):\n            pre = pre.next\n        \n        cur = pre.next\n        for i in range(left, right):\n            tmp = cur.next\n            cur.next = tmp.next\n            tmp.next = pre.next\n            pre.next = tmp\n        \n        return dummy.next"
        },
        {
            "task_id": "reverse-linked-list-ii",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        \n        for i in range(left-1):\n            pre = pre.next\n        \n        cur = pre.next\n        nxt = cur.next\n        \n        for i in range(right-left):\n            cur.next = nxt.next\n            nxt.next = pre.next\n            pre.next = nxt\n            nxt = cur.next\n            \n        return dummy.next"
        },
        {
            "task_id": "reverse-linked-list-ii",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        \n        for i in range(left-1):\n            pre = pre.next\n        \n        cur = pre.next\n        nxt = cur.next\n        \n        for i in range(right-left):\n            cur.next = nxt.next\n            nxt.next = pre.next\n            pre.next = nxt\n            nxt = cur.next\n            \n        return dummy.next"
        },
        {
            "task_id": "reverse-linked-list-ii",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        \n        for i in range(left-1):\n            pre = pre.next\n        \n        cur = pre.next\n        for i in range(left, right):\n            tmp = cur.next\n            cur.next = tmp.next\n            tmp.next = pre.next\n            pre.next = tmp\n        \n        return dummy.next"
        },
        {
            "task_id": "reverse-linked-list-ii",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        current = head\n        previous = None\n        next = None\n        count = 1\n        \n        while count <= right:\n            if count >= left:\n                next = current.next\n                current.next = previous\n                previous = current\n                current = next\n            else:\n                previous = current\n                current = current.next\n            count += 1\n        \n        if left == 1:\n            head.next = previous\n            return current\n        else:\n            previous = head.next\n            while previous.next != current:\n                previous = previous.next\n            previous.next = current\n            return head"
        }
    ],
    "shortest-palindrome": [
        {
            "task_id": "shortest-palindrome",
            "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Find the longest prefix which is also a suffix.\n        l = len(s)\n        for i in range(l//2):\n            if s[:l-i] == s[i+1:]:\n                break\n        else:\n            i = l\n        \n        # Build the palindrome\n        return s[l-i:][::-1] + s"
        },
        {
            "task_id": "shortest-palindrome",
            "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Find the longest prefix which is also a suffix.\n        # KMP Algorithm\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        \n        # Find the length of the longest prefix which is also a suffix.\n        length = self.getLongestPrefixSuffixLength(s)\n        \n        # Get the suffix which is also a prefix.\n        suffix = s[length:]\n        \n        # Get the prefix which is also a suffix.\n        prefix = s[:length]\n        \n        # Reverse the suffix.\n        suffix = suffix[::-1]\n        \n        # Return the concatenation of the suffix and the prefix.\n        return suffix + prefix\n    \n    def getLongestPrefixSuffixLength(self, s):\n        \"\"\"\n        Returns the length of the longest prefix which is also a suffix.\n        \"\"\"\n        \n        # Initialize the length.\n        length = 0\n        \n        # Initialize the next array.\n        next = [0] * len(s)\n        \n        # Fill the next array.\n        for i in range(1, len(s)):\n            while length > 0 and s[length] != s[i]:\n                length = next[length - 1]\n            if s[length] == s[i]:\n                length += 1\n            next[i] = length\n        \n        # Return the length of the longest prefix which is also a suffix.\n        return length"
        },
        {
            "task_id": "shortest-palindrome",
            "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Find the longest prefix which is also a suffix.\n        l = len(s)\n        for i in range(l//2):\n            if s[:l-i] == s[i+1:]:\n                break\n        else:\n            i = l\n        \n        # Build the palindrome around it.\n        return s[l-i:][::-1] + s"
        },
        {
            "task_id": "shortest-palindrome",
            "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Find the longest prefix which is also a suffix.\n        # KMP algorithm\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        \n        # Find the length of the longest prefix which is also a suffix.\n        length = self.getLongestPrefixSuffixLength(s)\n        \n        # Get the suffix which is also a prefix.\n        suffix = s[length:]\n        \n        # Get the prefix which is also a suffix.\n        prefix = s[:length]\n        \n        # Reverse the suffix.\n        suffix = suffix[::-1]\n        \n        # Return the concatenation of the suffix and the prefix.\n        return suffix + prefix\n    \n    def getLongestPrefixSuffixLength(self, s):\n        \"\"\"\n        Returns the length of the longest prefix which is also a suffix.\n        \"\"\"\n        \n        # Initialize the length.\n        length = 0\n        \n        # Initialize the next array.\n        next = [0] * len(s)\n        \n        # Fill the next array.\n        for i in range(1, len(s)):\n            while length > 0 and s[length] != s[i]:\n                length = next[length - 1]\n            if s[length] == s[i]:\n                length += 1\n            next[i] = length\n        \n        # Return the length of the longest prefix which is also a suffix.\n        return length"
        },
        {
            "task_id": "shortest-palindrome",
            "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Find the longest prefix which is also a suffix.\n        # KMP algorithm\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        \n        # Find the length of the longest prefix which is also a suffix.\n        length = self.getLongestPrefixSuffixLength(s)\n        \n        # Get the suffix which is also a prefix.\n        suffix = s[length:]\n        \n        # Get the prefix which is also a suffix.\n        prefix = s[:length]\n        \n        # Return the concatenation of the suffix and the reverse of the prefix.\n        return suffix + prefix[::-1]\n    \n    def getLongestPrefixSuffixLength(self, s):\n        \"\"\"\n        Returns the length of the longest prefix which is also a suffix.\n        \"\"\"\n        \n        # Initialize the length.\n        length = 0\n        \n        # Initialize the next array.\n        next = [0] * len(s)\n        \n        # Iterate over the string.\n        for i in range(1, len(s)):\n            \n            # Check if the current character matches the first character.\n            if s[i] == s[length]:\n                \n                # Increment the length.\n                length += 1\n                \n                # Set the value at the current index in the next array.\n                next[i] = length\n                \n            # Check if the length is greater than 0.\n            elif length > 0:\n                \n                # Get the previous index in the next array.\n                previous_index = next[i - 1]\n                \n                # Set the value at the current index in the next array.\n                next[i] = previous_index\n            \n            # Check if the length is 0.\n            else:\n                \n                # Set the value at the current index in the next array.\n                next[i] = 0\n        \n        # Return the length.\n        return length"
        }
    ],
    "minimum-window-substring": [
        {
            "task_id": "minimum-window-substring",
            "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the dictionary with all the characters of t.\n        need = {}\n        for i in t:\n            if i not in need:\n                need[i] = 1\n            else:\n                need[i] += 1\n        \n        # Number of unique characters in t, which need to be found in the window.\n        unique_chars = len(need)\n        \n        # Left and Right pointer\n        left, right = 0, 0\n        \n        # Formed window\n        window = {}\n        \n        # Answer\n        ans = float('inf'), None, None\n        \n        # Loop through the string\n        while right < len(s):\n            \n            # Add the character to the window\n            c = s[right]\n            window[c] = window.get(c, 0) + 1\n            \n            # If the frequency of the current character added equals to the frequency of the character in t, then decrement the unique_chars.\n            if need.get(c, 0) is not None and window[c] == need[c]:\n                unique_chars -= 1\n            \n            # Shrink the window if possible\n            while unique_chars == 0:\n                \n                # If the length of the current window is less than the answer, then update the answer\n                if right - left + 1 < ans[0]:\n                    ans = (right - left + 1, left, right)\n                \n                # Remove the first character of the window\n                d = s[left]\n                window[d] -= 1\n                \n                # If the frequency of the first character of the window is less than the frequency of the first character in t, then increment the unique_chars.\n                if need.get(d, 0) is not None and window[d] < need[d]:\n                    unique_chars += 1\n                \n                # Move the left pointer ahead\n                left += 1\n            \n            # Increment the right pointer\n            right += 1\n        \n        # If the answer is not found\n        if ans[0] == float('inf'):\n            return \"\"\n        else:\n            return s[ans[1]: ans[2] + 1]"
        },
        {
            "task_id": "minimum-window-substring",
            "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the dictionary with all the characters of t.\n        need = {}\n        for i in t:\n            if i not in need:\n                need[i] = 1\n            else:\n                need[i] += 1\n        \n        # Initialize the dictionary for the window.\n        have = {}\n        \n        # Left and right pointer\n        left = 0\n        right = 0\n        \n        # Length of the substring\n        length = float('inf')\n        \n        # Form the window\n        while right < len(s):\n            \n            # Add the character to have\n            if s[right] not in have:\n                have[s[right]] = 1\n            else:\n                have[s[right]] += 1\n            \n            # If the character is required\n            if s[right] in need:\n                \n                # If the frequency is less than the required frequency\n                if have[s[right]] <= need[s[right]]:\n                    \n                    # Move the left pointer\n                    while left < right and have[s[right]] > need[s[right]]:\n                        have[s[left]] -= 1\n                        left += 1\n                    \n                    # If the substring is valid\n                    if right - left + 1 < length:\n                        length = right - left + 1\n                        start = left\n                \n            right += 1\n        \n        # If no such substring is found\n        if length == float('inf'):\n            return \"\"\n        \n        # Return the substring\n        return s[start: start + length]"
        },
        {
            "task_id": "minimum-window-substring",
            "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the dictionary with all the characters of t.\n        window = {i:0 for i in t}\n        \n        # Initialize the counter to keep track of the characters in t.\n        count = len(t)\n        \n        # Left and right pointer\n        left = 0\n        right = 0\n        \n        # answer tuple\n        ans = (0,0)\n        \n        # Loop through the string s\n        while right < len(s):\n            \n            # If the character is in t, then increment the count.\n            if s[right] in window:\n                window[s[right]] += 1\n                \n                # If the count is equal to the number of times the character appears in t, then decrement the counter.\n                if window[s[right]] == t.count(s[right]):\n                    count -= 1\n            \n            # If the counter is 0, then we have found the window.\n            if count == 0:\n                \n                # Loop backward till we don't have a window.\n                while left <= right:\n                    \n                    # If the character is not in t or the count is more than the number of times it appears in t, then break.\n                    if s[left] not in window or window[s[left]] > t.count(s[left]):\n                        break\n                    \n                    # Decrement the count\n                    window[s[left]] -= 1\n                    \n                    # Increment the left pointer\n                    left += 1\n                \n                # If the length of the substring is less than the length of the previous substring or if this is the first window, then update the answer.\n                if right - left + 1 < ans[1] - ans[0] or ans == (0,0):\n                    ans = (left, right + 1)\n                \n                # Increment the left pointer\n                left += 1\n            \n            # Increment the right pointer\n            right += 1\n        \n        # If the length of the substring is 0, then return empty string.\n        if ans[1] - ans[0] == 0:\n            return \"\"\n        \n        # Else return the substring.\n        return s[ans[0]:ans[1]]"
        },
        {
            "task_id": "minimum-window-substring",
            "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the dictionary with all the characters of t.\n        need = {}\n        for i in t:\n            if i not in need:\n                need[i] = 1\n            else:\n                need[i] += 1\n        \n        # Number of unique characters in t, which need to be found in the window.\n        unique_chars = len(need)\n        \n        # Left and Right pointer\n        left, right = 0, 0\n        \n        # Formed window\n        window = {}\n        \n        # Answer\n        ans = float('inf'), None, None\n        \n        # Loop through the string\n        while right < len(s):\n            \n            # Add the character to the window\n            c = s[right]\n            window[c] = window.get(c, 0) + 1\n            \n            # If the frequency of the current character added equals to the frequency of the character in t, then decrement the unique_chars.\n            if need.get(c, 0) is not None and window[c] == need[c]:\n                unique_chars -= 1\n            \n            # Shrink the window if possible\n            while unique_chars == 0:\n                \n                # If the length of the current window is less than the answer, then update the answer\n                if right - left + 1 < ans[0]:\n                    ans = (right - left + 1, left, right)\n                \n                # Remove the first character of the window\n                d = s[left]\n                window[d] -= 1\n                \n                # If the frequency of the first character of the window is less than the frequency of the first character in t, then increment the unique_chars.\n                if need.get(d, 0) is not None and window[d] < need[d]:\n                    unique_chars += 1\n                \n                # Move the left pointer ahead\n                left += 1\n            \n            # Increment the right pointer\n            right += 1\n        \n        # If the answer is not found\n        if ans[0] == float('inf'):\n            return \"\"\n        else:\n            return s[ans[1]: ans[2] + 1]"
        },
        {
            "task_id": "minimum-window-substring",
            "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the dictionary with all the characters of t.\n        window = {i:0 for i in t}\n        \n        # Initialize the counter to keep track of the characters to be found.\n        count = len(t)\n        \n        # Left and right pointer\n        left = 0\n        right = 0\n        \n        # answer tuple\n        ans = (0,0)\n        \n        # Loop through the string s\n        while right < len(s):\n            \n            # If the character is in t, decrement the count.\n            if s[right] in window:\n                window[s[right]] += 1\n                \n                # If the count is 0, it means the character is found.\n                if window[s[right]] == 1:\n                    count -= 1\n            \n            # If the count is 0, it means all the characters are found.\n            if count == 0:\n                \n                # Move the left pointer until we find a character not in t.\n                while left < len(s) and s[left] in window:\n                    window[s[left]] -= 1\n                    left += 1\n                \n                # If this is the first window or the length of the window is less than the previous window, update the answer.\n                if ans == (0,0) or right - left + 1 < ans[1] - ans[0] + 1:\n                    ans = (left, right)\n                \n                # Move the left pointer back.\n                window[s[left]] += 1\n                count += 1\n                left += 1\n            \n            # Increment the right pointer.\n            right += 1\n        \n        # If no window is found, return empty string.\n        if ans == (0,0):\n            return \"\"\n        \n        # Return the substring.\n        return s[ans[0]:ans[1]+1]"
        }
    ],
    "self-crossing": [
        {
            "task_id": "self-crossing",
            "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) <= 3:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            if i >= 5 and distance[i-2] - distance[i-4] <= distance[i] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] >= distance[i-3] - distance[i-5] and distance[i-1] <= distance[i-3]:\n                return True\n        return False"
        },
        {
            "task_id": "self-crossing",
            "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) <= 3:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            if i >= 5 and distance[i-2] - distance[i-4] <= distance[i] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] >= distance[i-3] - distance[i-5] and distance[i-1] <= distance[i-3]:\n                return True\n        return False"
        },
        {
            "task_id": "self-crossing",
            "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) <= 3:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            if i >= 5 and distance[i-2] - distance[i-4] <= distance[i] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] >= distance[i-3] - distance[i-5] and distance[i-1] <= distance[i-3]:\n                return True\n        return False"
        },
        {
            "task_id": "self-crossing",
            "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) <= 3:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            if i >= 5 and distance[i-2] - distance[i-4] <= distance[i] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] >= distance[i-3] - distance[i-5] and distance[i-1] <= distance[i-3]:\n                return True\n        return False"
        },
        {
            "task_id": "self-crossing",
            "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) <= 3:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            if i >= 5 and distance[i-2] - distance[i-4] <= distance[i] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] >= distance[i-3] - distance[i-5] and distance[i-1] <= distance[i-3]:\n                return True\n        return False"
        }
    ],
    "remove-duplicates-from-sorted-list": [
        {
            "task_id": "remove-duplicates-from-sorted-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            head = head.next\n            return self.deleteDuplicates(head)\n        \n        head.next = self.deleteDuplicates(head.next)\n        return head"
        },
        {
            "task_id": "remove-duplicates-from-sorted-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            while head.next is not None and head.val == head.next.val:\n                head = head.next\n            return self.deleteDuplicates(head.next)\n        else:\n            head.next = self.deleteDuplicates(head.next)\n            return head"
        },
        {
            "task_id": "remove-duplicates-from-sorted-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            head = head.next\n            return self.deleteDuplicates(head)\n        \n        head.next = self.deleteDuplicates(head.next)\n        return head"
        },
        {
            "task_id": "remove-duplicates-from-sorted-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            head = head.next\n            return self.deleteDuplicates(head)\n        \n        head.next = self.deleteDuplicates(head.next)\n        return head"
        },
        {
            "task_id": "remove-duplicates-from-sorted-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            head = head.next\n            return self.deleteDuplicates(head)\n        \n        head.next = self.deleteDuplicates(head.next)\n        return head"
        }
    ],
    "longest-palindrome": [
        {
            "task_id": "longest-palindrome",
            "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store the count of each character in the string\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 0\n            char_count[char] += 1\n        \n        # Initialize a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # Iterate through the characters in the string\n        for char in char_count:\n            # If the character appears an even number of times, we can include all of them in the palindrome\n            if char_count[char] % 2 == 0:\n                longest_palindrome += char_count[char]\n            # If the character appears an odd number of times, we can include all of them except one in the palindrome\n            else:\n                longest_palindrome += char_count[char] - 1\n        \n        # Return the length of the longest palindrome\n        return longest_palindrome"
        },
        {
            "task_id": "longest-palindrome",
            "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store the count of each character in the string\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 0\n            char_count[char] += 1\n        \n        # Initialize a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # Iterate through the characters in the string\n        for char in char_count:\n            # If the character appears an even number of times, we can include all of them in the palindrome\n            if char_count[char] % 2 == 0:\n                longest_palindrome += char_count[char]\n            # If the character appears an odd number of times, we can include all of them except one in the palindrome\n            else:\n                longest_palindrome += char_count[char] - 1\n        \n        # Return the length of the longest palindrome\n        return longest_palindrome"
        },
        {
            "task_id": "longest-palindrome",
            "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store the count of each character in the string\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 0\n            char_count[char] += 1\n        \n        # Initialize a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # Iterate through the characters in the string\n        for char in char_count:\n            # If the character appears an even number of times, we can include all of them in the palindrome\n            if char_count[char] % 2 == 0:\n                longest_palindrome += char_count[char]\n            # If the character appears an odd number of times, we can include all of them except one in the palindrome\n            else:\n                longest_palindrome += char_count[char] - 1\n        \n        # Return the length of the longest palindrome\n        return longest_palindrome"
        },
        {
            "task_id": "longest-palindrome",
            "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store the count of each character in the string\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 0\n            char_count[char] += 1\n        \n        # Initialize a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # Iterate through the characters in the string\n        for char in char_count:\n            # If the character appears an even number of times, we can include all of them in the palindrome\n            if char_count[char] % 2 == 0:\n                longest_palindrome += char_count[char]\n            # If the character appears an odd number of times, we can include all of them except one in the palindrome\n            else:\n                longest_palindrome += char_count[char] - 1\n        \n        # Return the length of the longest palindrome\n        return longest_palindrome"
        },
        {
            "task_id": "longest-palindrome",
            "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store the count of each character in the string\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 0\n            char_count[char] += 1\n        \n        # Initialize a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # Iterate through the characters in the string\n        for char in char_count:\n            # If the character appears an even number of times, we can include all of them in the palindrome\n            if char_count[char] % 2 == 0:\n                longest_palindrome += char_count[char]\n            # If the character appears an odd number of times, we can include all of them except one in the palindrome\n            else:\n                longest_palindrome += char_count[char] - 1\n        \n        # Return the length of the longest palindrome\n        return longest_palindrome"
        }
    ],
    "construct-binary-tree-from-inorder-and-postorder-traversal": [
        {
            "task_id": "construct-binary-tree-from-inorder-and-postorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root"
        },
        {
            "task_id": "construct-binary-tree-from-inorder-and-postorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root"
        },
        {
            "task_id": "construct-binary-tree-from-inorder-and-postorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root"
        },
        {
            "task_id": "construct-binary-tree-from-inorder-and-postorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root"
        },
        {
            "task_id": "construct-binary-tree-from-inorder-and-postorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root"
        }
    ],
    "cut-off-trees-for-golf-event": [
        {
            "task_id": "cut-off-trees-for-golf-event",
            "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path to the tree\n        # cut the tree\n        # repeat until all trees are cut\n        \n        # find the shortest path to the tree\n        # BFS\n        # find the shortest path"
        },
        {
            "task_id": "cut-off-trees-for-golf-event",
            "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(forest, start):\n            queue = collections.deque([start])\n            visited = set([start])\n            height = 0\n            while queue:\n                for _ in range(len(queue)):\n                    x, y = queue.popleft()\n                    if forest[x][y] > height:\n                        height = forest[x][y]\n                    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < len(forest) and 0 <= ny < len(forest[0]) and (nx, ny) not in visited and forest[nx][ny] > 0:\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n                if height > 0:\n                    return height\n            return -1\n        \n        heights = [i for i in forest if i != [0] for j in i if j > 0]\n        heights.sort()\n        start = None\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 0:\n                    start = (i, j)\n                    break\n        ans = 0\n        for height in heights:\n            ans += bfs(forest, start)\n            if ans == -1:\n                return -1\n            forest[start[0]][start[1]] = 1\n            start = None\n        return ans"
        },
        {
            "task_id": "cut-off-trees-for-golf-event",
            "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # find the smallest tree\n        # find the shortest path to the smallest tree\n        # cut the smallest tree\n        # repeat\n        \n        # find the smallest tree\n        smallest_tree = 1000000000\n        smallest_tree_position = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1 and forest[i][j] < smallest_tree:\n                    smallest_tree = forest[i][j]\n                    smallest_tree_position = [i, j]\n        \n        # find the shortest path to the smallest tree\n        queue = []\n        queue.append([0, 0])\n        visited = set()\n        visited.add((0, 0))\n        step = 0\n        while queue:\n            for i in range(len(queue)):\n                current_position = queue.pop(0)\n                if current_position == smallest_tree_position:\n                    return step\n                for new_position in self.get_neighbors(current_position, forest):\n                    if new_position not in visited and forest[new_position[0]][new_position[1]] != 0:\n                        queue.append(new_position)\n                        visited.add(new_position)\n            step += 1\n        \n        return -1\n    \n    def get_neighbors(self, current_position, forest):\n        neighbors = []\n        if current_position[0] > 0 and forest[current_position[0] - 1][current_position[1]] != 0:\n            neighbors.append([current_position[0] - 1, current_position[1]])\n        if current_position[1] > 0 and forest[current_position[0]][current_position[1] - 1] != 0:\n            neighbors.append([current_position[0], current_position[1] - 1])\n        if current_position[0] < len(forest) - 1 and forest[current_position[0] + 1][current_position[1]] != 0:\n            neighbors.append([current_position[0] + 1, current_position[1]])\n        if current_position[1] < len(forest[0]) - 1 and forest[current_position[0]][current_position[1] + 1] != 0:\n            neighbors.append([current_position[0], current_position[1] + 1])\n        return neighbors"
        },
        {
            "task_id": "cut-off-trees-for-golf-event",
            "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # find the shortest path to the tree with the smallest height\n        # cut it off\n        # repeat until all trees are cut off\n        # return the number of steps\n        \n        # find the smallest tree\n        smallest_tree = min(tree for row in forest for tree in row if tree > 0)\n        \n        # find the smallest tree's position\n        smallest_tree_position = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] == smallest_tree:\n                    smallest_tree_position = [i, j]\n                    break\n            if smallest_tree_position:\n                break\n        \n        # BFS\n        queue = collections.deque([smallest_tree_position])\n        visited = set(smallest_tree_position)\n        distance = 0\n        \n        while queue:\n            for _ in range(len(queue)):\n                position = queue.popleft()\n                i, j = position\n                for new_position in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                    new_i, new_j = new_position\n                    if 0 <= new_i < len(forest) and 0 <= new_j < len(forest[0]) and forest[new_i][new_j] > 0 and new_position not in visited:\n                        if forest[new_i][new_j] == smallest_tree:\n                            return distance\n                        visited.add(new_position)\n                        queue.append(new_position)\n            distance += 1\n        \n        return -1"
        },
        {
            "task_id": "cut-off-trees-for-golf-event",
            "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(forest, start):\n            queue = collections.deque([start])\n            visited = set([start])\n            height = 0\n            while queue:\n                for _ in range(len(queue)):\n                    x, y = queue.popleft()\n                    if forest[x][y] > height:\n                        height = forest[x][y]\n                    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < len(forest) and 0 <= ny < len(forest[0]) and (nx, ny) not in visited and forest[nx][ny] > 0:\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n                if height > 0:\n                    return height\n            return -1\n        \n        heights = [i for i in forest if i != [0] for j in i if j > 0]\n        heights.sort()\n        start = None\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 0:\n                    start = (i, j)\n                    break\n        ans = 0\n        for height in heights:\n            ans += bfs(forest, start)\n            if ans == -1:\n                return -1\n            forest[start[0]][start[1]] = 1\n            start = None\n        return ans"
        }
    ],
    "minimum-depth-of-binary-tree": [
        {
            "task_id": "minimum-depth-of-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"
        },
        {
            "task_id": "minimum-depth-of-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"
        },
        {
            "task_id": "minimum-depth-of-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"
        },
        {
            "task_id": "minimum-depth-of-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"
        },
        {
            "task_id": "minimum-depth-of-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"
        }
    ],
    "count-of-range-sum": [
        {
            "task_id": "count-of-range-sum",
            "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Binary Search\n        def binarySearch(nums, target):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n\n        # Main\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        # prefix sum array\n        preSum = [0] * (n + 1)\n        for i in range(n):\n            preSum[i + 1] = preSum[i] + nums[i]\n\n        # sort prefix sum\n        mergeSort(preSum)\n\n        # count range sum\n        count = 0\n        for i in range(n + 1):\n            # find the range [j, k] s.t. preSum[j] <= preSum[i] - lower <= preSum[k]\n            j = binarySearch(preSum, preSum[i] - lower)\n            k = binarySearch(preSum, preSum[i] - upper)\n            count += k - j\n\n        return count"
        },
        {
            "task_id": "count-of-range-sum",
            "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Binary Search\n        def binarySearch(nums, target):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n\n        # Count Range Sum\n        def countRangeSum(nums, lower, upper):\n            n = len(nums)\n            if n == 0:\n                return 0\n            presum = [0] * (n + 1)\n            for i in range(n):\n                presum[i + 1] = presum[i] + nums[i]\n            mergeSort(presum)\n            count = 0\n            for i in range(n + 1):\n                if i == 0:\n                    count += binarySearch(presum, upper + 1)\n                else:\n                    count += binarySearch(presum, upper + 1) - binarySearch(presum, lower + presum[i])\n            return count\n\n        return countRangeSum(nums, lower, upper)"
        },
        {
            "task_id": "count-of-range-sum",
            "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Binary Search\n        def binarySearch(nums, target):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n\n        # Count Range Sum\n        def countRangeSum(nums, lower, upper):\n            n = len(nums)\n            if n == 0:\n                return 0\n            sums = [0] * (n + 1)\n            for i in range(n):\n                sums[i + 1] = sums[i] + nums[i]\n            mergeSort(sums)\n            count = 0\n            for i in range(n + 1):\n                if sums[i] >= lower and sums[i] <= upper:\n                    count += 1\n                if i < n:\n                    j = binarySearch(sums, sums[i] + lower)\n                    count += j - i\n            return count\n\n        return countRangeSum(nums, lower, upper)"
        },
        {
            "task_id": "count-of-range-sum",
            "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Binary Search\n        def binarySearch(nums, target):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n\n        # Count Range Sum\n        def countRangeSum(nums, lower, upper):\n            n = len(nums)\n            if n == 0:\n                return 0\n            presum = [0] * (n + 1)\n            for i in range(n):\n                presum[i + 1] = presum[i] + nums[i]\n            mergeSort(presum)\n            count = 0\n            for i in range(n + 1):\n                if i == 0:\n                    count += binarySearch(presum, upper + 1)\n                else:\n                    count += binarySearch(presum, upper + 1) - binarySearch(presum, lower + presum[i])\n            return count\n\n        return countRangeSum(nums, lower, upper)"
        },
        {
            "task_id": "count-of-range-sum",
            "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Binary Search\n        def binarySearch(nums, target):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n\n        # Count Range Sum\n        def countRangeSum(nums, lower, upper):\n            n = len(nums)\n            if n == 0:\n                return 0\n            presum = [0] * (n + 1)\n            for i in range(n):\n                presum[i + 1] = presum[i] + nums[i]\n            mergeSort(presum)\n            count = 0\n            for i in range(n + 1):\n                if i == 0:\n                    count += binarySearch(presum, upper + 1)\n                else:\n                    count += binarySearch(presum, upper + 1) - binarySearch(presum, lower + presum[i])\n            return count\n\n        return countRangeSum(nums, lower, upper)"
        }
    ],
    "arranging-coins": [
        {
            "task_id": "arranging-coins",
            "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Complete this function\n        # For loop to iterate from 1 to n\n        for i in range(1, n+1):\n            \n            # Check if the current row is complete\n            if n == 0:\n                return i-1\n            \n            # Subtract the current row from n\n            n -= i\n            \n        return i"
        },
        {
            "task_id": "arranging-coins",
            "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Complete this function\n        # For loop to iterate from 1 to n\n        for i in range(1, n+1):\n            # Check if the current row is complete\n            if n == i:\n                return i\n            # Check if the current row is incomplete\n            elif n < i:\n                return i-1"
        },
        {
            "task_id": "arranging-coins",
            "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Complete this function\n        # For loop to iterate from 1 to n\n        # Calculate the number of coins in each row\n        # If the number of coins in each row is less than or equal to n\n        # Then return the row number\n        # Else return the previous row number\n        \n        for i in range(1, n+1):\n            if i * (i+1) / 2 > n:\n                return i-1\n        return i"
        },
        {
            "task_id": "arranging-coins",
            "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Complete this function\n        # For loop to iterate from 1 to n\n        # For each iteration, check if n is greater than the sum of the row\n        # If n is greater than the sum of the row, then the row is complete\n        # If n is less than the sum of the row, then the row is not complete\n        # Return the number of complete rows\n        \n        row = 1\n        for i in range(1, n+1):\n            if i == (row*(row+1))/2:\n                row += 1\n            elif i < (row*(row+1))/2:\n                return row-1\n        return row-1"
        },
        {
            "task_id": "arranging-coins",
            "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Complete this function\n        # For loop to iterate from 1 to n\n        # Calculate the number of coins in each row\n        # If the number of coins in a row is greater than n, return the previous row\n        # Else, return the current row\n        \n        for i in range(1, n+1):\n            if i * (i+1) / 2 > n:\n                return i-1\n        return i"
        }
    ],
    "longest-uncommon-subsequence-i": [
        {
            "task_id": "longest-uncommon-subsequence-i",
            "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"
        },
        {
            "task_id": "longest-uncommon-subsequence-i",
            "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"
        },
        {
            "task_id": "longest-uncommon-subsequence-i",
            "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"
        },
        {
            "task_id": "longest-uncommon-subsequence-i",
            "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"
        },
        {
            "task_id": "longest-uncommon-subsequence-i",
            "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"
        }
    ],
    "binary-tree-level-order-traversal-ii": [
        {
            "task_id": "binary-tree-level-order-traversal-ii",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                \n            result.append(level)\n            \n        return result[::-1]"
        },
        {
            "task_id": "binary-tree-level-order-traversal-ii",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = collections.deque([root])\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.popleft()\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result[::-1]"
        },
        {
            "task_id": "binary-tree-level-order-traversal-ii",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = collections.deque([root])\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.popleft()\n                level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                \n            result.append(level)\n            \n        return result[::-1]"
        },
        {
            "task_id": "binary-tree-level-order-traversal-ii",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result[::-1]"
        },
        {
            "task_id": "binary-tree-level-order-traversal-ii",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                \n            result.append(level)\n            \n        return result[::-1]"
        }
    ],
    "palindrome-number": [
        {
            "task_id": "palindrome-number",
            "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        else:\n            return str(x) == str(x)[::-1]"
        },
        {
            "task_id": "palindrome-number",
            "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        else:\n            return str(x) == str(x)[::-1]"
        },
        {
            "task_id": "palindrome-number",
            "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        else:\n            return str(x) == str(x)[::-1]"
        },
        {
            "task_id": "palindrome-number",
            "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        else:\n            return str(x) == str(x)[::-1]"
        },
        {
            "task_id": "palindrome-number",
            "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        else:\n            return str(x) == str(x)[::-1]"
        }
    ],
    "decode-ways": [
        {
            "task_id": "decode-ways",
            "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize dp array\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        \n        # Initialize dp[1]\n        if s[0] != '0':\n            dp[1] = 1\n        \n        # Fill in the rest of the dp array\n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] == '1' or (s[i - 2] == '2' and int(s[i - 1]) <= 6):\n                dp[i] += dp[i - 2]\n        \n        return dp[len(s)]"
        },
        {
            "task_id": "decode-ways",
            "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        \n        # Initialize the dp array\n        for i in range(1, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if i > 1 and s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        return dp[len(s)]"
        },
        {
            "task_id": "decode-ways",
            "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize dp array\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        \n        # Initialize dp[1]\n        if s[0] == '0':\n            dp[1] = 0\n        else:\n            dp[1] = 1\n        \n        # Fill in the rest of dp array\n        for i in range(2, len(s) + 1):\n            if s[i - 1] == '0':\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n            \n            if int(s[i - 2:i]) <= 26 and s[i - 2] != '0':\n                dp[i] += dp[i - 2]\n        \n        return dp[len(s)]"
        },
        {
            "task_id": "decode-ways",
            "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize dp array\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        \n        # Initialize dp[1]\n        if s[0] != '0':\n            dp[1] = 1\n        \n        # Fill in the rest of the dp array\n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] == '1' or (s[i - 2] == '2' and int(s[i - 1]) <= 6):\n                dp[i] += dp[i - 2]\n        \n        return dp[len(s)]"
        },
        {
            "task_id": "decode-ways",
            "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        \n        # Initialize the dp array\n        for i in range(1, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if i > 1 and s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        return dp[len(s)]"
        }
    ],
    "is-subsequence": [
        {
            "task_id": "is-subsequence",
            "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        if i == len(s):\n            return True\n        return False"
        },
        {
            "task_id": "is-subsequence",
            "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        \n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "is-subsequence",
            "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        if i == len(s):\n            return True\n        return False"
        },
        {
            "task_id": "is-subsequence",
            "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        \n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "is-subsequence",
            "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        if i == len(s):\n            return True\n        else:\n            return False"
        }
    ],
    "gray-code": [
        {
            "task_id": "gray-code",
            "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def grayCodeHelper(n, prefix):\n            if n == 0:\n                return [prefix]\n            else:\n                result = []\n                for i in range(2):\n                    for code in grayCodeHelper(n-1, prefix*2 + i):\n                        result.append(code)\n                return result\n        \n        return grayCodeHelper(n, 0)"
        },
        {
            "task_id": "gray-code",
            "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def grayCodeHelper(n, prefix):\n            if n == 0:\n                return [prefix]\n            else:\n                result = []\n                for i in range(2):\n                    for code in grayCodeHelper(n-1, prefix*2 + i):\n                        result.append(code)\n                return result\n        \n        return grayCodeHelper(n, 0)"
        },
        {
            "task_id": "gray-code",
            "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def grayCodeHelper(n, prefix):\n            if n == 0:\n                return [prefix]\n            else:\n                result = []\n                for i in range(2):\n                    for code in grayCodeHelper(n-1, prefix*2 + i):\n                        result.append(code)\n                return result\n        \n        return grayCodeHelper(n, 0)"
        },
        {
            "task_id": "gray-code",
            "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def grayCodeHelper(n, prefix):\n            if n == 0:\n                return [prefix]\n            else:\n                result = []\n                for i in range(2):\n                    for code in grayCodeHelper(n-1, prefix*2 + i):\n                        result.append(code)\n                return result\n        \n        return grayCodeHelper(n, 0)"
        },
        {
            "task_id": "gray-code",
            "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def grayCodeHelper(n, prefix):\n            if n == 0:\n                return [prefix]\n            else:\n                result = []\n                for i in range(2):\n                    for code in grayCodeHelper(n-1, prefix*2 + i):\n                        result.append(code)\n                return result\n        \n        return grayCodeHelper(n, 0)"
        }
    ],
    "climbing-stairs": [
        {
            "task_id": "climbing-stairs",
            "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return self.climbStairs(n-1) + self.climbStairs(n-2)"
        },
        {
            "task_id": "climbing-stairs",
            "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return self.climbStairs(n-1) + self.climbStairs(n-2)"
        },
        {
            "task_id": "climbing-stairs",
            "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return self.climbStairs(n-1) + self.climbStairs(n-2)"
        },
        {
            "task_id": "climbing-stairs",
            "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return self.climbStairs(n-1) + self.climbStairs(n-2)"
        },
        {
            "task_id": "climbing-stairs",
            "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return self.climbStairs(n-1) + self.climbStairs(n-2)"
        }
    ],
    "word-break": [
        {
            "task_id": "word-break",
            "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the dp array with False\n        dp = [False] * (len(s) + 1)\n        \n        # Initialize the first element of dp array with True\n        dp[0] = True\n        \n        # Loop through the dp array\n        for i in range(1, len(dp)):\n            \n            # Loop through the wordDict\n            for word in wordDict:\n                \n                # Check if the word is a prefix of the string s\n                if s[:i] == word:\n                    \n                    # If the word is a prefix of the string s, then check if the previous index is True\n                    if dp[i - len(word)]:\n                        \n                        # If the previous index is True, then make the current index True\n                        dp[i] = True\n                        break\n                        \n        # Return the last index of dp array\n        return dp[-1]"
        },
        {
            "task_id": "word-break",
            "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the dp array with False\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        # Loop through the string\n        for i in range(1, len(s) + 1):\n            \n            # Loop through the wordDict\n            for word in wordDict:\n                \n                # Check if the word is a prefix of the string\n                if s[:i] == word:\n                    \n                    # If the word is a prefix, set the dp value to True\n                    dp[i] = True\n                    \n                    # Break the inner loop\n                    break\n                    \n        return dp[len(s)]"
        },
        {
            "task_id": "word-break",
            "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the dp array with False\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        # Loop through the string\n        for i in range(1, len(s) + 1):\n            \n            # Loop through the wordDict\n            for word in wordDict:\n                \n                # Check if the word is a prefix of the string\n                if s[:i] == word:\n                    \n                    # If it is, then check if the previous substring is True\n                    if dp[i - len(word)]:\n                        dp[i] = True\n                        break\n                        \n        return dp[len(s)]"
        },
        {
            "task_id": "word-break",
            "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the dp array with False\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        # Loop through the string\n        for i in range(1, len(s) + 1):\n            \n            # Loop through the wordDict\n            for word in wordDict:\n                \n                # Check if the word is a prefix of the string\n                if s[:i] == word:\n                    \n                    # If the word is a prefix, set the value of dp[i] to True\n                    dp[i] = True\n                    \n                    # Break the loop\n                    break\n                    \n        return dp[len(s)]"
        },
        {
            "task_id": "word-break",
            "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the dp array with False\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        # Loop through the string\n        for i in range(1, len(s) + 1):\n            \n            # Loop through the wordDict\n            for word in wordDict:\n                \n                # Check if the word is a prefix of the string\n                if s[:i] == word:\n                    \n                    # If the word is a prefix, set the dp value to True\n                    dp[i] = True\n                    \n                    # Break the loop\n                    break\n                    \n        return dp[len(s)]"
        }
    ],
    "validate-binary-search-tree": [
        {
            "task_id": "validate-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTUtil(root, minValue, maxValue):\n            if root is None:\n                return True\n            if root.val <= minValue or root.val >= maxValue:\n                return False\n            return isValidBSTUtil(root.left, minValue, root.val) and isValidBSTUtil(root.right, root.val, maxValue)\n        return isValidBSTUtil(root, float('-inf'), float('inf'))"
        },
        {
            "task_id": "validate-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTHelper(root, minValue, maxValue):\n            if root is None:\n                return True\n            if root.val <= minValue or root.val >= maxValue:\n                return False\n            return isValidBSTHelper(root.left, minValue, root.val) and isValidBSTHelper(root.right, root.val, maxValue)\n        return isValidBSTHelper(root, float('-inf'), float('inf'))"
        },
        {
            "task_id": "validate-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTUtil(root, minValue, maxValue):\n            if root is None:\n                return True\n            if root.val <= minValue or root.val >= maxValue:\n                return False\n            return isValidBSTUtil(root.left, minValue, root.val) and isValidBSTUtil(root.right, root.val, maxValue)\n        return isValidBSTUtil(root, float('-inf'), float('inf'))"
        },
        {
            "task_id": "validate-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTHelper(root, minValue, maxValue):\n            if root is None:\n                return True\n            if root.val <= minValue or root.val >= maxValue:\n                return False\n            return isValidBSTHelper(root.left, minValue, root.val) and isValidBSTHelper(root.right, root.val, maxValue)\n        return isValidBSTHelper(root, float('-inf'), float('inf'))"
        },
        {
            "task_id": "validate-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTUtil(root, minValue, maxValue):\n            if root is None:\n                return True\n            if root.val <= minValue or root.val >= maxValue:\n                return False\n            return isValidBSTUtil(root.left, minValue, root.val) and isValidBSTUtil(root.right, root.val, maxValue)\n        return isValidBSTUtil(root, float('-inf'), float('inf'))"
        }
    ],
    "insert-interval": [
        {
            "task_id": "insert-interval",
            "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is not empty and intervals is not empty\n        # find the index where newInterval should be inserted\n        index = 0\n        while index < len(intervals) and newInterval[0] > intervals[index][0]:\n            index += 1\n        \n        # insert newInterval at index\n        intervals.insert(index, newInterval)\n        \n        # merge intervals\n        for i in range(index, len(intervals)):\n            if intervals[i][0] <= intervals[i-1][1]:\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\n                intervals.pop(i)\n                i -= 1\n        \n        return intervals"
        },
        {
            "task_id": "insert-interval",
            "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is not empty and intervals is not empty\n        # find the index where newInterval should be inserted\n        index = 0\n        while index < len(intervals) and newInterval[0] > intervals[index][0]:\n            index += 1\n        \n        # if newInterval is not empty and intervals is not empty\n        # insert newInterval at the index\n        intervals.insert(index, newInterval)\n        \n        # if newInterval is not empty and intervals is not empty\n        # merge the overlapping intervals\n        for i in range(len(intervals)-1):\n            if intervals[i][1] >= intervals[i+1][0]:\n                intervals[i][1] = max(intervals[i][1], intervals[i+1][1])\n                intervals.pop(i+1)\n                i -= 1\n        \n        return intervals"
        },
        {
            "task_id": "insert-interval",
            "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is not empty and intervals is not empty\n        # find the index where newInterval should be inserted\n        index = 0\n        while index < len(intervals) and newInterval[0] > intervals[index][0]:\n            index += 1\n        \n        # insert newInterval at index\n        intervals.insert(index, newInterval)\n        \n        # merge intervals\n        result = []\n        for interval in intervals:\n            if not result or result[-1][1] < interval[0]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        \n        return result"
        },
        {
            "task_id": "insert-interval",
            "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is not empty and intervals is not empty\n        # find the index where newInterval should be inserted\n        index = 0\n        while index < len(intervals) and newInterval[0] > intervals[index][0]:\n            index += 1\n        \n        # if newInterval is not empty and intervals is not empty\n        # insert newInterval at the index\n        intervals.insert(index, newInterval)\n        \n        # if newInterval is not empty and intervals is not empty\n        # merge the overlapping intervals\n        for i in range(len(intervals)-1):\n            if intervals[i][1] >= intervals[i+1][0]:\n                intervals[i][1] = max(intervals[i][1], intervals[i+1][1])\n                intervals.pop(i+1)\n                i -= 1\n        \n        return intervals"
        },
        {
            "task_id": "insert-interval",
            "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is not empty and intervals is not empty\n        # find the index where newInterval should be inserted\n        index = 0\n        while index < len(intervals) and newInterval[0] > intervals[index][0]:\n            index += 1\n        \n        # insert newInterval at index\n        intervals.insert(index, newInterval)\n        \n        # merge intervals\n        result = []\n        for interval in intervals:\n            if not result or result[-1][1] < interval[0]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        \n        return result"
        }
    ],
    "palindrome-partitioning": [
        {
            "task_id": "palindrome-partitioning",
            "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def helper(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    helper(s[i:], path+[s[:i]], res)\n        \n        res = []\n        helper(s, [], res)\n        return res"
        },
        {
            "task_id": "palindrome-partitioning",
            "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def helper(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    helper(s[i:], path+[s[:i]], res)\n        \n        res = []\n        helper(s, [], res)\n        return res"
        },
        {
            "task_id": "palindrome-partitioning",
            "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def helper(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    helper(s[i:], path+[s[:i]], res)\n        \n        res = []\n        helper(s, [], res)\n        return res"
        },
        {
            "task_id": "palindrome-partitioning",
            "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def helper(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    helper(s[i:], path+[s[:i]], res)\n        \n        res = []\n        helper(s, [], res)\n        return res"
        },
        {
            "task_id": "palindrome-partitioning",
            "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def helper(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    helper(s[i:], path+[s[:i]], res)\n        \n        res = []\n        helper(s, [], res)\n        return res"
        }
    ],
    "smallest-range-covering-elements-from-k-lists": [
        {
            "task_id": "smallest-range-covering-elements-from-k-lists",
            "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the heap\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i][0], i, 0))\n        \n        # Initialize the min range\n        min_range = [float('inf'), float('-inf')]\n        \n        # Loop until the heap is empty\n        while heap:\n            # Get the smallest number\n            smallest = heapq.heappop(heap)\n            \n            # If the current range is smaller than the min range\n            if smallest[0] - min_range[0] < min_range[1] - min_range[0]:\n                min_range = [min_range[0], smallest[0]]\n            \n            # Add the next number from the list\n            if smallest[2] + 1 < len(nums[smallest[1]]):\n                heapq.heappush(heap, (nums[smallest[1]][smallest[2] + 1], smallest[1], smallest[2] + 1))\n        \n        return min_range"
        },
        {
            "task_id": "smallest-range-covering-elements-from-k-lists",
            "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the heap\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i][0], i, 0))\n        \n        # Initialize the range\n        smallest_range = [float('inf'), float('-inf')]\n        while heap:\n            smallest = heapq.heappop(heap)\n            smallest_range[0] = min(smallest_range[0], smallest[0])\n            smallest_range[1] = max(smallest_range[1], smallest[0])\n            \n            # If the range is smaller than the current smallest range\n            if smallest_range[1] - smallest_range[0] < smallest_range[1] - smallest_range[0]:\n                smallest_range = [smallest_range[0], smallest_range[1]]\n            \n            # Add the next number from the list to the heap\n            if smallest[2] + 1 < len(nums[smallest[1]]):\n                heapq.heappush(heap, (nums[smallest[1]][smallest[2] + 1], smallest[1], smallest[2] + 1))\n        \n        return smallest_range"
        },
        {
            "task_id": "smallest-range-covering-elements-from-k-lists",
            "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the heap\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i][0], i, 0))\n        \n        # Initialize the range\n        smallest_range = [float('inf'), float('-inf')]\n        while heap:\n            smallest = heapq.heappop(heap)\n            smallest_range[0] = min(smallest_range[0], smallest[0])\n            smallest_range[1] = max(smallest_range[1], smallest[0])\n            \n            # If the range is smaller than the current smallest range\n            if smallest_range[1] - smallest_range[0] < smallest_range[1] - smallest_range[0]:\n                smallest_range = [smallest_range[0], smallest_range[1]]\n            \n            # Add the next number from the list to the heap\n            if smallest[2] + 1 < len(nums[smallest[1]]):\n                heapq.heappush(heap, (nums[smallest[1]][smallest[2] + 1], smallest[1], smallest[2] + 1))\n        \n        return smallest_range"
        },
        {
            "task_id": "smallest-range-covering-elements-from-k-lists",
            "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the heap\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i][0], i, 0))\n        \n        # Initialize the min range\n        min_range = [float('inf'), float('-inf')]\n        \n        # Loop until the heap is empty\n        while heap:\n            # Get the smallest number\n            smallest = heapq.heappop(heap)\n            \n            # If the current range is smaller than the min range\n            if smallest[0] - min_range[0] < min_range[1] - min_range[0]:\n                min_range = [min_range[0], smallest[0]]\n            \n            # Add the next number from the list\n            if smallest[2] + 1 < len(nums[smallest[1]]):\n                heapq.heappush(heap, (nums[smallest[1]][smallest[2] + 1], smallest[1], smallest[2] + 1))\n        \n        return min_range"
        },
        {
            "task_id": "smallest-range-covering-elements-from-k-lists",
            "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the heap\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i][0], i, 0))\n        \n        # Initialize the range\n        smallest_range = [float('inf'), float('-inf')]\n        while heap:\n            smallest = heapq.heappop(heap)\n            smallest_range[0] = min(smallest_range[0], smallest[0])\n            smallest_range[1] = max(smallest_range[1], smallest[0])\n            \n            # If the range is smaller than the current smallest range\n            if smallest_range[1] - smallest_range[0] < smallest_range[1] - smallest_range[0]:\n                smallest_range = [smallest_range[0], smallest_range[1]]\n            \n            # Add the next number from the list to the heap\n            if smallest[2] + 1 < len(nums[smallest[1]]):\n                heapq.heappush(heap, (nums[smallest[1]][smallest[2] + 1], smallest[1], smallest[2] + 1))\n        \n        return smallest_range"
        }
    ],
    "poor-pigs": [
        {
            "task_id": "poor-pigs",
            "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if buckets == 1:\n            return 0\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        \n        # 15 / 15 = 1"
        },
        {
            "task_id": "poor-pigs",
            "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if buckets == 1:\n            return 0\n        \n        # minutesToDie = 15, minutesToTest = 15\n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        # 15 / 45 = 0.3333333333333333\n        # 15 / 60 = 0.25\n        # 15 / 75 = 0.19999999999999996\n        # 15 / 90 = 0.16666666666666666\n        # 15 / 105 = 0.14705882352941177\n        # 15 / 120 = 0.13333333333333333\n        # 15 / 135 = 0.11904761904761905\n        # 15 / 150 = 0.10666666666666667\n        # 15 / 165 = 0.09716981132075472\n        # 15 / 180 = 0.08823529411764706\n        # 15 / 195 = 0.07943925233644859\n        # 15 / 210 = 0.07142857142857143\n        # 15 / 225 = 0.06382978723404255\n        # 15 / 240 = 0.05652173913043478\n        # 15 / 255 = 0.05000000000000001\n        # 15 / 270 = 0.043478260869565216\n        # 15 / 285 = 0.03787878787878788\n        # 15 / 300 = 0.03225806451612903\n        # 15 / 315 = 0.027272727272727273\n        # 15 / 330 = 0.022988505747126436\n        # 15 / 345 = 0.019047619047619047\n        # 15 / 360 = 0.015625\n        # 15 / 375 = 0.01282051282051282\n        # 15 / 390 = 0.010329679411764705\n        # 15 / 405 = 0.008032786885245902\n        # 15 / 420 = 0.005853658536585366\n        # 15 / 435 = 0.003793103448275862\n        # 15 / 450 = 0.0020833333333333333\n        # 15 / 465 = 0.0008695652173913043\n        # 15 / 480 = 0.0\n        # 15 / 495 = -0.000869565217391304"
        },
        {
            "task_id": "poor-pigs",
            "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if buckets == 1:\n            return 0\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 4\n        \n        # minutesToTest = 30\n        # minutesToDie = 15\n        # buckets = 4\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 4\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 2\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 3\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 4\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 5\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 6\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 7\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 8\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 9\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 10\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 11\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 12\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 13\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 14\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 15\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 16\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 17\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 18\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 19\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 20\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 21\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 22\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 23\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 24\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 25\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 26\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 27\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 28\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 29\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        # buckets = 30\n        \n        # minutesToTest = 15\n        # minutesToDie = 15\n        #"
        },
        {
            "task_id": "poor-pigs",
            "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if buckets == 1:\n            return 0\n        \n        # minutesToDie = 15, minutesToTest = 15\n        # 15 / 15 = 1\n        # 15 / 30 = 0.5\n        # 15 / 45 = 0.3333333333333333\n        # 15 / 60 = 0.25\n        # 15 / 75 = 0.19999999999999996\n        # 15 / 90 = 0.16666666666666666\n        # 15 / 105 = 0.14705882352941177\n        # 15 / 120 = 0.13333333333333333\n        # 15 / 135 = 0.11904761904761905\n        # 15 / 150 = 0.10666666666666667\n        # 15 / 165 = 0.09716981132075472\n        # 15 / 180 = 0.08823529411764706\n        # 15 / 195 = 0.07943925233644859\n        # 15 / 210 = 0.07142857142857143\n        # 15 / 225 = 0.06382978723404255\n        # 15 / 240 = 0.05652173913043478\n        # 15 / 255 = 0.05000000000000001\n        # 15 / 270 = 0.04347826086956522\n        # 15 / 285 = 0.03787878787878788\n        # 15 / 300 = 0.03225806451612903\n        # 15 / 315 = 0.027272727272727273\n        # 15 / 330 = 0.022988505747126436\n        # 15 / 345 = 0.019047619047619047\n        # 15 / 360 = 0.015625\n        # 15 / 375 = 0.01282051282051282\n        # 15 / 390 = 0.01032967032967033\n        # 15 / 405 = 0.008032467526804123\n        # 15 / 420 = 0.005813953488372093\n        # 15 / 435 = 0.0037288135593220336\n        # 15 / 450 = 0.001923076923076923\n        # 15 / 465 = 0.0000000000000000000000000000000000000000000000000000000000000000000000"
        },
        {
            "task_id": "poor-pigs",
            "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if buckets == 1:\n            return 0\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 30\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 60\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 10"
        }
    ],
    "swim-in-rising-water": [
        {
            "task_id": "swim-in-rising-water",
            "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        \n        n = len(grid)\n        visited = set()\n        queue = collections.deque([(0,0)])\n        visited.add((0,0))\n        max_height = 0\n        while queue:\n            row, col = queue.popleft()\n            max_height = max(max_height, grid[row][col])\n            if row == n-1 and col == n-1:\n                return max_height\n            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n                if 0 <= r < n and 0 <= c < n and (r, c) not in visited:\n                    visited.add((r, c))\n                    queue.append((r, c))"
        },
        {
            "task_id": "swim-in-rising-water",
            "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        # grid[i][j] represents the elevation at that point (i, j).\n        # The rain starts to fall. At time t, the depth of the water everywhere is t.\n        # You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t.\n        # You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n        # Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        \n        # 1. Initialize queue with all elements\n        # 2. While queue is not empty\n        # 3.     Dequeue\n        # 4.     If dequeued element is not visited\n        # 5.         Mark as visited\n        # 6.         Add all adjacent elements to queue\n        \n        # 1. Initialize queue with all elements\n        # 2. Initialize visited set\n        # 3. Initialize time\n        # 4. While queue is not empty\n        # 5.     Dequeue\n        # 6.     If dequeued element is not visited\n        # 7.         Mark as visited\n        # 8.         Add all adjacent elements to queue\n        # 9.         Increment time\n        # 10. Return time\n        \n        # 1. Initialize queue with all elements\n        # 2. Initialize visited set\n        # 3. Initialize time\n        # 4. While queue is not empty\n        # 5.     Dequeue\n        # 6.     If dequeued element is not visited\n        # 7.         Mark as visited\n        # 8.         Add all adjacent elements to queue\n        # 9.         Increment time\n        # 10. Return time\n        \n        # 1. Initialize queue with all elements\n        # 2. Initialize visited set\n        # 3. Initialize time\n        # 4. While queue is not empty\n        # 5.     Dequeue\n        # 6.     If dequeued element is not visited\n        # 7.         Mark as visited\n        # 8.         Add all adjacent elements to queue\n        # 9.         Increment time\n        # 10. Return time\n        \n        # 1. Initialize queue with all elements\n        # 2. Initialize visited set\n        # 3. Initialize time\n        # 4. While queue is not empty\n        # 5.     Dequeue\n        # 6.     If dequeued element is not visited\n        # 7.         Mark as visited\n        # 8.         Add all adjacent elements to queue\n        # 9.         Increment time\n        # 10. Return time\n        \n        # 1. Initialize queue with all elements\n        # 2. Initialize visited set\n        # 3. Initialize time\n        # 4. While queue is not empty\n        # 5.     Dequeue\n        # 6.     If dequeued element is not visited\n        # 7.         Mark as visited\n        # 8.         Add all adjacent elements to queue\n        # 9.         Increment time\n        # 10. Return time\n        \n        # 1. Initialize queue with all elements\n        # 2. Initialize visited set\n        # 3. Initialize time\n        # 4. While queue is not empty\n        # 5.     Dequeue\n        # 6.     If dequeued element is not visited\n        # 7.         Mark as visited\n        # 8.         Add all adjacent elements to queue\n        # 9.         Increment time\n        # 10. Return time\n        \n        # 1. Initialize queue with all elements\n        # 2. Initialize visited set\n        # 3. Initialize time\n        # 4. While queue is not empty\n        # 5.     Dequeue\n        # 6.     If dequeued element is not visited\n        # 7.         Mark as visited\n        # 8.         Add all adjacent elements to queue\n        # 9.         Increment time\n        # 10. Return time\n        \n        #"
        },
        {
            "task_id": "swim-in-rising-water",
            "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        \n        n = len(grid)\n        visited = set()\n        queue = collections.deque([(0,0)])\n        visited.add((0,0))\n        max_height = 0\n        while queue:\n            row, col = queue.popleft()\n            max_height = max(max_height, grid[row][col])\n            if row == n-1 and col == n-1:\n                return max_height\n            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n                if 0 <= r < n and 0 <= c < n and (r, c) not in visited and grid[r][c] <= max_height:\n                    queue.append((r, c))\n                    visited.add((r, c))"
        },
        {
            "task_id": "swim-in-rising-water",
            "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        \n        n = len(grid)\n        visited = set()\n        queue = collections.deque([(0, 0)])\n        visited.add((0, 0))\n        max_height = 0\n        \n        while queue:\n            row, col = queue.popleft()\n            max_height = max(max_height, grid[row][col])\n            if row == n-1 and col == n-1:\n                return max_height\n            \n            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n                if 0 <= r < n and 0 <= c < n and (r, c) not in visited:\n                    visited.add((r, c))\n                    queue.append((r, c))\n                    \n        return -1"
        },
        {
            "task_id": "swim-in-rising-water",
            "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        # grid[i][j] represents the elevation at that point (i, j).\n        # The rain starts to fall. At time t, the depth of the water everywhere is t.\n        # You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t.\n        # You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n        # Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        # grid[i][j] represents the elevation at that point (i, j).\n        # The rain starts to fall. At time t, the depth of the water everywhere is t.\n        # You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t.\n        # You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n        # Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        # grid[i][j] represents the elevation at that point (i, j).\n        # The rain starts to fall. At time t, the depth of the water everywhere is t.\n        # You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t.\n        # You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n        # Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        # grid[i][j] represents the elevation at that point (i, j).\n        # The rain starts to fall. At time t, the depth of the water everywhere is t.\n        # You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t.\n        # You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n        # Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        # grid[i][j] represents the elevation at that point (i, j).\n        # The rain starts to fall. At time t, the depth of the water everywhere is t.\n        # You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t.\n        # You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n        # Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        # grid[i][j] represents the elevation at that point (i, j).\n        # The rain starts to fall. At time t, the depth of the water everywhere is t.\n        # You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t.\n        # You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n        # Return the least time until you can reach the bottom right square (n"
        }
    ],
    "unique-paths": [
        {
            "task_id": "unique-paths",
            "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp table with 1's.\n        dp = [[1]*n for _ in range(m)]\n        \n        # Fill in the values for the first row.\n        for i in range(1, m):\n            for j in range(n):\n                dp[i][j] = dp[i-1][j]\n        \n        # Fill in the values for the first column.\n        for i in range(m):\n            for j in range(1, n):\n                dp[i][j] = dp[i][j-1]\n        \n        return dp[m-1][n-1]"
        },
        {
            "task_id": "unique-paths",
            "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"
        },
        {
            "task_id": "unique-paths",
            "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        # Initialize the first column\n        for i in range(m):\n            dp[i][0] = 1\n            \n        # Initialize the first row\n        for j in range(n):\n            dp[0][j] = 1\n            \n        # Fill the dp array\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                \n        return dp[m-1][n-1]"
        },
        {
            "task_id": "unique-paths",
            "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"
        },
        {
            "task_id": "unique-paths",
            "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp table with 1's.\n        dp = [[1]*n for _ in range(m)]\n        \n        # Fill in the values for the first row.\n        for i in range(1, m):\n            for j in range(n):\n                dp[i][j] = dp[i-1][j]\n        \n        # Fill in the values for the first column.\n        for i in range(m):\n            for j in range(1, n):\n                dp[i][j] = dp[i][j-1]\n        \n        return dp[m-1][n-1]"
        }
    ],
    "multiply-strings": [
        {
            "task_id": "multiply-strings",
            "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        result = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)-1, -1, -1):\n            for j in range(len(num2)-1, -1, -1):\n                result[i+j+1] += int(num1[i]) * int(num2[j])\n                \n        carry = 0\n        for i in range(len(result)-1, -1, -1):\n            result[i] += carry\n            carry = result[i] // 10\n            result[i] %= 10\n            \n        if carry != 0:\n            result = [carry] + result\n            \n        return ''.join(map(str, result))"
        },
        {
            "task_id": "multiply-strings",
            "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        result = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1) - 1, -1, -1):\n            n1 = int(num1[i])\n            for j in range(len(num2) - 1, -1, -1):\n                n2 = int(num2[j])\n                result[i + j] += n1 * n2\n                \n        carry = 0\n        for i in range(len(result)):\n            result[i] += carry\n            carry = result[i] // 10\n            result[i] %= 10\n            \n        while carry:\n            result.append(carry % 10)\n            carry //= 10\n            \n        return ''.join(map(str, result[::-1]))"
        },
        {
            "task_id": "multiply-strings",
            "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        result = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1) - 1, -1, -1):\n            n1 = int(num1[i])\n            for j in range(len(num2) - 1, -1, -1):\n                n2 = int(num2[j])\n                result[i + j] += n1 * n2\n                \n        carry = 0\n        for i in range(len(result)):\n            result[i] += carry\n            carry = result[i] // 10\n            result[i] %= 10\n            \n        while carry:\n            result.append(carry % 10)\n            carry //= 10\n            \n        return ''.join(map(str, result[::-1]))"
        },
        {
            "task_id": "multiply-strings",
            "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        result = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)-1, -1, -1):\n            for j in range(len(num2)-1, -1, -1):\n                result[i+j+1] += int(num1[i]) * int(num2[j])\n                \n        carry = 0\n        for i in range(len(result)-1, -1, -1):\n            result[i] += carry\n            carry = result[i] // 10\n            result[i] %= 10\n            \n        if carry != 0:\n            result = [carry] + result\n            \n        return ''.join(str(i) for i in result)"
        },
        {
            "task_id": "multiply-strings",
            "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        result = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1) - 1, -1, -1):\n            n1 = int(num1[i])\n            for j in range(len(num2) - 1, -1, -1):\n                n2 = int(num2[j])\n                result[i + j] += n1 * n2\n                \n        carry = 0\n        for i in range(len(result)):\n            result[i] += carry\n            carry = result[i] // 10\n            result[i] %= 10\n            \n        while carry:\n            result.append(carry % 10)\n            carry //= 10\n            \n        return ''.join(map(str, result[::-1]))"
        }
    ],
    "best-time-to-buy-and-sell-stock-iii": [
        {
            "task_id": "best-time-to-buy-and-sell-stock-iii",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables\n        buy1 = float('inf')\n        buy2 = float('inf')\n        sell1 = 0\n        sell2 = 0\n        \n        # Iterate over the given list\n        for price in prices:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-iii",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables\n        buy1 = float('inf')\n        buy2 = float('inf')\n        sell1 = 0\n        sell2 = 0\n        \n        for price in prices:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-iii",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        buy1 = float('inf')\n        buy2 = float('inf')\n        sell1 = 0\n        sell2 = 0\n        \n        for price in prices:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-iii",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        buy1 = float('inf')\n        buy2 = float('inf')\n        sell1 = 0\n        sell2 = 0\n        \n        for price in prices:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-iii",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables\n        buy1 = float('inf')\n        buy2 = float('inf')\n        sell1 = 0\n        sell2 = 0\n        \n        for price in prices:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2"
        }
    ],
    "combination-sum-ii": [
        {
            "task_id": "combination-sum-ii",
            "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # List to store the result\n        res = []\n        \n        # Call the helper function\n        self.helper(candidates, target, 0, [], res)\n        \n        return res\n    \n    def helper(self, candidates, target, index, temp, res):\n        # Base case\n        if target < 0:\n            return\n        \n        if target == 0:\n            res.append(temp[:])\n            return\n        \n        # Loop through the list\n        for i in range(index, len(candidates)):\n            \n            # Avoid duplicates\n            if i > index and candidates[i] == candidates[i-1]:\n                continue\n            \n            # Add the element to the list\n            temp.append(candidates[i])\n            \n            # Recursive call\n            self.helper(candidates, target - candidates[i], i + 1, temp, res)\n            \n            # Backtrack\n            temp.pop()"
        },
        {
            "task_id": "combination-sum-ii",
            "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # List to store the final result\n        result = []\n        \n        # List to store the combination\n        combination = []\n        \n        # Call the helper function\n        self.helper(candidates, 0, target, combination, result)\n        \n        return result\n    \n    def helper(self, candidates, index, target, combination, result):\n        # Base case\n        if target == 0:\n            result.append(combination[:])\n            return\n        \n        # Edge case\n        if index == len(candidates) or target < 0:\n            return\n        \n        # First option\n        self.helper(candidates, index + 1, target, combination, result)\n        \n        # Second option\n        combination.append(candidates[index])\n        self.helper(candidates, index + 1, target - candidates[index], combination, result)\n        \n        # Backtracking\n        combination.pop()"
        },
        {
            "task_id": "combination-sum-ii",
            "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # List to store the result\n        res = []\n        \n        # Call the helper function\n        self.helper(candidates, target, 0, [], res)\n        \n        return res\n    \n    def helper(self, candidates, target, index, temp, res):\n        # Base case\n        if target == 0:\n            res.append(temp[:])\n            return\n        \n        # Loop through the list\n        for i in range(index, len(candidates)):\n            \n            # Check if the sum exceeds the target\n            if target - candidates[i] < 0:\n                break\n            \n            # If the element is not duplicate\n            if i == index or candidates[i] != candidates[i-1]:\n                \n                # Add the element to the list\n                temp.append(candidates[i])\n                \n                # Call the helper function\n                self.helper(candidates, target - candidates[i], i + 1, temp, res)\n                \n                # Remove the last element\n                temp.pop()"
        },
        {
            "task_id": "combination-sum-ii",
            "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # List to store the result\n        res = []\n        \n        # Call the helper function\n        self.helper(candidates, target, 0, [], res)\n        \n        return res\n    \n    def helper(self, candidates, target, index, temp, res):\n        # Base case\n        if target == 0:\n            res.append(temp[:])\n            return\n        \n        # Loop through the list\n        for i in range(index, len(candidates)):\n            \n            # Check if the sum exceeds the target\n            if target - candidates[i] < 0:\n                break\n            \n            # If the element is not duplicate\n            if i == index or candidates[i] != candidates[i-1]:\n                \n                # Add the element to the list\n                temp.append(candidates[i])\n                \n                # Call the helper function\n                self.helper(candidates, target - candidates[i], i + 1, temp, res)\n                \n                # Remove the last element\n                temp.pop()"
        },
        {
            "task_id": "combination-sum-ii",
            "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # List to store the final result\n        result = []\n        \n        # List to store the combination\n        combination = []\n        \n        # Call the helper function\n        self.helper(candidates, 0, target, combination, result)\n        \n        return result\n    \n    def helper(self, candidates, index, target, combination, result):\n        # Base case\n        if target == 0:\n            result.append(combination[:])\n            return\n        \n        # Edge case\n        if index == len(candidates) or target < 0:\n            return\n        \n        # First option\n        self.helper(candidates, index + 1, target, combination, result)\n        \n        # Check for the next element\n        if index < len(candidates) - 1 and candidates[index] == candidates[index + 1]:\n            index += 1\n            while index < len(candidates) - 1 and candidates[index] == candidates[index + 1]:\n                index += 1\n        \n        # Second option\n        combination.append(candidates[index])\n        self.helper(candidates, index + 1, target - candidates[index], combination, result)\n        combination.pop()"
        }
    ],
    "detect-capital": [
        {
            "task_id": "detect-capital",
            "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or (word.istitle() and word[0].isupper()):\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "detect-capital",
            "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or (word[0].isupper() and word[1:].islower()):\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "detect-capital",
            "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or (word[0].isupper() and word[1:].islower()):\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "detect-capital",
            "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or (word.istitle() and word[0].isupper()):\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "detect-capital",
            "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or (word[0].isupper() and word[1:].islower()):\n            return True\n        else:\n            return False"
        }
    ],
    "best-time-to-buy-and-sell-stock": [
        {
            "task_id": "best-time-to-buy-and-sell-stock",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        min_price = 10**10\n        \n        # Loop through the list of prices.\n        for price in prices:\n            \n            # Update min_price and max_profit.\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        # Return the maximum profit.\n        return max_profit"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        min_price = 10**10\n        \n        # Loop through the list of prices.\n        for price in prices:\n            \n            # If the current price is less than the minimum price,\n            # then the minimum price is updated.\n            if price < min_price:\n                min_price = price\n                \n            # If the maximum profit is less than the difference between the current price and the minimum price,\n            # then the maximum profit is updated.\n            elif max_profit < price - min_price:\n                max_profit = price - min_price\n                \n        # Return the maximum profit.\n        return max_profit"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        min_price = 10**10\n        \n        # Loop through the list of prices.\n        for price in prices:\n            \n            # Update min_price and max_profit.\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        # Return the maximum profit.\n        return max_profit"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        min_price = 10**10\n        \n        # Loop through the list of prices.\n        for price in prices:\n            \n            # Update min_price and max_profit.\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        # Return the maximum profit.\n        return max_profit"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        min_price = 10**10\n        \n        # Loop through the list of prices.\n        for price in prices:\n            \n            # If the current price is less than the minimum price,\n            # then the minimum price is updated.\n            if price < min_price:\n                min_price = price\n                \n            # If the maximum profit is less than the difference between the current price and the minimum price,\n            # then the maximum profit is updated.\n            elif max_profit < price - min_price:\n                max_profit = price - min_price\n                \n        # Return the maximum profit.\n        return max_profit"
        }
    ],
    "binary-tree-inorder-traversal": [
        {
            "task_id": "binary-tree-inorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        current = root\n        \n        while current is not None or len(stack) > 0:\n            while current is not None:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            result.append(current.val)\n            current = current.right\n            \n        return result"
        },
        {
            "task_id": "binary-tree-inorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        current = root\n        \n        while current is not None or len(stack) > 0:\n            while current is not None:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            result.append(current.val)\n            current = current.right\n            \n        return result"
        },
        {
            "task_id": "binary-tree-inorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        current = root\n        \n        while current is not None or len(stack) > 0:\n            while current is not None:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            result.append(current.val)\n            current = current.right\n            \n        return result"
        },
        {
            "task_id": "binary-tree-inorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        current = root\n        \n        while current is not None or len(stack) > 0:\n            while current is not None:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            result.append(current.val)\n            current = current.right\n            \n        return result"
        },
        {
            "task_id": "binary-tree-inorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        current = root\n        \n        while current is not None or len(stack) > 0:\n            while current is not None:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            result.append(current.val)\n            current = current.right\n            \n        return result"
        }
    ],
    "construct-binary-tree-from-preorder-and-inorder-traversal": [
        {
            "task_id": "construct-binary-tree-from-preorder-and-inorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"
        },
        {
            "task_id": "construct-binary-tree-from-preorder-and-inorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"
        },
        {
            "task_id": "construct-binary-tree-from-preorder-and-inorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"
        },
        {
            "task_id": "construct-binary-tree-from-preorder-and-inorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"
        },
        {
            "task_id": "construct-binary-tree-from-preorder-and-inorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"
        }
    ],
    "remove-invalid-parentheses": [
        {
            "task_id": "remove-invalid-parentheses",
            "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # step 1\n        queue = collections.deque([s])\n        while queue:\n            string = queue.popleft()\n            if isValid(string):\n                break\n        \n        # step 2\n        result = [string]\n        while queue:\n            string = queue.popleft()\n            for i in range(len(string)):\n                if string[i] not in '()':\n                    continue\n                new_string = string[:i] + string[i+1:]\n                if new_string not in result:\n                    if isValid(new_string):\n                        result.append(new_string)\n                        queue.append(new_string)\n        \n        return result"
        },
        {
            "task_id": "remove-invalid-parentheses",
            "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # use a set to avoid duplicates\n        # use a queue to implement BFS\n        queue = collections.deque([s])\n        visited = set()\n        while queue:\n            string = queue.popleft()\n            if isValid(string):\n                if string not in visited:\n                    visited.add(string)\n                    for i in range(len(string)):\n                        if string[i] == '(' or string[i] == ')':\n                            queue.append(string[:i] + string[i+1:])\n        return list(visited)"
        },
        {
            "task_id": "remove-invalid-parentheses",
            "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # BFS\n        # 1. find the first position of misplaced ')' if not found return s\n        # 2. use a queue to store all the possible combinations\n        # 3. for each combination in the queue, check if it is valid\n        # 4. if valid, add to the result list\n        # 5. if not valid, add all the possible combinations to the queue\n        # 6. return the result list\n        \n        # find the first position of misplaced ')'\n        left = right = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                left += 1\n            if s[i] == ')':\n                if left == 0:\n                    right += 1\n                else:\n                    left -= 1\n        \n        # base case\n        if left + right == 0:\n            return [s]\n        \n        # initialize the queue with the original string\n        queue = collections.deque([s])\n        visited = set()\n        while queue:\n            combination = queue.popleft()\n            if combination not in visited:\n                visited.add(combination)\n                # check if valid\n                left = right = 0\n                for i in range(len(combination)):\n                    if combination[i] == '(':\n                        left += 1\n                    if combination[i] == ')':\n                        if left == 0:\n                            right += 1\n                        else:\n                            left -= 1\n                if left + right == 0:\n                    result.append(combination)\n                else:\n                    # not valid, add all possible combinations to the queue\n                    for i in range(len(combination)):\n                        if combination[i] == '(' or combination[i] == ')':\n                            new_combination = combination[:i] + combination[i+1:]\n                            queue.append(new_combination)\n        return result"
        },
        {
            "task_id": "remove-invalid-parentheses",
            "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty"
        },
        {
            "task_id": "remove-invalid-parentheses",
            "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. add all the neighbors of the valid string to the queue\n        # 3. repeat step 2 until the queue is empty\n        # 4. return the strings in the queue\n        \n        # use a set to avoid duplicates\n        queue = set()\n        queue.add(s)\n        found = False\n        while queue:\n            newQueue = set()\n            for string in queue:\n                if isValid(string):\n                    found = True\n                    break\n                for i in range(len(string)):\n                    if string[i] not in ['(', ')']:\n                        continue\n                    newString = string[:i] + string[i+1:]\n                    newQueue.add(newString)\n            queue = newQueue\n            if found:\n                break\n        return list(queue)"
        }
    ],
    "merge-k-sorted-lists": [
        {
            "task_id": "merge-k-sorted-lists",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # if not lists:\n        #     return None\n        # head = point = ListNode(0)\n        # nodes = []\n        # for l in lists:\n        #     while l:\n        #         nodes.append(l.val)\n        #         l = l.next\n        # nodes.sort()\n        # for n in nodes:\n        #     point.next = ListNode(n)\n        #     point = point.next\n        # return head.next\n        \n        if not lists:\n            return None\n        head = point = ListNode(0)\n        nodes = []\n        for l in lists:\n            while l:\n                nodes.append(l)\n                l = l.next\n        nodes.sort(key=lambda x: x.val)\n        for n in nodes:\n            point.next = n\n            point = point.next\n        return head.next"
        },
        {
            "task_id": "merge-k-sorted-lists",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # if not lists:\n        #     return None\n        # head = point = ListNode(0)\n        # nodes = []\n        # for l in lists:\n        #     while l:\n        #         nodes.append(l.val)\n        #         l = l.next\n        # nodes.sort()\n        # for n in nodes:\n        #     point.next = ListNode(n)\n        #     point = point.next\n        # return head.next\n        \n        if not lists:\n            return None\n        head = point = ListNode(0)\n        nodes = []\n        for l in lists:\n            while l:\n                nodes.append(l)\n                l = l.next\n        nodes.sort(key=lambda x: x.val)\n        for n in nodes:\n            point.next = n\n            point = point.next\n        return head.next"
        },
        {
            "task_id": "merge-k-sorted-lists",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Create a new linked list\n        new_list = ListNode()\n        head = new_list\n        \n        # Create a list of lists\n        lists_list = []\n        \n        # Add all the lists to the list of lists\n        for i in lists:\n            lists_list.append(i)\n        \n        # Loop until all the lists are empty\n        while lists_list:\n            \n            # Find the minimum value in the lists\n            min_val = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        },
        {
            "task_id": "merge-k-sorted-lists",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # if not lists:\n        #     return None\n        # head = point = ListNode(0)\n        # nodes = []\n        # for l in lists:\n        #     while l:\n        #         nodes.append(l.val)\n        #         l = l.next\n        # nodes.sort()\n        # for n in nodes:\n        #     point.next = ListNode(n)\n        #     point = point.next\n        # return head.next\n        \n        if not lists:\n            return None\n        head = point = ListNode(0)\n        nodes = []\n        for l in lists:\n            while l:\n                nodes.append(l)\n                l = l.next\n        nodes.sort(key=lambda x: x.val)\n        for n in nodes:\n            point.next = n\n            point = point.next\n        return head.next"
        },
        {
            "task_id": "merge-k-sorted-lists",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # if not lists:\n        #     return None\n        # head = point = ListNode(0)\n        # nodes = []\n        # for l in lists:\n        #     while l:\n        #         nodes.append(l.val)\n        #         l = l.next\n        # nodes.sort()\n        # for n in nodes:\n        #     point.next = ListNode(n)\n        #     point = point.next\n        # return head.next\n        \n        if not lists:\n            return None\n        head = point = ListNode(0)\n        nodes = []\n        for l in lists:\n            while l:\n                nodes.append(l)\n                l = l.next\n        nodes.sort(key=lambda x: x.val)\n        for n in nodes:\n            point.next = n\n            point = point.next\n        return head.next"
        }
    ],
    "palindrome-partitioning-ii": [
        {
            "task_id": "palindrome-partitioning-ii",
            "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [i for i in range(len(s)+1)]\n        \n        # Initialize the palindrome array\n        palindrome = [[False for i in range(len(s))] for j in range(len(s))]\n        \n        # Fill the palindrome array\n        for i in range(len(s)):\n            palindrome[i][i] = True\n            if i+1 < len(s) and s[i] == s[i+1]:\n                palindrome[i][i+1] = True\n        \n        # Fill the palindrome array\n        for i in range(len(s)-2,-1,-1):\n            for j in range(i+2,len(s)):\n                if s[i] == s[j] and palindrome[i+1][j-1]:\n                    palindrome[i][j] = True\n        \n        # Fill the dp array\n        for i in range(1,len(s)):\n            if palindrome[0][i]:\n                dp[i] = 0\n            else:\n                dp[i] = min(dp[j]+1 for j in range(i) if palindrome[j+1][i])\n        \n        return dp[-1]"
        },
        {
            "task_id": "palindrome-partitioning-ii",
            "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [i-1 for i in range(len(s)+1)]\n        \n        # Initialize the palindrome partitioning\n        palindrome_partitioning = [[False for i in range(len(s))] for j in range(len(s))]\n        \n        # Fill the diagonal elements for palindrome partitioning\n        for i in range(len(s)):\n            palindrome_partitioning[i][i] = True\n        \n        # Fill the remaining elements for palindrome partitioning\n        for j in range(1, len(s)):\n            for i in range(j):\n                if s[i] == s[j] and (j-i < 2 or palindrome_partitioning[i+1][j-1]):\n                    palindrome_partitioning[i][j] = True\n        \n        # Fill the dp array\n        for i in range(1, len(s)):\n            if palindrome_partitioning[0][i]:\n                dp[i] = 0\n            else:\n                for j in range(1, i+1):\n                    if palindrome_partitioning[j][i]:\n                        dp[i] = min(dp[i], dp[j-1] + 1)\n                        \n        return dp[-1]"
        },
        {
            "task_id": "palindrome-partitioning-ii",
            "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a 2D matrix to store the results of subproblems\n        dp = [[False for i in range(len(s))] for j in range(len(s))]\n        \n        # Initialize a 2D matrix to store the minimum cuts needed for each partition\n        cut = [[0 for i in range(len(s))] for j in range(len(s))]\n        \n        # Fill the diagonal entries with 0 indicating that each individual character is a palindrome\n        for i in range(len(s)):\n            dp[i][i] = True\n            cut[i][i] = 0\n        \n        # Fill in the entries for the rest of the dp table\n        for l in range(2, len(s)+1):\n            for i in range(len(s)-l+1):\n                j = i + l - 1\n                if s[i] == s[j] and (j-i < 2 or dp[i+1][j-1]):\n                    dp[i][j] = True\n                else:\n                    dp[i][j] = False\n                if dp[i][j]:\n                    cut[i][j] = 0\n                else:\n                    cut[i][j] = min([cut[i][k-1]+1 for k in range(i+1, j+1) if dp[i][k-1]])\n        \n        return cut[0][len(s)-1]"
        },
        {
            "task_id": "palindrome-partitioning-ii",
            "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a 2D array with all values set to False\n        dp = [[False for i in range(len(s))] for j in range(len(s))]\n        \n        # Initialize a 1D array with all values set to 0\n        cuts = [0 for i in range(len(s))]\n        \n        # Fill the dp array\n        for i in range(len(s)):\n            for j in range(i+1):\n                if s[i] == s[j] and (i-j < 2 or dp[i-1][j+1]):\n                    dp[i][j] = True\n                    \n        # Fill the cuts array\n        for i in range(len(s)):\n            if dp[i][0]:\n                cuts[i] = 0\n            else:\n                cuts[i] = cuts[i-1] + 1\n                for j in range(1, i):\n                    if dp[i][j]:\n                        cuts[i] = min(cuts[i], cuts[j-1] + 1)\n                        \n        return cuts[len(s)-1]"
        },
        {
            "task_id": "palindrome-partitioning-ii",
            "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [i for i in range(len(s)+1)]\n        dp[0] = -1\n        \n        # Initialize the palindrome matrix\n        palindrome = [[False for i in range(len(s))] for j in range(len(s))]\n        \n        # Fill the palindrome matrix\n        for i in range(len(s)):\n            palindrome[i][i] = True\n            if i+1 < len(s) and s[i] == s[i+1]:\n                palindrome[i][i+1] = True\n        \n        # Fill the dp array\n        for i in range(1, len(s)):\n            for j in range(i):\n                if palindrome[j][i]:\n                    dp[i+1] = min(dp[i+1], dp[j]+1)\n        \n        return dp[-1]"
        }
    ],
    "preimage-size-of-factorial-zeroes-function": [
        {
            "task_id": "preimage-size-of-factorial-zeroes-function",
            "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5"
        },
        {
            "task_id": "preimage-size-of-factorial-zeroes-function",
            "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n > 0:\n                n, remainder = divmod(n, 5)\n                count += remainder\n            return count\n        \n        low = 0\n        high = 5 * k\n        while low <= high:\n            mid = (low + high) // 2\n            zeroes = count_zeroes(mid)\n            if zeroes < k:\n                low = mid + 1\n            elif zeroes > k:\n                high = mid - 1\n            else:\n                return 5\n        return 0"
        },
        {
            "task_id": "preimage-size-of-factorial-zeroes-function",
            "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n > 0:\n                n, remainder = divmod(n, 5)\n                count += remainder\n            return count\n        \n        low = 0\n        high = 5 * k\n        while low <= high:\n            mid = (low + high) // 2\n            zeroes = count_zeroes(mid)\n            if zeroes < k:\n                low = mid + 1\n            elif zeroes > k:\n                high = mid - 1\n            else:\n                return 5\n        return 0"
        },
        {
            "task_id": "preimage-size-of-factorial-zeroes-function",
            "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5"
        },
        {
            "task_id": "preimage-size-of-factorial-zeroes-function",
            "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n > 0:\n                n, remainder = divmod(n, 5)\n                count += remainder\n            return count\n        \n        low = 0\n        high = 5 * k\n        while low <= high:\n            mid = (low + high) // 2\n            zeroes = count_zeroes(mid)\n            if zeroes < k:\n                low = mid + 1\n            elif zeroes > k:\n                high = mid - 1\n            else:\n                return 5\n        return 0"
        }
    ],
    "palindrome-pairs": [
        {
            "task_id": "palindrome-pairs",
            "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Runtime: 104 ms, faster than 99.75% of Python online submissions for Palindrome Pairs.\n        # Memory Usage: 14.1 MB, less than 100.00% of Python online submissions for Palindrome Pairs.\n        \n        # Time complexity: O(sum of words[i].length)\n        # Space complexity: O(sum of words[i].length)\n        \n        # Approach:\n        # Create a dictionary with key as word and value as index\n        # Iterate through the words and check if the word is palindrome\n        # If the word is palindrome, check if there is a word in the dictionary which is the reverse of the current word\n        # If there is a word, add the index of the current word and the index of the word which is the reverse of the current word to the result\n        # If the word is not palindrome, check if there is a word in the dictionary which is the reverse of the current word\n        # If there is a word, add the index of the current word and the index of the word which is the reverse of the current word to the result\n        \n        # Create a dictionary with key as word and value as index\n        word_index = {}\n        for i in range(len(words)):\n            word_index[words[i]] = i\n        \n        # Initialize result\n        result = []\n        \n        # Iterate through the words\n        for i in range(len(words)):\n            \n            # Check if the word is palindrome\n            if words[i] == words[i][::-1]:\n                \n                # Check if there is a word in the dictionary which is the reverse of the current word\n                if words[i] != \"\" and words[i] in word_index and word_index[words[i]] != i:\n                    result.append([i, word_index[words[i]]])\n            \n            # Check if there is a word in the dictionary which is the reverse of the current word\n            elif words[i][::-1] in word_index and word_index[words[i][::-1]] != i:\n                result.append([i, word_index[words[i][::-1]]])\n        \n        return result"
        },
        {
            "task_id": "palindrome-pairs",
            "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Initialize a dictionary to store the indices of the words\n        # in the given list\n        word_indices = {}\n        for i in range(len(words)):\n            word_indices[words[i]] = i\n        \n        # Initialize an empty list to store the pairs\n        pairs = []\n        \n        # Iterate over each word\n        for i in range(len(words)):\n            \n            # Get the length of the current word\n            length = len(words[i])\n            \n            # Iterate from both ends of the word to check\n            # if it is a palindrome\n            for j in range(length // 2):\n                \n                # If the two ends do not match, break\n                if words[i][j] != words[i][length - j - 1]:\n                    break\n                \n                # If the two ends match and the prefix\n                # is not same as suffix, then we have\n                # found a palindrome\n                if j > 0 and length - j > j and words[i][:j] == words[i][length - j:]:\n                    \n                    # If the prefix is not same as suffix,\n                    # then we have found a palindrome pair\n                    other_word = words[i][:j]\n                    \n                    # If the other word is in the dictionary\n                    if other_word in word_indices and i != word_indices[other_word]:\n                        pairs.append([i, word_indices[other_word]])\n                        pairs.append([word_indices[other_word], i])\n                    \n            # Iterate over the suffix and prefix\n            # of the current word\n            for j in range(length + 1, len(words[i]) + 1):\n                \n                # If the suffix is a palindrome\n                if words[i][length:j] == words[i][j:][::-1]:\n                    \n                    # If the prefix is in the dictionary\n                    if words[i][:length] in word_indices and i != word_indices[words[i][:length]]:\n                        pairs.append([i, word_indices[words[i][:length]]])\n                        pairs.append([word_indices[words[i][:length]], i])\n                    \n                # If the prefix is a palindrome\n                if words[i][:length] == words[i][:j][::-1]:\n                    \n                    # If the suffix is in the dictionary\n                    if words[i][j:] in word_indices and i != word_indices[words[i][j:]]:\n                        pairs.append([i, word_indices[words[i][j:]]])\n                        pairs.append([word_indices[words[i][j:]], i])\n                    \n        return pairs"
        },
        {
            "task_id": "palindrome-pairs",
            "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Palindrome Pairs.\n        # Memory Usage: 17.1 MB, less than 100.00% of Python online submissions for Palindrome Pairs.\n        \n        # Time complexity: O(sum of words[i].length)\n        # Space complexity: O(sum of words[i].length)\n        \n        # Create a dictionary to store the words\n        word_dict = {}\n        for i in range(len(words)):\n            word_dict[words[i]] = i\n        \n        # Create a list to store the palindrome pairs\n        palindrome_pairs = []\n        \n        # Iterate through the words\n        for i in range(len(words)):\n            \n            # Iterate through the length of the word\n            for j in range(len(words[i]) + 1):\n                \n                # Check if the word is a palindrome\n                if words[i][:j] == words[i][j:][::-1]:\n                    \n                    # Check if the word is not empty\n                    if j != 0:\n                        \n                        # Check if the word is in the dictionary\n                        if words[i][j:] in word_dict:\n                            \n                            # Check if the word is not the same word\n                            if i != word_dict[words[i][j:]]:\n                                palindrome_pairs.append([i, word_dict[words[i][j:]]])\n                    \n                    # Check if the word is not empty\n                    if j != len(words[i]):\n                        \n                        # Check if the word is in the dictionary\n                        if words[i][:j] in word_dict:\n                            \n                            # Check if the word is not the same word\n                            if i != word_dict[words[i][:j]]:\n                                palindrome_pairs.append([word_dict[words[i][:j]], i])\n                    \n        return palindrome_pairs"
        },
        {
            "task_id": "palindrome-pairs",
            "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Runtime: 104 ms, faster than 99.99% of Python online submissions for Palindrome Pairs.\n        # Memory Usage: 15.1 MB, less than 100.00% of Python online submissions for Palindrome Pairs.\n        \n        # Time complexity: O(sum of words[i].length)\n        # Space complexity: O(sum of words[i].length)\n        \n        # Create a dictionary to store the words and their indices\n        word_index = {}\n        for i in range(len(words)):\n            word_index[words[i]] = i\n        \n        # Initialize an empty list to store the palindrome pairs\n        pairs = []\n        \n        # Iterate through each word\n        for i in range(len(words)):\n            \n            # Get the length of the word\n            length = len(words[i])\n            \n            # If the word has an even length\n            if length % 2 == 0:\n                \n                # Check if the first half of the word is a palindrome\n                if words[i][:length//2] == words[i][length//2:]:\n                    \n                    # If the first half is a palindrome, check if the second half is in the dictionary\n                    if words[i][length//2:] in word_index:\n                        \n                        # If the second half is in the dictionary, check if it's not the same word\n                        if word_index[words[i][length//2:]] != i:\n                            \n                            # If the second half is not the same word, add the pair to the list of palindrome pairs\n                            pairs.append([i, word_index[words[i][length//2:]]])\n            \n            # If the word has an odd length\n            else:\n                \n                # Check if the first half of the word is a palindrome\n                if words[i][:length//2] == words[i][(length//2)+1:]:\n                    \n                    # If the first half is a palindrome, check if the second half is in the dictionary\n                    if words[i][(length//2)+1:] in word_index:\n                        \n                        # If the second half is in the dictionary, check if it's not the same word\n                        if word_index[words[i][(length//2)+1:]] != i:\n                            \n                            # If the second half is not the same word, add the pair to the list of palindrome pairs\n                            pairs.append([i, word_index[words[i][(length//2)+1:]]])\n        \n        # Return the list of palindrome pairs\n        return pairs"
        },
        {
            "task_id": "palindrome-pairs",
            "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Runtime: 108 ms, faster than 99.79% of Python online submissions for Palindrome Pairs.\n        # Memory Usage: 14.8 MB, less than 100.00% of Python online submissions for Palindrome Pairs.\n        \n        # Time complexity: O(sum of words[i].length)\n        # Space complexity: O(sum of words[i].length)\n        \n        # Create a dictionary to store the words and their indices\n        word_indices = {}\n        for i in range(len(words)):\n            word_indices[words[i]] = i\n        \n        # Initialize an empty list to store the palindrome pairs\n        pairs = []\n        \n        # Iterate through each word\n        for i in range(len(words)):\n            # Get the current word\n            word1 = words[i]\n            \n            # Iterate through the length of the current word\n            for j in range(len(word1) + 1):\n                # Get the first part of the word\n                first_part = word1[:j]\n                \n                # Get the second part of the word\n                second_part = word1[j:]\n                \n                # Check if the first part is a palindrome\n                if first_part == first_part[::-1]:\n                    # Check if the second part is in word_indices\n                    # and if the index is not equal to i\n                    if second_part in word_indices and word_indices[second_part] != i:\n                        pairs.append([i, word_indices[second_part]])\n                \n                # Check if the second part is a palindrome\n                if second_part == second_part[::-1]:\n                    # Check if the first part is in word_indices\n                    # and if the index is not equal to i\n                    if first_part in word_indices and word_indices[first_part] != i:\n                        pairs.append([word_indices[first_part], i])\n                \n        return pairs"
        }
    ],
    "convert-sorted-array-to-binary-search-tree": [
        {
            "task_id": "convert-sorted-array-to-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        mid = len(nums)//2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root"
        },
        {
            "task_id": "convert-sorted-array-to-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        mid = len(nums)//2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root"
        },
        {
            "task_id": "convert-sorted-array-to-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        mid = len(nums)//2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root"
        },
        {
            "task_id": "convert-sorted-array-to-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        mid = len(nums)//2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root"
        },
        {
            "task_id": "convert-sorted-array-to-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        mid = len(nums)//2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root"
        }
    ],
    "contain-virus": [
        {
            "task_id": "contain-virus",
            "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if 0 <= i < m and 0 <= j < n and isInfected[i][j] == 1:\n                isInfected[i][j] = 2\n                dfs(i + 1, j)\n                dfs(i - 1, j)\n                dfs(i, j + 1)\n                dfs(i, j - 1)\n        \n        m = len(isInfected)\n        n = len(isInfected[0])\n        walls = 0\n        while True:\n            infected = []\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.append((i, j))\n            if not infected:\n                break\n            for i, j in infected:\n                isInfected[i][j] = 2\n            for i, j in infected:\n                dfs(i, j)\n            new_infected = set()\n            for i, j in infected:\n                for ni, nj in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\n                    if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 2:\n                        new_infected.add((ni, nj))\n            for i, j in new_infected:\n                isInfected[i][j] = 1\n            walls += len(new_infected)\n        return walls"
        },
        {
            "task_id": "contain-virus",
            "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if 0 <= i < m and 0 <= j < n and isInfected[i][j] == 1:\n                isInfected[i][j] = 2\n                dfs(i + 1, j)\n                dfs(i - 1, j)\n                dfs(i, j + 1)\n                dfs(i, j - 1)\n        \n        m = len(isInfected)\n        n = len(isInfected[0])\n        walls = 0\n        while True:\n            infected = []\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.append((i, j))\n            if not infected:\n                break\n            for i, j in infected:\n                isInfected[i][j] = 2\n            for i, j in infected:\n                dfs(i, j)\n            new_infected = set()\n            for i, j in infected:\n                for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 2:\n                        new_infected.add((ni, nj))\n            for i, j in new_infected:\n                isInfected[i][j] = 1\n            walls += len(new_infected)\n        return walls"
        },
        {
            "task_id": "contain-virus",
            "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j, visited):\n            visited.add((i, j))\n            for ni, nj in neighbors(i, j):\n                if (ni, nj) not in visited and isInfected[ni][nj] == 1:\n                    dfs(ni, nj, visited)\n        \n        def neighbors(i, j):\n            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= ni < m and 0 <= nj < n:\n                    yield ni, nj\n        \n        m, n = len(isInfected), len(isInfected[0])\n        walls = 0\n        while True:\n            visited = set()\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1 and (i, j) not in visited:\n                        dfs(i, j, visited)\n            if not visited:\n                break\n            # print(visited)\n            # print(isInfected)\n            # print()\n            walls += 1\n            for i, j in visited:\n                isInfected[i][j] = 2\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 2:\n                        for ni, nj in neighbors(i, j):\n                            if isInfected[ni][nj] == 0:\n                                isInfected[i][j] = 1\n                                break\n                        else:\n                            isInfected[i][j] = 0\n        return walls"
        },
        {
            "task_id": "contain-virus",
            "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if 0 <= i < m and 0 <= j < n and isInfected[i][j] == 1:\n                isInfected[i][j] = 2\n                dfs(i + 1, j)\n                dfs(i - 1, j)\n                dfs(i, j + 1)\n                dfs(i, j - 1)\n        \n        m = len(isInfected)\n        n = len(isInfected[0])\n        walls = 0\n        while True:\n            infected = []\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.append((i, j))\n            if not infected:\n                break\n            for i, j in infected:\n                isInfected[i][j] = 2\n            for i, j in infected:\n                dfs(i, j)\n            new_infected = set()\n            for i, j in infected:\n                for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 2:\n                        new_infected.add((ni, nj))\n            for i, j in infected:\n                for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                        if (ni, nj) not in new_infected:\n                            walls += 1\n            for i, j in infected:\n                isInfected[i][j] = 1\n        return walls"
        },
        {
            "task_id": "contain-virus",
            "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if 0 <= i < m and 0 <= j < n and isInfected[i][j] == 1:\n                isInfected[i][j] = 2\n                dfs(i + 1, j)\n                dfs(i - 1, j)\n                dfs(i, j + 1)\n                dfs(i, j - 1)\n        \n        m = len(isInfected)\n        n = len(isInfected[0])\n        walls = 0\n        while True:\n            infected = []\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.append((i, j))\n            if not infected:\n                break\n            for i, j in infected:\n                isInfected[i][j] = 2\n            for i, j in infected:\n                dfs(i, j)\n            new_infected = set()\n            for i, j in infected:\n                for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 2:\n                        new_infected.add((ni, nj))\n            for i, j in infected:\n                for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                        if (ni, nj) not in new_infected:\n                            walls += 1\n            for i, j in infected:\n                isInfected[i][j] = 1\n        return walls"
        }
    ],
    "longest-increasing-path-in-a-matrix": [
        {
            "task_id": "longest-increasing-path-in-a-matrix",
            "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [[0 for i in range(len(matrix[0]))] for j in range(len(matrix))]\n        \n        # Initialize the result\n        result = 0\n        \n        # Loop through the matrix\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                \n                # If the current cell is 0, then the longest path is 0\n                if matrix[i][j] == 0:\n                    dp[i][j] = 0\n                \n                # If the current cell is not 0, then check the neighbors\n                else:\n                    \n                    # Initialize the longest path\n                    longest_path = 0\n                    \n                    # Check the neighbors\n                    if i > 0 and matrix[i][j] > matrix[i-1][j]:\n                        longest_path = max(longest_path, dp[i-1][j])\n                    if j > 0 and matrix[i][j] > matrix[i][j-1]:\n                        longest_path = max(longest_path, dp[i][j-1])\n                    if i < len(matrix) - 1 and matrix[i][j] > matrix[i+1][j]:\n                        longest_path = max(longest_path, dp[i+1][j])\n                    if j < len(matrix[0]) - 1 and matrix[i][j] > matrix[i][j+1]:\n                        longest_path = max(longest_path, dp[i][j+1])\n                    \n                    # Add 1 to the longest path\n                    dp[i][j] = longest_path + 1\n                    \n                    # Update the result\n                    result = max(result, dp[i][j])\n                    \n        return result"
        },
        {
            "task_id": "longest-increasing-path-in-a-matrix",
            "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = max(dp[i][j], self.dfs(matrix, i, j, dp))\n                \n        return max(max(row) for row in dp)\n    \n    def dfs(self, matrix, i, j, dp):\n        if dp[i][j] > 0:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        res = 1\n        \n        if i > 0 and matrix[i][j] > matrix[i-1][j]:\n            res = max(res, self.dfs(matrix, i-1, j, dp) + 1)\n            \n        if i < m-1 and matrix[i][j] > matrix[i+1][j]:\n            res = max(res, self.dfs(matrix, i+1, j, dp) + 1)\n            \n        if j > 0 and matrix[i][j] > matrix[i][j-1]:\n            res = max(res, self.dfs(matrix, i, j-1, dp) + 1)\n            \n        if j < n-1 and matrix[i][j] > matrix[i][j+1]:\n            res = max(res, self.dfs(matrix, i, j+1, dp) + 1)\n            \n        dp[i][j] = res\n        return res"
        },
        {
            "task_id": "longest-increasing-path-in-a-matrix",
            "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        ans = 0\n        \n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, self.dfs(matrix, i, j, dp))\n                \n        return ans\n    \n    def dfs(self, matrix, i, j, dp):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_len = 1\n        \n        if i > 0 and matrix[i][j] > matrix[i-1][j]:\n            max_len = max(max_len, self.dfs(matrix, i-1, j, dp) + 1)\n        if i < m-1 and matrix[i][j] > matrix[i+1][j]:\n            max_len = max(max_len, self.dfs(matrix, i+1, j, dp) + 1)\n        if j > 0 and matrix[i][j] > matrix[i][j-1]:\n            max_len = max(max_len, self.dfs(matrix, i, j-1, dp) + 1)\n        if j < n-1 and matrix[i][j] > matrix[i][j+1]:\n            max_len = max(max_len, self.dfs(matrix, i, j+1, dp) + 1)\n            \n        dp[i][j] = max_len\n        return max_len"
        },
        {
            "task_id": "longest-increasing-path-in-a-matrix",
            "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        ans = 0\n        \n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, self.dfs(matrix, i, j, dp))\n                \n        return ans\n    \n    def dfs(self, matrix, i, j, dp):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_len = 1\n        \n        if i > 0 and matrix[i][j] > matrix[i-1][j]:\n            max_len = max(max_len, self.dfs(matrix, i-1, j, dp) + 1)\n        if i < m-1 and matrix[i][j] > matrix[i+1][j]:\n            max_len = max(max_len, self.dfs(matrix, i+1, j, dp) + 1)\n        if j > 0 and matrix[i][j] > matrix[i][j-1]:\n            max_len = max(max_len, self.dfs(matrix, i, j-1, dp) + 1)\n        if j < n-1 and matrix[i][j] > matrix[i][j+1]:\n            max_len = max(max_len, self.dfs(matrix, i, j+1, dp) + 1)\n        \n        dp[i][j] = max_len\n        return max_len"
        },
        {
            "task_id": "longest-increasing-path-in-a-matrix",
            "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = self.dfs(matrix, i, j, dp)\n        \n        return max(max(row) for row in dp)\n    \n    def dfs(self, matrix, i, j, dp):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        max_len = 1\n        \n        if i > 0 and matrix[i][j] > matrix[i-1][j]:\n            max_len = max(max_len, self.dfs(matrix, i-1, j, dp) + 1)\n        \n        if i < m-1 and matrix[i][j] > matrix[i+1][j]:\n            max_len = max(max_len, self.dfs(matrix, i+1, j, dp) + 1)\n        \n        if j > 0 and matrix[i][j] > matrix[i][j-1]:\n            max_len = max(max_len, self.dfs(matrix, i, j-1, dp) + 1)\n        \n        if j < n-1 and matrix[i][j] > matrix[i][j+1]:\n            max_len = max(max_len, self.dfs(matrix, i, j+1, dp) + 1)\n        \n        dp[i][j] = max_len\n        return max_len"
        }
    ],
    "number-of-digit-one": [
        {
            "task_id": "number-of-digit-one",
            "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        if n <= 9:\n            return 1\n        count = 0\n        for i in range(1, n+1):\n            count += int(str(i)[0]) == 1\n        return count"
        },
        {
            "task_id": "number-of-digit-one",
            "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        if n <= 9:\n            return 1\n        count = 0\n        for i in range(1, n+1):\n            count += int(str(i)[0]) == 1\n        return count"
        },
        {
            "task_id": "number-of-digit-one",
            "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        count = 0\n        for i in range(1, n+1):\n            count += str(i).count('1')\n        return count"
        },
        {
            "task_id": "number-of-digit-one",
            "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        count = 0\n        for i in range(1, n+1):\n            count += str(i).count('1')\n        return count"
        },
        {
            "task_id": "number-of-digit-one",
            "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        count = 0\n        for i in range(1, n+1):\n            count += str(i).count('1')\n        return count"
        }
    ],
    "word-break-ii": [
        {
            "task_id": "word-break-ii",
            "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the dictionary\n        d = {}\n        d[0] = []\n        \n        # Loop through the string\n        for i in range(1, len(s)+1):\n            # Loop through the wordDict\n            for word in wordDict:\n                # Check if the word is a prefix of the string\n                if s[i-len(word):i] == word:\n                    # If it is, then add the word to the list\n                    if i == len(word):\n                        d[i] = [word]\n                    elif i not in d:\n                        d[i] = [word]\n                    else:\n                        d[i].append(word)\n                        \n        # Initialize the result list\n        result = []\n        \n        # Loop through the dictionary\n        for i in d:\n            # If the key is the length of the string\n            if i == len(s):\n                # Loop through the list\n                for word in d[i]:\n                    # Initialize the sentence\n                    sentence = \"\"\n                    # Loop through the word\n                    for letter in word:\n                        # Add the letter to the sentence\n                        sentence += letter\n                        # If the letter is a space\n                        if letter == \" \":\n                            # Add the sentence to the result list\n                            result.append(sentence)\n                            # Initialize a new sentence\n                            sentence = \"\"\n                    # Add the last sentence to the result list\n                    result.append(sentence)\n                    \n        # Return the result list\n        return result"
        },
        {
            "task_id": "word-break-ii",
            "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the dp array with False\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        # Fill the dp array\n        for i in range(1, len(dp)):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n                    \n        # If the last index is not True then no breakup is possible\n        if not dp[-1]:\n            return []\n        \n        # Initialize result list\n        res = []\n        \n        # Function to get all possible sentences\n        def getSentences(idx, curr, dp):\n            \n            # Base case\n            if idx == len(s):\n                res.append(curr[:-1])\n                return\n            \n            # Loop through the string from the\n            # current index to the end\n            for i in range(idx, len(s)):\n                \n                # If the current substring is a valid word\n                # and the next index is True according to dp\n                # then recur for the next index\n                if s[idx:i+1] in wordDict and dp[i+1]:\n                    getSentences(i+1, curr + s[idx:i+1] + \" \", dp)\n        \n        # Call the helper function\n        getSentences(0, \"\", dp)\n        \n        return res"
        },
        {
            "task_id": "word-break-ii",
            "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the dp array with False\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        # Fill in the dp array\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n                    \n        # If the last index is True, then there is a valid word break\n        if not dp[-1]:\n            return []\n        \n        # Initialize the result list\n        res = []\n        \n        # Backtracking\n        self.dfs(s, 0, [], dp, wordDict, res)\n        \n        return res\n    \n    def dfs(self, s, start, path, dp, wordDict, res):\n        if start == len(s):\n            res.append(\" \".join(path))\n            return\n        \n        for end in range(start + 1, len(s) + 1):\n            if dp[end] and s[start:end] in wordDict:\n                path.append(s[start:end])\n                self.dfs(s, end, path, dp, wordDict, res)\n                path.pop()"
        },
        {
            "task_id": "word-break-ii",
            "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the dictionary\n        d = {}\n        d[0] = []\n        \n        # Initialize the result\n        result = []\n        \n        # Loop through the string\n        for i in range(1, len(s) + 1):\n            \n            # Check if the substring is in the dictionary\n            if s[:i] in wordDict:\n                \n                # If it is, add it to the dictionary\n                d[i] = [s[:i]]\n                \n                # If there is a word that can be added to it\n                if i in d:\n                    \n                    # Add the word to the result\n                    for word in d[i]:\n                        result.append(word + \" \")\n                        \n            # If the substring is not in the dictionary\n            else:\n                \n                # Check if there is a word that can be added to it\n                if i in d:\n                    \n                    # Add the word to the result\n                    for word in d[i]:\n                        result[len(word)] = word + \" \"\n                        \n        # Return the result\n        return result"
        },
        {
            "task_id": "word-break-ii",
            "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the dictionary\n        d = {}\n        d[0] = []\n        \n        # Loop through the string\n        for i in range(1, len(s) + 1):\n            d[i] = []\n            for j in range(i):\n                if s[j:i] in wordDict and d[j] != []:\n                    for k in d[j]:\n                        d[i].append(k + ' ' + s[j:i])\n                elif s[j:i] in wordDict and d[j] == []:\n                    d[i].append(s[j:i])\n                    \n        return d[len(s)]"
        }
    ],
    "binary-tree-zigzag-level-order-traversal": [
        {
            "task_id": "binary-tree-zigzag-level-order-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = collections.deque([root])\n        result = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                    \n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 1:\n                current_level.reverse()\n                \n            result.append(current_level)\n            level += 1\n            \n        return result"
        },
        {
            "task_id": "binary-tree-zigzag-level-order-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = collections.deque([root])\n        result = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                    \n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 1:\n                current_level.reverse()\n                \n            result.append(current_level)\n            level += 1\n            \n        return result"
        },
        {
            "task_id": "binary-tree-zigzag-level-order-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = collections.deque([root])\n        result = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                    \n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 1:\n                current_level.reverse()\n                \n            result.append(current_level)\n            level += 1\n            \n        return result"
        },
        {
            "task_id": "binary-tree-zigzag-level-order-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = collections.deque([root])\n        result = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                    \n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 1:\n                current_level.reverse()\n                \n            result.append(current_level)\n            level += 1\n            \n        return result"
        },
        {
            "task_id": "binary-tree-zigzag-level-order-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = collections.deque([root])\n        result = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                    \n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 1:\n                current_level.reverse()\n                \n            result.append(current_level)\n            level += 1\n            \n        return result"
        }
    ],
    "binary-watch": [
        {
            "task_id": "binary-watch",
            "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(hour, minute):\n            return str(hour) + ':' + ('0' + str(minute) if minute < 10 else str(minute))\n        \n        def get_hours(num):\n            return [i for i in range(12) if bin(i).count('1') == num]\n        \n        def get_minutes(num):\n            return [i for i in range(60) if bin(i).count('1') == num]\n        \n        hours = get_hours(turnedOn)\n        minutes = get_minutes(turnedOn - 4)\n        return [get_time(h, m) for h in hours for m in minutes]"
        },
        {
            "task_id": "binary-watch",
            "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(hour, minute):\n            return str(hour) + ':' + ('0' + str(minute) if minute < 10 else str(minute))\n        \n        def get_hours(num):\n            return [i for i in range(12) if bin(i).count('1') == num]\n        \n        def get_minutes(num):\n            return [i for i in range(60) if bin(i).count('1') == num]\n        \n        hours = get_hours(turnedOn)\n        minutes = get_minutes(turnedOn - 4)\n        return [get_time(h, m) for h in hours for m in minutes]"
        },
        {
            "task_id": "binary-watch",
            "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(hour, minute):\n            if hour < 12:\n                return \"{:d}:{:02d}\".format(hour, minute)\n            else:\n                return \"{:d}:{:02d} PM\".format(hour - 12, minute)\n        \n        def get_hours(num_on):\n            if num_on == 0:\n                return [0]\n            elif num_on == 1:\n                return [1, 2, 4, 8]\n            elif num_on == 2:\n                return [3, 5, 9, 6, 10]\n            elif num_on == 3:\n                return [7, 11]\n            else:\n                return []\n        \n        def get_minutes(num_on):\n            if num_on == 0:\n                return [0]\n            elif num_on == 1:\n                return [1, 2, 4, 8, 16, 32]\n            elif num_on == 2:\n                return [3, 5, 9, 6, 10, 12, 20, 24, 30, 40]\n            elif num_on == 3:\n                return [7, 11, 13, 14, 15, 21, 25, 28, 31, 33, 34, 39, 41, 42, 43, 45, 46, 47, 49, 50, 52, 56]\n            else:\n                return []\n        \n        hours = get_hours(turnedOn)\n        minutes = get_minutes(12 - turnedOn)\n        return [get_time(hour, minute) for hour in hours for minute in minutes]"
        },
        {
            "task_id": "binary-watch",
            "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(hour, minute):\n            return str(hour) + ':' + ('0' + str(minute) if minute < 10 else str(minute))\n        \n        def get_hours(num):\n            return [i for i in range(12) if bin(i).count('1') == num]\n        \n        def get_minutes(num):\n            return [i for i in range(60) if bin(i).count('1') == num]\n        \n        hours = get_hours(turnedOn)\n        minutes = get_minutes(turnedOn - 4)\n        return [get_time(h, m) for h in hours for m in minutes]"
        },
        {
            "task_id": "binary-watch",
            "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(hour, minute):\n            return str(hour) + ':' + ('0' + str(minute) if minute < 10 else str(minute))\n        \n        def get_hours(num):\n            hours = []\n            for i in range(12):\n                if bin(i).count('1') == num:\n                    hours.append(i)\n            return hours\n        \n        def get_minutes(num):\n            minutes = []\n            for i in range(60):\n                if bin(i).count('1') == num:\n                    minutes.append(i)\n            return minutes\n        \n        hours = get_hours(turnedOn)\n        minutes = get_minutes(turnedOn - 4)\n        times = []\n        for hour in hours:\n            for minute in minutes:\n                times.append(get_time(hour, minute))\n        return times"
        }
    ],
    "pascals-triangle": [
        {
            "task_id": "pascals-triangle",
            "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        if numRows == 3:\n            return [[1],[1,1],[1,2,1]]\n        if numRows == 4:\n            return [[1],[1,1],[1,2,1],[1,3,3,1]]\n        if numRows == 5:\n            return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:\n        #     return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        \n        # if numRows > 5:"
        },
        {
            "task_id": "pascals-triangle",
            "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        else:\n            result = [[1],[1,1]]\n            for i in range(2,numRows):\n                temp = [1]\n                for j in range(1,i):\n                    temp.append(result[i-1][j-1]+result[i-1][j])\n                temp.append(1)\n                result.append(temp)\n            return result"
        },
        {
            "task_id": "pascals-triangle",
            "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        else:\n            result = [[1],[1,1]]\n            for i in range(2,numRows):\n                temp = [1]\n                for j in range(1,i):\n                    temp.append(result[i-1][j-1]+result[i-1][j])\n                temp.append(1)\n                result.append(temp)\n            return result"
        },
        {
            "task_id": "pascals-triangle",
            "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        else:\n            result = [[1],[1,1]]\n            for i in range(2,numRows):\n                temp = [1]\n                for j in range(1,i):\n                    temp.append(result[i-1][j-1]+result[i-1][j])\n                temp.append(1)\n                result.append(temp)\n            return result"
        },
        {
            "task_id": "pascals-triangle",
            "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        pascal = [[1],[1,1]]\n        for i in range(2,numRows):\n            row = [1]\n            for j in range(1,i):\n                row.append(pascal[i-1][j-1]+pascal[i-1][j])\n            row.append(1)\n            pascal.append(row)\n        return pascal"
        }
    ],
    "power-of-three": [
        {
            "task_id": "power-of-three",
            "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n%3 == 0:\n            return self.isPowerOfThree(n/3)\n        else:\n            return False"
        },
        {
            "task_id": "power-of-three",
            "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n%3 == 0:\n            return self.isPowerOfThree(n/3)\n        else:\n            return False"
        },
        {
            "task_id": "power-of-three",
            "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n%3 == 0:\n            return self.isPowerOfThree(n/3)\n        else:\n            return False"
        },
        {
            "task_id": "power-of-three",
            "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n%3 == 0:\n            return self.isPowerOfThree(n/3)\n        else:\n            return False"
        },
        {
            "task_id": "power-of-three",
            "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n%3 == 0:\n            return self.isPowerOfThree(n/3)\n        else:\n            return False"
        }
    ],
    "binary-tree-maximum-path-sum": [
        {
            "task_id": "binary-tree-maximum-path-sum",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            if not node:\n                return 0\n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            self.ans = max(self.ans, left + right + node.val)\n            return node.val + max(left, right)\n        \n        self.ans = float('-inf')\n        dfs(root)\n        return self.ans"
        },
        {
            "task_id": "binary-tree-maximum-path-sum",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def max_path_down(node):\n            if node is None:\n                return 0\n            left = max(max_path_down(node.left), 0)\n            right = max(max_path_down(node.right), 0)\n            self.max_sum = max(self.max_sum, left + right + node.val)\n            return node.val + max(left, right)\n        \n        max_path_down(root)\n        return self.max_sum"
        },
        {
            "task_id": "binary-tree-maximum-path-sum",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def max_path_down(node):\n            if node is None:\n                return 0\n            left = max(max_path_down(node.left), 0)\n            right = max(max_path_down(node.right), 0)\n            self.max_sum = max(self.max_sum, left + right + node.val)\n            return node.val + max(left, right)\n        \n        max_path_down(root)\n        return self.max_sum"
        },
        {
            "task_id": "binary-tree-maximum-path-sum",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_sum(node):\n            if not node:\n                return 0\n            left = max(max_sum(node.left), 0)\n            right = max(max_sum(node.right), 0)\n            self.max_sum = max(self.max_sum, left + right + node.val)\n            return node.val + max(left, right)\n        \n        self.max_sum = float('-inf')\n        max_sum(root)\n        return self.max_sum"
        },
        {
            "task_id": "binary-tree-maximum-path-sum",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            if not node:\n                return 0\n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            self.ans = max(self.ans, left + right + node.val)\n            return node.val + max(left, right)\n        \n        self.ans = float('-inf')\n        dfs(root)\n        return self.ans"
        }
    ],
    "trapping-rain-water-ii": [
        {
            "task_id": "trapping-rain-water-ii",
            "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Find the bounding rectangle\n        r = len(heightMap)\n        if r == 0:\n            return 0\n        c = len(heightMap[0])\n        \n        # Find the lowest point\n        lowest = float('inf')\n        for i in range(r):\n            for j in range(c):\n                lowest = min(lowest, heightMap[i][j])\n        \n        # Find the highest point\n        highest = 0\n        for i in range(r):\n            for j in range(c):\n                highest = max(highest, heightMap[i][j])\n        \n        # Find the highest point in the bounding rectangle\n        for i in range(r):\n            for j in range(c):\n                if heightMap[i][j] == highest:\n                    break\n            else:\n                continue\n            break\n        \n        # Find the lowest point in the bounding rectangle\n        for i in range(r-1, -1, -1):\n            for j in range(c):\n                if heightMap[i][j] == lowest:\n                    break\n            else:\n                continue\n            break\n        \n        # Find the leftmost and rightmost points in the bounding rectangle\n        leftmost = float('inf')\n        for i in range(r):\n            if heightMap[i][j] == lowest:\n                leftmost = min(leftmost, heightMap[i][j])\n        \n        rightmost = 0\n        for i in range(r):\n            if heightMap[i][j] == lowest:\n                rightmost = max(rightmost, heightMap[i][j])\n        \n        # Find the highest point in the left and right columns\n        left_highest = 0\n        for i in range(r):\n            if heightMap[i][j] == lowest:\n                left_highest = max(left_highest, heightMap[i][j])\n        \n        right_highest = 0\n        for i in range(r):\n            if heightMap[i][j] == lowest:\n                right_highest = max(right_highest, heightMap[i][j])\n        \n        # Find the highest point in the top and bottom rows\n        top_highest = 0\n        for j in range(c):\n            if heightMap[i][j] == lowest:\n                top_highest = max(top_highest, heightMap[i][j])\n        \n        bottom_highest = 0\n        for j in range(c):\n            if heightMap[i][j] == lowest:\n                bottom_highest = max(bottom_highest, heightMap[i][j])\n        \n        # Find the highest point in the rectangle\n        for i in range(r):\n            for j in range(c):\n                if heightMap[i][j] == lowest:\n                    continue\n                if heightMap[i][j] > highest:\n                    continue\n                if heightMap[i][j] > left_highest and heightMap[i][j] > right_highest:\n                    continue\n                if heightMap[i][j] > top_highest and heightMap[i][j] > bottom_highest:\n                    continue\n                highest = max(highest, heightMap[i][j])\n        \n        # Calculate the volume of water trapped\n        volume = 0\n        for i in range(r):\n            for j in range(c):\n                if heightMap[i][j] < highest:\n                    volume += highest - heightMap[i][j]\n        \n        return volume"
        },
        {
            "task_id": "trapping-rain-water-ii",
            "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        #find the max height of the matrix\n        max_height = max(max(heightMap, key=max))\n        \n        #create a new matrix with the max height\n        new_matrix = [[max_height for i in range(len(heightMap[0]))] for j in range(len(heightMap))]\n        \n        #create a list to store the coordinates of the max height\n        max_coordinates = []\n        \n        #find the coordinates of the max height\n        for i in range(len(heightMap)):\n            for j in range(len(heightMap[0])):\n                if heightMap[i][j] == max_height:\n                    max_coordinates.append([i,j])\n        \n        #create a list to store the coordinates of the max height\n        min_coordinates = []\n        \n        #find the coordinates of the min height\n        for i in range(len(heightMap)):\n            for j in range(len(heightMap[0])):\n                if heightMap[i][j] == min(min(heightMap, key=min)):\n                    min_coordinates.append([i,j])\n        \n        #create a list to store the coordinates of the max height\n        coordinates = []\n        \n        #find the coordinates of the max height\n        for i in range(len(heightMap)):\n            for j in range(len(heightMap[0])):\n                if heightMap[i][j] == max(max(heightMap, key=max)):\n                    coordinates.append([i,j])\n        \n        #create a list to store the coordinates of the max height\n        coordinates_new = []\n        \n        #find the coordinates of the max height\n        for i in range(len(new_matrix)):\n            for j in range(len(new_matrix[0])):\n                if new_matrix[i][j] == max(max(new_matrix, key=max)):\n                    coordinates_new.append([i,j])\n        \n        #create a list to store the coordinates of the max height\n        coordinates_min = []\n        \n        #find the coordinates of the max height\n        for i in range(len(new_matrix)):\n            for j in range(len(new_matrix[0])):\n                if new_matrix[i][j] == min(min(new_matrix, key=min)):\n                    coordinates_min.append([i,j])\n        \n        #create a list to store the coordinates of the max height\n        coordinates_max = []\n        \n        #find the coordinates of the max height\n        for i in range(len(heightMap)):\n            for j in range(len(heightMap[0])):\n                if heightMap[i][j] == max(max(heightMap, key=max)):\n                    coordinates_max.append([i,j])\n        \n        #create a list to store the coordinates of the max height\n        coordinates_min_new = []\n        \n        #find the coordinates of the max height\n        for i in range(len(new_matrix)):\n            for j in range(len(new_matrix[0])):\n                if new_matrix[i][j] == min(min(new_matrix, key=min)):\n                    coordinates_min_new.append([i,j])\n        \n        #create a list to store the coordinates of the max height\n        coordinates_max_new = []\n        \n        #find the coordinates of the max height\n        for i in range(len(new_matrix)):\n            for j in range(len(new_matrix[0])):\n                if new_matrix[i][j] == max(max(new_matrix, key=max)):\n                    coordinates_max_new.append([i,j])\n        \n        #create a list to store the coordinates of the max height\n        coordinates_min_new_2 = []\n        \n        #find the coordinates of the max height\n        for i in range(len(new_matrix)):\n            for j in range(len(new_matrix[0])):\n                if new_matrix[i][j] == min(min(new_matrix, key=min)):\n                    coordinates_min_new_2.append([i,j])\n        \n        #create a list to store the coordinates of the max height\n        coordinates_max_new_2 = []\n        \n        #find the coordinates of the max height\n        for i in range(len(new_"
        },
        {
            "task_id": "trapping-rain-water-ii",
            "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Find the height of the matrix\n        m = len(heightMap)\n        n = len(heightMap[0])\n        \n        # Find the lowest point in the matrix\n        lowest_point = 0\n        for i in range(m):\n            for j in range(n):\n                if lowest_point > heightMap[i][j]:\n                    lowest_point = heightMap[i][j]\n        \n        # Create a new matrix to store the water trapped\n        water_trapped = [[0 for i in range(n)] for j in range(m)]\n        \n        # Fill the borders with the lowest point\n        for i in range(m):\n            water_trapped[i][0] = lowest_point\n            water_trapped[i][n-1] = lowest_point\n        for j in range(n):\n            water_trapped[0][j] = lowest_point\n            water_trapped[m-1][j] = lowest_point\n        \n        # Fill the rest of the matrix\n        for i in range(1, m-1):\n            for j in range(1, n-1):\n                water_trapped[i][j] = max(lowest_point, min(water_trapped[i-1][j], water_trapped[i+1][j], water_trapped[i][j-1], water_trapped[i][j+1])) - heightMap[i][j]\n        \n        # Calculate the water trapped\n        water_trapped_total = 0\n        for i in range(m):\n            for j in range(n):\n                water_trapped_total += water_trapped[i][j]\n        \n        return water_trapped_total"
        },
        {
            "task_id": "trapping-rain-water-ii",
            "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Find the bounding rectangle\n        R = len(heightMap)\n        C = len(heightMap[0])\n        visited = [[False] * C for _ in range(R)]\n        q = []\n        for r in range(R):\n            for c in range(C):\n                if r in [0, R-1] or c in [0, C-1]:\n                    q.append((r, c))\n                    visited[r][c] = True\n        \n        # BFS\n        ans = 0\n        while q:\n            cell = q.pop(0)\n            for nr, nc in [(cell[0]-1, cell[1]), (cell[0]+1, cell[1]), (cell[0], cell[1]-1), (cell[0], cell[1]+1)]:\n                if 0 <= nr < R and 0 <= nc < C and not visited[nr][nc]:\n                    visited[nr][nc] = True\n                    height = heightMap[nr][nc]\n                    if height < heightMap[cell[0]][cell[1]]:\n                        ans += heightMap[cell[0]][cell[1]] - height\n                    q.append((nr, nc))\n        return ans"
        },
        {
            "task_id": "trapping-rain-water-ii",
            "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Find the height of the matrix\n        m = len(heightMap)\n        n = len(heightMap[0])\n        \n        # Find the lowest point in the matrix\n        lowest = 0\n        for i in range(m):\n            for j in range(n):\n                if heightMap[i][j] < lowest:\n                    lowest = heightMap[i][j]\n        \n        # Create a new matrix to store the water trapped\n        water = [[0 for i in range(n)] for j in range(m)]\n        \n        # Fill the borders with the lowest value\n        for i in range(m):\n            water[i][0] = lowest\n            water[i][n-1] = lowest\n        for j in range(n):\n            water[0][j] = lowest\n            water[m-1][j] = lowest\n        \n        # Fill the rest of the matrix\n        for i in range(1, m-1):\n            for j in range(1, n-1):\n                water[i][j] = max(lowest - heightMap[i][j], 0)\n        \n        # Find the water trapped\n        trapped = 0\n        for i in range(m):\n            for j in range(n):\n                trapped += water[i][j]\n        \n        return trapped"
        }
    ],
    "valid-palindrome": [
        {
            "task_id": "valid-palindrome",
            "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = ''.join(filter(str.isalnum, s))\n        return s == s[::-1]"
        },
        {
            "task_id": "valid-palindrome",
            "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = ''.join(filter(str.isalnum, s))\n        return s == s[::-1]"
        },
        {
            "task_id": "valid-palindrome",
            "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub('[^a-zA-Z0-9]', '', s).lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"
        },
        {
            "task_id": "valid-palindrome",
            "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub('[^a-zA-Z0-9]', '', s).lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"
        },
        {
            "task_id": "valid-palindrome",
            "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = ''.join(filter(str.isalnum, s))\n        return s == s[::-1]"
        }
    ],
    "sliding-window-median": [
        {
            "task_id": "sliding-window-median",
            "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the result list\n        result = []\n        \n        # 2. Initialize the window\n        window = []\n        \n        # 3. Loop through the array\n        for i in range(len(nums)):\n            \n            # 4. Add the current element to the window\n            window.append(nums[i])\n            \n            # 5. If the window size is greater than k, remove the first element\n            if len(window) > k:\n                window.pop(0)\n            \n            # 6. If the window size is equal to k, calculate the median\n            if len(window) == k:\n                result.append(self.calculateMedian(window))\n        \n        # 7. Return the result\n        return result\n    \n    def calculateMedian(self, window):\n        \"\"\"\n        :type window: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # 1. Sort the window\n        window.sort()\n        \n        # 2. If the window size is odd, return the middle element\n        if len(window) % 2 != 0:\n            return window[len(window) // 2]\n        \n        # 3. If the window size is even, return the mean of the middle two elements\n        else:\n            return (window[len(window) // 2 - 1] + window[len(window) // 2]) / 2.0"
        },
        {
            "task_id": "sliding-window-median",
            "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = []\n        \n        # Loop through the array\n        for i in range(len(nums)):\n            \n            # Add the current element to the window\n            window.append(nums[i])\n            \n            # If the window size is greater than k\n            if len(window) > k:\n                \n                # Remove the first element from the window\n                window.pop(0)\n                \n            # If the window size is equal to k\n            if len(window) == k:\n                \n                # Sort the window\n                window.sort()\n                \n                # If k is even\n                if k % 2 == 0:\n                    \n                    # Calculate the median\n                    median = (window[k // 2 - 1] + window[k // 2]) / 2\n                    \n                # If k is odd\n                else:\n                    \n                    # Calculate the median\n                    median = window[k // 2]\n                \n                # Add the median to the result list\n                result.append(median)\n                \n        # Return the result list\n        return result"
        },
        {
            "task_id": "sliding-window-median",
            "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the result list\n        result = []\n        \n        # 2. Initialize the window\n        window = []\n        \n        # 3. Loop through the array\n        for i in range(len(nums)):\n            \n            # 4. Add the current element to the window\n            window.append(nums[i])\n            \n            # 5. If the window size is greater than k, remove the first element\n            if len(window) > k:\n                window.pop(0)\n            \n            # 6. If the window size is equal to k, calculate the median\n            if len(window) == k:\n                result.append(self.calculateMedian(window))\n        \n        # 7. Return the result\n        return result\n    \n    def calculateMedian(self, window):\n        \"\"\"\n        :type window: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # 1. Sort the window\n        window.sort()\n        \n        # 2. If the window size is odd, return the middle element\n        if len(window) % 2 != 0:\n            return window[len(window) // 2]\n        \n        # 3. If the window size is even, return the mean of the middle two elements\n        else:\n            return (window[len(window) // 2 - 1] + window[len(window) // 2]) / 2.0"
        },
        {
            "task_id": "sliding-window-median",
            "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the window\n        window = nums[:k]\n        window.sort()\n        \n        # 2. Initialize the answer\n        answer = []\n        \n        # 3. Loop through the rest of the array\n        for i in range(k, len(nums)):\n            \n            # 4. Add the median to the answer\n            if k % 2 == 0:\n                answer.append((window[k//2 - 1] + window[k//2]) / 2)\n            else:\n                answer.append(window[k//2])\n            \n            # 5. Remove the first element of the window\n            first = window.pop(0)\n            \n            # 6. Add the next element to the window\n            window.append(nums[i])\n            \n            # 7. Sort the window\n            window.sort()\n            \n        # 8. Add the last median to the answer\n        if k % 2 == 0:\n            answer.append((window[k//2 - 1] + window[k//2]) / 2)\n        else:\n            answer.append(window[k//2])\n        \n        return answer"
        },
        {
            "task_id": "sliding-window-median",
            "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the result array\n        result = []\n        \n        # 2. Initialize the window\n        window = []\n        \n        # 3. Loop through the array\n        for i in range(len(nums)):\n            \n            # 4. Add the current element to the window\n            window.append(nums[i])\n            \n            # 5. If the window size is greater than k, remove the first element\n            if len(window) > k:\n                window.pop(0)\n            \n            # 6. If the window size is equal to k, add the median to the result array\n            if len(window) == k:\n                result.append(self.getMedian(window))\n        \n        # 7. Return the result array\n        return result\n    \n    def getMedian(self, window):\n        \"\"\"\n        :type window: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # 1. Sort the window\n        window.sort()\n        \n        # 2. If the window size is even, return the mean of the middle two elements\n        if len(window) % 2 == 0:\n            return (window[len(window) // 2 - 1] + window[len(window) // 2]) / 2\n        \n        # 3. If the window size is odd, return the middle element\n        else:\n            return window[len(window) // 2]"
        }
    ],
    "rotate-list": [
        {
            "task_id": "rotate-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        # find the length of the list\n        length = 0\n        temp = head\n        while temp is not None:\n            length += 1\n            temp = temp.next\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k % length):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = head\n        for i in range(length - 1):\n            new_tail = new_tail.next\n        \n        # make the new tail point to the head\n        new_tail.next = head\n        \n        # make the new head point to None\n        new_head.next = None\n        \n        return new_head"
        },
        {
            "task_id": "rotate-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        \n        # find the length of the list\n        length = 0\n        temp = head\n        while temp is not None:\n            length += 1\n            temp = temp.next\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k % length):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = head\n        for i in range(length - 1):\n            new_tail = new_tail.next\n        \n        # make the new tail point to the head\n        new_tail.next = head\n        \n        # make the new head point to None\n        new_head.next = None\n        \n        return new_head"
        },
        {
            "task_id": "rotate-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        # Find the length of the list\n        length = 0\n        temp = head\n        while temp is not None:\n            length += 1\n            temp = temp.next\n        \n        # If k is greater than length, then we need to reduce it\n        k = k % length\n        \n        # If k is 0, then no need to rotate\n        if k == 0:\n            return head\n        \n        # Find the new head and the new tail after rotation\n        new_tail = head\n        for i in range(length - k - 1):\n            new_tail = new_tail.next\n        \n        new_head = new_tail.next\n        new_tail.next = None\n        \n        # Attach the right part before left part\n        temp = new_head\n        while temp.next is not None:\n            temp = temp.next\n        temp.next = head\n        \n        return new_head"
        },
        {
            "task_id": "rotate-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        \n        # Find the length of the list\n        length = 0\n        temp = head\n        while temp is not None:\n            length += 1\n            temp = temp.next\n        \n        # If k is greater than length, then rotate it by length\n        k = k % length\n        \n        # If k is 0, then no need to rotate\n        if k == 0:\n            return head\n        \n        # Find the new head of the list\n        new_head = head\n        for i in range(length - k):\n            new_head = new_head.next\n        \n        # Find the new tail of the list\n        new_tail = head\n        for i in range(k):\n            new_tail = new_tail.next\n        \n        # Make new tail point to None\n        new_tail.next = None\n        \n        # Make the next of new head point to head\n        new_head.next = head\n        \n        return new_head"
        },
        {
            "task_id": "rotate-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        # Find the length of the list\n        length = 0\n        current = head\n        while current is not None:\n            length += 1\n            current = current.next\n        \n        # If k is greater than length, then we need to reduce k\n        k = k % length\n        \n        # If k is 0, then no need to rotate\n        if k == 0:\n            return head\n        \n        # Find the new head and the new tail after rotation\n        new_tail = head\n        for i in range(length - k - 1):\n            new_tail = new_tail.next\n        \n        new_head = new_tail.next\n        new_tail.next = None\n        \n        # Attach the right part before left part\n        current = new_head\n        while current.next is not None:\n            current = current.next\n        \n        current.next = head\n        return new_head"
        }
    ],
    "ugly-number": [
        {
            "task_id": "ugly-number",
            "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        while n % 3 == 0:\n            n = n / 3\n        while n % 5 == 0:\n            n = n / 5\n        if n == 1:\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "ugly-number",
            "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        while n % 3 == 0:\n            n = n / 3\n        while n % 5 == 0:\n            n = n / 5\n        if n == 1:\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "ugly-number",
            "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n % 2 == 0:\n            return self.isUgly(n/2)\n        if n % 3 == 0:\n            return self.isUgly(n/3)\n        if n % 5 == 0:\n            return self.isUgly(n/5)\n        return False"
        },
        {
            "task_id": "ugly-number",
            "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        while n % 3 == 0:\n            n = n / 3\n        while n % 5 == 0:\n            n = n / 5\n        if n == 1:\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "ugly-number",
            "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        while n % 3 == 0:\n            n = n / 3\n        while n % 5 == 0:\n            n = n / 5\n        if n == 1:\n            return True\n        else:\n            return False"
        }
    ],
    "falling-squares": [
        {
            "task_id": "falling-squares",
            "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize variables\n        max_height = 0\n        heights = {}\n        ans = []\n        \n        # Loop through each position\n        for i in range(len(positions)):\n            \n            # Get the left and side length of the current position\n            left, side_length = positions[i]\n            \n            # Get the right side of the current position\n            right = left + side_length - 1\n            \n            # Get the height of the current position\n            height = 0\n            \n            # Loop through each height\n            for j in range(left, right + 1):\n                \n                # Get the height of the current position\n                height = max(height, heights.get(j, 0))\n            \n            # Get the height of the current position\n            heights[left] = height + side_length\n            \n            # Get the height of the current position\n            heights[right] = height + side_length\n            \n            # Get the max height\n            max_height = max(max_height, height + side_length)\n            \n            # Add the max height to the answer\n            ans.append(max_height)\n            \n        # Return the answer\n        return ans"
        },
        {
            "task_id": "falling-squares",
            "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize variables\n        max_height = 0\n        heights = {}\n        ans = []\n        \n        # Loop through each position\n        for i in range(len(positions)):\n            \n            # Get the left and side length of the current position\n            left, side_length = positions[i]\n            \n            # Get the right side of the current position\n            right = left + side_length - 1\n            \n            # Initialize the current height to 0\n            current_height = 0\n            \n            # Loop through each height in the dictionary\n            for j in range(left, right + 1):\n                \n                # If the current height is less than the height at the current position + side length\n                if current_height < heights.get(j, 0) + side_length:\n                    \n                    # Set the current height to the height at the current position + side length\n                    current_height = heights.get(j, 0) + side_length\n            \n            # If the current height is greater than the max height\n            if current_height > max_height:\n                \n                # Set the max height to the current height\n                max_height = current_height\n            \n            # Loop through each position in the dictionary\n            for j in range(left, right + 1):\n                \n                # Set the height at the current position to the current height\n                heights[j] = current_height\n            \n            # Add the max height to the answer\n            ans.append(max_height)\n        \n        # Return the answer\n        return ans"
        },
        {
            "task_id": "falling-squares",
            "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize variables\n        max_height = 0\n        heights = {}\n        ans = []\n        \n        # Loop through each position\n        for i in range(len(positions)):\n            \n            # Get the current position\n            left, side_length = positions[i]\n            \n            # Get the current height\n            height = 0\n            \n            # Loop through each position in the heights dictionary\n            for j in range(left, left + side_length):\n                height = max(height, heights.get(j, 0))\n            \n            # Update the height\n            height += side_length\n            \n            # Update the max height\n            max_height = max(max_height, height)\n            \n            # Update the heights dictionary\n            for j in range(left, left + side_length):\n                heights[j] = height\n            \n            # Add the max height to the answer\n            ans.append(max_height)\n            \n        return ans"
        },
        {
            "task_id": "falling-squares",
            "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize variables\n        max_height = 0\n        heights = {}\n        ans = []\n        \n        # Loop through each position\n        for i in range(len(positions)):\n            \n            # Get the left and side length of the current position\n            left, side_length = positions[i]\n            \n            # Get the right side of the current position\n            right = left + side_length - 1\n            \n            # Get the height of the current position\n            height = 0\n            \n            # Loop through each position in the heights dictionary\n            for j in range(left, right + 1):\n                \n                # If the current position is in the heights dictionary\n                if j in heights:\n                    \n                    # Get the height of the current position\n                    height = max(height, heights[j])\n            \n            # Set the height of the current position\n            heights[left] = height + side_length\n            \n            # Get the maximum height\n            max_height = max(max_height, heights[left])\n            \n            # Add the maximum height to the answer\n            ans.append(max_height)\n            \n        # Return the answer\n        return ans"
        },
        {
            "task_id": "falling-squares",
            "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize variables\n        max_height = 0\n        heights = {}\n        ans = []\n        \n        # Loop through each position\n        for i in range(len(positions)):\n            \n            # Get the left and side length of the current position\n            left, side_length = positions[i]\n            \n            # Get the right side of the current position\n            right = left + side_length - 1\n            \n            # Get the height of the current position\n            height = 0\n            \n            # Loop through each height\n            for j in range(left, right + 1):\n                \n                # Get the height of the current position\n                height = max(height, heights.get(j, 0))\n            \n            # Get the new height of the current position\n            new_height = height + side_length\n            \n            # Update the heights of the current position\n            for j in range(left, right + 1):\n                heights[j] = new_height\n            \n            # Update the max height\n            max_height = max(max_height, new_height)\n            \n            # Add the max height to the answer\n            ans.append(max_height)\n        \n        return ans"
        }
    ],
    "sum-of-left-leaves": [
        {
            "task_id": "sum-of-left-leaves",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"
        },
        {
            "task_id": "sum-of-left-leaves",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"
        },
        {
            "task_id": "sum-of-left-leaves",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is not None:\n            if root.left.left is None and root.left.right is None:\n                return root.left.val + self.sumOfLeftLeaves(root.right)\n            else:\n                return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)\n        else:\n            return self.sumOfLeftLeaves(root.right)"
        },
        {
            "task_id": "sum-of-left-leaves",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"
        },
        {
            "task_id": "sum-of-left-leaves",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"
        }
    ],
    "max-sum-of-rectangle-no-larger-than-k": [
        {
            "task_id": "max-sum-of-rectangle-no-larger-than-k",
            "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = -float('inf')\n        \n        for i in range(m):\n            for j in range(i,m):\n                s = [0]*n\n                for l in range(i,j+1):\n                    for c in range(n):\n                        s[c] += matrix[l][c]\n                \n                max_sum = max(max_sum, self.maxSubArray(s, k))\n                \n        return max_sum\n    \n    def maxSubArray(self, nums, k):\n        max_sum = -float('inf')\n        curr_sum = 0\n        for i in range(len(nums)):\n            curr_sum += nums[i]\n            if curr_sum > k:\n                max_sum = max(max_sum, curr_sum - nums[i])\n                curr_sum = 0\n            elif curr_sum == k:\n                return k\n            max_sum = max(max_sum, curr_sum)\n        return max_sum"
        },
        {
            "task_id": "max-sum-of-rectangle-no-larger-than-k",
            "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = -float('inf')\n        \n        for i in range(m):\n            for j in range(i,m):\n                s = [0]*n\n                for l in range(i,j+1):\n                    for c in range(n):\n                        s[c] += matrix[l][c]\n                \n                max_sum = max(max_sum, self.maxSubarray(s,k))\n                \n        return max_sum\n    \n    def maxSubarray(self, nums, k):\n        max_sum = -float('inf')\n        curr_sum = 0\n        d = {}\n        for i in range(len(nums)):\n            curr_sum += nums[i]\n            if curr_sum == k:\n                return k\n            elif curr_sum < k:\n                max_sum = max(max_sum, curr_sum)\n            else:\n                for j in range(i):\n                    if curr_sum - nums[j] == k:\n                        return k\n                    elif curr_sum - nums[j] < k:\n                        max_sum = max(max_sum, curr_sum - nums[j])\n                    else:\n                        d[j] = curr_sum - nums[j]\n                        break\n        return max_sum"
        },
        {
            "task_id": "max-sum-of-rectangle-no-larger-than-k",
            "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maximum sum to be 0\n        max_sum = 0\n        \n        # Loop through each row of the matrix\n        for i in range(len(matrix)):\n            \n            # Initialize a list to store the prefix sum for each row\n            prefix_sum = [0] * len(matrix[i])\n            \n            # Loop through each column of the matrix\n            for j in range(i, len(matrix)):\n                \n                # Calculate the prefix sum for each row\n                for l in range(len(matrix[j])):\n                    prefix_sum[l] += matrix[j][l]\n                \n                # Initialize two pointers for binary search\n                left, right = 0, len(prefix_sum) - 1\n                \n                # Loop through each prefix sum\n                for m in range(len(prefix_sum)):\n                    \n                    # Check if the current prefix sum - k is less than or equal to 0\n                    if prefix_sum[m] - k <= 0:\n                        \n                        # Update the left pointer\n                        left = m\n                        \n                    # Check if the current prefix sum is greater than k\n                    elif prefix_sum[m] > k:\n                        \n                        # Update the right pointer\n                        right = m - 1\n                        break\n                    \n                    # Check if the maximum sum is less than the current sum\n                    if max_sum < prefix_sum[m]:\n                        \n                        # Update the maximum sum\n                        max_sum = prefix_sum[m]\n                \n        return max_sum"
        },
        {
            "task_id": "max-sum-of-rectangle-no-larger-than-k",
            "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maximum sum to be 0\n        max_sum = 0\n        \n        # Loop through each row of the matrix\n        for i in range(len(matrix)):\n            \n            # Initialize a list to store the prefix sum\n            prefix_sum = [0] * len(matrix[i])\n            \n            # Loop through each column of the matrix\n            for j in range(i, len(matrix)):\n                \n                # Calculate the prefix sum\n                for l in range(len(matrix[j])):\n                    prefix_sum[l] += matrix[j][l]\n                \n                # Initialize two pointers for binary search\n                left, right = 0, len(prefix_sum) - 1\n                \n                # Loop through each prefix sum\n                for m in range(len(prefix_sum)):\n                    \n                    # Check if the prefix sum is less than k\n                    if prefix_sum[m] <= k:\n                        \n                        # Binary search to find the largest rectangle\n                        while left < right:\n                            if prefix_sum[right] - prefix_sum[m] > k:\n                                right -= 1\n                            else:\n                                break\n                        \n                        # Update the maximum sum\n                        max_sum = max(max_sum, prefix_sum[right] - prefix_sum[m])\n                    \n                    # If the prefix sum is greater than k\n                    else:\n                        \n                        # Binary search to find the smallest rectangle\n                        while left < right:\n                            if prefix_sum[left + 1] - prefix_sum[m] <= k:\n                                left += 1\n                            else:\n                                break\n                        \n                        # Update the maximum sum\n                        max_sum = max(max_sum, prefix_sum[left] - prefix_sum[m])\n                \n        return max_sum"
        },
        {
            "task_id": "max-sum-of-rectangle-no-larger-than-k",
            "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = -float('inf')\n        \n        for i in range(m):\n            for j in range(i,m):\n                s = [0]*n\n                for l in range(i,j+1):\n                    for c in range(n):\n                        s[c] += matrix[l][c]\n                \n                max_sum = max(max_sum, self.maxSubarray(s,k))\n                \n        return max_sum\n    \n    def maxSubarray(self, nums, k):\n        max_sum = -float('inf')\n        curr_sum = 0\n        d = {}\n        for i in range(len(nums)):\n            curr_sum += nums[i]\n            if curr_sum == k:\n                return k\n            elif curr_sum < k:\n                max_sum = max(max_sum, curr_sum)\n            else:\n                for j in range(i):\n                    if curr_sum - nums[j] == k:\n                        return k\n                    elif curr_sum - nums[j] < k:\n                        max_sum = max(max_sum, curr_sum - nums[j])\n                    else:\n                        d[j] = curr_sum - nums[j]\n                        break\n        return max_sum"
        }
    ],
    "divide-two-integers": [
        {
            "task_id": "divide-two-integers",
            "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if divisor == -1:\n            return -dividend\n        \n        sign = 1\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0):\n            sign = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        quotient = 0\n        while dividend >= divisor:\n            temp = divisor\n            i = 0\n            while dividend >= temp:\n                dividend -= temp\n                quotient += 2**i\n                i += 1\n                temp <<= 1\n                \n        if sign == -1:\n            quotient = -quotient\n        \n        if quotient >= 2**31 - 1:\n            return 2**31 - 1\n        if quotient <= -2**31:\n            return -2**31\n        \n        return quotient"
        },
        {
            "task_id": "divide-two-integers",
            "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if divisor == -1:\n            return -dividend\n        \n        sign = 1\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0):\n            sign = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        quotient = 0\n        while dividend >= divisor:\n            temp = divisor\n            i = 0\n            while temp << i <= dividend:\n                i += 1\n            quotient += 2**(i-1)\n            dividend -= temp << (i-1)\n        \n        if sign == -1:\n            quotient = -quotient\n        \n        if quotient >= 2**31 - 1:\n            return 2**31 - 1\n        if quotient <= -2**31:\n            return -2**31\n        \n        return quotient"
        },
        {
            "task_id": "divide-two-integers",
            "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if divisor == -1:\n            return -dividend\n        \n        sign = 1\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0):\n            sign = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        quotient = 0\n        while dividend >= divisor:\n            temp = divisor\n            i = 1\n            while temp << 1 < dividend:\n                temp <<= 1\n                i <<= 1\n            dividend -= temp\n            quotient += i\n        \n        if sign == -1:\n            quotient = -quotient\n        \n        if quotient >= 2**31 - 1:\n            return 2**31 - 1\n        if quotient <= -2**31:\n            return -2**31\n        \n        return quotient"
        },
        {
            "task_id": "divide-two-integers",
            "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if divisor == 1:\n            return dividend\n        \n        if divisor == -1:\n            return -dividend\n        \n        if dividend == divisor:\n            return 1\n        \n        if dividend == -divisor:\n            return -1\n        \n        if abs(dividend) < abs(divisor):\n            return 0\n        \n        sign = 1\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\n            sign = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        quotient = 0\n        while dividend >= divisor:\n            dividend -= divisor\n            quotient += 1\n        \n        return quotient * sign"
        },
        {
            "task_id": "divide-two-integers",
            "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if divisor == -1:\n            return -dividend\n        \n        sign = 1\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0):\n            sign = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        quotient = 0\n        while dividend >= divisor:\n            temp = divisor\n            i = 0\n            while dividend >= temp:\n                dividend -= temp\n                quotient += 2**i\n                i += 1\n                temp <<= 1\n                \n        if sign == -1:\n            quotient = -quotient\n        \n        if quotient >= 2**31 - 1:\n            return 2**31 - 1\n        if quotient <= -2**31:\n            return -2**31\n        \n        return quotient"
        }
    ],
    "surrounded-regions": [
        {
            "task_id": "surrounded-regions",
            "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m = len(board)\n        n = len(board[0])\n        \n        def dfs(i, j):\n            if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':\n                board[i][j] = 'A'\n                dfs(i+1, j)\n                dfs(i-1, j)\n                dfs(i, j+1)\n                dfs(i, j-1)\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    dfs(i, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'"
        },
        {
            "task_id": "surrounded-regions",
            "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        rows = len(board)\n        cols = len(board[0])\n        \n        def dfs(r, c):\n            if 0 <= r < rows and 0 <= c < cols and board[r][c] == 'O':\n                board[r][c] = 'A'\n                dfs(r-1, c)\n                dfs(r+1, c)\n                dfs(r, c-1)\n                dfs(r, c+1)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if i == 0 or i == rows-1 or j == 0 or j == cols-1:\n                    dfs(i, j)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'"
        },
        {
            "task_id": "surrounded-regions",
            "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        rows = len(board)\n        cols = len(board[0])\n        \n        def dfs(r, c):\n            if 0 <= r < rows and 0 <= c < cols and board[r][c] == 'O':\n                board[r][c] = 'A'\n                dfs(r-1, c)\n                dfs(r+1, c)\n                dfs(r, c-1)\n                dfs(r, c+1)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if i == 0 or i == rows-1 or j == 0 or j == cols-1:\n                    dfs(i, j)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'"
        },
        {
            "task_id": "surrounded-regions",
            "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        rows = len(board)\n        cols = len(board[0])\n        \n        def dfs(r, c):\n            if 0 <= r < rows and 0 <= c < cols and board[r][c] == 'O':\n                board[r][c] = 'A'\n                dfs(r-1, c)\n                dfs(r+1, c)\n                dfs(r, c-1)\n                dfs(r, c+1)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if i == 0 or i == rows-1 or j == 0 or j == cols-1:\n                    dfs(i, j)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'"
        },
        {
            "task_id": "surrounded-regions",
            "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        rows = len(board)\n        cols = len(board[0])\n        \n        def dfs(r, c):\n            if 0 <= r < rows and 0 <= c < cols and board[r][c] == 'O':\n                board[r][c] = 'A'\n                dfs(r-1, c)\n                dfs(r+1, c)\n                dfs(r, c-1)\n                dfs(r, c+1)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if i == 0 or i == rows-1 or j == 0 or j == cols-1:\n                    dfs(i, j)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'"
        }
    ],
    "two-sum": [
        {
            "task_id": "two-sum",
            "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i]+nums[j]==target:\n                    return [i,j]"
        },
        {
            "task_id": "two-sum",
            "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i]+nums[j]==target:\n                    return [i,j]"
        },
        {
            "task_id": "two-sum",
            "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i]+nums[j]==target:\n                    return [i,j]"
        },
        {
            "task_id": "two-sum",
            "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i]+nums[j]==target:\n                    return [i,j]"
        },
        {
            "task_id": "two-sum",
            "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i]+nums[j]==target:\n                    return [i,j]"
        }
    ],
    "24-game": [
        {
            "task_id": "24-game",
            "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def solve(cards):\n            if not cards:\n                return False\n            if len(cards) == 1:\n                return abs(cards[0] - 24.0) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(i+1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    rest = cards[:i] + cards[i+1:j] + cards[j+1:]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '/':\n                            if b == 0:\n                                continue\n                            if solve(rest + [a / b]):\n                                return True\n                        else:\n                            if solve(rest + [a + b, a - b, a * b]):\n                                return True\n            return False\n        \n        return solve(cards)"
        },
        {
            "task_id": "24-game",
            "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def solve(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i+1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    rest = cards[:i] + cards[i+1:j] + cards[j+1:]\n                    if solve(rest + [a+b, a-b, a*b, b-a, a/b, b/a]):\n                        return True\n            return False\n        return solve(cards)"
        },
        {
            "task_id": "24-game",
            "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def solve(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i+1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    rest = cards[:i] + cards[i+1:j] + cards[j+1:]\n                    if solve(rest + [a+b, a-b, a*b, b-a, a/b, b/a]):\n                        return True\n            return False\n        return solve(cards)"
        },
        {
            "task_id": "24-game",
            "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def solve(cards):\n            if not cards:\n                return False\n            if len(cards) == 1:\n                return abs(cards[0] - 24.0) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(i+1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    rest = cards[:i] + cards[i+1:j] + cards[j+1:]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '/':\n                            if b == 0:\n                                continue\n                            if solve(rest + [a / b]):\n                                return True\n                        else:\n                            if solve(rest + [a + b, a - b, a * b]):\n                                return True\n            return False\n        \n        return solve(cards)"
        },
        {
            "task_id": "24-game",
            "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def solve(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i+1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    rest = cards[:i] + cards[i+1:j] + cards[j+1:]\n                    if solve(rest + [a+b, a-b, a*b, b-a, a/b, b/a]):\n                        return True\n            return False\n        return solve(cards)"
        }
    ],
    "wildcard-matching": [
        {
            "task_id": "wildcard-matching",
            "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if pattern is empty, return False\n        if p == '':\n            return False\n        \n        # if pattern is '*', return True\n        if p == '*':\n            return True\n        \n        # if pattern is '?' and string is not empty, return True\n        if p == '?' and s != '':\n            return True\n        \n        # if pattern is '?' and string is empty, return False\n        if p == '?' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*'"
        },
        {
            "task_id": "wildcard-matching",
            "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # If pattern is empty then return False if string is not empty\n        if p == \"\":\n            return s == \"\"\n        \n        # If pattern is not empty and string is empty then return False\n        if s == \"\":\n            return False\n        \n        # If last character of pattern is '*' then remove it\n        if p[-1] == \"*\":\n            p = p[:-1]\n        \n        # If last character of string is not '*' then remove it\n        if s[-1] != \"*\":\n            s = s[:-1]\n        \n        # If last character of pattern is '?' or last character of both pattern and string are same then remove last character from both\n        if p[-1] == \"?\" or p[-1] == s[-1]:\n            p = p[:-1]\n            s = s[:-1]\n        \n        # If last character of pattern is '*' then True\n        if p[-1] == \"*\":\n            return True\n        \n        # If last character of both pattern and string are same then True\n        if p[-1] == s[-1]:\n            return True\n        \n        # If last character of pattern is not same as string then False\n        else:\n            return False"
        },
        {
            "task_id": "wildcard-matching",
            "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if pattern is empty, return False\n        if p == '':\n            return False\n        \n        # if pattern is '*', return True\n        if p == '*':\n            return True\n        \n        # if pattern is '?' and string is not empty, return True\n        if p == '?' and s != '':\n            return True\n        \n        # if pattern is '?' and string is empty, return False\n        if p == '?' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*'"
        },
        {
            "task_id": "wildcard-matching",
            "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if pattern is empty, return False\n        if p == '':\n            return False\n        \n        # if pattern is '*', return True\n        if p == '*':\n            return True\n        \n        # if pattern is '?' and string is not empty, return True\n        if p == '?' and s != '':\n            return True\n        \n        # if pattern is '?' and string is empty, return False\n        if p == '?' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*' and string is not empty, return True\n        if p == '*' and s != '':\n            return True\n        \n        # if pattern is not '*' and string is empty, return False\n        if p != '*' and s == '':\n            return False\n        \n        # if pattern is '*' and string is empty, return False\n        if p == '*' and s == '':\n            return False\n        \n        # if pattern is not '*' and string is not empty, return True\n        if p != '*' and s != '':\n            return True\n        \n        # if pattern is '*'"
        },
        {
            "task_id": "wildcard-matching",
            "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # If pattern is empty then return False if string is not empty\n        if p == \"\":\n            return s == \"\"\n        \n        # If pattern is not empty and string is empty then return False\n        if s == \"\":\n            return False\n        \n        # If last character of pattern is '*' then remove it\n        if p[-1] == \"*\":\n            p = p[:-1]\n        \n        # If last character of string is not '*' then remove it\n        if s[-1] != \"*\":\n            s = s[:-1]\n        \n        # If last character of pattern is '?' or last character of both pattern and string are same then remove last character from both\n        if p[-1] == \"?\" or p[-1] == s[-1]:\n            p = p[:-1]\n            s = s[:-1]\n        \n        # If pattern is empty then return True\n        if p == \"\":\n            return True\n        \n        # If string is empty then return False\n        if s == \"\":\n            return False\n        \n        # If last character of pattern is '*' then True\n        if p[-1] == \"*\":\n            return True\n        \n        # If last character of string is not '*' then return False\n        if s[-1] != \"*\":\n            return False\n        \n        # If last character of both pattern and string are same then return True\n        if p[-1] == s[-1]:\n            return True\n        \n        # If last character of pattern is '?' then return True\n        if p[-1] == \"?\":\n            return True\n        \n        # Else return False\n        return False"
        }
    ],
    "majority-element": [
        {
            "task_id": "majority-element",
            "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store count of each element\n        count = {}\n        \n        # Loop through the array\n        for i in nums:\n            if i in count:\n                count[i] += 1\n            else:\n                count[i] = 1\n        \n        # Return the element with max count\n        max_count = max(count.values())\n        for key, value in count.items():\n            if value == max_count:\n                return key"
        },
        {
            "task_id": "majority-element",
            "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store the count of each element\n        count = {}\n        \n        # Loop through the array\n        for i in nums:\n            if i in count:\n                count[i] += 1\n            else:\n                count[i] = 1\n        \n        # Return the element with the highest count\n        return max(count, key=count.get)"
        },
        {
            "task_id": "majority-element",
            "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store the count of each element\n        count = {}\n        \n        # Loop through the array\n        for i in nums:\n            if i in count:\n                count[i] += 1\n            else:\n                count[i] = 1\n        \n        # Find the element with the highest count\n        max_count = max(count.values())\n        \n        # Return the element with the highest count\n        for key, value in count.items():\n            if value == max_count:\n                return key"
        },
        {
            "task_id": "majority-element",
            "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store count of each element\n        count = {}\n        \n        # Loop through the array\n        for i in nums:\n            \n            # If the element is not in the dictionary add it\n            if i not in count:\n                count[i] = 1\n            \n            # If the element is in the dictionary increment its count\n            else:\n                count[i] += 1\n                \n        # Return the element with the highest count\n        return max(count, key=count.get)"
        },
        {
            "task_id": "majority-element",
            "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store the count of each element\n        count = {}\n        \n        # Loop through the array\n        for i in nums:\n            \n            # If the element is not in the dictionary add it\n            if i not in count:\n                count[i] = 1\n            \n            # If the element is in the dictionary increment its count\n            else:\n                count[i] += 1\n                \n        # Return the element with the highest count\n        return max(count, key=count.get)"
        }
    ],
    "reconstruct-itinerary": [
        {
            "task_id": "reconstruct-itinerary",
            "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Create a dictionary to store the itinerary\n        itinerary = {}\n        \n        # Create a dictionary to store the lexical order\n        lexical_order = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets = {}\n        \n        # Create a list to store the final itinerary\n        final_itinerary = []\n        \n        # Create a list to store the final lexical order\n        final_lexical_order = []\n        \n        # Create a list to store the final number of tickets\n        final_number_of_tickets = []\n        \n        # Create a list to store the final itinerary\n        final_itinerary = []\n        \n        # Create a list to store the final lexical order\n        final_lexical_order = []\n        \n        # Create a list to store the final number of tickets\n        final_number_of_tickets = []\n        \n        # Sort the tickets in the order of the lexical order\n        tickets.sort(key = lambda x: x[0])\n        \n        # Sort the tickets in the order of the number of tickets\n        tickets.sort(key = lambda x: x[1])\n        \n        # Loop through the tickets\n        for ticket in tickets:\n            \n            # If the departure airport is not in the dictionary\n            if ticket[0] not in itinerary:\n                \n                # Add the departure airport to the dictionary\n                itinerary[ticket[0]] = [ticket[1]]\n                \n                # Add the lexical order to the dictionary\n                lexical_order[ticket[0]] = ticket[0]\n                \n                # Add the number of tickets to the dictionary\n                number_of_tickets[ticket[0]] = 1\n                \n            # If the departure airport is in the dictionary\n            else:\n                \n                # Add the arrival airport to the list in the dictionary\n                itinerary[ticket[0]].append(ticket[1])\n                \n                # Add the lexical order to the dictionary\n                lexical_order[ticket[0]] = ticket[0]\n                \n                # Add the number of tickets to the dictionary\n                number_of_tickets[ticket[0]] += 1\n                \n        # Sort the itinerary in the order of the number of tickets\n        itinerary = {k: v for k, v in sorted(itinerary.items(), key=lambda item: item[1])}\n        \n        # Sort the lexical order in the order of the lexical order\n        lexical_order = {k: v for k, v in sorted(lexical_order.items(), key=lambda item: item[1])}\n        \n        # Sort the number of tickets in the order of the number of tickets\n        number_of_tickets = {k: v for k, v in sorted(number_of_tickets.items(), key=lambda item: item[1])}\n        \n        # Loop through the itinerary\n        for departure_airport in itinerary:\n            \n            # Add the departure airport to the final itinerary\n            final_itinerary.append(departure_airport)\n            \n            # Add the lexical order to the final lexical order\n            final_lexical_order.append(lexical_order[departure_airport])\n            \n            # Add the number of tickets to the final number of tickets\n            final_number_of_tickets.append(number_of_tickets[departure_airport])\n            \n        # Return the final itinerary\n        return final_itinerary"
        },
        {
            "task_id": "reconstruct-itinerary",
            "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Create a dictionary to store the itinerary\n        itinerary = {}\n        \n        # Create a dictionary to store the lexical order\n        lexical_order = {}\n        \n        # Create a dictionary to store the number of tickets\n        ticket_count = {}\n        \n        # Create a list to store the itinerary\n        itinerary_list = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final"
        },
        {
            "task_id": "reconstruct-itinerary",
            "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Create a dictionary to store the itinerary\n        itinerary = {}\n        \n        # Create a dictionary to store the lexical order\n        lexical_order = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final"
        },
        {
            "task_id": "reconstruct-itinerary",
            "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Create a dictionary to store the itinerary\n        itinerary = {}\n        \n        # Create a dictionary to store the lexical order\n        lexical_order = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets = {}\n        \n        # Create a list to store the final itinerary\n        final_itinerary = []\n        \n        # Create a list to store the final lexical order\n        final_lexical_order = []\n        \n        # Create a list to store the final number of tickets\n        final_number_of_tickets = []\n        \n        # Create a list to store the final itinerary\n        final_itinerary = []\n        \n        # Create a list to store the final lexical order\n        final_lexical_order = []\n        \n        # Create a list to store the final number of tickets\n        final_number_of_tickets = []\n        \n        # Sort the list of tickets\n        tickets.sort()\n        \n        # Loop through the list of tickets\n        for ticket in tickets:\n            \n            # If the departure airport is not in the dictionary\n            if ticket[0] not in itinerary:\n                \n                # Add the departure airport to the dictionary\n                itinerary[ticket[0]] = [ticket[1]]\n                \n                # Add the departure airport to the lexical order\n                lexical_order[ticket[0]] = ticket[1]\n                \n                # Add the departure airport to the number of tickets\n                number_of_tickets[ticket[0]] = 1\n                \n            # If the departure airport is in the dictionary\n            else:\n                \n                # Add the arrival airport to the list of the departure airport\n                itinerary[ticket[0]].append(ticket[1])\n                \n                # Add the arrival airport to the lexical order\n                lexical_order[ticket[0]] += ticket[1]\n                \n                # Increase the number of tickets\n                number_of_tickets[ticket[0]] += 1\n                \n        # Sort the list of tickets\n        tickets.sort(key = lambda x: x[0])\n        \n        # Loop through the list of tickets\n        for ticket in tickets:\n            \n            # If the departure airport is not in the dictionary\n            if ticket[0] not in itinerary:\n                \n                # Add the departure airport to the dictionary\n                itinerary[ticket[0]] = [ticket[1]]\n                \n                # Add the departure airport to the lexical order\n                lexical_order[ticket[0]] = ticket[1]\n                \n                # Add the departure airport to the number of tickets\n                number_of_tickets[ticket[0]] = 1\n                \n            # If the departure airport is in the dictionary\n            else:\n                \n                # Add the arrival airport to the list of the departure airport\n                itinerary[ticket[0]].append(ticket[1])\n                \n                # Add the arrival airport to the lexical order\n                lexical_order[ticket[0]] += ticket[1]\n                \n                # Increase the number of tickets\n                number_of_tickets[ticket[0]] += 1\n                \n        # Sort the list of tickets\n        tickets.sort(key = lambda x: x[1])\n        \n        # Loop through the list of tickets\n        for ticket in tickets:\n            \n            # If the arrival airport is not in the dictionary\n            if ticket[1] not in itinerary:\n                \n                # Add the arrival airport to the dictionary\n                itinerary[ticket[1]] = [ticket[0]]\n                \n                # Add the arrival airport to the lexical order\n                lexical_order[ticket[1]] = ticket[0]\n                \n                # Add the arrival airport to the number of tickets\n                number_of_tickets[ticket[1]] = 1\n                \n            # If the arrival airport is in the dictionary\n            else:\n                \n                # Add the departure airport to the list of the arrival airport\n                itinerary[ticket[1]].append(ticket[0])\n                \n                # Add the departure airport to the"
        },
        {
            "task_id": "reconstruct-itinerary",
            "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Create a dictionary to store the itinerary\n        itinerary = {}\n        \n        # Create a dictionary to store the lexical order\n        lexical_order = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final_final_final_final_final_final = {}\n        \n        # Create a dictionary to store the number of tickets\n        number_of_tickets_used_lexical_order_itinerary_final_final_final_final_final_final_final_final_final_final"
        }
    ],
    "4sum": [
        {
            "task_id": "4sum",
            "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j>i+1 and nums[j] == nums[j-1]:\n                    continue\n                low = j+1\n                high = len(nums)-1\n                while low < high:\n                    if nums[i] + nums[j] + nums[low] + nums[high] == target:\n                        res.append([nums[i], nums[j], nums[low], nums[high]])\n                        low += 1\n                        high -= 1\n                        while low < high and nums[low] == nums[low-1]:\n                            low += 1\n                        while low < high and nums[high] == nums[high+1]:\n                            high -= 1\n                    elif nums[i] + nums[j] + nums[low] + nums[high] > target:\n                        high -= 1\n                    else:\n                        low += 1\n        return res"
        },
        {
            "task_id": "4sum",
            "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j>i+1 and nums[j] == nums[j-1]:\n                    continue\n                low = j+1\n                high = len(nums)-1\n                while low < high:\n                    if nums[i] + nums[j] + nums[low] + nums[high] == target:\n                        res.append([nums[i], nums[j], nums[low], nums[high]])\n                        low += 1\n                        high -= 1\n                        while low < high and nums[low] == nums[low-1]:\n                            low += 1\n                        while low < high and nums[high] == nums[high+1]:\n                            high -= 1\n                    elif nums[i] + nums[j] + nums[low] + nums[high] > target:\n                        high -= 1\n                    else:\n                        low += 1\n        return res"
        },
        {
            "task_id": "4sum",
            "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j>i+1 and nums[j] == nums[j-1]:\n                    continue\n                low = j+1\n                high = len(nums)-1\n                while low < high:\n                    curr_sum = nums[i] + nums[j] + nums[low] + nums[high]\n                    if curr_sum == target:\n                        res.append([nums[i], nums[j], nums[low], nums[high]])\n                        low += 1\n                        high -= 1\n                        while low < high and nums[low] == nums[low-1]:\n                            low += 1\n                        while low < high and nums[high] == nums[high+1]:\n                            high -= 1\n                    elif curr_sum < target:\n                        low += 1\n                    else:\n                        high -= 1\n        return res"
        },
        {
            "task_id": "4sum",
            "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j>i+1 and nums[j] == nums[j-1]:\n                    continue\n                low = j+1\n                high = len(nums)-1\n                while low < high:\n                    if nums[i] + nums[j] + nums[low] + nums[high] == target:\n                        res.append([nums[i], nums[j], nums[low], nums[high]])\n                        low += 1\n                        high -= 1\n                        while low < high and nums[low] == nums[low-1]:\n                            low += 1\n                        while low < high and nums[high] == nums[high+1]:\n                            high -= 1\n                    elif nums[i] + nums[j] + nums[low] + nums[high] > target:\n                        high -= 1\n                    else:\n                        low += 1\n        return res"
        },
        {
            "task_id": "4sum",
            "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Initialize variables to keep track of each quadruplet\n        i = 0\n        j = 0\n        k = 0\n        l = 0\n        \n        # List to store the quadruplets\n        quadruplets = []\n        \n        # Loop through the list\n        for i in range(0, len(nums)-3):\n            j = i+1\n            while j < len(nums)-2:\n                k = j+1\n                while k < len(nums)-1:\n                    l = k+1\n                    while l < len(nums):\n                        if nums[i] + nums[j] + nums[k] + nums[l] == target:\n                            quadruplets.append([nums[i], nums[j], nums[k], nums[l]])\n                            l += 1\n                        else:\n                            l += 1\n                    k += 1\n                j += 1\n            i += 1\n        \n        return quadruplets"
        }
    ],
    "the-skyline-problem": [
        {
            "task_id": "the-skyline-problem",
            "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. Sort the buildings by their right endpoint,\n        #    and sort the buildings with the same right endpoint by their height.\n        # 2. Use a heap to store the current buildings in the skyline.\n        #    If a building has a height that is currently in the heap,\n        #    we remove the height and add the new height.\n        # 3. Iterate through the buildings, maintain a variable prev\n        #    to store the previous height in the skyline.\n        #    If the current height is different from prev, we add the point\n        #    to the skyline.\n        # 4. The skyline is a list of points, and we need to make sure\n        #    that there are no consecutive horizontal lines of equal height.\n        #    To ensure this, whenever we add a point to the skyline,\n        #    we need to remove the previous point if they have the same x-coordinate.\n        \n        # Sort by right endpoint, then by height.\n        buildings.sort(key=lambda x: (x[1], x[2]))\n        \n        # Use a heap to store the current buildings in the skyline.\n        heap = []\n        res = []\n        prev = 0\n        \n        for building in buildings:\n            # If a building has a height that is currently in the heap,\n            # we remove the height and add the new height.\n            while heap and building[0] > heap[0][0]:\n                heapq.heappop(heap)\n            heapq.heappush(heap, (building[1], building[2]))\n            \n            # The height of the current building.\n            curr = heap[0][1] if heap else 0\n            \n            # If the current height is different from prev,\n            # we add the point to the skyline.\n            if curr != prev:\n                res.append([building[0], curr])\n                prev = curr\n        \n        # Maintain a variable prev to store the previous height in the skyline.\n        # If the current height is different from prev,\n        # we add the point to the skyline.\n        return res"
        },
        {
            "task_id": "the-skyline-problem",
            "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. Sort the buildings by their right endpoint,\n        #    and sort the buildings with the same right endpoint by their height.\n        # 2. Use a heap to store the current buildings in the skyline.\n        #    If a building has a height that is currently in the heap,\n        #    we remove the height and add the new height.\n        # 3. Iterate through the buildings, maintain a variable prev\n        #    to store the previous height in the skyline.\n        #    If the current height is different from prev, we add the point\n        #    to the skyline.\n        # 4. The skyline is then constructed by merging the heights and the x-coordinates.\n        \n        # Sort by (right, -height)\n        buildings.sort(key=lambda x: (x[1], -x[2]))\n        res = []\n        hp = []\n        prev = 0\n        for l, r, h in buildings:\n            while hp and hp[0] <= l:\n                heapq.heappop(hp)\n            if hp and -hp[0] != prev:\n                res.append([l, -hp[0]])\n                prev = -hp[0]\n            heapq.heappush(hp, -h)\n        while hp:\n            if -hp[0] != prev:\n                res.append([r, -hp[0]])\n            prev = -hp[0]\n            heapq.heappop(hp)\n        return res"
        },
        {
            "task_id": "the-skyline-problem",
            "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the buildings by their right endpoint,\n        # and sort the height in descending order.\n        buildings.sort(key=lambda x: (x[1], -x[2]))\n        \n        # Use a heap to store the height of buildings.\n        heap = []\n        res = []\n        prev_height = 0\n        \n        for building in buildings:\n            # If there is a higher building ahead,\n            # then we can pop it out.\n            while heap and heap[0][0] <= building[0]:\n                heap.pop(0)\n            \n            # Add the current building into heap.\n            heapq.heappush(heap, (building[1], building[2]))\n            \n            # Get the highest height.\n            height = heap[0][1] if heap else 0\n            \n            # If the height is different from the previous height,\n            # we add it to the result.\n            if height != prev_height:\n                res.append([building[0], height])\n                prev_height = height\n        \n        return res"
        },
        {
            "task_id": "the-skyline-problem",
            "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. Sort the buildings by their right endpoint,\n        #    and sort the buildings with the same right endpoint by their height.\n        # 2. Use a heap to store the current buildings in the skyline.\n        #    If a building has a height that is currently in the heap,\n        #    we remove the height and add the new height.\n        # 3. Iterate through the buildings, maintain a variable prev\n        #    to store the previous height in the skyline.\n        #    If the current height is different from prev, we add the point\n        #    to the skyline.\n        # 4. The skyline is then constructed by merging the heights and the x-coordinates.\n        \n        # Sort by right endpoint, then by height.\n        buildings.sort(key=lambda x: (x[1], x[2]))\n        \n        res = []\n        heap = [(0, float('inf'))]\n        prev = 0\n        \n        for building in buildings:\n            while heap[0][1] <= building[0]:\n                heapq.heappop(heap)\n            if heap[0][0] != building[2]:\n                res.append([building[0], building[2]])\n                prev = building[2]\n            heapq.heappush(heap, (building[2], building[1]))\n        \n        return res"
        },
        {
            "task_id": "the-skyline-problem",
            "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. Sort the buildings by their right endpoint,\n        #    and sort the height in descending order.\n        # 2. Use a heap to store the height of the buildings.\n        # 3. Iterate over the buildings and update the height.\n        # 4. If the height is changed, add the point to the result.\n        \n        res = []\n        heights = []\n        n = len(buildings)\n        if n == 0:\n            return res\n        \n        for b in buildings:\n            heights.append((-b[1], b[2]))\n        \n        heights.sort()\n        heapq.heapify(heights)\n        \n        prev_height = 0\n        boundary = -heights[0][0]\n        res.append([boundary, 0])\n        \n        while heights:\n            height = -heapq.heappop(heights)[1]\n            if height != prev_height:\n                res.append([boundary, height])\n                prev_height = height\n            if heights:\n                boundary = -heights[0][0]\n                res.append([boundary, 0])\n        \n        return res"
        }
    ],
    "reverse-string": [
        {
            "task_id": "reverse-string",
            "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()"
        },
        {
            "task_id": "reverse-string",
            "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # Two pointer approach\n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1"
        },
        {
            "task_id": "reverse-string",
            "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"
        },
        {
            "task_id": "reverse-string",
            "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # Two pointer approach\n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1"
        },
        {
            "task_id": "reverse-string",
            "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()"
        }
    ],
    "reverse-linked-list": [
        {
            "task_id": "reverse-linked-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        else:\n            current = head\n            previous = None\n            while current is not None:\n                next = current.next\n                current.next = previous\n                previous = current\n                current = next\n            return previous"
        },
        {
            "task_id": "reverse-linked-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        else:\n            current = head\n            previous = None\n            while current is not None:\n                next = current.next\n                current.next = previous\n                previous = current\n                current = next\n            return previous"
        },
        {
            "task_id": "reverse-linked-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        else:\n            current = head\n            previous = None\n            while current is not None:\n                next = current.next\n                current.next = previous\n                previous = current\n                current = next\n            return previous"
        },
        {
            "task_id": "reverse-linked-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        else:\n            current = head\n            previous = None\n            while current is not None:\n                next = current.next\n                current.next = previous\n                previous = current\n                current = next\n            return previous"
        },
        {
            "task_id": "reverse-linked-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        else:\n            current = head\n            previous = None\n            while current is not None:\n                next = current.next\n                current.next = previous\n                previous = current\n                current = next\n            return previous"
        }
    ],
    "triangle": [
        {
            "task_id": "triangle",
            "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array with the first row\n        dp = triangle[0]\n        \n        # Loop through the rest of the rows\n        for row in triangle[1:]:\n            # Initialize the new row\n            new_row = [0] * len(row)\n            \n            # Loop through the current row\n            for i in range(len(row)):\n                # Calculate the minimum path sum\n                new_row[i] = min(dp[i], dp[i-1]) + row[i]\n                \n            # Update the dp array\n            dp = new_row\n            \n        # Return the minimum path sum\n        return min(dp)"
        },
        {
            "task_id": "triangle",
            "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array with the first row\n        dp = triangle[0]\n        \n        # Loop through the rest of the rows\n        for row in triangle[1:]:\n            # Initialize the new row\n            new_row = [0] * len(row)\n            \n            # Loop through the current row\n            for i in range(len(row)):\n                # Calculate the minimum path sum\n                new_row[i] = min(dp[i], dp[i-1]) + row[i]\n                \n            # Update the dp array\n            dp = new_row\n            \n        # Return the minimum path sum\n        return min(dp)"
        },
        {
            "task_id": "triangle",
            "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array with the first row\n        dp = triangle[0]\n        \n        # Loop through the rest of the rows\n        for row in triangle[1:]:\n            # Initialize the new row\n            new_row = [0] * len(row)\n            \n            # Loop through the current row\n            for i in range(len(row)):\n                # Calculate the minimum path sum\n                new_row[i] = min(dp[i], dp[i-1]) + row[i]\n                \n            # Update the dp array\n            dp = new_row\n            \n        # Return the minimum path sum\n        return min(dp)"
        },
        {
            "task_id": "triangle",
            "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array with the first row\n        dp = triangle[0]\n        \n        # Loop through the rest of the rows\n        for row in triangle[1:]:\n            # Initialize the new row\n            new_row = [0] * len(row)\n            \n            # Loop through the current row\n            for i in range(len(row)):\n                # Calculate the minimum path sum\n                new_row[i] = min(dp[i], dp[i-1]) + row[i]\n                \n            # Update the dp array\n            dp = new_row\n            \n        # Return the minimum path sum\n        return min(dp)"
        },
        {
            "task_id": "triangle",
            "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array with the first row\n        dp = triangle[0]\n        \n        # Loop through the rest of the rows\n        for row in triangle[1:]:\n            \n            # Initialize the new row\n            new_row = [0] * len(row)\n            \n            # Loop through the current row\n            for i in range(len(row)):\n                \n                # Calculate the minimum path sum\n                new_row[i] = min(dp[i], dp[i-1]) + row[i]\n                \n            # Update the dp array\n            dp = new_row\n            \n        # Return the minimum path sum\n        return min(dp)"
        }
    ],
    "integer-to-english-words": [
        {
            "task_id": "integer-to-english-words",
            "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return small[num] + \" \"\n            elif num < 100:\n                return helper(num - num % 10) + small[num % 10] + \" \"\n            elif num < 1000:\n                return helper(num // 100) + \"Hundred \" + helper(num % 100)\n            elif num < 1000000:\n                return helper(num // 1000) + \"Thousand \" + helper(num % 1000)\n            elif num < 1000000000:\n                return helper(num // 1000000) + \"Million \" + helper(num % 1000000)\n            else:\n                return helper(num // 1000000000) + \"Billion \" + helper(num % 1000000000)\n        \n        small = [\"\", \"One \", \"Two \", \"Three \", \"Four \", \"Five \", \"Six \", \"Seven \", \"Eight \", \"Nine \", \"Ten \", \"Eleven \", \"Twelve \", \"Thirteen \", \"Fourteen \", \"Fifteen \", \"Sixteen \", \"Seventeen \", \"Eighteen \", \"Nineteen \"]\n        big = [\"\", \"\", \"Twenty \", \"Thirty \", \"Forty \", \"Fifty \", \"Sixty \", \"Seventy \", \"Eighty \", \"Ninety \"]\n        \n        return helper(num).strip()"
        },
        {
            "task_id": "integer-to-english-words",
            "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(n):\n            under_twenty = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            if n < 20:\n                return under_twenty[n]\n            elif n < 100:\n                return tens[n//10] + \" \" + helper(n%10)\n            elif n < 1000:\n                return helper(n//100) + \" Hundred \" + helper(n%100)\n            elif n < 1000000:\n                return helper(n//1000) + \" Thousand \" + helper(n%1000)\n            elif n < 1000000000:\n                return helper(n//1000000) + \" Million \" + helper(n%1000000)\n            else:\n                return helper(n//1000000000) + \" Billion \" + helper(n%1000000000)\n        \n        return helper(num).strip()"
        },
        {
            "task_id": "integer-to-english-words",
            "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(n):\n            under_twenty = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            if n < 20:\n                return under_twenty[n]\n            elif n < 100:\n                return tens[n//10] + \" \" + helper(n%10)\n            elif n < 1000:\n                return helper(n//100) + \" Hundred \" + helper(n%100)\n            elif n < 1000000:\n                return helper(n//1000) + \" Thousand \" + helper(n%1000)\n            elif n < 1000000000:\n                return helper(n//1000000) + \" Million \" + helper(n%1000000)\n            else:\n                return helper(n//1000000000) + \" Billion \" + helper(n%1000000000)\n        \n        return helper(num).strip()"
        },
        {
            "task_id": "integer-to-english-words",
            "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return numbers[num] + \" \"\n            elif num < 100:\n                return helper(num - num % 10) + numbers[num] + \" \"\n            elif num < 1000:\n                return helper(num // 100) + \"Hundred \" + helper(num % 100)\n            elif num < 1000000:\n                return helper(num // 1000) + \"Thousand \" + helper(num % 1000)\n            elif num < 1000000000:\n                return helper(num // 1000000) + \"Million \" + helper(num % 1000000)\n            else:\n                return helper(num // 1000000000) + \"Billion \" + helper(num % 1000000000)\n        \n        numbers = ['', 'One ', 'Two ', 'Three ', 'Four ', 'Five ', 'Six ', 'Seven ', 'Eight ', 'Nine ', 'Ten ', 'Eleven ', 'Twelve ', 'Thirteen ', 'Fourteen ', 'Fifteen ', 'Sixteen ', 'Seventeen ', 'Eighteen ', 'Nineteen ']\n        numbers2 = ['', '', 'Twenty ', 'Thirty ', 'Forty ', 'Fifty ', 'Sixty ', 'Seventy ', 'Eighty ', 'Ninety ']\n        \n        return helper(num).strip()"
        },
        {
            "task_id": "integer-to-english-words",
            "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return numbers[num] + \" \"\n            elif num < 100:\n                return helper(num - num%10) + numbers[num] + \" \"\n            elif num < 1000:\n                return helper(num//100) + \"Hundred \" + helper(num%100)\n            elif num < 1000000:\n                return helper(num//1000) + \"Thousand \" + helper(num%1000)\n            elif num < 1000000000:\n                return helper(num//1000000) + \"Million \" + helper(num%1000000)\n            else:\n                return helper(num//1000000000) + \"Billion \" + helper(num%1000000000)\n        \n        numbers = ['', 'One ', 'Two ', 'Three ', 'Four ', 'Five ', 'Six ', 'Seven ', 'Eight ', 'Nine ', 'Ten ', 'Eleven ', 'Twelve ', 'Thirteen ', 'Fourteen ', 'Fifteen ', 'Sixteen ', 'Seventeen ', 'Eighteen ', 'Nineteen ']\n        numbers2 = ['', '', 'Twenty ', 'Thirty ', 'Forty ', 'Fifty ', 'Sixty ', 'Seventy ', 'Eighty ', 'Ninety ']\n        \n        return helper(num).strip()"
        }
    ],
    "k-inverse-pairs-array": [
        {
            "task_id": "k-inverse-pairs-array",
            "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n                if i >= 2:\n                    dp[i][j] = (dp[i][j] - dp[i-2][j-1] + MOD) % MOD\n        return dp[n][k]"
        },
        {
            "task_id": "k-inverse-pairs-array",
            "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n                if i >= 2:\n                    dp[i][j] = (dp[i][j] - dp[i-2][j-1] + MOD) % MOD\n        return dp[n][k]"
        },
        {
            "task_id": "k-inverse-pairs-array",
            "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n                if i >= 2:\n                    dp[i][j] = (dp[i][j] - dp[i-2][j-1] + MOD) % MOD\n        return dp[n][k]"
        },
        {
            "task_id": "k-inverse-pairs-array",
            "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n                if i >= 2:\n                    dp[i][j] = (dp[i][j] - dp[i-2][j-1] + MOD) % MOD\n        return dp[n][k]"
        },
        {
            "task_id": "k-inverse-pairs-array",
            "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n                if i >= 2:\n                    dp[i][j] = (dp[i][j] - dp[i-2][j-1] + MOD) % MOD\n        return dp[n][k]"
        }
    ],
    "swap-nodes-in-pairs": [
        {
            "task_id": "swap-nodes-in-pairs",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        \n        return newHead"
        },
        {
            "task_id": "swap-nodes-in-pairs",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        \n        return newHead"
        },
        {
            "task_id": "swap-nodes-in-pairs",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead"
        },
        {
            "task_id": "swap-nodes-in-pairs",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead"
        },
        {
            "task_id": "swap-nodes-in-pairs",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None or head.next == None:\n            return head\n        \n        temp = head.next\n        head.next = self.swapPairs(temp.next)\n        temp.next = head\n        return temp"
        }
    ],
    "path-sum": [
        {
            "task_id": "path-sum",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"
        },
        {
            "task_id": "path-sum",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"
        },
        {
            "task_id": "path-sum",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"
        },
        {
            "task_id": "path-sum",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"
        },
        {
            "task_id": "path-sum",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"
        }
    ],
    "partition-list": [
        {
            "task_id": "partition-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        less = ListNode(0)\n        greater = ListNode(0)\n        lessHead = less\n        greaterHead = greater\n        \n        while head:\n            if head.val < x:\n                less.next = head\n                less = less.next\n            else:\n                greater.next = head\n                greater = greater.next\n            head = head.next\n        \n        less.next = greaterHead.next\n        greater.next = None\n        \n        return lessHead.next"
        },
        {
            "task_id": "partition-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        less = ListNode(0)\n        greater = ListNode(0)\n        lessHead = less\n        greaterHead = greater\n        \n        while head:\n            if head.val < x:\n                less.next = head\n                less = less.next\n            else:\n                greater.next = head\n                greater = greater.next\n            head = head.next\n        \n        less.next = greaterHead.next\n        greater.next = None\n        \n        return lessHead.next"
        },
        {
            "task_id": "partition-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        less = ListNode(0)\n        greater = ListNode(0)\n        lessHead = less\n        greaterHead = greater\n        \n        while head:\n            if head.val < x:\n                less.next = head\n                less = less.next\n            else:\n                greater.next = head\n                greater = greater.next\n            head = head.next\n        \n        less.next = greaterHead.next\n        greater.next = None\n        \n        return lessHead.next"
        },
        {
            "task_id": "partition-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        less = ListNode(0)\n        greater = ListNode(0)\n        lessHead = less\n        greaterHead = greater\n        \n        while head:\n            if head.val < x:\n                less.next = head\n                less = less.next\n            else:\n                greater.next = head\n                greater = greater.next\n            head = head.next\n        \n        less.next = greaterHead.next\n        greater.next = None\n        \n        return lessHead.next"
        },
        {
            "task_id": "partition-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        less = ListNode(0)\n        greater = ListNode(0)\n        lessHead = less\n        greaterHead = greater\n        \n        while head:\n            if head.val < x:\n                less.next = head\n                less = less.next\n            else:\n                greater.next = head\n                greater = greater.next\n            head = head.next\n        \n        less.next = greaterHead.next\n        greater.next = None\n        \n        return lessHead.next"
        }
    ],
    "redundant-connection-ii": [
        {
            "task_id": "redundant-connection-ii",
            "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize a dictionary to keep track of all nodes\n        # and their parents.\n        parents = {}\n        \n        # Initialize a dictionary to keep track of all nodes\n        # and their children.\n        children = {}\n        \n        # Initialize a set to keep track of all nodes\n        # that have multiple parents.\n        multiple_parents = set()\n        \n        # Initialize a set to keep track of all nodes\n        # that have multiple children.\n        multiple_children = set()\n        \n        # Iterate over all edges.\n        for edge in edges:\n            \n            # If the child is already in the dictionary of parents,\n            # then we have found a cycle.\n            if edge[1] in parents:\n                \n                # If the parent of the child is not the new parent,\n                # then we have found a redundant edge.\n                if parents[edge[1]] != edge[0]:\n                    return edge\n                \n                # If the parent of the child is the new parent,\n                # then we have found a cycle.\n                else:\n                    return [parents[edge[1]], edge[1]]\n            \n            # If the child is not in the dictionary of parents,\n            # then add the edge to the dictionary.\n            else:\n                parents[edge[1]] = edge[0]\n            \n            # If the parent is already in the dictionary of children,\n            # then we have found a cycle.\n            if edge[0] in children:\n                \n                # If the child of the parent is not the new child,\n                # then we have found a redundant edge.\n                if children[edge[0]] != edge[1]:\n                    return edge\n                \n                # If the child of the parent is the new child,\n                # then we have found a cycle.\n                else:\n                    return [edge[0], children[edge[0]]]\n            \n            # If the parent is not in the dictionary of children,\n            # then add the edge to the dictionary.\n            else:\n                children[edge[0]] = edge[1]\n        \n        # If we have not found a cycle or a redundant edge,\n        # then we have found a tree.\n        return []"
        },
        {
            "task_id": "redundant-connection-ii",
            "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize a dictionary to keep track of all nodes\n        # and their parents.\n        parents = {}\n        \n        # Initialize a dictionary to keep track of all nodes\n        # and their children.\n        children = {}\n        \n        # Initialize a set to keep track of all nodes\n        # that have multiple parents.\n        multiple_parents = set()\n        \n        # Initialize a set to keep track of all nodes\n        # that have multiple children.\n        multiple_children = set()\n        \n        # Iterate over all edges.\n        for edge in edges:\n            \n            # If the child is already in the dictionary of parents,\n            # then we have found a redundant edge.\n            if edge[1] in parents:\n                \n                # If the parent of the child is not the same as the\n                # new parent, then we have found a redundant edge.\n                if parents[edge[1]] != edge[0]:\n                    return edge\n                \n                # If the parent of the child is the same as the new\n                # parent, then we have found a cycle.\n                else:\n                    return [parents[edge[1]], edge[1]]\n            \n            # If the child is not in the dictionary of parents,\n            # then add the edge to the dictionary.\n            else:\n                parents[edge[1]] = edge[0]\n                \n                # If the parent is already in the dictionary of children,\n                # then we have found a node with multiple children.\n                if edge[0] in children:\n                    multiple_children.add(edge[0])\n                \n                # If the parent is not in the dictionary of children,\n                # then add the edge to the dictionary.\n                else:\n                    children[edge[0]] = edge[1]\n        \n        # If we have not found a redundant edge, then we must have\n        # a cycle.\n        for node in multiple_children:\n            if node not in multiple_parents:\n                return [node, children[node]]\n        \n        # If we have not found a redundant edge or a cycle, then we\n        # must have a forest (a collection of trees).\n        for edge in edges:\n            if edge[0] not in parents and edge[1] not in children:\n                return edge"
        },
        {
            "task_id": "redundant-connection-ii",
            "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize a dictionary to keep track of all the nodes\n        # and their parents.\n        parents = {}\n        \n        # Initialize a dictionary to keep track of all the nodes\n        # and their children.\n        children = {}\n        \n        # Initialize a set to keep track of all the nodes\n        # that have multiple parents.\n        multiple_parents = set()\n        \n        # Initialize a set to keep track of all the nodes\n        # that have multiple children.\n        multiple_children = set()\n        \n        # Iterate over all the edges in the graph.\n        for edge in edges:\n            \n            # If the child is already in the dictionary of parents,\n            # then we have found a cycle in the graph.\n            if edge[1] in parents:\n                \n                # If the parent of the child is not the same as the\n                # new parent, then we have found a redundant edge.\n                if parents[edge[1]] != edge[0]:\n                    return edge\n                \n                # If the parent of the child is the same as the new\n                # parent, then we have found a redundant edge.\n                else:\n                    return [parents[edge[1]], edge[1]]\n            \n            # If the child is not in the dictionary of parents, then\n            # we add the child to the dictionary of parents.\n            else:\n                parents[edge[1]] = edge[0]\n            \n            # If the parent is already in the dictionary of children,\n            # then we have found a node with multiple children.\n            if edge[0] in children:\n                \n                # If the child is not already in the list of children\n                # of the parent, then we add the child to the list of\n                # children of the parent.\n                if edge[1] not in children[edge[0]]:\n                    children[edge[0]].append(edge[1])\n                \n                # If the child is already in the list of children of\n                # the parent, then we have found a node with multiple\n                # parents.\n                else:\n                    multiple_parents.add(edge[1])\n            \n            # If the parent is not in the dictionary of children, then\n            # we add the parent to the dictionary of children.\n            else:\n                children[edge[0]] = [edge[1]]\n        \n        # If we have not found a redundant edge, then we iterate over\n        # all the nodes that have multiple parents.\n        for node in multiple_parents:\n            \n            # If the parent of the node is not the root, then we have\n            # found a redundant edge.\n            if parents[node] != 1:\n                return [parents[node], node]\n        \n        # If we have not found a redundant edge, then we iterate over\n        # all the nodes that have multiple children.\n        for node in multiple_children:\n            \n            # If the node has more than one child, then we have found\n            # a redundant edge.\n            if len(children[node]) > 1:\n                return [node, children[node][1]]\n        \n        # If we have not found a redundant edge, then we return an\n        # empty list.\n        return []"
        },
        {
            "task_id": "redundant-connection-ii",
            "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize a dictionary to keep track of all the nodes\n        # and their parents.\n        parents = {}\n        \n        # Initialize a dictionary to keep track of all the nodes\n        # and their children.\n        children = {}\n        \n        # Initialize a set to keep track of all the nodes\n        # that have multiple parents.\n        multiple_parents = set()\n        \n        # Initialize a set to keep track of all the nodes\n        # that have multiple children.\n        multiple_children = set()\n        \n        # Iterate over all the edges in the graph.\n        for edge in edges:\n            \n            # If the child is already in the dictionary of parents,\n            # then we have found a cycle in the graph.\n            if edge[1] in parents:\n                \n                # If the parent of the child is not the same as the\n                # new parent, then we have found a redundant edge.\n                if parents[edge[1]] != edge[0]:\n                    return edge\n                \n                # If the parent of the child is the same as the new\n                # parent, then we have found a redundant edge.\n                else:\n                    return [parents[edge[1]], edge[1]]\n            \n            # If the child is not in the dictionary of parents, then\n            # we add the child to the dictionary of parents.\n            else:\n                parents[edge[1]] = edge[0]\n            \n            # If the parent is already in the dictionary of children,\n            # then we have found a node with multiple children.\n            if edge[0] in children:\n                \n                # If the child is not already in the list of children,\n                # then we add the child to the list of children.\n                if edge[1] not in children[edge[0]]:\n                    children[edge[0]].append(edge[1])\n                \n                # If the child is already in the list of children, then\n                # we have found a node with multiple parents.\n                else:\n                    multiple_parents.add(edge[1])\n                    multiple_children.add(edge[0])\n            \n            # If the parent is not in the dictionary of children, then\n            # we add the parent to the dictionary of children.\n            else:\n                children[edge[0]] = [edge[1]]\n        \n        # If there are no nodes with multiple parents, then we return\n        # the last edge in the graph.\n        if not multiple_parents:\n            return edges[-1]\n        \n        # If there are nodes with multiple parents, then we iterate\n        # over all the nodes with multiple parents.\n        for node in multiple_parents:\n            \n            # If the node is also a node with multiple children, then\n            # we return the edge between the node and its parent.\n            if node in multiple_children:\n                return [parents[node], node]"
        },
        {
            "task_id": "redundant-connection-ii",
            "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize a dictionary to keep track of all nodes\n        # and their parents.\n        parents = {}\n        \n        # Initialize a dictionary to keep track of all nodes\n        # and their children.\n        children = {}\n        \n        # Initialize a set to keep track of all nodes that\n        # have multiple parents.\n        multiple_parents = set()\n        \n        # Initialize a set to keep track of all nodes that\n        # have children.\n        has_children = set()\n        \n        # Iterate over all edges.\n        for edge in edges:\n            \n            # Get the parent and child nodes.\n            parent, child = edge\n            \n            # If the child already has a parent, then\n            # we have found a cycle.\n            if child in parents:\n                \n                # If the child already has a parent, then\n                # we have found a cycle.\n                if child in multiple_parents:\n                    return edge\n                \n                # If the child does not have a parent, then\n                # we have found a cycle.\n                else:\n                    return [parents[child], child]\n            \n            # If the child does not have a parent, then\n            # we add the child to the dictionary of children.\n            else:\n                children.setdefault(parent, set()).add(child)\n                parents[child] = parent\n                has_children.add(parent)\n        \n        # If we have not found a cycle, then we iterate\n        # over all nodes that have children.\n        for parent in has_children:\n            \n            # If the parent has multiple children, then\n            # we have found a cycle.\n            if len(children[parent]) > 1:\n                return [parent, list(children[parent])[1]]\n            \n            # If the parent only has one child, then we\n            # add the child to the set of nodes that have\n            # multiple parents.\n            else:\n                multiple_parents.add(list(children[parent])[0])\n        \n        # If we have not found a cycle, then we iterate\n        # over all nodes that have multiple parents.\n        for child in multiple_parents:\n            \n            # If the child has multiple parents, then\n            # we have found a cycle.\n            if len(parents[child]) > 1:\n                return [parents[child][0], child]"
        }
    ],
    "permutations-ii": [
        {
            "task_id": "permutations-ii",
            "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        dfs(nums, [], res)\n        return res"
        },
        {
            "task_id": "permutations-ii",
            "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        dfs(nums, [], res)\n        return res"
        },
        {
            "task_id": "permutations-ii",
            "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Create a list to store the permutations\n        permutations = []\n        \n        # Create a list to store the used elements\n        used = []\n        \n        # Call the function to generate permutations\n        self.generate_permutations(nums, permutations, used, [])\n        \n        return permutations\n    \n    def generate_permutations(self, nums, permutations, used, current):\n        if len(current) == len(nums):\n            permutations.append(current[:])\n            return\n        \n        for i in range(len(nums)):\n            if i in used:\n                continue\n            \n            # If the number is not unique, then skip the current iteration\n            if i > 0 and nums[i] == nums[i-1] and used[i-1] == 0:\n                continue\n            \n            used[i] = 1\n            current.append(nums[i])\n            self.generate_permutations(nums, permutations, used, current)\n            current.pop()\n            used[i] = 0"
        },
        {
            "task_id": "permutations-ii",
            "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Create a list to store the permutations\n        permutations = []\n        \n        # Create a list to mark the elements as visited\n        visited = [False] * len(nums)\n        \n        # Call the helper function to generate the permutations\n        self.generate_permutations(nums, permutations, visited, [])\n        \n        return permutations\n    \n    def generate_permutations(self, nums, permutations, visited, current):\n        # If the length of the 'current' array is equal to the length of the 'nums' array,\n        # then we have reached the end of the permutation\n        if len(current) == len(nums):\n            permutations.append(current[:])\n            return\n        \n        # Iterate over the elements of the 'nums' array\n        for i in range(len(nums)):\n            \n            # If the element is already visited, then continue to the next iteration\n            if visited[i]:\n                continue\n            \n            # If the previous element is the same as the current element,\n            # and the previous element is not visited, then continue to the next iteration\n            if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                continue\n            \n            # Mark the element as visited\n            visited[i] = True\n            \n            # Add the element to the 'current' array\n            current.append(nums[i])\n            \n            # Call the helper function recursively\n            self.generate_permutations(nums, permutations, visited, current)\n            \n            # Remove the element from the 'current' array\n            current.pop()\n            \n            # Mark the element as not visited\n            visited[i] = False"
        },
        {
            "task_id": "permutations-ii",
            "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Create a list to store the permutations\n        permutations = []\n        \n        # Create a list to store the used elements\n        used = []\n        \n        # Call the function to generate permutations\n        self.generate_permutations(nums, permutations, used, [])\n        \n        return permutations\n    \n    def generate_permutations(self, nums, permutations, used, current):\n        if len(current) == len(nums):\n            permutations.append(current[:])\n            return\n        \n        for i in range(len(nums)):\n            if i in used:\n                continue\n            \n            # If the number is not unique, then skip the current iteration\n            if i > 0 and nums[i] == nums[i-1] and used[i-1] == 0:\n                continue\n            \n            used[i] = 1\n            current.append(nums[i])\n            self.generate_permutations(nums, permutations, used, current)\n            current.pop()\n            used[i] = 0"
        }
    ],
    "add-digits": [
        {
            "task_id": "add-digits",
            "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num-1)%9+1"
        },
        {
            "task_id": "add-digits",
            "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num-1)%9+1"
        },
        {
            "task_id": "add-digits",
            "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num-1)%9+1"
        },
        {
            "task_id": "add-digits",
            "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num-1)%9+1"
        },
        {
            "task_id": "add-digits",
            "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num-1)%9+1"
        }
    ],
    "single-number": [
        {
            "task_id": "single-number",
            "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # 0 ^ 0 = 0\n        # 0 ^ 1 = 1\n        # 1 ^ 0 = 1\n        # 1 ^ 1 = 0\n        \n        # XOR operation is commutative\n        # 1 ^ 2 ^ 3 ^ 1 ^ 2 = 1 ^ 1 ^ 2 ^ 2 ^ 3 = 3\n        \n        # XOR operation is associative\n        # 1 ^ 2 ^ 3 ^ 4 = 1 ^ (2 ^ 3) ^ 4 = 1 ^ 5 ^ 4 = 6\n        \n        # XOR operation is distributive\n        # 1 ^ (2 ^ 3) = 1 ^ 2 ^ 3 = 0\n        \n        # XOR operation is idempotent\n        # 1 ^ 1 = 0\n        \n        # XOR operation is involutive\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-inverse\n        # 1 ^ 2 = 3\n        # 3 ^ 1 = 2\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative"
        },
        {
            "task_id": "single-number",
            "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # a XOR a = 0\n        # a XOR 0 = a\n        # a XOR b XOR a = (a XOR a) XOR b = 0 XOR b = b\n        # a XOR b XOR c XOR a = (a XOR a) XOR b XOR c = 0 XOR b XOR c = b XOR c\n        # a XOR b XOR c XOR d XOR a = (a XOR a) XOR b XOR c XOR d = 0 XOR b XOR c XOR d = b XOR c XOR d\n        # ...\n        # a XOR b XOR c XOR d XOR ... XOR n XOR a = (a XOR a) XOR b XOR c XOR d XOR ... XOR n = 0 XOR b XOR c XOR d XOR ... XOR n = b XOR c XOR d XOR ... XOR n\n        # So, if we XOR all elements together, all the duplicate elements will cancel out each other except the single one.\n        # The single one will remain.\n        \n        result = 0\n        for num in nums:\n            result ^= num\n        return result"
        },
        {
            "task_id": "single-number",
            "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # a XOR a = 0\n        # a XOR 0 = a\n        # a XOR b XOR a = (a XOR a) XOR b = 0 XOR b = b\n        # a XOR b XOR c XOR a = (a XOR a) XOR b XOR c = 0 XOR b XOR c = b XOR c\n        # a XOR b XOR c XOR d XOR a = (a XOR a) XOR b XOR c XOR d = 0 XOR b XOR c XOR d = b XOR c XOR d\n        # ...\n        # a XOR b XOR c XOR d XOR ... XOR n XOR a = (a XOR a) XOR b XOR c XOR d XOR ... XOR n = 0 XOR b XOR c XOR d XOR ... XOR n = b XOR c XOR d XOR ... XOR n\n        # So, the result is the number that appears only once in the array.\n        \n        result = 0\n        for num in nums:\n            result ^= num\n        return result"
        },
        {
            "task_id": "single-number",
            "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # a XOR a = 0\n        # a XOR 0 = a\n        # a XOR b XOR a = (a XOR a) XOR b = 0 XOR b = b\n        # a XOR b XOR c XOR a = (a XOR a) XOR b XOR c = 0 XOR b XOR c = b XOR c\n        # a XOR b XOR c XOR d XOR a = (a XOR a) XOR b XOR c XOR d = 0 XOR b XOR c XOR d = b XOR c XOR d\n        # ...\n        # a XOR b XOR c XOR d XOR ... XOR n XOR a = (a XOR a) XOR b XOR c XOR d XOR ... XOR n = 0 XOR b XOR c XOR d XOR ... XOR n = b XOR c XOR d XOR ... XOR n\n        # So, if we XOR all elements together, the result will be the single number.\n        \n        result = 0\n        for num in nums:\n            result ^= num\n        return result"
        },
        {
            "task_id": "single-number",
            "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # 0 ^ 0 = 0\n        # 0 ^ 1 = 1\n        # 1 ^ 0 = 1\n        # 1 ^ 1 = 0\n        \n        # XOR operation is commutative\n        # 1 ^ 2 ^ 1 = 0\n        # 1 ^ 2 ^ 1 = 2 ^ 1 ^ 1\n        \n        # XOR operation is associative\n        # 1 ^ 2 ^ 3 = 1 ^ (2 ^ 3)\n        # 1 ^ 2 ^ 3 = (1 ^ 2) ^ 3\n        \n        # XOR operation is distributive\n        # 1 ^ (2 ^ 3) = (1 ^ 2) ^ (1 ^ 3)\n        # 1 ^ (2 ^ 3) = (1 ^ 2) ^ 3\n        \n        # XOR operation is idempotent\n        # 1 ^ 1 = 0\n        \n        # XOR operation is involutive\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-inverse\n        # 1 ^ 2 = 3\n        # 3 ^ 1 = 2\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-invertible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-reversible\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # XOR operation is self-cancellative\n        # 1 ^ 2 = 3\n        # 3 ^ 2 = 1\n        \n        # X"
        }
    ],
    "length-of-last-word": [
        {
            "task_id": "length-of-last-word",
            "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = s.strip()\n        if len(s) == 0:\n            return 0\n        else:\n            return len(s.split()[-1])"
        },
        {
            "task_id": "length-of-last-word",
            "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = s.strip()\n        if len(s) == 0:\n            return 0\n        else:\n            return len(s.split()[-1])"
        },
        {
            "task_id": "length-of-last-word",
            "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = s.strip()\n        if len(s) == 0:\n            return 0\n        else:\n            return len(s.split()[-1])"
        },
        {
            "task_id": "length-of-last-word",
            "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = s.strip()\n        if len(s) == 0:\n            return 0\n        else:\n            return len(s.split()[-1])"
        },
        {
            "task_id": "length-of-last-word",
            "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = s.strip()\n        if len(s) == 0:\n            return 0\n        else:\n            return len(s.split()[-1])"
        }
    ],
    "cherry-pickup": [
        {
            "task_id": "cherry-pickup",
            "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j][k] represents the max number of cherries you can collect by following the rules below:\n        # Starting at the position (0, 0) and reaching (i, j) by moving right or down through valid path cells (cells with value 0 or 1).\n        # After reaching (i, j), returning to (0, 0) by moving left or up through valid path cells.\n        # When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\n        # If there is no valid path between (0, 0) and (i, j), then dp[i][j][k] = -1.\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-"
        },
        {
            "task_id": "cherry-pickup",
            "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j][k] represents the maximum number of cherries you can collect by following the rules below:\n        # Starting at the position (0, 0) and reaching (i, j) by moving right or down through valid path cells (cells with value 0 or 1).\n        # After reaching (i, j), returning to (0, 0) by moving left or up through valid path cells.\n        # When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\n        # If there is no valid path between (0, 0) and (i, j), then dp[i][j][k] is -1.\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k"
        },
        {
            "task_id": "cherry-pickup",
            "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j][k] represents the max number of cherries you can collect by following the rules below:\n        # Starting at the position (0, 0) and reaching (i, j) by moving right or down through valid path cells (cells with value 0 or 1).\n        # After reaching (i, j), returning to (0, 0) by moving left or up through valid path cells.\n        # When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\n        # If there is no valid path between (0, 0) and (i, j), then no cherries can be collected.\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i-1][j][k], dp[i][j-1][k])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i-1][j][k], dp[i][j-1][k]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i-1][j][k], dp[i][j-1][k]) + grid[i][j] + grid[i][k]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i-1][j][k], dp[i][j-1][k]) + grid[i][j] + grid[i][k] + grid[j][k]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i-1][j][k], dp[i][j-1][k]) + grid[i][j] + grid[i][k] + grid[j][k]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i-1][j][k], dp[i][j-1][k]) + grid[i][j] + grid[i][k] + grid[j][k]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i-1][j][k], dp[i][j-1][k]) + grid[i][j] + grid[i][k] + grid[j][k]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i-1][j][k], dp[i][j-1][k]) + grid[i][j] + grid[i][k] + grid[j][k]\n        # dp[i][j][k] = max(dp[i-1][j-1"
        },
        {
            "task_id": "cherry-pickup",
            "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j][k] represents the max number of cherries you can collect by following the rules below:\n        # Starting at the position (0, 0) and reaching (i, j) by moving right or down through valid path cells (cells with value 0 or 1).\n        # After reaching (i, j), returning to (0, 0) by moving left or up through valid path cells.\n        # When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\n        # If there is no valid path between (0, 0) and (i, j), then dp[i][j][k] = -1.\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2]) + grid[i][j]\n        # dp[i][j][k] = max(dp[i-"
        },
        {
            "task_id": "cherry-pickup",
            "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j][k] represents the maximum number of cherries you can collect by following the rules below:\n        # Starting at the position (0, 0) and reaching (i, j) by moving right or down through valid path cells (cells with value 0 or 1).\n        # After reaching (i, j), returning to (0, 0) by moving left or up through valid path cells.\n        # When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\n        # If there is no valid path between (0, 0) and (i, j), then dp[i][j][k] is -1.\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k"
        }
    ],
    "student-attendance-record-ii": [
        {
            "task_id": "student-attendance-record-ii",
            "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 3\n        \n        for i in range(2, n+1):\n            dp[i] = (dp[i-1] * 3 + dp[i-2] * 2) % MOD\n            \n        return dp[n]"
        },
        {
            "task_id": "student-attendance-record-ii",
            "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 3\n        \n        for i in range(2, n+1):\n            dp[i] = (dp[i-1] * 3 + dp[i-2] * 2) % MOD\n            \n        return dp[n]"
        },
        {
            "task_id": "student-attendance-record-ii",
            "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 3\n        \n        for i in range(2, n+1):\n            dp[i] = (dp[i-1] * 3 + dp[i-2] * 2) % MOD\n            \n        return dp[n]"
        },
        {
            "task_id": "student-attendance-record-ii",
            "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 3\n        \n        for i in range(2, n+1):\n            dp[i] = (dp[i-1] * 3 + dp[i-2] * 2) % MOD\n            \n        return dp[n]"
        },
        {
            "task_id": "student-attendance-record-ii",
            "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 3\n        \n        for i in range(2, n+1):\n            dp[i] = (dp[i-1] * 3 + dp[i-2] * 2) % MOD\n            \n        return dp[n]"
        }
    ],
    "happy-number": [
        {
            "task_id": "happy-number",
            "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_sum(n):\n            sum = 0\n            while n > 0:\n                sum += (n % 10) ** 2\n                n //= 10\n            return sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_sum(n)\n        return n == 1"
        },
        {
            "task_id": "happy-number",
            "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_sum(n):\n            sum = 0\n            while n > 0:\n                sum += (n % 10) ** 2\n                n //= 10\n            return sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_sum(n)\n        return n == 1"
        },
        {
            "task_id": "happy-number",
            "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_sum(n):\n            sum = 0\n            while n > 0:\n                sum += (n % 10) ** 2\n                n //= 10\n            return sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_sum(n)\n        return n == 1"
        },
        {
            "task_id": "happy-number",
            "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_sum(n):\n            sum = 0\n            while n > 0:\n                sum += (n % 10) ** 2\n                n //= 10\n            return sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_sum(n)\n        return n == 1"
        },
        {
            "task_id": "happy-number",
            "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_sum(n):\n            sum = 0\n            while n > 0:\n                sum += (n % 10) ** 2\n                n //= 10\n            return sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_sum(n)\n        return n == 1"
        }
    ],
    "search-insert-position": [
        {
            "task_id": "search-insert-position",
            "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
        },
        {
            "task_id": "search-insert-position",
            "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
        },
        {
            "task_id": "search-insert-position",
            "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
        },
        {
            "task_id": "search-insert-position",
            "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
        },
        {
            "task_id": "search-insert-position",
            "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
        }
    ],
    "jump-game": [
        {
            "task_id": "jump-game",
            "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the maximum reachable index\n        maxReach = 0\n        \n        # Iterate over the array\n        for i in range(len(nums)):\n            \n            # If the current index is greater than the maximum reachable index,\n            # we can reach the current index from the previous index\n            if i <= maxReach:\n                \n                # Update the maximum reachable index\n                maxReach = max(maxReach, i + nums[i])\n                \n                # If the maximum reachable index is greater than or equal to the\n                # length of the array, we can reach the last index\n                if maxReach >= len(nums) - 1:\n                    return True\n                    \n        return False"
        },
        {
            "task_id": "jump-game",
            "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the maximum jump length\n        max_jump = 0\n        \n        # Iterate through the list\n        for i in range(len(nums)):\n            \n            # If the current index is greater than the maximum jump length,\n            # then update the maximum jump length\n            if i > max_jump:\n                max_jump = max_jump + nums[max_jump]\n                \n            # If the maximum jump length is greater than or equal to the length of the list,\n            # then return True\n            if max_jump >= len(nums) - 1:\n                return True\n                \n        # If the loop completes and the maximum jump length is still less than the length of the list,\n        # then return False\n        return False"
        },
        {
            "task_id": "jump-game",
            "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the maximum jump length\n        max_jump = 0\n        \n        # Iterate through the array\n        for i in range(len(nums)):\n            \n            # If the current index is greater than the maximum jump length,\n            # then update the maximum jump length\n            if i > max_jump:\n                max_jump = max_jump + nums[max_jump]\n                \n            # If the maximum jump length is greater than or equal to the length of the array,\n            # then return True\n            if max_jump >= len(nums) - 1:\n                return True\n            \n        # If the loop completes and the maximum jump length is still less than the length of the array,\n        # then return False\n        return False"
        },
        {
            "task_id": "jump-game",
            "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the maximum reachable index\n        maxReach = 0\n        \n        # Iterate over the array\n        for i in range(len(nums)):\n            \n            # If we have reached the end of the array, return True\n            if i == len(nums) - 1:\n                return True\n            \n            # Update the maximum reachable index\n            maxReach = max(maxReach, i + nums[i])\n            \n            # If the maximum reachable index is less than the current index,\n            # we cannot reach the last index\n            if maxReach < i:\n                return False\n            \n        return False"
        },
        {
            "task_id": "jump-game",
            "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the maximum jump length\n        max_jump = 0\n        \n        # Iterate through the array\n        for i in range(len(nums)):\n            \n            # If the current index is greater than the maximum jump length,\n            # then we can jump to the current index\n            if i > max_jump:\n                return False\n            \n            # Update the maximum jump length\n            max_jump = max(max_jump, i + nums[i])\n            \n        return True"
        }
    ],
    "minimum-path-sum": [
        {
            "task_id": "minimum-path-sum",
            "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [[0 for i in range(len(grid[0]))] for j in range(len(grid))]\n        \n        # Initialize the first row\n        for i in range(len(grid[0])):\n            dp[0][i] = grid[0][i]\n        \n        # Initialize the first column\n        for i in range(len(grid)):\n            dp[i][0] = grid[i][0]\n        \n        # Fill the dp array\n        for i in range(1, len(grid)):\n            for j in range(1, len(grid[0])):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[-1][-1]"
        },
        {
            "task_id": "minimum-path-sum",
            "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array with the first row\n        dp = grid[0]\n        \n        # Initialize the first column\n        for i in range(1, len(grid)):\n            dp[i] += dp[i-1]\n            \n        # Fill the rest of the dp array\n        for i in range(1, len(grid)):\n            for j in range(len(grid[i])):\n                if j == 0:\n                    dp[j] += dp[j]\n                else:\n                    dp[j] = min(dp[j], dp[j-1]) + grid[i][j]\n                    \n        return dp[-1]"
        },
        {
            "task_id": "minimum-path-sum",
            "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array with the first row\n        dp = grid[0]\n        \n        # Initialize the first column\n        for i in range(1, len(grid)):\n            dp[i] += dp[i-1]\n            \n        # Fill the rest of the dp table\n        for i in range(1, len(grid)):\n            for j in range(len(grid[i])):\n                if j == 0:\n                    dp[j] += dp[j]\n                else:\n                    dp[j] = min(dp[j], dp[j-1]) + grid[i][j]\n                    \n        return dp[-1]"
        },
        {
            "task_id": "minimum-path-sum",
            "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array with the first row\n        dp = grid[0]\n        \n        # Initialize the first column\n        for i in range(1, len(grid)):\n            dp[i] += dp[i-1]\n            \n        # Fill the rest of the dp array\n        for i in range(1, len(grid)):\n            for j in range(len(grid[i])):\n                if j == 0:\n                    dp[j] += dp[j]\n                else:\n                    dp[j] = min(dp[j], dp[j-1]) + grid[i][j]\n                    \n        return dp[-1]"
        },
        {
            "task_id": "minimum-path-sum",
            "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [[0 for i in range(len(grid[0]))] for j in range(len(grid))]\n        \n        # Initialize the first row\n        for i in range(len(grid[0])):\n            dp[0][i] = grid[0][i]\n        \n        # Initialize the first column\n        for i in range(len(grid)):\n            dp[i][0] = grid[i][0]\n        \n        # Fill the dp array\n        for i in range(1, len(grid)):\n            for j in range(1, len(grid[0])):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[-1][-1]"
        }
    ],
    "count-and-say": [
        {
            "task_id": "count-and-say",
            "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        else:\n            prev = self.countAndSay(n-1)\n            count = 1\n            result = ''\n            for i in range(len(prev)-1):\n                if prev[i] == prev[i+1]:\n                    count += 1\n                else:\n                    result += str(count) + prev[i]\n                    count = 1\n            result += str(count) + prev[-1]\n            return result"
        },
        {
            "task_id": "count-and-say",
            "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        else:\n            prev = self.countAndSay(n-1)\n            count = 1\n            result = ''\n            for i in range(len(prev)-1):\n                if prev[i] == prev[i+1]:\n                    count += 1\n                else:\n                    result += str(count) + prev[i]\n                    count = 1\n            result += str(count) + prev[-1]\n            return result"
        },
        {
            "task_id": "count-and-say",
            "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        else:\n            prev = self.countAndSay(n-1)\n            count = 1\n            result = \"\"\n            for i in range(len(prev)-1):\n                if prev[i] == prev[i+1]:\n                    count += 1\n                else:\n                    result += str(count) + prev[i]\n                    count = 1\n            result += str(count) + prev[-1]\n            return result"
        },
        {
            "task_id": "count-and-say",
            "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        else:\n            prev = self.countAndSay(n-1)\n            count = 1\n            result = \"\"\n            for i in range(len(prev)-1):\n                if prev[i] == prev[i+1]:\n                    count += 1\n                else:\n                    result += str(count) + prev[i]\n                    count = 1\n            result += str(count) + prev[-1]\n            return result"
        },
        {
            "task_id": "count-and-say",
            "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        else:\n            prev_str = self.countAndSay(n-1)\n            curr_str = ''\n            count = 1\n            for i in range(len(prev_str)-1):\n                if prev_str[i] == prev_str[i+1]:\n                    count += 1\n                else:\n                    curr_str += str(count) + prev_str[i]\n                    count = 1\n            curr_str += str(count) + prev_str[-1]\n            return curr_str"
        }
    ],
    "split-array-largest-sum": [
        {
            "task_id": "split-array-largest-sum",
            "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, mid):\n            cnt = 0\n            s = 0\n            for i in range(len(nums)):\n                s += nums[i]\n                if s > mid:\n                    cnt += 1\n                    s = nums[i]\n            cnt += 1\n            return cnt <= k\n        \n        def check_mid(nums, k, mid):\n            cnt = 0\n            s = 0\n            for i in range(len(nums)):\n                s += nums[i]\n                if s > mid:\n                    cnt += 1\n                    s = nums[i]\n            cnt += 1\n            return cnt\n        \n        l = max(nums)\n        r = sum(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if check(nums, k, mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l"
        },
        {
            "task_id": "split-array-largest-sum",
            "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, mid):\n            cnt = 0\n            s = 0\n            for i in range(len(nums)):\n                s += nums[i]\n                if s > mid:\n                    cnt += 1\n                    s = nums[i]\n            return cnt + 1 <= k\n        \n        def check_mid(nums, k, left, right):\n            while left < right:\n                mid = (left + right) // 2\n                if check(nums, k, mid):\n                    right = mid\n                else:\n                    left = mid + 1\n            return left\n        \n        left = max(nums)\n        right = sum(nums)\n        return check_mid(nums, k, left, right)"
        },
        {
            "task_id": "split-array-largest-sum",
            "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, mid):\n            cnt = 0\n            s = 0\n            for i in range(len(nums)):\n                s += nums[i]\n                if s > mid:\n                    cnt += 1\n                    s = nums[i]\n            cnt += 1\n            return cnt <= k\n        \n        def check_mid(nums, k, mid):\n            cnt = 0\n            s = 0\n            for i in range(len(nums)):\n                s += nums[i]\n                if s > mid:\n                    cnt += 1\n                    s = nums[i]\n            cnt += 1\n            return cnt\n        \n        l = max(nums)\n        r = sum(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if check(nums, k, mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l"
        },
        {
            "task_id": "split-array-largest-sum",
            "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, mid):\n            cnt = 0\n            s = 0\n            for i in range(len(nums)):\n                s += nums[i]\n                if s > mid:\n                    cnt += 1\n                    s = nums[i]\n            cnt += 1\n            return cnt <= k\n        \n        def check_mid(nums, k, left, right):\n            while left < right:\n                mid = (left + right) // 2\n                if check(nums, k, mid):\n                    right = mid\n                else:\n                    left = mid + 1\n            return left\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if check(nums, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"
        },
        {
            "task_id": "split-array-largest-sum",
            "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, mid):\n            cnt = 0\n            s = 0\n            for i in range(len(nums)):\n                s += nums[i]\n                if s > mid:\n                    cnt += 1\n                    s = nums[i]\n            cnt += 1\n            return cnt <= k\n        \n        def check_mid(nums, k, mid):\n            cnt = 0\n            s = 0\n            for i in range(len(nums)):\n                s += nums[i]\n                if s > mid:\n                    cnt += 1\n                    s = nums[i]\n            cnt += 1\n            return cnt\n        \n        l = max(nums)\n        r = sum(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if check(nums, k, mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l"
        }
    ],
    "search-in-rotated-sorted-array": [
        {
            "task_id": "search-in-rotated-sorted-array",
            "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > nums[right]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1"
        },
        {
            "task_id": "search-in-rotated-sorted-array",
            "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return -1\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[mid] >= nums[left]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                    \n        return -1"
        },
        {
            "task_id": "search-in-rotated-sorted-array",
            "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return -1\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > nums[right]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1"
        },
        {
            "task_id": "search-in-rotated-sorted-array",
            "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > nums[right]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1"
        },
        {
            "task_id": "search-in-rotated-sorted-array",
            "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return -1\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > nums[right]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1"
        }
    ],
    "letter-combinations-of-a-phone-number": [
        {
            "task_id": "letter-combinations-of-a-phone-number",
            "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        result = []\n        self.backtrack(digits, mapping, \"\", result)\n        return result\n    \n    def backtrack(self, digits, mapping, combination, result):\n        if len(digits) == 0:\n            result.append(combination)\n            return\n        \n        for letter in mapping[digits[0]]:\n            self.backtrack(digits[1:], mapping, combination + letter, result)"
        },
        {
            "task_id": "letter-combinations-of-a-phone-number",
            "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        result = []\n        self.backtrack(digits, mapping, 0, \"\", result)\n        return result\n    \n    def backtrack(self, digits, mapping, index, combination, result):\n        if index == len(digits):\n            result.append(combination)\n            return\n        \n        for letter in mapping[digits[index]]:\n            self.backtrack(digits, mapping, index + 1, combination + letter, result)"
        },
        {
            "task_id": "letter-combinations-of-a-phone-number",
            "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        result = []\n        self.backtrack(digits, mapping, \"\", result)\n        return result\n    \n    def backtrack(self, digits, mapping, combination, result):\n        if len(digits) == 0:\n            result.append(combination)\n            return\n        \n        for letter in mapping[digits[0]]:\n            self.backtrack(digits[1:], mapping, combination + letter, result)"
        },
        {
            "task_id": "letter-combinations-of-a-phone-number",
            "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        result = []\n        \n        for i in range(len(digits)):\n            if i == 0:\n                for j in mapping[digits[i]]:\n                    result.append(j)\n            else:\n                temp = []\n                for j in mapping[digits[i]]:\n                    for k in result:\n                        temp.append(k+j)\n                result = temp\n                \n        return result"
        },
        {
            "task_id": "letter-combinations-of-a-phone-number",
            "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        result = []\n        self.backtrack(digits, mapping, \"\", result)\n        return result\n    \n    def backtrack(self, digits, mapping, combination, result):\n        if len(digits) == 0:\n            result.append(combination)\n            return\n        \n        for letter in mapping[digits[0]]:\n            self.backtrack(digits[1:], mapping, combination + letter, result)"
        }
    ],
    "combination-sum": [
        {
            "task_id": "combination-sum",
            "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # Initialize an empty list to store the combinations\n        combinations = []\n        \n        # Call the helper function to find the combinations\n        self.helper(candidates, target, combinations, [], 0)\n        \n        return combinations\n    \n    def helper(self, candidates, target, combinations, current, index):\n        # If the target is 0, then the current combination is a valid answer\n        if target == 0:\n            combinations.append(current[:])\n            return\n        \n        # If the target is less than 0, then the current combination is not valid, so return\n        if target < 0:\n            return\n        \n        # Loop through the candidates list\n        for i in range(index, len(candidates)):\n            # Add the current candidate to the current combination\n            current.append(candidates[i])\n            \n            # Call the helper function again to find the combinations\n            self.helper(candidates, target - candidates[i], combinations, current, i)\n            \n            # Remove the current candidate from the current combination\n            current.pop()"
        },
        {
            "task_id": "combination-sum",
            "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # Initialize an empty list to store the combinations\n        combinations = []\n        \n        # Call the helper function to find the combinations\n        self.helper(candidates, target, combinations, [], 0)\n        \n        return combinations\n    \n    def helper(self, candidates, target, combinations, current, index):\n        # If the target is 0, then the current combination is a valid answer\n        if target == 0:\n            combinations.append(current[:])\n            return\n        \n        # If the target is less than 0, then the current combination is not valid, so return\n        if target < 0:\n            return\n        \n        # Loop through the candidates list\n        for i in range(index, len(candidates)):\n            # Add the current candidate to the current combination\n            current.append(candidates[i])\n            \n            # Call the helper function again to find the combinations\n            self.helper(candidates, target - candidates[i], combinations, current, i)\n            \n            # Remove the current candidate from the current combination\n            current.pop()"
        },
        {
            "task_id": "combination-sum",
            "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # Initialize an empty list to store the combinations\n        combinations = []\n        \n        # Call the helper function to find the combinations\n        self.helper(candidates, target, combinations, [])\n        \n        return combinations\n    \n    def helper(self, candidates, target, combinations, current):\n        # If the target is 0, then the current combination is a valid answer\n        if target == 0:\n            combinations.append(current[:])\n            return\n        \n        # If the target is less than 0, then the current combination is not valid, so return\n        if target < 0:\n            return\n        \n        # Loop through each element in the list\n        for i in range(len(candidates)):\n            # Add the element to the current combination\n            current.append(candidates[i])\n            \n            # Call the helper function again to find the combinations\n            self.helper(candidates, target - candidates[i], combinations, current)\n            \n            # Remove the last element from the current combination\n            current.pop()"
        },
        {
            "task_id": "combination-sum",
            "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # Initialize an empty list to store the combinations\n        combinations = []\n        \n        # Call the helper function to find the combinations\n        self.helper(candidates, target, combinations, [], 0)\n        \n        return combinations\n    \n    def helper(self, candidates, target, combinations, current, index):\n        # If the target is 0, then the current combination is a valid answer\n        if target == 0:\n            combinations.append(current[:])\n            return\n        \n        # If the target is less than 0, then the current combination is not valid, so return\n        if target < 0:\n            return\n        \n        # Loop through the candidates list\n        for i in range(index, len(candidates)):\n            # Add the current candidate to the current combination\n            current.append(candidates[i])\n            \n            # Call the helper function again to find the combinations\n            self.helper(candidates, target - candidates[i], combinations, current, i)\n            \n            # Remove the current candidate from the current combination\n            current.pop()"
        },
        {
            "task_id": "combination-sum",
            "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # Initialize an empty list to store the combinations\n        combinations = []\n        \n        # Call the helper function to find the combinations\n        self.helper(candidates, target, combinations, [], 0)\n        \n        return combinations\n    \n    def helper(self, candidates, target, combinations, current, index):\n        # If the target is 0, then the current combination is a valid answer\n        if target == 0:\n            combinations.append(current[:])\n            return\n        \n        # If the target is less than 0, then the current combination is not valid, so return\n        if target < 0:\n            return\n        \n        # Loop through the candidates list\n        for i in range(index, len(candidates)):\n            # Add the current candidate to the current combination\n            current.append(candidates[i])\n            \n            # Call the helper function again to find the combinations\n            self.helper(candidates, target - candidates[i], combinations, current, i)\n            \n            # Remove the current candidate from the current combination\n            current.pop()"
        }
    ],
    "find-the-closest-palindrome": [
        {
            "task_id": "find-the-closest-palindrome",
            "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPalindrome(s):\n            return s + s[::-1]\n        \n        def getClosest(s):\n            l = len(s)\n            if l % 2 == 0:\n                return min(s[:l//2-1] + getPalindrome(s[l//2-1:]), s[:l//2] + getPalindrome(s[l//2:]))\n            else:\n                return min(s[:l//2] + getPalindrome(s[l//2+1:]), s[:l//2-1] + getPalindrome(s[l//2:]))\n        \n        if len(n) == 1:\n            return str(int(n)-1)\n        \n        l = len(n)\n        if isPalindrome(n):\n            return getClosest(n[:l//2-1] + n[l//2+1:])\n        \n        left = n[:l//2]\n        right = n[l//2:]\n        if left == right:\n            return getPalindrome(left)\n        \n        closest = getClosest(left)\n        if abs(int(closest) - int(n)) > abs(int(n[:l//2-1] + n[l//2+1:]) - int(n)):\n            return n[:l//2-1] + n[l//2+1:]\n        return closest"
        },
        {
            "task_id": "find-the-closest-palindrome",
            "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPalindrome(s):\n            return s + s[::-1]\n        \n        def getClosest(s):\n            left, right = s[:len(s) // 2], s[len(s) // 2:]\n            if left == right:\n                return s\n            if left > right:\n                right = left\n            else:\n                left = right\n            return left + right[::-1]\n        \n        n = int(n)\n        if n == 1:\n            return '0'\n        s = str(n)\n        if isPalindrome(s):\n            return getPalindrome(s[:len(s) // 2])\n        left, right = getPalindrome(s[:len(s) // 2]), getPalindrome(s[len(s) // 2 + 1:])\n        return str(min([n, left, right, getClosest(s)], key=lambda x: abs(x - n)))"
        },
        {
            "task_id": "find-the-closest-palindrome",
            "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPalindrome(s):\n            return s + s[::-1]\n        \n        def getClosest(s):\n            s = int(s)\n            s1 = (s // 10) + (s % 10)\n            s2 = int(s / 10)\n            return str(s1) + str(s1)[::-1] if abs(s - s1) < abs(s - s2) else str(s2) + str(s2)[::-1]\n        \n        if len(n) == 1:\n            return '0'\n        elif len(n) == 2:\n            return getPalindrome(n)\n        else:\n            mid = len(n) // 2\n            left = n[:mid]\n            right = n[mid:]\n            if left == right:\n                return getClosest(n)\n            else:\n                return getPalindrome(left + right)"
        },
        {
            "task_id": "find-the-closest-palindrome",
            "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPalindrome(s):\n            return s + s[::-1]\n        \n        def getClosest(s):\n            l = len(s)\n            if l % 2 == 0:\n                return min(s[:l//2-1] + getPalindrome(s[l//2-1:]), s[:l//2] + getPalindrome(s[l//2:]))\n            else:\n                return min(s[:l//2] + getPalindrome(s[l//2+1:]), s[:l//2-1] + getPalindrome(s[l//2:]))\n        \n        l = len(n)\n        if l == 1:\n            return str(int(n)-1)\n        elif l == 2:\n            return str(int(n)-1) if int(n) > 10 else \"99\"\n        else:\n            half = n[:l//2]\n            if isPalindrome(half):\n                return getClosest(half)\n            else:\n                return getPalindrome(half[:-1])"
        },
        {
            "task_id": "find-the-closest-palindrome",
            "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPalindrome(s):\n            return s + s[::-1]\n        \n        def getClosest(s):\n            s = int(s)\n            s1 = (s // 10) + (s % 10)\n            s2 = int(s / 10)\n            s3 = (s2 // 10) + (s2 % 10) * 10 + (s2 % 10)\n            s4 = int(s / 100) * 100 + int(s / 10) % 10 + int(s % 10)\n            return str(min(s1, s2, s3, s4, s))\n        \n        if len(n) == 1:\n            return str(int(n) - 1)\n        elif len(n) == 2:\n            if isPalindrome(n):\n                return getPalindrome(n)\n            else:\n                return getClosest(n)\n        else:\n            left, right = n[:len(n) // 2], n[len(n) // 2:]\n            if left == right:\n                return getPalindrome(left)\n            elif isPalindrome(left):\n                return getClosest(left)\n            else:\n                return getClosest(n)"
        }
    ],
    "spiral-matrix-ii": [
        {
            "task_id": "spiral-matrix-ii",
            "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Initialize the matrix\n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        # Initialize the variables\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        count = 1\n        \n        # Loop until all the elements are not filled\n        while count <= n * n:\n            \n            # Print the first row from the remaining rows\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = count\n                count += 1\n            row_start += 1\n            \n            # Print the last column from the remaining columns\n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = count\n                count += 1\n            col_end -= 1\n            \n            # Print the last row from the remaining rows\n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = count\n                    count += 1\n                row_end -= 1\n            \n            # Print the first column from the remaining columns\n            if col_start <= col_end:\n                for i in range(row_end, row_start - 1, -1):\n                    matrix[i][col_start] = count\n                    count += 1\n                col_start += 1\n        \n        return matrix"
        },
        {
            "task_id": "spiral-matrix-ii",
            "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        row_start = 0\n        row_end = n-1\n        col_start = 0\n        col_end = n-1\n        count = 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = count\n                count += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = count\n                count += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start-1, -1):\n                    matrix[row_end][i] = count\n                    count += 1\n                row_end -= 1\n                \n            if col_start <= col_end:\n                for i in range(row_end, row_start-1, -1):\n                    matrix[i][col_start] = count\n                    count += 1\n                col_start += 1\n                \n        return matrix"
        },
        {
            "task_id": "spiral-matrix-ii",
            "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        row_start = 0\n        row_end = n-1\n        col_start = 0\n        col_end = n-1\n        count = 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = count\n                count += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = count\n                count += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start-1, -1):\n                    matrix[row_end][i] = count\n                    count += 1\n                row_end -= 1\n                \n            if col_start <= col_end:\n                for i in range(row_end, row_start-1, -1):\n                    matrix[i][col_start] = count\n                    count += 1\n                col_start += 1\n                \n        return matrix"
        },
        {
            "task_id": "spiral-matrix-ii",
            "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        row_start = 0\n        row_end = n-1\n        col_start = 0\n        col_end = n-1\n        count = 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = count\n                count += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = count\n                count += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start-1, -1):\n                    matrix[row_end][i] = count\n                    count += 1\n                row_end -= 1\n                \n            if col_start <= col_end:\n                for i in range(row_end, row_start-1, -1):\n                    matrix[i][col_start] = count\n                    count += 1\n                col_start += 1\n                \n        return matrix"
        },
        {
            "task_id": "spiral-matrix-ii",
            "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        row_start = 0\n        row_end = n-1\n        col_start = 0\n        col_end = n-1\n        count = 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = count\n                count += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = count\n                count += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start-1, -1):\n                    matrix[row_end][i] = count\n                    count += 1\n                row_end -= 1\n                \n            if col_start <= col_end:\n                for i in range(row_end, row_start-1, -1):\n                    matrix[i][col_start] = count\n                    count += 1\n                col_start += 1\n                \n        return matrix"
        }
    ],
    "reverse-integer": [
        {
            "task_id": "reverse-integer",
            "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x > 0:\n            sign = 1\n        else:\n            sign = -1\n        \n        x = abs(x)\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        rev = rev * sign\n        \n        if rev < -2**31 or rev > 2**31 - 1:\n            return 0\n        else:\n            return rev"
        },
        {
            "task_id": "reverse-integer",
            "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x < 0:\n            x = -x\n            reverse = int(str(x)[::-1])\n            reverse = -reverse\n        else:\n            reverse = int(str(x)[::-1])\n        \n        if reverse < -2**31 or reverse > 2**31 - 1:\n            return 0\n        else:\n            return reverse"
        },
        {
            "task_id": "reverse-integer",
            "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x > 0:\n            sign = 1\n        else:\n            sign = -1\n        \n        x = abs(x)\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        rev = rev * sign\n        \n        if rev < -2**31 or rev > 2**31 - 1:\n            return 0\n        else:\n            return rev"
        },
        {
            "task_id": "reverse-integer",
            "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x < 0:\n            x = -x\n            rev = int(str(x)[::-1])\n            rev = -rev\n        else:\n            rev = int(str(x)[::-1])\n        \n        if rev < -2**31 or rev > 2**31 - 1:\n            return 0\n        else:\n            return rev"
        },
        {
            "task_id": "reverse-integer",
            "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            return -int(str(abs(x))[::-1])\n        else:\n            return int(str(x)[::-1])"
        }
    ],
    "rotate-image": [
        {
            "task_id": "rotate-image",
            "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"
        },
        {
            "task_id": "rotate-image",
            "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for layer in range(n//2):\n            first = layer\n            last = n - layer - 1\n            for i in range(first, last):\n                offset = i - first\n                # save top\n                top = matrix[first][i]\n                # left -> top\n                matrix[first][i] = matrix[last - offset][first]\n                # bottom -> left\n                matrix[last - offset][first] = matrix[last][last - offset]\n                # right -> bottom\n                matrix[last][last - offset] = matrix[first + offset][last]\n                # top -> right\n                matrix[first + offset][last] = top"
        },
        {
            "task_id": "rotate-image",
            "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"
        },
        {
            "task_id": "rotate-image",
            "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for layer in range(n//2):\n            first = layer\n            last = n - layer - 1\n            for i in range(first, last):\n                offset = i - first\n                # save top\n                top = matrix[first][i]\n                # left -> top\n                matrix[first][i] = matrix[last - offset][first]\n                # bottom -> left\n                matrix[last - offset][first] = matrix[last][last - offset]\n                # right -> bottom\n                matrix[last][last - offset] = matrix[first + offset][last]\n                # top -> right\n                matrix[first + offset][last] = top"
        },
        {
            "task_id": "rotate-image",
            "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"
        }
    ],
    "maximum-product-subarray": [
        {
            "task_id": "maximum-product-subarray",
            "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_product = nums[0]\n        min_product = nums[0]\n        max_so_far = nums[0]\n        min_so_far = nums[0]\n        \n        # Loop through the list\n        for i in range(1, len(nums)):\n            \n            # Calculate the max and min products\n            max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n            min_product = min(nums[i], max_product * nums[i], min_product * nums[i])\n            \n            # Calculate the max so far\n            max_so_far = max(max_so_far, max_product)\n            \n        return max_so_far"
        },
        {
            "task_id": "maximum-product-subarray",
            "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_product = nums[0]\n        min_product = nums[0]\n        max_so_far = nums[0]\n        min_so_far = nums[0]\n        \n        # Loop through the array\n        for i in range(1, len(nums)):\n            \n            # Calculate the max and min products\n            max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n            min_product = min(nums[i], max_product * nums[i], min_product * nums[i])\n            \n            # Calculate the max so far\n            max_so_far = max(max_so_far, max_product)\n            \n        return max_so_far"
        },
        {
            "task_id": "maximum-product-subarray",
            "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        max_so_far = nums[0]\n        min_so_far = nums[0]\n        \n        for i in range(1, len(nums)):\n            num = nums[i]\n            \n            max_product = max(num, max_product * num, min_product * num)\n            min_product = min(num, max_product * num, min_product * num)\n            \n            max_so_far = max(max_so_far, max_product)\n            min_so_far = min(min_so_far, min_product)\n            \n        return max_so_far"
        },
        {
            "task_id": "maximum-product-subarray",
            "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_product = nums[0]\n        min_product = nums[0]\n        max_so_far = nums[0]\n        min_so_far = nums[0]\n        \n        # Loop through the array\n        for i in range(1, len(nums)):\n            # Calculate the max and min products\n            max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n            min_product = min(nums[i], max_product * nums[i], min_product * nums[i])\n            \n            # Calculate the max so far\n            max_so_far = max(max_so_far, max_product)\n            \n        return max_so_far"
        },
        {
            "task_id": "maximum-product-subarray",
            "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_product = nums[0]\n        min_product = nums[0]\n        max_so_far = nums[0]\n        min_so_far = nums[0]\n        \n        # Loop through the list\n        for i in range(1, len(nums)):\n            \n            # Calculate the max and min products\n            max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n            min_product = min(nums[i], max_product * nums[i], min_product * nums[i])\n            \n            # Calculate the max so far\n            max_so_far = max(max_so_far, max_product)\n            \n        return max_so_far"
        }
    ],
    "frog-jump": [
        {
            "task_id": "frog-jump",
            "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) == 1:\n            return True\n        \n        if stones[1] != 1:\n            return False\n        \n        dp = [False] * len(stones)\n        dp[1] = True\n        \n        for i in range(2, len(stones)):\n            for j in range(i):\n                if dp[j] and stones[i] - stones[j] <= j + 1:\n                    dp[i] = True\n                    break\n                    \n        return dp[-1]"
        },
        {
            "task_id": "frog-jump",
            "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) == 1:\n            return True\n        \n        if stones[1] != 1:\n            return False\n        \n        dp = [False] * len(stones)\n        dp[1] = True\n        \n        for i in range(2, len(stones)):\n            for j in range(i):\n                if dp[j] and stones[i] - stones[j] <= j + 1:\n                    dp[i] = True\n                    break\n                    \n        return dp[-1]"
        },
        {
            "task_id": "frog-jump",
            "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) == 1:\n            return True\n        \n        if stones[1] != 1:\n            return False\n        \n        dp = [False] * len(stones)\n        dp[1] = True\n        \n        for i in range(2, len(stones)):\n            for j in range(i):\n                if dp[j] and stones[i] - stones[j] <= j + 1:\n                    dp[i] = True\n                    break\n                    \n        return dp[-1]"
        },
        {
            "task_id": "frog-jump",
            "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) == 1:\n            return True\n        \n        if stones[1] != 1:\n            return False\n        \n        dp = [False] * len(stones)\n        dp[1] = True\n        \n        for i in range(2, len(stones)):\n            for j in range(i):\n                if dp[j] and stones[i] - stones[j] <= j + 1:\n                    dp[i] = True\n                    break\n                    \n        return dp[-1]"
        },
        {
            "task_id": "frog-jump",
            "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) == 1:\n            return True\n        \n        if stones[1] != 1:\n            return False\n        \n        dp = [False] * len(stones)\n        dp[1] = True\n        \n        for i in range(2, len(stones)):\n            for j in range(i):\n                if dp[j] and stones[i] - stones[j] <= j + 1:\n                    dp[i] = True\n                    break\n                    \n        return dp[-1]"
        }
    ],
    "relative-ranks": [
        {
            "task_id": "relative-ranks",
            "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list in descending order\n        score.sort(reverse=True)\n        \n        # Create a dictionary to map the scores to their ranks\n        rank_dict = {score[i]: i+1 for i in range(len(score))}\n        \n        # Create a list to map the ranks to their corresponding medal\n        rank_medal = {1: \"Gold Medal\", 2: \"Silver Medal\", 3: \"Bronze Medal\"}\n        \n        # Create an empty list to store the final answer\n        answer = []\n        \n        # Iterate through each score and map it to its corresponding rank and medal\n        for s in score:\n            if rank_dict[s] in rank_medal:\n                answer.append(rank_medal[rank_dict[s]])\n            else:\n                answer.append(str(rank_dict[s]))\n                \n        return answer"
        },
        {
            "task_id": "relative-ranks",
            "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        rank = ['Gold Medal', 'Silver Medal', 'Bronze Medal'] + list(map(str, range(4, len(score) + 1)))\n        return [rank[i] for i in sorted(range(len(score)), key=score.__getitem__, reverse=True)]"
        },
        {
            "task_id": "relative-ranks",
            "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list in descending order\n        score.sort(reverse=True)\n        \n        # Create a dictionary to map the scores to their ranks\n        rank_map = {score[i]:str(i+1) for i in range(len(score))}\n        \n        # Create a list to map the ranks to their corresponding medal\n        rank_medal_map = {1:\"Gold Medal\", 2:\"Silver Medal\", 3:\"Bronze Medal\"}\n        \n        # Create a list to store the final answer\n        answer = []\n        \n        # Iterate through each score and map it to its corresponding rank and medal\n        for s in score:\n            if s in rank_medal_map:\n                answer.append(rank_medal_map[s])\n            else:\n                answer.append(rank_map[s])\n                \n        return answer"
        },
        {
            "task_id": "relative-ranks",
            "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list in descending order\n        score.sort(reverse=True)\n        \n        # Create a dictionary to map the scores to their ranks\n        rank_map = {score[i]:str(i+1) for i in range(len(score))}\n        \n        # Create a list to map the ranks to their corresponding medal\n        rank_medal_map = {1:\"Gold Medal\", 2:\"Silver Medal\", 3:\"Bronze Medal\"}\n        \n        # Create a list to store the final answer\n        answer = []\n        \n        # Iterate through each score and map it to its corresponding rank and medal\n        for s in score:\n            if s in rank_medal_map:\n                answer.append(rank_medal_map[s])\n            else:\n                answer.append(rank_map[s])\n                \n        return answer"
        },
        {
            "task_id": "relative-ranks",
            "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list in descending order\n        score.sort(reverse=True)\n        \n        # Create a dictionary to map the scores to their ranks\n        rank_dict = {score[i]: i+1 for i in range(len(score))}\n        \n        # Create a list to map the ranks to their corresponding medal\n        rank_medal = {1: \"Gold Medal\", 2: \"Silver Medal\", 3: \"Bronze Medal\"}\n        \n        # Create an empty list to store the final answer\n        answer = []\n        \n        # Iterate through the scores and map them to their corresponding rank and medal\n        for i in score:\n            if rank_dict[i] in rank_medal:\n                answer.append(rank_medal[rank_dict[i]])\n            else:\n                answer.append(str(rank_dict[i]))\n                \n        return answer"
        }
    ],
    "longest-substring-without-repeating-characters": [
        {
            "task_id": "longest-substring-without-repeating-characters",
            "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_len = 0\n        curr_len = 0\n        start = 0\n        end = 0\n        s_len = len(s)\n        \n        # Edge case\n        if s_len == 0:\n            return 0\n        \n        # Loop through the string\n        while end < s_len:\n            \n            # If the character is not in the current window\n            if s[end] not in s[start:end]:\n                curr_len += 1\n                end += 1\n                \n            # If the character is in the current window\n            else:\n                max_len = max(max_len, curr_len)\n                start = s.index(s[end]) + 1\n                curr_len = end - start + 1\n                end += 1\n                \n        # Update the max length\n        max_len = max(max_len, curr_len)\n        \n        return max_len"
        },
        {
            "task_id": "longest-substring-without-repeating-characters",
            "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_len = 0\n        curr_len = 0\n        start = 0\n        end = 0\n        char_dict = {}\n        \n        # Loop through the string\n        while end < len(s):\n            \n            # If the character is not in the dictionary\n            if s[end] not in char_dict:\n                \n                # Add the character to the dictionary\n                char_dict[s[end]] = end\n                \n                # Increment the end pointer\n                end += 1\n                \n                # Increment the current length\n                curr_len += 1\n                \n            # If the character is in the dictionary\n            else:\n                \n                # Get the index of the character\n                prev_index = char_dict[s[end]]\n                \n                # If the previous index is less than the start\n                if prev_index < start:\n                    \n                    # Increment the end pointer\n                    end += 1\n                    \n                    # Increment the current length\n                    curr_len += 1\n                    \n                # If the previous index is greater than or equal to the start\n                else:\n                    \n                    # Update the maximum length\n                    max_len = max(max_len, curr_len)\n                    \n                    # Update the start pointer\n                    start = prev_index + 1\n                    \n                    # Update the current length\n                    curr_len = end - start + 1\n                    \n                    # Add the character to the dictionary\n                    char_dict[s[end]] = end\n                    \n                    # Increment the end pointer\n                    end += 1\n                    \n        # Update the maximum length\n        max_len = max(max_len, curr_len)\n        \n        # Return the maximum length\n        return max_len"
        },
        {
            "task_id": "longest-substring-without-repeating-characters",
            "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_len = 0\n        curr_len = 0\n        start = 0\n        end = 0\n        s_len = len(s)\n        \n        # Edge case\n        if s_len == 0:\n            return 0\n        \n        # Loop through the string\n        while end < s_len:\n            \n            # If the character is not in the current window\n            if s[end] not in s[start:end]:\n                curr_len += 1\n                end += 1\n                \n            # If the character is in the current window\n            else:\n                max_len = max(max_len, curr_len)\n                start = s.index(s[end]) + 1\n                curr_len = end - start + 1\n                end += 1\n                \n        # Update the max length\n        max_len = max(max_len, curr_len)\n        \n        return max_len"
        },
        {
            "task_id": "longest-substring-without-repeating-characters",
            "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_len = 0\n        curr_len = 0\n        start = 0\n        end = 0\n        s_len = len(s)\n        \n        # If string is empty, return 0\n        if s_len == 0:\n            return 0\n        \n        # If string has only one character, return 1\n        if s_len == 1:\n            return 1\n        \n        # Loop through string\n        while end < s_len:\n            \n            # If character is not in substring, add it\n            if s[end] not in s[start:end]:\n                curr_len += 1\n                end += 1\n                \n            # If character is in substring, remove it and all characters before it\n            else:\n                max_len = max(max_len, curr_len)\n                start = s.index(s[end]) + 1\n                curr_len = end - start + 1\n                \n        # Return max length\n        return max(max_len, curr_len)"
        },
        {
            "task_id": "longest-substring-without-repeating-characters",
            "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_len = 0\n        curr_len = 0\n        start = 0\n        end = 0\n        s_len = len(s)\n        \n        # If the string is empty, return 0\n        if s_len == 0:\n            return 0\n        \n        # If the string has only one character, return 1\n        if s_len == 1:\n            return 1\n        \n        # Loop through the string\n        while end < s_len:\n            \n            # If the character is not in the substring, add it\n            if s[end] not in s[start:end]:\n                curr_len += 1\n                end += 1\n                \n            # If the character is in the substring\n            else:\n                \n                # Update the max length\n                if curr_len > max_len:\n                    max_len = curr_len\n                \n                # Update the start index\n                start = s.index(s[end]) + 1\n                \n                # Update the current length\n                curr_len = end - start + 1\n                \n                # Update the end index\n                end += 1\n                \n        # Update the max length\n        if curr_len > max_len:\n            max_len = curr_len\n            \n        return max_len"
        }
    ],
    "substring-with-concatenation-of-all-words": [
        {
            "task_id": "substring-with-concatenation-of-all-words",
            "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        total_len = word_len * len(words)\n        word_dict = {}\n        for word in words:\n            if word not in word_dict:\n                word_dict[word] = 1\n            else:\n                word_dict[word] += 1\n        \n        result = []\n        for i in range(len(s) - total_len + 1):\n            if self.check_substring(s[i:i+total_len], word_len, word_dict):\n                result.append(i)\n                \n        return result\n    \n    def check_substring(self, s, word_len, word_dict):\n        word_count = {}\n        for i in range(0, len(s), word_len):\n            word = s[i:i+word_len]\n            if word not in word_dict:\n                return False\n            if word not in word_count:\n                word_count[word] = 1\n            else:\n                word_count[word] += 1\n            if word_count[word] > word_dict[word]:\n                return False\n        return True"
        },
        {
            "task_id": "substring-with-concatenation-of-all-words",
            "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        total_len = word_len * len(words)\n        word_dict = {}\n        for word in words:\n            if word not in word_dict:\n                word_dict[word] = 1\n            else:\n                word_dict[word] += 1\n        \n        result = []\n        for i in range(len(s) - total_len + 1):\n            substr = s[i:i+total_len]\n            substr_dict = {}\n            for j in range(0, total_len, word_len):\n                word = substr[j:j+word_len]\n                if word not in word_dict:\n                    break\n                if word not in substr_dict:\n                    substr_dict[word] = 1\n                else:\n                    substr_dict[word] += 1\n                if substr_dict[word] > word_dict[word]:\n                    break\n            else:\n                result.append(i)\n        return result"
        },
        {
            "task_id": "substring-with-concatenation-of-all-words",
            "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_num = len(words)\n        total_len = word_len * word_num\n        \n        word_dict = {}\n        for word in words:\n            if word not in word_dict:\n                word_dict[word] = 1\n            else:\n                word_dict[word] += 1\n        \n        result = []\n        for i in range(len(s) - total_len + 1):\n            if s[i:i+word_len] in word_dict:\n                word_dict[s[i:i+word_len]] -= 1\n                if word_dict[s[i:i+word_len]] == 0:\n                    del word_dict[s[i:i+word_len]]\n                j = 1\n                while j < word_num:\n                    if s[i+j*word_len:i+(j+1)*word_len] in word_dict:\n                        word_dict[s[i+j*word_len:i+(j+1)*word_len]] -= 1\n                        if word_dict[s[i+j*word_len:i+(j+1)*word_len]] == 0:\n                            del word_dict[s[i+j*word_len:i+(j+1)*word_len]]\n                        j += 1\n                    else:\n                        break\n                if len(word_dict) == 0:\n                    result.append(i)\n                for k in range(j, word_num):\n                    word = s[i+k*word_len:i+(k+1)*word_len]\n                    if word in word_dict:\n                        word_dict[word] += 1\n            else:\n                continue\n            word_dict = {}\n            for word in words:\n                word_dict[word] = 1\n        \n        return result"
        },
        {
            "task_id": "substring-with-concatenation-of-all-words",
            "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_num = len(words)\n        total_len = word_len * word_num\n        \n        word_dict = {}\n        for word in words:\n            if word not in word_dict:\n                word_dict[word] = 1\n            else:\n                word_dict[word] += 1\n        \n        result = []\n        for i in range(len(s) - total_len + 1):\n            if s[i:i+word_len] in word_dict:\n                word_dict[s[i:i+word_len]] -= 1\n                j = 1\n                while j < word_num and s[i+j*word_len:i+(j+1)*word_len] in word_dict:\n                    word_dict[s[i+j*word_len:i+(j+1)*word_len]] -= 1\n                    j += 1\n                if j == word_num:\n                    result.append(i)\n                for k in range(j):\n                    word_dict[s[i+k*word_len:i+(k+1)*word_len]] += 1\n        return result"
        },
        {
            "task_id": "substring-with-concatenation-of-all-words",
            "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        total_len = word_len * len(words)\n        word_dict = {}\n        for word in words:\n            if word not in word_dict:\n                word_dict[word] = 1\n            else:\n                word_dict[word] += 1\n        \n        result = []\n        for i in range(len(s) - total_len + 1):\n            substr = s[i:i+total_len]\n            substr_dict = {}\n            for j in range(0, total_len, word_len):\n                word = substr[j:j+word_len]\n                if word not in word_dict:\n                    break\n                if word not in substr_dict:\n                    substr_dict[word] = 1\n                else:\n                    substr_dict[word] += 1\n                if substr_dict[word] > word_dict[word]:\n                    break\n            else:\n                result.append(i)\n        return result"
        }
    ],
    "max-chunks-to-make-sorted-ii": [
        {
            "task_id": "max-chunks-to-make-sorted-ii",
            "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a list to store the count of each element in the array\n        count = [0] * 1000\n        \n        # Store the count of each element in the array\n        for num in arr:\n            count[num] += 1\n            \n        # Initialize a variable to store the maximum number of chunks\n        max_chunks = 0\n        \n        # Initialize a variable to store the count of elements less than or equal to the index\n        elements_count = 0\n        \n        # Iterate through the count array\n        for i, x in enumerate(count):\n            \n            # Add the count of elements less than or equal to the index\n            elements_count += x\n            \n            # If the count of elements is equal to the index, it means that the elements\n            # have been sorted till the index, so increment the maximum number of chunks\n            if elements_count == i + 1:\n                max_chunks += 1\n                \n        return max_chunks"
        },
        {
            "task_id": "max-chunks-to-make-sorted-ii",
            "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_val = -1\n        count = 0\n        \n        # Iterate through the list\n        for i in range(len(arr)):\n            \n            # If the current element is greater than max_val, then it is the largest element so far\n            if arr[i] > max_val:\n                max_val = arr[i]\n                \n                # Increment the count\n                count += 1\n                \n        return count"
        },
        {
            "task_id": "max-chunks-to-make-sorted-ii",
            "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_val = -1\n        count = 0\n        \n        # Iterate through the list\n        for i in range(len(arr)):\n            \n            # If the current element is greater than max_val\n            # then increment the count\n            if arr[i] > max_val:\n                max_val = arr[i]\n                count += 1\n                \n        return count"
        },
        {
            "task_id": "max-chunks-to-make-sorted-ii",
            "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_val = -1\n        count = 0\n        \n        # Iterate through the list\n        for i in range(len(arr)):\n            \n            # If the current value is greater than max_val, then it is the largest value so far\n            if arr[i] > max_val:\n                max_val = arr[i]\n                count += 1\n                \n        return count"
        },
        {
            "task_id": "max-chunks-to-make-sorted-ii",
            "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_val = 0\n        count = 0\n        \n        # Iterate through the list\n        for i in range(len(arr)):\n            \n            # If the current value is greater than max_val, then it is the largest value in the subarray\n            if arr[i] > max_val:\n                max_val = arr[i]\n                \n            # If the current value is equal to the index of the subarray, then it is sorted\n            if arr[i] == i:\n                count += 1\n                \n        return count"
        }
    ],
    "insertion-sort-list": [
        {
            "task_id": "insertion-sort-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        pre = head\n        \n        while cur:\n            if cur.val >= pre.val:\n                pre = cur\n                cur = cur.next\n            else:\n                tmp = cur.next\n                cur.next = pre.next\n                pre.next = cur\n                pre = cur\n                cur = tmp\n                \n        return dummy.next"
        },
        {
            "task_id": "insertion-sort-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        pre = head\n        \n        while cur:\n            if cur.val >= pre.val:\n                pre = cur\n                cur = cur.next\n            else:\n                tmp = cur.next\n                cur.next = pre.next\n                pre.next = cur\n                pre = cur\n                cur = tmp\n                \n        return dummy.next"
        },
        {
            "task_id": "insertion-sort-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        pre = head\n        \n        while cur:\n            if cur.val >= pre.val:\n                pre = cur\n                cur = cur.next\n            else:\n                tmp = cur.next\n                cur.next = pre.next\n                pre.next = cur\n                pre = cur\n                cur = tmp\n                \n        return dummy.next"
        },
        {
            "task_id": "insertion-sort-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        pre = head\n        \n        while cur:\n            if cur.val >= pre.val:\n                pre = cur\n                cur = cur.next\n            else:\n                tmp = cur.next\n                cur.next = pre.next\n                pre.next = cur\n                pre = cur\n                cur = tmp\n                \n        return dummy.next"
        },
        {
            "task_id": "insertion-sort-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        pre = head\n        \n        while cur:\n            if cur.val >= pre.val:\n                pre = cur\n                cur = cur.next\n            else:\n                tmp = cur.next\n                cur.next = pre.next\n                pre.next = cur\n                pre = cur\n                cur = tmp\n                \n        return dummy.next"
        }
    ],
    "remove-duplicates-from-sorted-list-ii": [
        {
            "task_id": "remove-duplicates-from-sorted-list-ii",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            while head.next is not None and head.val == head.next.val:\n                head = head.next\n            return self.deleteDuplicates(head.next)\n        else:\n            head.next = self.deleteDuplicates(head.next)\n            return head"
        },
        {
            "task_id": "remove-duplicates-from-sorted-list-ii",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            while head.next is not None and head.val == head.next.val:\n                head = head.next\n            return self.deleteDuplicates(head.next)\n        else:\n            head.next = self.deleteDuplicates(head.next)\n            return head"
        },
        {
            "task_id": "remove-duplicates-from-sorted-list-ii",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            while head.next is not None and head.val == head.next.val:\n                head = head.next\n            return self.deleteDuplicates(head.next)\n        else:\n            head.next = self.deleteDuplicates(head.next)\n            return head"
        },
        {
            "task_id": "remove-duplicates-from-sorted-list-ii",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            while head.next is not None and head.val == head.next.val:\n                head = head.next\n            return self.deleteDuplicates(head.next)\n        else:\n            head.next = self.deleteDuplicates(head.next)\n            return head"
        },
        {
            "task_id": "remove-duplicates-from-sorted-list-ii",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            while head.next is not None and head.val == head.next.val:\n                head = head.next\n            return self.deleteDuplicates(head.next)\n        else:\n            head.next = self.deleteDuplicates(head.next)\n            return head"
        }
    ],
    "3sum": [
        {
            "task_id": "3sum",
            "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Initialize the result list\n        result = []\n        \n        # Loop through the list\n        for i in range(len(nums)-2):\n            \n            # Initialize the left and right pointers\n            l = i + 1\n            r = len(nums) - 1\n            \n            # Check if the number at the current index is not equal to zero\n            if nums[i] != 0:\n                \n                # Loop through the list\n                while l < r:\n                    \n                    # Check if the sum of the current index and the left and right pointers is equal to zero\n                    if nums[i] + nums[l] + nums[r] == 0:\n                        \n                        # Add the current index, left, and right pointers to the result list\n                        result.append([nums[i], nums[l], nums[r]])\n                        \n                        # Increment the left pointer\n                        l += 1\n                        \n                        # Decrement the right pointer\n                        r -= 1\n                        \n                    # Check if the sum of the current index and the left and right pointers is less than zero\n                    elif nums[i] + nums[l] + nums[r] < 0:\n                        \n                        # Increment the left pointer\n                        l += 1\n                        \n                    # Check if the sum of the current index and the left and right pointers is greater than zero\n                    else:\n                        \n                        # Decrement the right pointer\n                        r -= 1\n                        \n        # Return the result list\n        return result"
        },
        {
            "task_id": "3sum",
            "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Initialize the result list\n        result = []\n        \n        # Loop through the list\n        for i in range(len(nums)-2):\n            \n            # Initialize the left and right pointers\n            l = i + 1\n            r = len(nums) - 1\n            \n            # Check if the number at the current index is not equal to zero\n            if nums[i] != 0:\n                \n                # Loop through the list\n                while l < r:\n                    \n                    # Check if the sum of the current index, left and right is equal to zero\n                    if nums[i] + nums[l] + nums[r] == 0:\n                        \n                        # Add the current index, left and right to the result list\n                        result.append([nums[i], nums[l], nums[r]])\n                        \n                        # Increment the left pointer\n                        l += 1\n                        \n                        # Decrement the right pointer\n                        r -= 1\n                        \n                    # Check if the sum of the current index, left and right is less than zero\n                    elif nums[i] + nums[l] + nums[r] < 0:\n                        \n                        # Increment the left pointer\n                        l += 1\n                        \n                    # Check if the sum of the current index, left and right is greater than zero\n                    else:\n                        \n                        # Decrement the right pointer\n                        r -= 1\n                        \n        # Return the result list\n        return result"
        },
        {
            "task_id": "3sum",
            "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Initialize the result list\n        result = []\n        \n        # Loop through the list\n        for i in range(len(nums)-2):\n            \n            # Initialize the left and right pointers\n            l = i + 1\n            r = len(nums) - 1\n            \n            # Check if the number at the current index is not equal to zero\n            if nums[i] != 0:\n                \n                # Loop through the list\n                while l < r:\n                    \n                    # Check if the sum of the current index, left and right is equal to zero\n                    if nums[i] + nums[l] + nums[r] == 0:\n                        \n                        # Add the current index, left and right to the result list\n                        result.append([nums[i], nums[l], nums[r]])\n                        \n                        # Increment the left pointer\n                        l += 1\n                        \n                        # Decrement the right pointer\n                        r -= 1\n                        \n                    # Check if the sum of the current index, left and right is less than zero\n                    elif nums[i] + nums[l] + nums[r] < 0:\n                        \n                        # Increment the left pointer\n                        l += 1\n                        \n                    # Check if the sum of the current index, left and right is greater than zero\n                    else:\n                        \n                        # Decrement the right pointer\n                        r -= 1\n                        \n        # Return the result list\n        return result"
        },
        {
            "task_id": "3sum",
            "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Initialize the result list\n        result = []\n        \n        # Loop through the list\n        for i in range(len(nums)-2):\n            \n            # Initialize the left and right pointers\n            l = i + 1\n            r = len(nums) - 1\n            \n            # Check for the sum\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                \n                # Check for the sum\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    result.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n                    \n        return result"
        },
        {
            "task_id": "3sum",
            "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Initialize the result list\n        result = []\n        \n        # Loop through the list\n        for i in range(len(nums)-2):\n            \n            # Initialize the left and right pointers\n            l = i + 1\n            r = len(nums) - 1\n            \n            # Check for the sum\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                \n                # Check for the sum\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    result.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n                    \n        return result"
        }
    ],
    "edit-distance": [
        {
            "task_id": "edit-distance",
            "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp matrix\n        dp = [[0 for i in range(len(word2)+1)] for j in range(len(word1)+1)]\n        \n        # Fill the first row and first column with the values\n        for i in range(1, len(word1)+1):\n            dp[i][0] = i\n        for j in range(1, len(word2)+1):\n            dp[0][j] = j\n            \n        # Fill the rest of the dp matrix\n        for i in range(1, len(word1)+1):\n            for j in range(1, len(word2)+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\n                    \n        return dp[len(word1)][len(word2)]"
        },
        {
            "task_id": "edit-distance",
            "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp table\n        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]\n        \n        # Fill in the table\n        for i in range(1, len(word1) + 1):\n            for j in range(1, len(word2) + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        # Return the result\n        return len(word1) + len(word2) - 2 * dp[-1][-1]"
        },
        {
            "task_id": "edit-distance",
            "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp table\n        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]\n        \n        # Fill in the table\n        for i in range(1, len(word1) + 1):\n            for j in range(1, len(word2) + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        # Return the result\n        return len(word1) + len(word2) - 2 * dp[-1][-1]"
        },
        {
            "task_id": "edit-distance",
            "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp table\n        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]\n        \n        # Fill in the table\n        for i in range(1, len(word1) + 1):\n            for j in range(1, len(word2) + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        # Return the result\n        return len(word1) + len(word2) - 2 * dp[-1][-1]"
        },
        {
            "task_id": "edit-distance",
            "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp table\n        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]\n        \n        # Fill in the table\n        for i in range(1, len(word1) + 1):\n            for j in range(1, len(word2) + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        # Return the result\n        return len(word1) + len(word2) - 2 * dp[-1][-1]"
        }
    ],
    "hamming-distance": [
        {
            "task_id": "hamming-distance",
            "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x^y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"
        },
        {
            "task_id": "hamming-distance",
            "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x^y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"
        },
        {
            "task_id": "hamming-distance",
            "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x^y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"
        },
        {
            "task_id": "hamming-distance",
            "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x^y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"
        },
        {
            "task_id": "hamming-distance",
            "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x^y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"
        }
    ],
    "binary-tree-paths": [
        {
            "task_id": "binary-tree-paths",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        paths = []\n        self.traverse(root, \"\", paths)\n        return paths\n    \n    def traverse(self, node, path, paths):\n        if node.left is None and node.right is None:\n            paths.append(path + str(node.val))\n            return\n        \n        if node.left is not None:\n            self.traverse(node.left, path + str(node.val) + \"->\", paths)\n        \n        if node.right is not None:\n            self.traverse(node.right, path + str(node.val) + \"->\", paths)"
        },
        {
            "task_id": "binary-tree-paths",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        paths = []\n        self.traverse(root, \"\", paths)\n        return paths\n    \n    def traverse(self, node, path, paths):\n        if node.left is None and node.right is None:\n            paths.append(path + str(node.val))\n            return\n        \n        if node.left is not None:\n            self.traverse(node.left, path + str(node.val) + \"->\", paths)\n        \n        if node.right is not None:\n            self.traverse(node.right, path + str(node.val) + \"->\", paths)"
        },
        {
            "task_id": "binary-tree-paths",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        paths = []\n        self.traverse(root, \"\", paths)\n        return paths\n    \n    def traverse(self, node, path, paths):\n        if node.left is None and node.right is None:\n            paths.append(path + str(node.val))\n            return\n        \n        if node.left is not None:\n            self.traverse(node.left, path + str(node.val) + \"->\", paths)\n        \n        if node.right is not None:\n            self.traverse(node.right, path + str(node.val) + \"->\", paths)"
        },
        {
            "task_id": "binary-tree-paths",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        paths = []\n        self.findPaths(root, \"\", paths)\n        return paths\n    \n    def findPaths(self, root, path, paths):\n        if root.left is None and root.right is None:\n            paths.append(path + str(root.val))\n            return\n        \n        if root.left is not None:\n            self.findPaths(root.left, path + str(root.val) + \"->\", paths)\n        \n        if root.right is not None:\n            self.findPaths(root.right, path + str(root.val) + \"->\", paths)"
        },
        {
            "task_id": "binary-tree-paths",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        paths = []\n        self.traverse(root, \"\", paths)\n        return paths\n    \n    def traverse(self, root, path, paths):\n        if root.left is None and root.right is None:\n            paths.append(path + str(root.val))\n            return\n        \n        if root.left is not None:\n            self.traverse(root.left, path + str(root.val) + \"->\", paths)\n        \n        if root.right is not None:\n            self.traverse(root.right, path + str(root.val) + \"->\", paths)"
        }
    ],
    "reverse-pairs": [
        {
            "task_id": "reverse-pairs",
            "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            result = []\n            i, j = 0, 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        def count_pairs(nums):\n            count = 0\n            for i in range(len(nums)):\n                for j in range(i+1, len(nums)):\n                    if nums[i] > 2 * nums[j]:\n                        count += 1\n            return count\n        \n        return count_pairs(merge_sort(nums))"
        },
        {
            "task_id": "reverse-pairs",
            "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            result = []\n            i, j = 0, 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        def count_pairs(nums):\n            count = 0\n            for i in range(len(nums)):\n                for j in range(i+1, len(nums)):\n                    if nums[i] > 2 * nums[j]:\n                        count += 1\n            return count\n        \n        return count_pairs(merge_sort(nums))"
        },
        {
            "task_id": "reverse-pairs",
            "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            result = []\n            i, j = 0, 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        def count_pairs(nums):\n            count = 0\n            for i in range(len(nums)):\n                for j in range(i+1, len(nums)):\n                    if nums[i] > 2 * nums[j]:\n                        count += 1\n            return count\n        \n        return count_pairs(merge_sort(nums))"
        },
        {
            "task_id": "reverse-pairs",
            "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            result = []\n            i, j = 0, 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        def count_pairs(nums):\n            count = 0\n            for i in range(len(nums)):\n                for j in range(i+1, len(nums)):\n                    if nums[i] > 2 * nums[j]:\n                        count += 1\n            return count\n        \n        return count_pairs(merge_sort(nums))"
        },
        {
            "task_id": "reverse-pairs",
            "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            result = []\n            i, j = 0, 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        def count_pairs(nums):\n            count = 0\n            for i in range(len(nums)):\n                for j in range(i+1, len(nums)):\n                    if nums[i] > 2 * nums[j]:\n                        count += 1\n            return count\n        \n        return count_pairs(merge_sort(nums))"
        }
    ],
    "reaching-points": [
        {
            "task_id": "reaching-points",
            "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while sx < tx and sy < ty:\n            if tx < ty:\n                ty %= tx\n            else:\n                tx %= ty\n        if sx == tx and sy == ty:\n            return True\n        elif sx == tx:\n            return (ty - sy) % sx == 0\n        elif sy == ty:\n            return (tx - sx) % sy == 0\n        else:\n            return False"
        },
        {
            "task_id": "reaching-points",
            "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while sx < tx and sy < ty:\n            if tx < ty:\n                ty %= tx\n            else:\n                tx %= ty\n        if sx == tx and sy == ty:\n            return True\n        elif sx == tx:\n            return (ty - sy) % sx == 0\n        elif sy == ty:\n            return (tx - sx) % sy == 0\n        else:\n            return False"
        },
        {
            "task_id": "reaching-points",
            "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while sx < tx and sy < ty:\n            if tx < ty:\n                ty %= tx\n            else:\n                tx %= ty\n        if sx == tx and sy == ty:\n            return True\n        elif sx == tx:\n            return (ty - sy) % sx == 0\n        elif sy == ty:\n            return (tx - sx) % sy == 0\n        else:\n            return False"
        },
        {
            "task_id": "reaching-points",
            "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while sx < tx and sy < ty:\n            if tx < ty:\n                ty %= tx\n            else:\n                tx %= ty\n        if sx == tx and sy == ty:\n            return True\n        elif sx == tx:\n            return (ty - sy) % sx == 0\n        elif sy == ty:\n            return (tx - sx) % sy == 0\n        else:\n            return False"
        },
        {
            "task_id": "reaching-points",
            "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while sx < tx and sy < ty:\n            if tx < ty:\n                ty %= tx\n            else:\n                tx %= ty\n        if sx == tx and sy == ty:\n            return True\n        elif sx == tx:\n            return (ty - sy) % sx == 0\n        elif sy == ty:\n            return (tx - sx) % sy == 0\n        else:\n            return False"
        }
    ],
    "compare-version-numbers": [
        {
            "task_id": "compare-version-numbers",
            "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        l1 = len(v1)\n        l2 = len(v2)\n        \n        if l1 > l2:\n            for i in range(l1-l2):\n                v2.append('0')\n        elif l1 < l2:\n            for i in range(l2-l1):\n                v1.append('0')\n        \n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0"
        },
        {
            "task_id": "compare-version-numbers",
            "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        l1 = len(v1)\n        l2 = len(v2)\n        \n        if l1 > l2:\n            v2 += ['0'] * (l1 - l2)\n        elif l1 < l2:\n            v1 += ['0'] * (l2 - l1)\n        \n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0"
        },
        {
            "task_id": "compare-version-numbers",
            "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        l1 = len(v1)\n        l2 = len(v2)\n        \n        if l1 > l2:\n            v2 += ['0'] * (l1 - l2)\n        elif l1 < l2:\n            v1 += ['0'] * (l2 - l1)\n        \n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0"
        },
        {
            "task_id": "compare-version-numbers",
            "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        l1 = len(v1)\n        l2 = len(v2)\n        \n        if l1 > l2:\n            for i in range(l1-l2):\n                v2.append('0')\n        elif l1 < l2:\n            for i in range(l2-l1):\n                v1.append('0')\n        \n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0"
        },
        {
            "task_id": "compare-version-numbers",
            "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        l1 = len(v1)\n        l2 = len(v2)\n        \n        if l1 > l2:\n            v2 += ['0'] * (l1 - l2)\n        elif l1 < l2:\n            v1 += ['0'] * (l2 - l1)\n        \n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0"
        }
    ],
    "best-time-to-buy-and-sell-stock-ii": [
        {
            "task_id": "best-time-to-buy-and-sell-stock-ii",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        buy_price = 0\n        sell_price = 0\n        \n        # Loop through the list of prices.\n        for i in range(len(prices)):\n            \n            # Check if the current price is less than the buy price or if the buy price is 0.\n            if prices[i] < buy_price or buy_price == 0:\n                \n                # If so, set the buy price to the current price.\n                buy_price = prices[i]\n                \n            # Check if the current price is greater than the sell price.\n            if prices[i] > sell_price:\n                \n                # If so, set the sell price to the current price.\n                sell_price = prices[i]\n                \n            # Check if the sell price minus the buy price is greater than the max profit.\n            if sell_price - buy_price > max_profit:\n                \n                # If so, set the max profit to the sell price minus the buy price.\n                max_profit = sell_price - buy_price\n                \n        # Return the max profit.\n        return max_profit"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-ii",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        buy_price = 0\n        sell_price = 0\n        \n        # Loop through the list of prices.\n        for i in range(len(prices)):\n            \n            # Check if the current price is less than the buy price or if the buy price is 0.\n            if prices[i] < buy_price or buy_price == 0:\n                \n                # If so, set the buy price to the current price.\n                buy_price = prices[i]\n                \n            # Check if the current price is greater than the sell price.\n            if prices[i] > sell_price:\n                \n                # If so, set the sell price to the current price.\n                sell_price = prices[i]\n                \n            # Check if the sell price minus the buy price is greater than the max profit.\n            if sell_price - buy_price > max_profit:\n                \n                # If so, set the max profit to the sell price minus the buy price.\n                max_profit = sell_price - buy_price\n                \n        # Return the max profit.\n        return max_profit"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-ii",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        buy_price = 0\n        sell_price = 0\n        \n        # Loop through the list of prices.\n        for i in range(len(prices)):\n            \n            # Check if the current price is less than the buy price or if the buy price is 0.\n            if prices[i] < buy_price or buy_price == 0:\n                \n                # If so, set the buy price to the current price.\n                buy_price = prices[i]\n                \n            # Check if the current price is greater than the sell price.\n            if prices[i] > sell_price:\n                \n                # If so, set the sell price to the current price.\n                sell_price = prices[i]\n                \n            # Check if the sell price minus the buy price is greater than the max profit.\n            if sell_price - buy_price > max_profit:\n                \n                # If so, set the max profit to the sell price minus the buy price.\n                max_profit = sell_price - buy_price\n                \n        # Return the max profit.\n        return max_profit"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-ii",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        buy_price = 0\n        sell_price = 0\n        \n        # Loop through the list of prices.\n        for i in range(len(prices)):\n            \n            # Check if the current price is less than the buy price or if the buy price is 0.\n            if prices[i] < buy_price or buy_price == 0:\n                \n                # If so, set the buy price to the current price.\n                buy_price = prices[i]\n                \n            # Check if the current price is greater than the sell price.\n            if prices[i] > sell_price:\n                \n                # If so, set the sell price to the current price.\n                sell_price = prices[i]\n                \n            # Check if the sell price minus the buy price is greater than the max profit.\n            if sell_price - buy_price > max_profit:\n                \n                # If so, set the max profit to the sell price minus the buy price.\n                max_profit = sell_price - buy_price\n                \n        # Return the max profit.\n        return max_profit"
        },
        {
            "task_id": "best-time-to-buy-and-sell-stock-ii",
            "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        buy_price = 0\n        sell_price = 0\n        \n        # Loop through the list of prices.\n        for i in range(len(prices)):\n            \n            # Check if the current price is less than the buy price or if the buy price is 0.\n            if prices[i] < buy_price or buy_price == 0:\n                \n                # If so, set the buy price to the current price.\n                buy_price = prices[i]\n                \n            # Check if the current price is greater than the sell price.\n            if prices[i] > sell_price:\n                \n                # If so, set the sell price to the current price.\n                sell_price = prices[i]\n                \n            # Check if the sell price minus the buy price is greater than the max profit.\n            if sell_price - buy_price > max_profit:\n                \n                # If so, set the max profit to the sell price minus the buy price.\n                max_profit = sell_price - buy_price\n                \n        # Return the max profit.\n        return max_profit"
        }
    ],
    "course-schedule-iii": [
        {
            "task_id": "course-schedule-iii",
            "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        max_heap = []\n        cur_time = 0\n        for course in courses:\n            if cur_time + course[0] <= course[1]:\n                heapq.heappush(max_heap, -course[0])\n                cur_time += course[0]\n            elif max_heap and -max_heap[0] > course[0]:\n                cur_time += course[0] - max_heap[0]\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, -course[0])\n        return len(max_heap)"
        },
        {
            "task_id": "course-schedule-iii",
            "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        max_heap = []\n        time = 0\n        for course in courses:\n            if time + course[0] <= course[1]:\n                heapq.heappush(max_heap, -course[0])\n                time += course[0]\n            elif max_heap and -max_heap[0] > course[0]:\n                time += course[0] - max_heap[0]\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, -course[0])\n        return len(max_heap)"
        },
        {
            "task_id": "course-schedule-iii",
            "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        max_heap = []\n        time = 0\n        for course in courses:\n            if time + course[0] <= course[1]:\n                heapq.heappush(max_heap, -course[0])\n                time += course[0]\n            elif max_heap and -max_heap[0] > course[0]:\n                time += course[0] - max_heap[0]\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, -course[0])\n        return len(max_heap)"
        },
        {
            "task_id": "course-schedule-iii",
            "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        max_heap = []\n        cur_time = 0\n        for course in courses:\n            if cur_time + course[0] <= course[1]:\n                heapq.heappush(max_heap, -course[0])\n                cur_time += course[0]\n            elif max_heap and -max_heap[0] > course[0]:\n                cur_time += course[0] - max_heap[0]\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, -course[0])\n        return len(max_heap)"
        },
        {
            "task_id": "course-schedule-iii",
            "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        max_heap = []\n        cur_time = 0\n        for course in courses:\n            if cur_time + course[0] <= course[1]:\n                heapq.heappush(max_heap, -course[0])\n                cur_time += course[0]\n            elif max_heap and -max_heap[0] > course[0]:\n                cur_time += course[0] - max_heap[0]\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, -course[0])\n        return len(max_heap)"
        }
    ],
    "reverse-nodes-in-k-group": [
        {
            "task_id": "reverse-nodes-in-k-group",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        nxt = head\n        \n        while cur:\n            count = k\n            while count > 1 and nxt:\n                nxt = nxt.next\n                count -= 1\n                \n            if count == 1:\n                pre.next = cur\n                pre = cur\n                cur = nxt\n            else:\n                nxt = cur.next\n                end = pre.next\n                while end != nxt:\n                    cur.next = end.next\n                    end.next = pre.next\n                    pre.next = end\n                    end = cur.next\n                pre = cur\n                cur = nxt\n                \n        return dummy.next"
        },
        {
            "task_id": "reverse-nodes-in-k-group",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        nxt = head\n        \n        while cur:\n            count = k\n            while count > 1 and nxt:\n                nxt = nxt.next\n                count -= 1\n                \n            if count == 1:\n                pre.next = cur\n                pre = cur\n                cur = nxt\n            else:\n                nxt = cur.next\n                end = pre.next\n                while cur != nxt:\n                    cur.next = pre.next\n                    pre.next = cur\n                    cur = cur.next\n                pre.next = end\n                pre = cur\n                cur = nxt\n                \n        return dummy.next"
        },
        {
            "task_id": "reverse-nodes-in-k-group",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        nxt = head\n        \n        while cur:\n            count = k\n            while count > 1 and nxt:\n                nxt = nxt.next\n                count -= 1\n                \n            if count == 1:\n                pre.next = cur\n                pre = cur\n                cur = nxt\n            else:\n                nxt = cur.next\n                end = pre.next\n                while cur != nxt:\n                    cur.next = pre.next\n                    pre.next = cur\n                    cur = cur.next\n                pre.next = end\n                pre = cur\n                cur = nxt\n                \n        return dummy.next"
        },
        {
            "task_id": "reverse-nodes-in-k-group",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        nxt = None\n        count = 0\n        \n        while cur:\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n            count += 1\n            if count == k:\n                dummy.next.next = cur\n                dummy = pre\n                pre = head\n                cur = nxt\n                count = 0\n                \n        return dummy.next"
        },
        {
            "task_id": "reverse-nodes-in-k-group",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        nxt = head\n        \n        while cur:\n            count = k\n            while count > 1 and nxt:\n                nxt = nxt.next\n                count -= 1\n                \n            if nxt == None:\n                break\n                \n            nxt = nxt.next\n            head = pre.next\n            while head != nxt:\n                tmp = head.next\n                head.next = nxt\n                nxt = head\n                head = tmp\n            pre.next = nxt\n            pre = head\n            cur = nxt\n            \n        return dummy.next"
        }
    ],
    "repeated-substring-pattern": [
        {
            "task_id": "repeated-substring-pattern",
            "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        #check if the string is empty\n        if s == \"\":\n            return False\n        \n        #check if the string is a palindrome\n        if s == s[::-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[2:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[3:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[4:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[5:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[6:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[7:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[8:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[9:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[10:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[11:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-12]:\n            return True\n        \n        #check"
        },
        {
            "task_id": "repeated-substring-pattern",
            "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        #check if the string is empty\n        if s == \"\":\n            return False\n        \n        #check if the string is a palindrome\n        if s == s[::-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[2:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[3:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[4:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[5:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[6:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[7:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[8:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[9:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[10:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[11:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-12]:\n            return True\n        \n        #check"
        },
        {
            "task_id": "repeated-substring-pattern",
            "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        #check if the string is empty\n        if s == \"\":\n            return False\n        \n        #check if the string is a palindrome\n        if s == s[::-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[2:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[3:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[4:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[5:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[6:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[7:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[8:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[9:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[10:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[11:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-12]:\n            return True\n        \n        #check"
        },
        {
            "task_id": "repeated-substring-pattern",
            "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        #check if the string is empty\n        if s == \"\":\n            return False\n        \n        #check if the string is a palindrome\n        if s == s[::-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[2:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[3:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[4:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[5:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[6:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[7:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[8:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[9:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[10:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[11:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-12]:\n            return True\n        \n        #check"
        },
        {
            "task_id": "repeated-substring-pattern",
            "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        #check if the string is empty\n        if s == \"\":\n            return False\n        \n        #check if the string is a palindrome\n        if s == s[::-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[2:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[3:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[4:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[5:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[6:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[7:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[8:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[9:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[10:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[11:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-12]:\n            return True\n        \n        #check"
        }
    ],
    "unique-binary-search-trees": [
        {
            "task_id": "unique-binary-search-trees",
            "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0]*(n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2,n+1):\n            for j in range(1,i+1):\n                dp[i] += dp[j-1]*dp[i-j]\n                \n        return dp[n]"
        },
        {
            "task_id": "unique-binary-search-trees",
            "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0]*(n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2,n+1):\n            for j in range(1,i+1):\n                dp[i] += dp[j-1]*dp[i-j]\n                \n        return dp[n]"
        },
        {
            "task_id": "unique-binary-search-trees",
            "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0]*(n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2,n+1):\n            for j in range(1,i+1):\n                dp[i] += dp[j-1]*dp[i-j]\n                \n        return dp[n]"
        },
        {
            "task_id": "unique-binary-search-trees",
            "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0]*(n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2,n+1):\n            for j in range(1,i+1):\n                dp[i] += dp[j-1]*dp[i-j]\n                \n        return dp[n]"
        },
        {
            "task_id": "unique-binary-search-trees",
            "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0]*(n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2,n+1):\n            for j in range(1,i+1):\n                dp[i] += dp[j-1]*dp[i-j]\n                \n        return dp[n]"
        }
    ],
    "single-number-ii": [
        {
            "task_id": "single-number-ii",
            "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        #initialize a dictionary\n        d = {}\n        \n        #loop through the list\n        for i in nums:\n            \n            #if the element is not in the dictionary\n            if i not in d:\n                \n                #add the element to the dictionary\n                d[i] = 1\n                \n            #if the element is in the dictionary\n            else:\n                \n                #delete the element from the dictionary\n                del d[i]\n                \n        #return the element in the dictionary\n        return list(d.keys())[0]"
        },
        {
            "task_id": "single-number-ii",
            "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize three bits\n        a = b = c = 0\n        \n        # Traverse through all elements\n        for i in nums:\n        \n            # XOR the element with\n            # existing elements in a, b, c\n            a = (a ^ i) & ~b & ~c\n            b = (b ^ i) & ~a & ~c\n            c = (c ^ i) & ~a & ~b\n            \n        # Return a, b, c\n        return a, b, c"
        },
        {
            "task_id": "single-number-ii",
            "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize three bits\n        a = b = c = 0\n        \n        # Traverse through all elements\n        for i in nums:\n        \n            # XOR the element with\n            # existing elements in a, b, c\n            a = (a ^ i) & ~b & ~c\n            b = (b ^ i) & ~a & ~c\n            c = (c ^ i) & ~a & ~b\n            \n        # Return a, b, c\n        return a, b, c"
        },
        {
            "task_id": "single-number-ii",
            "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        #initialize a dictionary\n        d = {}\n        \n        #loop through the list\n        for i in nums:\n            \n            #if the element is not in the dictionary\n            if i not in d:\n                \n                #add the element to the dictionary\n                d[i] = 1\n            \n            #if the element is in the dictionary\n            else:\n                \n                #delete the element from the dictionary\n                del d[i]\n        \n        #return the element in the dictionary\n        for i in d:\n            return i"
        },
        {
            "task_id": "single-number-ii",
            "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        #initialize a dictionary\n        d = {}\n        \n        #loop through the list\n        for i in nums:\n            \n            #if the element is not in the dictionary\n            if i not in d:\n                \n                #add the element to the dictionary\n                d[i] = 1\n            \n            #if the element is in the dictionary\n            else:\n                \n                #delete the element from the dictionary\n                del d[i]\n        \n        #return the key of the dictionary\n        return list(d.keys())[0]"
        }
    ],
    "stickers-to-spell-word": [
        {
            "task_id": "stickers-to-spell-word",
            "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def check(target, d):\n            for c in target:\n                if c not in d or d[c] <= 0:\n                    return False\n            return True\n        \n        def dfs(target, d, step):\n            if check(target, d):\n                return step\n            for i in range(len(stickers)):\n                for c in stickers[i]:\n                    if c in d:\n                        d[c] += 1\n                if dfs(target, d, step + 1) != -1:\n                    return step + 1\n                for c in stickers[i]:\n                    if c in d:\n                        d[c] -= 1\n            return -1\n        \n        d = {}\n        for c in target:\n            if c not in d:\n                d[c] = 0\n        return dfs(target, d, 0)"
        },
        {
            "task_id": "stickers-to-spell-word",
            "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] represents the minimum number of stickers needed to form the first i characters of target\n        dp = [0] * (len(target) + 1)\n        for i in range(1, len(target) + 1):\n            dp[i] = float('inf')\n            for j in range(len(stickers)):\n                if target[i - 1] in stickers[j]:\n                    dp[i] = min(dp[i], dp[i - 1] + 1)\n                    break\n            for k in range(i):\n                if target[k] in stickers[j]:\n                    dp[i] = min(dp[i], dp[k] + 1)\n                    break\n                    \n        return -1 if dp[-1] == float('inf') else dp[-1]"
        },
        {
            "task_id": "stickers-to-spell-word",
            "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the dp array\n        dp = [0] * 26\n        for i in range(len(target)):\n            dp[ord(target[i]) - ord('a')] += 1\n        \n        # 2. Initialize the dp array\n        dp = [0] * 26\n        for i in range(len(target)):\n            dp[ord(target[i]) - ord('a')] += 1\n        \n        # 3. Loop through the dp array\n        for i in range(26):\n            if dp[i] > 0:\n                for j in range(len(stickers)):\n                    if ord(stickers[j][i]) - ord('a') == i:\n                        dp[i] = min(dp[i], 1 + self.minStickers(stickers[:j] + stickers[j+1:], target))\n                        break\n        return min(dp) if sum(dp) == len(target) else -1"
        },
        {
            "task_id": "stickers-to-spell-word",
            "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Create a dictionary to store the frequency of each letter in the target string\n        target_freq = {}\n        for letter in target:\n            if letter not in target_freq:\n                target_freq[letter] = 1\n            else:\n                target_freq[letter] += 1\n        \n        # 2. Create a dictionary to store the frequency of each letter in each sticker\n        sticker_freq = {}\n        for sticker in stickers:\n            for letter in sticker:\n                if letter not in sticker_freq:\n                    sticker_freq[letter] = 1\n                else:\n                    sticker_freq[letter] += 1\n        \n        # 3. Create a dictionary to store the frequency of each letter in the stickers combined\n        combined_freq = {}\n        for sticker in stickers:\n            for letter in sticker:\n                if letter not in combined_freq:\n                    combined_freq[letter] = sticker_freq[letter]\n                else:\n                    combined_freq[letter] += sticker_freq[letter]\n        \n        # 4. Create a queue to store the letters in the target string\n        queue = []\n        for letter in target:\n            queue.append(letter)\n        \n        # 5. Create a set to store the letters that have been used\n        used = set()\n        \n        # 6. Create a variable to store the number of stickers used\n        stickers_used = 0\n        \n        # 7. While the queue is not empty\n        while queue:\n            \n            # 8. Get the first letter in the queue\n            letter = queue.pop(0)\n            \n            # 9. If the letter has not been used\n            if letter not in used:\n                \n                # 10. If the letter is not in the combined frequency dictionary\n                if letter not in combined_freq:\n                    \n                    # 11. Return -1\n                    return -1\n                \n                # 12. If the letter is in the combined frequency dictionary\n                else:\n                    \n                    # 13. Get the frequency of the letter in the combined frequency dictionary\n                    freq = combined_freq[letter]\n                    \n                    # 14. If the frequency is less than the frequency of the letter in the target string\n                    if freq < target_freq[letter]:\n                        \n                        # 15. Return -1\n                        return -1\n                    \n                    # 16. If the frequency is greater than or equal to the frequency of the letter in the target string\n                    else:\n                        \n                        # 17. Add the letter to the used set\n                        used.add(letter)\n                        \n                        # 18. Increment the number of stickers used\n                        stickers_used += 1\n                        \n                        # 19. If the number of letters in the used set is equal to the length of the target string\n                        if len(used) == len(target):\n                            \n                            # 20. Return the number of stickers used\n                            return stickers_used\n                        \n                        # 21. If the number of letters in the used set is less than the length of the target string\n                        else:\n                            \n                            # 22. Add the letters in the target string that are not in the used set to the queue\n                            for letter in target:\n                                if letter not in used:\n                                    queue.append(letter)"
        },
        {
            "task_id": "stickers-to-spell-word",
            "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def check(stickers, target):\n            # check if we can form target using stickers\n            # return True if we can form target\n            # return False if we can't form target\n            # we use a set to keep track of the letters we have formed\n            # if we have formed all the letters in target, we return True\n            # else we return False\n            letters = set()\n            for sticker in stickers:\n                for letter in sticker:\n                    letters.add(letter)\n            for letter in target:\n                if letter not in letters:\n                    return False\n            return True\n        \n        def dfs(stickers, target, memo, count):\n            # if we have formed target using stickers, we return count\n            if check(stickers, target):\n                return count\n            # if we have already visited this state, we return memo[target]\n            if target in memo:\n                return memo[target]\n            # initialize minimum number of stickers to infinity\n            minimum = float('inf')\n            # loop through each sticker\n            for sticker in stickers:\n                # if the first letter of the sticker is in target\n                if sticker[0] in target:\n                    # add the sticker to the used stickers\n                    used_stickers.add(sticker)\n                    # remove the first letter of the sticker from target\n                    new_target = target.replace(sticker[0], '', 1)\n                    # increment count\n                    count += 1\n                    # recurse\n                    minimum = min(minimum, dfs(used_stickers, new_target, memo, count))\n                    # backtrack\n                    used_stickers.remove(sticker)\n                    count -= 1\n            # if we can't form target using the given stickers, we return -1\n            if minimum == float('inf'):\n                return -1\n            # memoize the result\n            memo[target] = minimum\n            return minimum\n        \n        # memoization dictionary\n        memo = {}\n        # set of used stickers\n        used_stickers = set()\n        # sort the stickers in descending order\n        stickers.sort(key=len, reverse=True)\n        # dfs\n        return dfs(stickers, target, memo, 0)"
        }
    ],
    "strange-printer": [
        {
            "task_id": "strange-printer",
            "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize dp array\n        dp = [[0] * len(s) for _ in range(len(s))]\n        \n        # Fill the diagonal\n        for i in range(len(s)):\n            dp[i][i] = 1\n            \n        # Fill the table\n        for length in range(2, len(s) + 1):\n            for start in range(len(s) - length + 1):\n                end = start + length - 1\n                dp[start][end] = length\n                for k in range(start, end):\n                    dp[start][end] = min(dp[start][end], dp[start][k] + dp[k + 1][end])\n                    \n        return dp[0][len(s) - 1]"
        },
        {
            "task_id": "strange-printer",
            "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Dynamic Programming\n        # Time: O(n^2)\n        # Space: O(n^2)\n        \n        n = len(s)\n        dp = [[0]*n for _ in range(n)]\n        \n        for i in range(n-1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1] + 1\n                for k in range(i+1, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        return dp[0][n-1]"
        },
        {
            "task_id": "strange-printer",
            "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Dynamic Programming\n        # Time: O(n^2)\n        # Space: O(n^2)\n        \n        n = len(s)\n        dp = [[0]*n for _ in range(n)]\n        \n        for i in range(n-1,-1,-1):\n            dp[i][i] = 1\n            for j in range(i+1,n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1] + 1\n                for k in range(i+1,j):\n                    dp[i][j] = min(dp[i][j], dp[i][k-1] + dp[k][j-1])\n        return dp[0][n-1]"
        },
        {
            "task_id": "strange-printer",
            "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a 2D array with all values as 0\n        dp = [[0 for i in range(len(s))] for j in range(len(s))]\n        \n        # Fill the diagonal values\n        for i in range(len(s)):\n            dp[i][i] = 1\n            \n        # Fill in the table\n        for i in range(len(s)-1):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n                    \n        return dp[0][len(s)-1]"
        },
        {
            "task_id": "strange-printer",
            "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Dynamic Programming\n        # Time: O(n^2)\n        # Space: O(n^2)\n        \n        n = len(s)\n        dp = [[0]*n for _ in range(n)]\n        \n        for i in range(n-1,-1,-1):\n            dp[i][i] = 1\n            for j in range(i+1,n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1] + 1\n                for k in range(i+1,j):\n                    dp[i][j] = min(dp[i][j], dp[i][k-1] + dp[k][j-1])\n        return dp[0][n-1]"
        }
    ],
    "sqrtx": [
        {
            "task_id": "sqrtx",
            "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        if x == 2:\n            return 1\n        if x == 3:\n            return 1\n        if x == 4:\n            return 2\n        if x == 5:\n            return 2\n        if x == 6:\n            return 2\n        if x == 7:\n            return 2\n        if x == 8:\n            return 2\n        if x == 9:\n            return 3\n        if x == 10:\n            return 3\n        if x == 11:\n            return 3\n        if x == 12:\n            return 3\n        if x == 13:\n            return 3\n        if x == 14:\n            return 3\n        if x == 15:\n            return 3\n        if x == 16:\n            return 4\n        if x == 17:\n            return 4\n        if x == 18:\n            return 4\n        if x == 19:\n            return 4\n        if x == 20:\n            return 4\n        if x == 21:\n            return 4\n        if x == 22:\n            return 4\n        if x == 23:\n            return 4\n        if x == 24:\n            return 4\n        if x == 25:\n            return 5\n        if x == 26:\n            return 5\n        if x == 27:\n            return 5\n        if x == 28:\n            return 5\n        if x == 29:\n            return 5\n        if x == 30:\n            return 5\n        if x == 31:\n            return 5\n        if x == 32:\n            return 5\n        if x == 33:\n            return 5\n        if x == 34:\n            return 5\n        if x == 35:\n            return 5\n        if x == 36:\n            return 6\n        if x == 37:\n            return 6\n        if x == 38:\n            return 6\n        if x == 39:\n            return 6\n        if x == 40:\n            return 6\n        if x == 41:\n            return 6\n        if x == 42:\n            return 6\n        if x == 43:\n            return 6\n        if x == 44:\n            return 6\n        if x == 45:\n            return 6\n        if x == 46:\n            return 6\n        if x == 47:\n            return 6\n        if x == 48:\n            return 6\n        if x == 49:\n            return 7\n        if x == 50:\n            return 7\n        if x == 51:\n            return 7\n        if x == 52:\n            return 7\n        if x == 53:\n            return 7\n        if x == 54:\n            return 7\n        if x == 55:\n            return 7\n        if x == 56:\n            return 7\n        if x == 57:\n            return 7\n        if x == 58:\n            return 7\n        if x == 59:\n            return 7\n        if x == 60:\n            return 7\n        if x == 61:\n            return 7\n        if x == 62:\n            return 7\n        if x == 63:\n            return 7\n        if x == 64:\n            return 8\n        if x == 65:\n            return 8\n        if x == 66:\n            return 8\n        if x == 67:\n            return 8\n        if x == 68:\n            return 8\n        if x == 69:\n            return 8\n        if x == 70:\n            return 8\n        if x == 71:\n            return 8\n        if x == 72:\n            return 8\n        if x == 73:\n            return"
        },
        {
            "task_id": "sqrtx",
            "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        if x == 2:\n            return 1\n        if x == 3:\n            return 1\n        if x == 4:\n            return 2\n        if x == 5:\n            return 2\n        if x == 6:\n            return 2\n        if x == 7:\n            return 2\n        if x == 8:\n            return 2\n        if x == 9:\n            return 3\n        if x == 10:\n            return 3\n        if x == 11:\n            return 3\n        if x == 12:\n            return 3\n        if x == 13:\n            return 3\n        if x == 14:\n            return 3\n        if x == 15:\n            return 3\n        if x == 16:\n            return 4\n        if x == 17:\n            return 4\n        if x == 18:\n            return 4\n        if x == 19:\n            return 4\n        if x == 20:\n            return 4\n        if x == 21:\n            return 4\n        if x == 22:\n            return 4\n        if x == 23:\n            return 4\n        if x == 24:\n            return 4\n        if x == 25:\n            return 5\n        if x == 26:\n            return 5\n        if x == 27:\n            return 5\n        if x == 28:\n            return 5\n        if x == 29:\n            return 5\n        if x == 30:\n            return 5\n        if x == 31:\n            return 5\n        if x == 32:\n            return 5\n        if x == 33:\n            return 5\n        if x == 34:\n            return 5\n        if x == 35:\n            return 5\n        if x == 36:\n            return 6\n        if x == 37:\n            return 6\n        if x == 38:\n            return 6\n        if x == 39:\n            return 6\n        if x == 40:\n            return 6\n        if x == 41:\n            return 6\n        if x == 42:\n            return 6\n        if x == 43:\n            return 6\n        if x == 44:\n            return 6\n        if x == 45:\n            return 6\n        if x == 46:\n            return 6\n        if x == 47:\n            return 6\n        if x == 48:\n            return 6\n        if x == 49:\n            return 7\n        if x == 50:\n            return 7\n        if x == 51:\n            return 7\n        if x == 52:\n            return 7\n        if x == 53:\n            return 7\n        if x == 54:\n            return 7\n        if x == 55:\n            return 7\n        if x == 56:\n            return 7\n        if x == 57:\n            return 7\n        if x == 58:\n            return 7\n        if x == 59:\n            return 7\n        if x == 60:\n            return 7\n        if x == 61:\n            return 7\n        if x == 62:\n            return 7\n        if x == 63:\n            return 7\n        if x == 64:\n            return 7\n        if x == 65:\n            return 8\n        if x == 66:\n            return 8\n        if x == 67:\n            return 8\n        if x == 68:\n            return 8\n        if x == 69:\n            return 8\n        if x == 70:\n            return 8\n        if x == 71:\n            return 8\n        if x == 72:\n            return 8\n        if x == 73:\n            return"
        },
        {
            "task_id": "sqrtx",
            "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        low = 1\n        high = x\n        while low <= high:\n            mid = (low + high) // 2\n            if mid * mid <= x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return low - 1"
        },
        {
            "task_id": "sqrtx",
            "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        if x == 2:\n            return 1\n        if x == 3:\n            return 1\n        if x == 4:\n            return 2\n        if x == 5:\n            return 2\n        if x == 6:\n            return 2\n        if x == 7:\n            return 2\n        if x == 8:\n            return 2\n        if x == 9:\n            return 3\n        if x == 10:\n            return 3\n        if x == 11:\n            return 3\n        if x == 12:\n            return 3\n        if x == 13:\n            return 3\n        if x == 14:\n            return 3\n        if x == 15:\n            return 3\n        if x == 16:\n            return 4\n        if x == 17:\n            return 4\n        if x == 18:\n            return 4\n        if x == 19:\n            return 4\n        if x == 20:\n            return 4\n        if x == 21:\n            return 4\n        if x == 22:\n            return 4\n        if x == 23:\n            return 4\n        if x == 24:\n            return 4\n        if x == 25:\n            return 5\n        if x == 26:\n            return 5\n        if x == 27:\n            return 5\n        if x == 28:\n            return 5\n        if x == 29:\n            return 5\n        if x == 30:\n            return 5\n        if x == 31:\n            return 5\n        if x == 32:\n            return 5\n        if x == 33:\n            return 5\n        if x == 34:\n            return 5\n        if x == 35:\n            return 5\n        if x == 36:\n            return 6\n        if x == 37:\n            return 6\n        if x == 38:\n            return 6\n        if x == 39:\n            return 6\n        if x == 40:\n            return 6\n        if x == 41:\n            return 6\n        if x == 42:\n            return 6\n        if x == 43:\n            return 6\n        if x == 44:\n            return 6\n        if x == 45:\n            return 6\n        if x == 46:\n            return 6\n        if x == 47:\n            return 6\n        if x == 48:\n            return 6\n        if x == 49:\n            return 7\n        if x == 50:\n            return 7\n        if x == 51:\n            return 7\n        if x == 52:\n            return 7\n        if x == 53:\n            return 7\n        if x == 54:\n            return 7\n        if x == 55:\n            return 7\n        if x == 56:\n            return 7\n        if x == 57:\n            return 7\n        if x == 58:\n            return 7\n        if x == 59:\n            return 7\n        if x == 60:\n            return 7\n        if x == 61:\n            return 7\n        if x == 62:\n            return 7\n        if x == 63:\n            return 7\n        if x == 64:\n            return 7\n        if x == 65:\n            return 8\n        if x == 66:\n            return 8\n        if x == 67:\n            return 8\n        if x == 68:\n            return 8\n        if x == 69:\n            return 8\n        if x == 70:\n            return 8\n        if x == 71:\n            return 8\n        if x == 72:\n            return 8\n        if x == 73:\n            return"
        },
        {
            "task_id": "sqrtx",
            "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        low = 1\n        high = x\n        while low <= high:\n            mid = (low + high) // 2\n            if mid * mid <= x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return low - 1"
        }
    ],
    "roman-to-integer": [
        {
            "task_id": "roman-to-integer",
            "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i-1]]:\n                result += roman_dict[s[i]] - 2*roman_dict[s[i-1]]\n            else:\n                result += roman_dict[s[i]]\n        return result"
        },
        {
            "task_id": "roman-to-integer",
            "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        total = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i-1]]:\n                total += roman_dict[s[i]] - 2 * roman_dict[s[i-1]]\n            else:\n                total += roman_dict[s[i]]\n        return total"
        },
        {
            "task_id": "roman-to-integer",
            "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i-1]]:\n                result += roman_dict[s[i]] - 2*roman_dict[s[i-1]]\n            else:\n                result += roman_dict[s[i]]\n        return result"
        },
        {
            "task_id": "roman-to-integer",
            "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        total = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i-1]]:\n                total += roman_dict[s[i]] - 2 * roman_dict[s[i-1]]\n            else:\n                total += roman_dict[s[i]]\n        return total"
        },
        {
            "task_id": "roman-to-integer",
            "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        total = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i-1]]:\n                total += roman_dict[s[i]] - 2 * roman_dict[s[i-1]]\n            else:\n                total += roman_dict[s[i]]\n        return total"
        }
    ],
    "contains-duplicate": [
        {
            "task_id": "contains-duplicate",
            "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"
        },
        {
            "task_id": "contains-duplicate",
            "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"
        },
        {
            "task_id": "contains-duplicate",
            "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"
        },
        {
            "task_id": "contains-duplicate",
            "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"
        },
        {
            "task_id": "contains-duplicate",
            "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"
        }
    ],
    "sliding-window-maximum": [
        {
            "task_id": "sliding-window-maximum",
            "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        n = len(nums)\n        left = [0] * n\n        right = [0] * n\n        left[0] = nums[0]\n        right[n-1] = nums[n-1]\n        \n        for i in range(1, n):\n            if i % k == 0:\n                left[i] = nums[i]\n            else:\n                left[i] = max(left[i-1], nums[i])\n                \n            j = n - i - 1\n            if j % k == 0:\n                right[j] = nums[j]\n            else:\n                right[j] = max(right[j+1], nums[j])\n                \n        ans = []\n        for i in range(n-k+1):\n            ans.append(max(right[i], left[i+k-1]))\n            \n        return ans"
        },
        {
            "task_id": "sliding-window-maximum",
            "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        n = len(nums)\n        left = [0] * n\n        right = [0] * n\n        left[0] = nums[0]\n        right[n-1] = nums[n-1]\n        \n        for i in range(1, n):\n            if i % k == 0:\n                left[i] = nums[i]\n            else:\n                left[i] = max(left[i-1], nums[i])\n                \n            j = n - i - 1\n            if j % k == 0:\n                right[j] = nums[j]\n            else:\n                right[j] = max(right[j+1], nums[j])\n                \n        ans = []\n        for i in range(n-k+1):\n            ans.append(max(right[i], left[i+k-1]))\n            \n        return ans"
        },
        {
            "task_id": "sliding-window-maximum",
            "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        max_window = []\n        window = []\n        for i in range(len(nums)):\n            if len(window) > 0 and window[0] == i - k:\n                window.pop(0)\n            while len(window) > 0 and nums[window[-1]] < nums[i]:\n                window.pop()\n            window.append(i)\n            if i >= k - 1:\n                max_window.append(nums[window[0]])\n        return max_window"
        },
        {
            "task_id": "sliding-window-maximum",
            "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        result = []\n        for i in range(len(nums) - k + 1):\n            result.append(max(nums[i:i+k]))\n            \n        return result"
        },
        {
            "task_id": "sliding-window-maximum",
            "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        n = len(nums)\n        left = [0] * n\n        right = [0] * n\n        left[0] = nums[0]\n        right[n-1] = nums[n-1]\n        \n        for i in range(1, n):\n            if i % k == 0:\n                left[i] = nums[i]\n            else:\n                left[i] = max(left[i-1], nums[i])\n                \n            j = n - i - 1\n            if (j+1) % k == 0:\n                right[j] = nums[j]\n            else:\n                right[j] = max(right[j+1], nums[j])\n                \n        ans = []\n        for i in range(n-k+1):\n            ans.append(max(right[i], left[i+k-1]))\n            \n        return ans"
        }
    ],
    "median-of-two-sorted-arrays": [
        {
            "task_id": "median-of-two-sorted-arrays",
            "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1)%2==0:\n            return (nums1[len(nums1)//2]+nums1[len(nums1)//2-1])/2\n        else:\n            return nums1[len(nums1)//2]"
        },
        {
            "task_id": "median-of-two-sorted-arrays",
            "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1)%2==0:\n            return (nums1[len(nums1)//2]+nums1[len(nums1)//2-1])/2\n        else:\n            return nums1[len(nums1)//2]"
        },
        {
            "task_id": "median-of-two-sorted-arrays",
            "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1)%2==0:\n            return (nums1[len(nums1)//2]+nums1[len(nums1)//2-1])/2\n        else:\n            return nums1[len(nums1)//2]"
        },
        {
            "task_id": "median-of-two-sorted-arrays",
            "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1)%2==0:\n            return (nums1[len(nums1)//2]+nums1[len(nums1)//2-1])/2\n        else:\n            return nums1[len(nums1)//2]"
        },
        {
            "task_id": "median-of-two-sorted-arrays",
            "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # Merge two sorted arrays\n        nums = nums1 + nums2\n        nums.sort()\n        \n        # Find the median\n        if len(nums) % 2 == 0:\n            return (nums[len(nums) // 2 - 1] + nums[len(nums) // 2]) / 2\n        else:\n            return nums[len(nums) // 2]"
        }
    ],
    "find-minimum-in-rotated-sorted-array": [
        {
            "task_id": "find-minimum-in-rotated-sorted-array",
            "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return nums[left]"
        },
        {
            "task_id": "find-minimum-in-rotated-sorted-array",
            "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return nums[left]"
        },
        {
            "task_id": "find-minimum-in-rotated-sorted-array",
            "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n                \n        return nums[left]"
        },
        {
            "task_id": "find-minimum-in-rotated-sorted-array",
            "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return nums[left]"
        },
        {
            "task_id": "find-minimum-in-rotated-sorted-array",
            "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return nums[left]"
        }
    ],
    "pascals-triangle-ii": [
        {
            "task_id": "pascals-triangle-ii",
            "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,78,336,918,1430,1679,1430,918,336,78,13,1]\n        if rowIndex == 14:\n            return [1,14,91,407,1287,2304,3060,3060,2304,1287,407,91,14,1]\n        if rowIndex == 15:\n            return [1,15,105,541,1820,4365,6435,7292,6435,4365,1820,541,105,15,1]\n        if rowIndex == 16:\n            return [1,16,120,683,2016,4925,8536,10575,8536,4925,2016,683,120,16,1]\n        if rowIndex == 17:\n            return [1,17,136,856,2860,6951,11628,15747,15747,11628,6951,2860,856,136,17,1]\n        if rowIndex == 18:\n            return [1,18,153,1040,3432,8640,16064,22542,24310,22542,16064,8640,3432,1040,153,18,1]\n        if rowIndex == 19:\n            return [1,19,171,1287,4032,9496,18364,30279,36491,36491,30279,18364,9496,4032,1287,171,19,1]\n        if rowIndex == 20:\n            return [1,20,190,1440,4860,11976,25025,40"
        },
        {
            "task_id": "pascals-triangle-ii",
            "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        else:\n            row = [1]\n            for i in range(1, rowIndex+1):\n                row.append(row[i-1]*(rowIndex+1-i)/i)\n            return row"
        },
        {
            "task_id": "pascals-triangle-ii",
            "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,78,336,918,1430,1716,1430,918,336,78,13,1]\n        if rowIndex == 14:\n            return [1,14,91,407,1287,2304,3060,3060,2304,1287,407,91,14,1]\n        if rowIndex == 15:\n            return [1,15,105,541,1820,4365,6435,7292,6435,4365,1820,541,105,15,1]\n        if rowIndex == 16:\n            return [1,16,120,683,2016,4925,8536,10575,8536,4925,2016,683,120,16,1]\n        if rowIndex == 17:\n            return [1,17,136,856,2860,6951,11628,15700,15700,11628,6951,2860,856,136,17,1]\n        if rowIndex == 18:\n            return [1,18,153,1040,3432,8870,17556,26725,30270,26725,17556,8870,3432,1040,153,18,1]\n        if rowIndex == 19:\n            return [1,19,171,1287,4032,10935,22528,35175,44060,44060,35175,22528,10935,4032,1287,171,19,1]\n        if rowIndex == 20:\n            return [1,20,190,1512,4900,12870,28025,"
        },
        {
            "task_id": "pascals-triangle-ii",
            "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,78,336,918,1430,1716,1430,918,336,78,13,1]\n        if rowIndex == 14:\n            return [1,14,91,407,1287,2304,3060,3060,2304,1287,407,91,14,1]\n        if rowIndex == 15:\n            return [1,15,105,541,1820,4365,6435,7292,6435,4365,1820,541,105,15,1]\n        if rowIndex == 16:\n            return [1,16,120,683,2016,4925,8536,10575,9525,6435,2016,4925,8536,10575,120,16,1]\n        if rowIndex == 17:\n            return [1,17,136,856,2860,7156,12870,18475,20470,18475,12870,7156,2860,856,136,17,1]\n        if rowIndex == 18:\n            return [1,18,153,1039,3531,9297,18446,30273,38105,38105,30273,18446,9297,3531,1039,153,18,1]\n        if rowIndex == 19:\n            return [1,19,171,1287,4862,13959,28996,48620,64070,70825,64070,48620,28996,13959,4862,1287,171,19,1]\n        if rowIndex == 20:\n            return [1"
        },
        {
            "task_id": "pascals-triangle-ii",
            "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,78,336,918,1430,1679,1430,918,336,78,13,1]\n        if rowIndex == 14:\n            return [1,14,91,407,1287,2304,3060,3060,2304,1287,407,91,14,1]\n        if rowIndex == 15:\n            return [1,15,105,541,1820,4365,6435,7292,6435,4365,1820,541,105,15,1]\n        if rowIndex == 16:\n            return [1,16,120,683,2016,4925,8435,10355,9491,7505,3649,1575,225,16,1]\n        if rowIndex == 17:\n            return [1,17,136,858,2731,6438,11010,13660,13660,11010,6438,2731,858,136,17,1]\n        if rowIndex == 18:\n            return [1,18,153,1039,3432,8157,15504,24310,28650,24310,15504,8157,3432,1039,153,18,1]\n        if rowIndex == 19:\n            return [1,19,171,1297,4181,9800,18475,30575,38720,38720,30575,18475,9800,4181,1297,171,19,1]\n        if rowIndex == 20:\n            return [1,20,190,1513,4862,11924,25725,4"
        }
    ],
    "path-sum-ii": [
        {
            "task_id": "path-sum-ii",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        result = []\n        self.helper(root, targetSum, [], result)\n        return result\n    \n    def helper(self, root, targetSum, path, result):\n        if root is None:\n            return\n        \n        if root.left is None and root.right is None:\n            if targetSum == root.val:\n                path.append(root.val)\n                result.append(path)\n                return\n        \n        path.append(root.val)\n        self.helper(root.left, targetSum - root.val, path[:], result)\n        self.helper(root.right, targetSum - root.val, path[:], result)\n        path.pop()"
        },
        {
            "task_id": "path-sum-ii",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        result = []\n        self.dfs(root, targetSum, [], result)\n        return result\n    \n    def dfs(self, root, targetSum, path, result):\n        if not root:\n            return\n        \n        if not root.left and not root.right:\n            if targetSum == root.val:\n                path.append(root.val)\n                result.append(path)\n                return\n        \n        path.append(root.val)\n        self.dfs(root.left, targetSum - root.val, path[:], result)\n        self.dfs(root.right, targetSum - root.val, path[:], result)\n        path.pop()"
        },
        {
            "task_id": "path-sum-ii",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        result = []\n        self.dfs(root, targetSum, [], result)\n        return result\n    \n    def dfs(self, root, targetSum, path, result):\n        if root is None:\n            return\n        \n        path.append(root.val)\n        if root.left is None and root.right is None and targetSum == root.val:\n            result.append(path[:])\n        \n        self.dfs(root.left, targetSum - root.val, path, result)\n        self.dfs(root.right, targetSum - root.val, path, result)\n        path.pop()"
        },
        {
            "task_id": "path-sum-ii",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        result = []\n        self.dfs(root, targetSum, [], result)\n        return result\n    \n    def dfs(self, root, targetSum, path, result):\n        if not root.left and not root.right:\n            if targetSum == root.val:\n                path.append(root.val)\n                result.append(path)\n                return\n            else:\n                return\n        \n        if root.left:\n            self.dfs(root.left, targetSum - root.val, path + [root.val], result)\n        if root.right:\n            self.dfs(root.right, targetSum - root.val, path + [root.val], result)"
        },
        {
            "task_id": "path-sum-ii",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        result = []\n        self.helper(root, targetSum, [], result)\n        return result\n    \n    def helper(self, root, targetSum, path, result):\n        if root is None:\n            return\n        \n        if root.left is None and root.right is None:\n            if targetSum == root.val:\n                path.append(root.val)\n                result.append(path)\n                return\n        \n        path.append(root.val)\n        self.helper(root.left, targetSum - root.val, path[:], result)\n        self.helper(root.right, targetSum - root.val, path[:], result)\n        path.pop()"
        }
    ],
    "construct-the-rectangle": [
        {
            "task_id": "construct-the-rectangle",
            "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the square root of the area\n        # if the square root is a whole number, then the length and width are the same\n        # if the square root is not a whole number, then the length and width are the factors of the area\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of"
        },
        {
            "task_id": "construct-the-rectangle",
            "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the square root of the area\n        # if the square root is a whole number, then the length and width are the same\n        # if the square root is not a whole number, then the length and width are the factors of the area\n        # the length is the larger of the two factors\n        # the width is the smaller of the two factors\n        # the length and width are the same if the square root is a whole number\n        # the length and width are different if the square root is not a whole number\n        \n        # find the square root of the area\n        square_root = math.sqrt(area)\n        \n        # if the square root is a whole number, then the length and width are the same\n        if square_root % 1 == 0:\n            length = int(square_root)\n            width = int(square_root)\n            \n        # if the square root is not a whole number, then the length and width are the factors of the area\n        else:\n            # find the factors of the area\n            factors = []\n            for i in range(1, int(square_root) + 1):\n                if area % i == 0:\n                    factors.append(i)\n                    factors.append(area / i)\n            \n            # the length is the larger of the two factors\n            length = max(factors)\n            \n            # the width is the smaller of the two factors\n            width = min(factors)\n        \n        return [length, width]"
        },
        {
            "task_id": "construct-the-rectangle",
            "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the square root of the area\n        # if the square root is a whole number, then the length and width are the same\n        # if the square root is not a whole number, then the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the factors of the area\n        # the length and width are the"
        },
        {
            "task_id": "construct-the-rectangle",
            "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the square root of the area\n        # if the square root is a whole number, then the length and width are the same\n        # if the square root is not a whole number, then the length and width are the factors of the area\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the factors of"
        },
        {
            "task_id": "construct-the-rectangle",
            "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the square root of the area\n        # if the square root is a whole number, then the length and width are the same\n        # if the square root is a decimal, then the length and width are the factors of the area\n        # the length and width are the factors of the area that are closest to the square root\n        # the length and width are the same if the square root is a whole number\n        # the length and width are the same if the square root is a decimal and the factors are the same\n        # the length and width are different if the square root is a decimal and the factors are different\n        \n        # find the square root of the area\n        square_root = math.sqrt(area)\n        \n        # if the square root is a whole number, then the length and width are the same\n        if square_root % 1 == 0:\n            return [int(square_root), int(square_root)]\n        \n        # if the square root is a decimal, then the length and width are the factors of the area\n        else:\n            \n            # initialize the length and width\n            length = 0\n            width = 0\n            \n            # find the factors of the area\n            for i in range(1, int(square_root) + 1):\n                if area % i == 0:\n                    length = area / i\n                    width = i\n                    \n            # return the length and width\n            return [int(length), int(width)]"
        }
    ],
    "word-ladder-ii": [
        {
            "task_id": "word-ladder-ii",
            "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # BFS\n        # Time O(N)\n        # Space O(N)\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        queue = collections.deque([(beginWord, 0)])\n        visited = set()\n        while queue:\n            word, step = queue.popleft()\n            if word not in visited:\n                visited.add(word)\n                for i in range(len(word)):\n                    for j in range(26):\n                        new_word = word[:i] + chr(97+j) + word[i+1:]\n                        if new_word in wordList:\n                            if new_word == endWord:\n                                return [[beginWord] + [new_word]]\n                            queue.append((new_word, step+1))\n        return []"
        },
        {
            "task_id": "word-ladder-ii",
            "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # BFS\n        # Time O(N)\n        # Space O(N)\n        \n        # Step 1). Build the graph\n        graph = collections.defaultdict(list)\n        wordList = set(wordList)\n        wordList.add(beginWord)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + '_' + word[i+1:]\n                graph[pattern].append(word)\n        \n        # Step 2). BFS\n        queue = collections.deque([(beginWord, [beginWord])])\n        seen = set()\n        while queue:\n            word, path = queue.popleft()\n            if word not in seen:\n                seen.add(word)\n                for i in range(len(word)):\n                    pattern = word[:i] + '_' + word[i+1:]\n                    for next_word in graph[pattern]:\n                        if next_word == endWord:\n                            return [path + [next_word]]\n                        queue.append((next_word, path + [next_word]))\n        return []"
        },
        {
            "task_id": "word-ladder-ii",
            "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # BFS\n        # Time O(N)\n        # Space O(N)\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        queue = collections.deque([(beginWord, 0)])\n        visited = set()\n        while queue:\n            word, step = queue.popleft()\n            if word not in visited:\n                visited.add(word)\n                for i in range(len(word)):\n                    for j in range(26):\n                        new_word = word[:i] + chr(97+j) + word[i+1:]\n                        if new_word in wordList:\n                            if new_word == endWord:\n                                return [self.get_path(beginWord, endWord, visited)]\n                            queue.append((new_word, step+1))\n        return []\n    \n    def get_path(self, beginWord, endWord, visited):\n        path = []\n        word = endWord\n        while word != beginWord:\n            path.append(word)\n            for w in visited:\n                if w != word and self.diff_by_one(w, word):\n                    word = w\n                    break\n        path.append(beginWord)\n        return path[::-1]\n    \n    def diff_by_one(self, word1, word2):\n        diff = 0\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                diff += 1\n        return diff == 1"
        },
        {
            "task_id": "word-ladder-ii",
            "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # BFS\n        # Time O(N)\n        # Space O(N)\n        \n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 0)])\n        visited = set()\n        found = False\n        res = []\n        \n        while queue:\n            word, step = queue.popleft()\n            if word == endWord:\n                found = True\n                break\n            for i in range(len(word)):\n                for j in range(26):\n                    new_word = word[:i] + chr(97+j) + word[i+1:]\n                    if new_word in wordList and new_word not in visited:\n                        visited.add(new_word)\n                        queue.append((new_word, step+1))\n        if not found:\n            return []\n        \n        def dfs(word, step, path):\n            if word == endWord:\n                res.append(path)\n                return\n            for i in range(len(word)):\n                for j in range(26):\n                    new_word = word[:i] + chr(97+j) + word[i+1:]\n                    if new_word in wordList and new_word not in visited:\n                        visited.add(new_word)\n                        dfs(new_word, step+1, path+[new_word])\n        \n        dfs(word, step+1, path+[word])\n        return res"
        },
        {
            "task_id": "word-ladder-ii",
            "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # BFS\n        # Time O(N)\n        # Space O(N)\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        queue = collections.deque([(beginWord, [beginWord])])\n        visited = set()\n        while queue:\n            word, path = queue.popleft()\n            if word == endWord:\n                return [path]\n            for i in range(len(word)):\n                for j in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + j + word[i+1:]\n                    if new_word in wordList and new_word not in visited:\n                        visited.add(new_word)\n                        queue.append((new_word, path + [new_word]))\n        return []"
        }
    ],
    "balanced-binary-tree": [
        {
            "task_id": "balanced-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        if abs(self.height(root.left) - self.height(root.right)) > 1:\n            return False\n        \n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n    def height(self, root):\n        if root is None:\n            return 0\n        \n        return max(self.height(root.left), self.height(root.right)) + 1"
        },
        {
            "task_id": "balanced-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        if abs(self.height(root.left) - self.height(root.right)) > 1:\n            return False\n        \n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n    def height(self, root):\n        if root is None:\n            return 0\n        \n        return max(self.height(root.left), self.height(root.right)) + 1"
        },
        {
            "task_id": "balanced-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if abs(left_height - right_height) > 1:\n            return False\n        \n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return max(self.get_height(root.left), self.get_height(root.right)) + 1"
        },
        {
            "task_id": "balanced-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        left = self.getHeight(root.left)\n        right = self.getHeight(root.right)\n        \n        if abs(left - right) > 1:\n            return False\n        else:\n            return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n    def getHeight(self, root):\n        if root is None:\n            return 0\n        else:\n            return max(self.getHeight(root.left), self.getHeight(root.right)) + 1"
        },
        {
            "task_id": "balanced-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        if abs(self.height(root.left) - self.height(root.right)) > 1:\n            return False\n        \n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n    def height(self, root):\n        if root is None:\n            return 0\n        \n        return max(self.height(root.left), self.height(root.right)) + 1"
        }
    ],
    "power-of-two": [
        {
            "task_id": "power-of-two",
            "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        else:\n            return n & (n-1) == 0"
        },
        {
            "task_id": "power-of-two",
            "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        else:\n            return n & (n-1) == 0"
        },
        {
            "task_id": "power-of-two",
            "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        else:\n            return n & (n-1) == 0"
        },
        {
            "task_id": "power-of-two",
            "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        else:\n            return n & (n-1) == 0"
        },
        {
            "task_id": "power-of-two",
            "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        else:\n            return n & (n-1) == 0"
        }
    ],
    "subsets-ii": [
        {
            "task_id": "subsets-ii",
            "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        result = []\n        self.helper(nums, [], result)\n        return result\n    \n    def helper(self, nums, path, result):\n        result.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.helper(nums[i+1:], path+[nums[i]], result)"
        },
        {
            "task_id": "subsets-ii",
            "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        result = []\n        self.helper(nums, [], result)\n        return result\n    \n    def helper(self, nums, path, result):\n        result.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.helper(nums[i+1:], path+[nums[i]], result)"
        },
        {
            "task_id": "subsets-ii",
            "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        result = []\n        self.subsetsWithDupHelper(nums, 0, [], result)\n        return result\n    \n    def subsetsWithDupHelper(self, nums, index, path, result):\n        result.append(path)\n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i-1]:\n                continue\n            self.subsetsWithDupHelper(nums, i+1, path+[nums[i]], result)"
        },
        {
            "task_id": "subsets-ii",
            "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        result = []\n        self.subsetsWithDupHelper(nums, 0, [], result)\n        return result\n    \n    def subsetsWithDupHelper(self, nums, index, path, result):\n        result.append(path)\n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i-1]:\n                continue\n            self.subsetsWithDupHelper(nums, i+1, path+[nums[i]], result)"
        },
        {
            "task_id": "subsets-ii",
            "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        result = []\n        self.helper(nums, [], result)\n        return result\n    \n    def helper(self, nums, temp, result):\n        result.append(temp)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.helper(nums[i+1:], temp+[nums[i]], result)"
        }
    ],
    "largest-rectangle-in-histogram": [
        {
            "task_id": "largest-rectangle-in-histogram",
            "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the stack\n        stack = []\n        # Initialize the max area\n        max_area = 0\n        # Traverse the histogram\n        for i in range(len(heights)):\n            # If the stack is empty or the height of current bar is higher than the height of top of the stack,\n            # push the index into the stack\n            if not stack or heights[i] > heights[stack[-1]]:\n                stack.append(i)\n            # If the height of current bar is lower than the height of top of the stack,\n            # keep popping the stack and calculate the area\n            else:\n                while stack and heights[i] <= heights[stack[-1]]:\n                    # Get the height of the bar\n                    height = heights[stack.pop()]\n                    # Get the width of the bar\n                    if stack:\n                        width = i - stack[-1] - 1\n                    else:\n                        width = i\n                    # Calculate the area\n                    max_area = max(max_area, height * width)\n                # After the above while loop, the top of the stack has the height that is lower than the height of current bar,\n                # so push the index of current bar into the stack\n                stack.append(i)\n        # After the above for loop, the stack still has some bars,\n        # so pop all the bars and calculate the area\n        while stack:\n            height = heights[stack.pop()]\n            if stack:\n                width = len(heights) - stack[-1] - 1\n            else:\n                width = len(heights)\n            max_area = max(max_area, height * width)\n        return max_area"
        },
        {
            "task_id": "largest-rectangle-in-histogram",
            "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the stack\n        stack = []\n        max_area = 0\n        heights.append(0)\n        \n        # Loop through the heights\n        for i in range(len(heights)):\n            \n            # If the stack is empty or the height is greater than the last element in the stack\n            if not stack or heights[i] > heights[stack[-1]]:\n                stack.append(i)\n            \n            # If the height is less than the last element in the stack\n            else:\n                \n                # While the stack is not empty and the height is less than the last element in the stack\n                while stack and heights[i] <= heights[stack[-1]]:\n                    \n                    # Get the last element in the stack\n                    last_element = stack.pop()\n                    \n                    # Calculate the area\n                    area = heights[last_element] * (i - stack[-1] - 1)\n                    \n                    # Update the max area\n                    max_area = max(max_area, area)\n                \n                # Add the current element to the stack\n                stack.append(i)\n                \n        # Return the max area\n        return max_area"
        },
        {
            "task_id": "largest-rectangle-in-histogram",
            "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the stack\n        stack = []\n        max_area = 0\n        heights.append(0)\n        \n        # Loop through the heights\n        for i in range(len(heights)):\n            \n            # If the stack is empty or the height is greater than the last element in the stack\n            if not stack or heights[i] > heights[stack[-1]]:\n                stack.append(i)\n            \n            # If the height is less than the last element in the stack\n            else:\n                \n                # While the stack is not empty and the height is less than the last element in the stack\n                while stack and heights[i] <= heights[stack[-1]]:\n                    \n                    # Get the last element in the stack\n                    last_element = stack.pop()\n                    \n                    # Calculate the area\n                    area = heights[last_element] * (i - stack[-1] - 1)\n                    \n                    # Update the max area\n                    max_area = max(max_area, area)\n                \n                # Add the current element to the stack\n                stack.append(i)\n                \n        # Return the max area\n        return max_area"
        },
        {
            "task_id": "largest-rectangle-in-histogram",
            "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the stack\n        stack = []\n        max_area = 0\n        heights.append(0)\n        \n        # Loop through the heights\n        for i in range(len(heights)):\n            \n            # If the stack is empty or the height is greater than the last element in the stack\n            if not stack or heights[i] > heights[stack[-1]]:\n                stack.append(i)\n            \n            # If the height is less than the last element in the stack\n            else:\n                \n                # While the stack is not empty and the height is less than the last element in the stack\n                while stack and heights[i] <= heights[stack[-1]]:\n                    \n                    # Get the last element in the stack\n                    last = stack.pop()\n                    \n                    # Calculate the area\n                    area = heights[last] * (i - last - 1)\n                    \n                    # Update the max area\n                    max_area = max(max_area, area)\n                \n                # Add the current height to the stack\n                stack.append(i)\n                \n        # Return the max area\n        return max_area"
        },
        {
            "task_id": "largest-rectangle-in-histogram",
            "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the stack\n        stack = []\n        max_area = 0\n        heights.append(0)\n        \n        # Loop through the heights\n        for i in range(len(heights)):\n            \n            # If the stack is empty or the height is greater than the last element in the stack\n            if not stack or heights[i] > heights[stack[-1]]:\n                stack.append(i)\n            \n            # If the stack is not empty and the height is less than the last element in the stack\n            else:\n                \n                # While the stack is not empty and the height is less than the last element in the stack\n                while stack and heights[i] <= heights[stack[-1]]:\n                    \n                    # Get the last element in the stack\n                    last_element = stack.pop()\n                    \n                    # Calculate the area\n                    area = heights[last_element] * (i - stack[-1] - 1)\n                    \n                    # Update the max area\n                    max_area = max(max_area, area)\n                \n                # Add the current element to the stack\n                stack.append(i)\n                \n        # Return the max area\n        return max_area"
        }
    ],
    "evaluate-reverse-polish-notation": [
        {
            "task_id": "evaluate-reverse-polish-notation",
            "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in ['+', '-', '*', '/']:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == '+':\n                    stack.append(num1 + num2)\n                elif token == '-':\n                    stack.append(num1 - num2)\n                elif token == '*':\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(num1 / num2))\n            else:\n                stack.append(int(token))\n        return stack.pop()"
        },
        {
            "task_id": "evaluate-reverse-polish-notation",
            "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in ['+', '-', '*', '/']:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == '+':\n                    stack.append(num1 + num2)\n                elif token == '-':\n                    stack.append(num1 - num2)\n                elif token == '*':\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(num1 / num2))\n            else:\n                stack.append(int(token))\n        return stack.pop()"
        },
        {
            "task_id": "evaluate-reverse-polish-notation",
            "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in ['+', '-', '*', '/']:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == '+':\n                    stack.append(num1 + num2)\n                elif token == '-':\n                    stack.append(num1 - num2)\n                elif token == '*':\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(num1 / num2))\n            else:\n                stack.append(int(token))\n        return stack.pop()"
        },
        {
            "task_id": "evaluate-reverse-polish-notation",
            "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in ['+', '-', '*', '/']:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == '+':\n                    stack.append(num1 + num2)\n                elif token == '-':\n                    stack.append(num1 - num2)\n                elif token == '*':\n                    stack.append(num1 * num2)\n                elif token == '/':\n                    stack.append(int(num1 / num2))\n            else:\n                stack.append(int(token))\n        return stack.pop()"
        },
        {
            "task_id": "evaluate-reverse-polish-notation",
            "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in ['+', '-', '*', '/']:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == '+':\n                    stack.append(num1 + num2)\n                elif token == '-':\n                    stack.append(num1 - num2)\n                elif token == '*':\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(num1 / num2))\n            else:\n                stack.append(int(token))\n        return stack.pop()"
        }
    ],
    "perfect-rectangle": [
        {
            "task_id": "perfect-rectangle",
            "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # find the min and max x and y\n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        \n        for rectangle in rectangles:\n            x_min = min(x_min, rectangle[0])\n            x_max = max(x_max, rectangle[2])\n            y_min = min(y_min, rectangle[1])\n            y_max = max(y_max, rectangle[3])\n            \n        area = (x_max - x_min) * (y_max - y_min)\n        total_area = 0\n        \n        for rectangle in rectangles:\n            total_area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1])\n            \n        if area != total_area:\n            return False\n        \n        points = set()\n        \n        for rectangle in rectangles:\n            for point in [rectangle[0:2], rectangle[0:2], rectangle[2:4], rectangle[2:4]]:\n                if point in points:\n                    points.remove(point)\n                else:\n                    points.add(point)\n                    \n        return len(points) == 4 and (x_min, y_min) in points and (x_min, y_max) in points and (x_max, y_min) in points and (x_max, y_max) in points"
        },
        {
            "task_id": "perfect-rectangle",
            "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # find the min and max x and y\n        x_min = 1000000000\n        x_max = -1000000000\n        y_min = 1000000000\n        y_max = -1000000000\n        \n        for rectangle in rectangles:\n            x_min = min(x_min, rectangle[0])\n            y_min = min(y_min, rectangle[1])\n            x_max = max(x_max, rectangle[2])\n            y_max = max(y_max, rectangle[3])\n            \n        area = (x_max - x_min) * (y_max - y_min)\n        total_area = 0\n        \n        for rectangle in rectangles:\n            total_area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1])\n            \n        if total_area != area:\n            return False\n        \n        points = set()\n        \n        for rectangle in rectangles:\n            for x in [rectangle[0], rectangle[2]]:\n                for y in [rectangle[1], rectangle[3]]:\n                    points.add((x, y))\n                    \n        for x in [x_min, x_max]:\n            for y in [y_min, y_max]:\n                if (x, y) not in points:\n                    return False\n                    \n        return True"
        },
        {
            "task_id": "perfect-rectangle",
            "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # find the min and max x and y\n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        \n        for rectangle in rectangles:\n            x_min = min(x_min, rectangle[0])\n            x_max = max(x_max, rectangle[2])\n            y_min = min(y_min, rectangle[1])\n            y_max = max(y_max, rectangle[3])\n            \n        area = (x_max - x_min) * (y_max - y_min)\n        total_area = 0\n        \n        for rectangle in rectangles:\n            total_area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1])\n            \n        if area != total_area:\n            return False\n        \n        points = set()\n        for rectangle in rectangles:\n            for point in [rectangle[0:2], rectangle[0:2], rectangle[2:4], rectangle[2:4]]:\n                points.add(tuple(point))\n                \n        for point in [(x_min, y_min), (x_min, y_max), (x_max, y_min), (x_max, y_max)]:\n            if tuple(point) not in points:\n                return False\n                \n        return True"
        },
        {
            "task_id": "perfect-rectangle",
            "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # find the min and max x and y\n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        \n        for rectangle in rectangles:\n            x_min = min(x_min, rectangle[0])\n            x_max = max(x_max, rectangle[2])\n            y_min = min(y_min, rectangle[1])\n            y_max = max(y_max, rectangle[3])\n            \n        area = (x_max - x_min) * (y_max - y_min)\n        total_area = 0\n        \n        for rectangle in rectangles:\n            total_area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1])\n            \n        if area != total_area:\n            return False\n        \n        points = set()\n        for rectangle in rectangles:\n            for point in [rectangle[0:2], rectangle[0:2], rectangle[2:4], rectangle[2:4]]:\n                points.add(tuple(point))\n                \n        for point in [(x_min, y_min), (x_min, y_max), (x_max, y_min), (x_max, y_max)]:\n            if tuple(point) not in points:\n                return False\n                \n        return True"
        },
        {
            "task_id": "perfect-rectangle",
            "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # find the min and max x and y coordinates\n        x_coords = [i for sublist in rectangles for i in sublist[0:2]]\n        y_coords = [i for sublist in rectangles for i in sublist[2:4]]\n        \n        min_x = min(x_coords)\n        max_x = max(x_coords)\n        min_y = min(y_coords)\n        max_y = max(y_coords)\n        \n        # find the area of the bounding box\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        # find the sum of the areas of all the rectangles\n        sum_area = 0\n        for rectangle in rectangles:\n            sum_area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1])\n        \n        # if the sum of the areas of all the rectangles is equal to the area of the bounding box, then the rectangles together form an exact cover of a rectangular region\n        if sum_area == area:\n            return True\n        else:\n            return False"
        }
    ],
    "excel-sheet-column-title": [
        {
            "task_id": "excel-sheet-column-title",
            "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # Initialize an empty string\n        result = \"\"\n        \n        # Loop until columnNumber becomes 0\n        while columnNumber:\n            \n            # Find the reminder\n            remainder = columnNumber % 26\n            \n            # If remainder is 0, then a Z should be there in the result\n            if remainder == 0:\n                result = \"Z\" + result\n                columnNumber = int((columnNumber - 1) / 26)\n                \n            # If remainder is non-zero, then add the character\n            # in the result\n            else:\n                result = chr(remainder - 1 + ord('A')) + result\n                columnNumber = int(columnNumber / 26)\n                \n        return result"
        },
        {
            "task_id": "excel-sheet-column-title",
            "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # Initialize an empty string\n        result = \"\"\n        \n        # Loop until columnNumber becomes 0\n        while columnNumber:\n            \n            # Find the reminder\n            reminder = columnNumber % 26\n            \n            # If reminder is 0, then a 'Z' must be there in the result\n            if reminder == 0:\n                result = 'Z' + result\n                columnNumber = int((columnNumber - 1) / 26)\n                \n            # If reminder is not 0, then add the char\n            # having ascii value to the result\n            else:\n                result = chr(reminder - 1 + ord('A')) + result\n                columnNumber = int(columnNumber / 26)\n                \n        return result"
        },
        {
            "task_id": "excel-sheet-column-title",
            "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # Initialize an empty string\n        result = \"\"\n        \n        # Loop until columnNumber becomes 0\n        while columnNumber:\n            \n            # Find the reminder\n            remainder = columnNumber % 26\n            \n            # If remainder is 0, then a Z should be there in the result\n            if remainder == 0:\n                result = \"Z\" + result\n                columnNumber = int((columnNumber - 1) / 26)\n                \n            # If remainder is not 0, then add the character\n            # in the result\n            else:\n                result = chr(remainder - 1 + ord('A')) + result\n                columnNumber = int(columnNumber / 26)\n                \n        return result"
        },
        {
            "task_id": "excel-sheet-column-title",
            "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # Initialize an empty string\n        result = \"\"\n        \n        # Loop until columnNumber becomes 0\n        while columnNumber:\n            \n            # Find the reminder\n            reminder = columnNumber % 26\n            \n            # If reminder is 0, then a Z should be there in the result\n            if reminder == 0:\n                result = \"Z\" + result\n                columnNumber = int((columnNumber - 1) / 26)\n                \n            # If reminder is not 0, then normal calculation can be done\n            else:\n                result = chr(reminder + 64) + result\n                columnNumber = int(columnNumber / 26)\n                \n        return result"
        },
        {
            "task_id": "excel-sheet-column-title",
            "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # Initialize an empty string\n        result = \"\"\n        \n        # Loop until columnNumber becomes 0\n        while columnNumber:\n            \n            # Find the reminder\n            remainder = columnNumber % 26\n            \n            # If remainder is 0, then a Z should be there in the result\n            if remainder == 0:\n                result = \"Z\" + result\n                columnNumber = int((columnNumber - 1) / 26)\n                \n            # If remainder is not 0, then add the character\n            # in the result\n            else:\n                result = chr(remainder - 1 + ord('A')) + result\n                columnNumber = int(columnNumber / 26)\n                \n        return result"
        }
    ],
    "maximum-subarray": [
        {
            "task_id": "maximum-subarray",
            "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_sum = nums[0]\n        current_sum = 0\n        \n        # Loop through the array\n        for i in range(len(nums)):\n            current_sum = max(current_sum + nums[i], nums[i])\n            max_sum = max(max_sum, current_sum)\n            \n        return max_sum"
        },
        {
            "task_id": "maximum-subarray",
            "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_sum = nums[0]\n        current_sum = 0\n        \n        # Loop through the array\n        for i in range(len(nums)):\n            current_sum = max(current_sum + nums[i], nums[i])\n            max_sum = max(max_sum, current_sum)\n            \n        return max_sum"
        },
        {
            "task_id": "maximum-subarray",
            "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_sum = nums[0]\n        current_sum = 0\n        \n        # Loop through the array\n        for i in range(len(nums)):\n            current_sum = max(current_sum + nums[i], nums[i])\n            max_sum = max(max_sum, current_sum)\n            \n        return max_sum"
        },
        {
            "task_id": "maximum-subarray",
            "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_sum = nums[0]\n        current_sum = 0\n        \n        # Loop through the array\n        for i in range(len(nums)):\n            current_sum = max(current_sum + nums[i], nums[i])\n            max_sum = max(max_sum, current_sum)\n            \n        return max_sum"
        },
        {
            "task_id": "maximum-subarray",
            "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_sum = nums[0]\n        current_sum = 0\n        \n        # Loop through the array\n        for i in range(len(nums)):\n            current_sum = max(current_sum + nums[i], nums[i])\n            max_sum = max(current_sum, max_sum)\n            \n        return max_sum"
        }
    ],
    "sliding-puzzle": [
        {
            "task_id": "sliding-puzzle",
            "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the queue with the starting board\n        queue = [board]\n        \n        # 2. Initialize the visited set\n        visited = set()\n        \n        # 3. Initialize the depth\n        depth = 0\n        \n        # 4. Loop until the queue is empty\n        while queue:\n            \n            # 5. Get the size of the queue\n            size = len(queue)\n            \n            # 6. Loop for the size of the queue\n            for i in range(size):\n                \n                # 7. Get the current board\n                current_board = queue.pop(0)\n                \n                # 8. Check if the current board is the goal board\n                if current_board == [[1,2,3],[4,5,0]]:\n                    return depth\n                \n                # 9. Get the zero index\n                zero_index = self.get_zero_index(current_board)\n                \n                # 10. Get the possible moves\n                possible_moves = self.get_possible_moves(current_board, zero_index)\n                \n                # 11. Loop through the possible moves\n                for move in possible_moves:\n                    \n                    # 12. Check if the move is not in the visited set\n                    if str(move) not in visited:\n                        \n                        # 13. Add the move to the visited set\n                        visited.add(str(move))\n                        \n                        # 14. Add the move to the queue\n                        queue.append(move)\n                \n            # 15. Increment the depth\n            depth += 1\n        \n        # 16. Return -1 if no solution is found\n        return -1\n    \n    def get_zero_index(self, board):\n        for i in range(2):\n            for j in range(3):\n                if board[i][j] == 0:\n                    return (i, j)\n    \n    def get_possible_moves(self, board, zero_index):\n        possible_moves = []\n        # 1. Check if the zero is in the first row\n        if zero_index[0] == 0:\n            \n            # 2. Check if the zero is in the first column\n            if zero_index[1] == 0:\n                \n                # 3. Add the board with the zero in the second column to the possible moves\n                possible_moves.append(self.move_zero(board, zero_index, (0, 1)))\n                \n                # 4. Add the board with the zero in the second row to the possible moves\n                possible_moves.append(self.move_zero(board, zero_index, (1, 0)))\n            \n            # 5. Check if the zero is in the second column\n            elif zero_index[1] == 1:\n                \n                # 6. Add the board with the zero in the first column to the possible moves\n                possible_moves.append(self.move_zero(board, zero_index, (0, 0)))\n                \n                # 7. Add the board with the zero in the second row to the possible moves\n                possible_moves.append(self.move_zero(board, zero_index, (1, 1)))\n                \n                # 8. Add the board with the zero in the third column to the possible moves\n                possible_moves.append(self.move_zero(board, zero_index, (0, 2)))\n            \n            # 9. Check if the zero is in the third column\n            elif zero_index[1] == 2:\n                \n                # 10. Add the board with the zero in the second column to the possible moves\n                possible_moves.append(self.move_zero(board, zero_index, (0, 1)))\n                \n                # 11. Add the board with the zero in the first row to the possible moves\n                possible_moves.append(self.move_zero(board, zero_index, (1, 2)))\n        \n        # 12. Check if the zero is in the second row\n        elif zero_index[0] == 1:\n            \n            # 13. Check if the zero is in the first column\n            if zero_index[1] == 0:\n                \n                # 14. Add"
        },
        {
            "task_id": "sliding-puzzle",
            "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # 1. Create a queue\n        # 2. Create a set to store visited states\n        # 3. Create a set to store the goal state\n        # 4. Create a function to check if the state is goal state\n        # 5. Create a function to get the neighbors of a state\n        # 6. Create a function to check if the state is visited\n        # 7. Create a function to check if the state is valid\n        # 8. Create a function to get the number of moves\n        # 9. Create a function to get the next state\n        # 10. Create a function to get the current state\n        # 11. Create a function to get the goal state\n        # 12. Create a function to get the visited states\n        # 13. Create a function to get the neighbors of a state\n        # 14. Create a function to check if the state is valid\n        # 15. Create a function to check if the state is goal state\n        # 16. Create a function to get the number of moves\n        # 17. Create a function to get the next state\n        # 18. Create a function to get the current state\n        # 19. Create a function to get the goal state\n        # 20. Create a function to get the visited states\n        # 21. Create a function to get the neighbors of a state\n        # 22. Create a function to check if the state is valid\n        # 23. Create a function to check if the state is goal state\n        # 24. Create a function to get the number of moves\n        # 25. Create a function to get the next state\n        # 26. Create a function to get the current state\n        # 27. Create a function to get the goal state\n        # 28. Create a function to get the visited states\n        # 29. Create a function to get the neighbors of a state\n        # 30. Create a function to check if the state is valid\n        # 31. Create a function to check if the state is goal state\n        # 32. Create a function to get the number of moves\n        # 33. Create a function to get the next state\n        # 34. Create a function to get the current state\n        # 35. Create a function to get the goal state\n        # 36. Create a function to get the visited states\n        # 37. Create a function to get the neighbors of a state\n        # 38. Create a function to check if the state is valid\n        # 39. Create a function to check if the state is goal state\n        # 40. Create a function to get the number of moves\n        # 41. Create a function to get the next state\n        # 42. Create a function to get the current state\n        # 43. Create a function to get the goal state\n        # 44. Create a function to get the visited states\n        # 45. Create a function to get the neighbors of a state\n        # 46. Create a function to check if the state is valid\n        # 47. Create a function to check if the state is goal state\n        # 48. Create a function to get the number of moves\n        # 49. Create a function to get the next state\n        # 50. Create a function to get the current state\n        # 51. Create a function to get the goal state\n        # 52. Create a function to get the visited states\n        # 53. Create a function to get the neighbors of a state\n        # 54. Create a function to check if the state is valid\n        # 55. Create a function to check if the state is goal state\n        # 56. Create a function to get the number of moves\n        # 57. Create a function to get the next state\n        # 58. Create a function to get the current state\n        # 59. Create a function to get the goal state\n        # 60. Create a function to get the visited states\n        # 61. Create a function to get the neighbors of a state\n        # 62. Create a function to check if the state is valid\n        # 63. Create a function to check if the state is goal state\n        # 64. Create a function to get the number of moves"
        },
        {
            "task_id": "sliding-puzzle",
            "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # 1. Create a queue\n        # 2. Create a set to store visited states\n        # 3. Create a set to store the goal state\n        # 4. Create a set to store the initial state\n        # 5. While queue is not empty\n        # 6.     Dequeue the first element\n        # 7.     If the current state is the goal state, return the step\n        # 8.     If the current state is not in the visited set, mark it as visited\n        # 9.     Generate all possible next states\n        # 10.    Enqueue all possible next states\n        # 11. Return -1\n        \n        # BFS\n        # 1. Create a queue\n        # 2. Create a set to store visited states\n        # 3. Create a set to store the goal state\n        # 4. Create a set to store the initial state\n        # 5. While queue is not empty\n        # 6.     Dequeue the first element\n        # 7.     If the current state is the goal state, return the step\n        # 8.     If the current state is not in the visited set, mark it as visited\n        # 9.     Generate all possible next states\n        # 10.    Enqueue all possible next states\n        # 11. Return -1\n        \n        # BFS\n        # 1. Create a queue\n        # 2. Create a set to store visited states\n        # 3. Create a set to store the goal state\n        # 4. Create a set to store the initial state\n        # 5. While queue is not empty\n        # 6.     Dequeue the first element\n        # 7.     If the current state is the goal state, return the step\n        # 8.     If the current state is not in the visited set, mark it as visited\n        # 9.     Generate all possible next states\n        # 10.    Enqueue all possible next states\n        # 11. Return -1\n        \n        # BFS\n        # 1. Create a queue\n        # 2. Create a set to store visited states\n        # 3. Create a set to store the goal state\n        # 4. Create a set to store the initial state\n        # 5. While queue is not empty\n        # 6.     Dequeue the first element\n        # 7.     If the current state is the goal state, return the step\n        # 8.     If the current state is not in the visited set, mark it as visited\n        # 9.     Generate all possible next states\n        # 10.    Enqueue all possible next states\n        # 11. Return -1\n        \n        # BFS\n        # 1. Create a queue\n        # 2. Create a set to store visited states\n        # 3. Create a set to store the goal state\n        # 4. Create a set to store the initial state\n        # 5. While queue is not empty\n        # 6.     Dequeue the first element\n        # 7.     If the current state is the goal state, return the step\n        # 8.     If the current state is not in the visited set, mark it as visited\n        # 9.     Generate all possible next states\n        # 10.    Enqueue all possible next states\n        # 11. Return -1\n        \n        # BFS\n        # 1. Create a queue\n        # 2. Create a set to store visited states\n        # 3. Create a set to store the goal state\n        # 4. Create a set to store the initial state\n        # 5. While queue is not empty\n        # 6.     Dequeue the first element\n        # 7.     If the current state is the goal state, return the step\n        # 8.     If the current state is not in the visited set, mark it as visited\n        # 9.     Generate all possible next states\n        # 10.    Enqueue all possible next states\n        # 11. Return -1\n        \n        # BFS\n        # 1. Create a queue\n        # 2. Create a set to store visited states\n        # 3. Create a set to store the goal state\n        # 4. Create a set to store the initial state\n        # 5. While queue is not empty\n        # 6.     Dequeue the first"
        },
        {
            "task_id": "sliding-puzzle",
            "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the queue with the starting board\n        queue = [board]\n        # 2. Initialize the visited set with the starting board\n        visited = set([str(board)])\n        # 3. Initialize the depth\n        depth = 0\n        \n        # 4. Loop until the queue is empty\n        while queue:\n            # 5. Get the size of the queue\n            size = len(queue)\n            # 6. Loop through the queue\n            for i in range(size):\n                # 7. Get the current board\n                current_board = queue.pop(0)\n                # 8. Check if the current board is the goal board\n                if current_board == [[1,2,3],[4,5,0]]:\n                    # 9. Return the depth\n                    return depth\n                # 10. Get the row and column of the 0\n                row, column = self.get_row_and_column(current_board)\n                # 11. Check if the 0 is in the first row\n                if row == 0:\n                    # 12. Check if the 0 is in the first column\n                    if column == 0:\n                        # 13. Check if the number below the 0 is valid\n                        if current_board[row+1][column] != 0 and current_board[row+1][column] != 0:\n                            # 14. Swap the 0 and the number below the 0\n                            new_board = self.swap(current_board, row, column, row+1, column)\n                            # 15. Check if the new board is not in the visited set\n                            if str(new_board) not in visited:\n                                # 16. Add the new board to the queue\n                                queue.append(new_board)\n                                # 17. Add the new board to the visited set\n                                visited.add(str(new_board))\n                    # 18. Check if the 0 is in the second column\n                    elif column == 1:\n                        # 19. Check if the number below the 0 is valid\n                        if current_board[row+1][column] != 0 and current_board[row+1][column] != 0:\n                            # 20. Swap the 0 and the number below the 0\n                            new_board = self.swap(current_board, row, column, row+1, column)\n                            # 21. Check if the new board is not in the visited set\n                            if str(new_board) not in visited:\n                                # 22. Add the new board to the queue\n                                queue.append(new_board)\n                                # 23. Add the new board to the visited set\n                                visited.add(str(new_board))\n                        # 24. Check if the number to the left of the 0 is valid\n                        if current_board[row][column-1] != 0 and current_board[row][column-1] != 0:\n                            # 25. Swap the 0 and the number to the left of the 0\n                            new_board = self.swap(current_board, row, column, row, column-1)\n                            # 26. Check if the new board is not in the visited set\n                            if str(new_board) not in visited:\n                                # 27. Add the new board to the queue\n                                queue.append(new_board)\n                                # 28. Add the new board to the visited set\n                                visited.add(str(new_board))\n                    # 29. Check if the 0 is in the third column\n                    elif column == 2:\n                        # 30. Check if the number below the 0 is valid\n                        if current_board[row+1][column] != 0 and current_board[row+1][column] != 0:\n                            # 31. Swap the 0 and the number below the 0\n                            new_board = self.swap(current_board, row, column, row+1, column)\n                            # 32. Check if the new board is not in the visited set\n                            if str(new_board) not in visited:\n                                # 33. Add"
        },
        {
            "task_id": "sliding-puzzle",
            "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the queue with the starting position\n        queue = [(\"\".join(str(i) for i in row), 0) for row in board]\n        \n        # 2. Loop until the queue is empty\n        while queue:\n            \n            # 3. Dequeue the first element\n            state, moves = queue.pop(0)\n            \n            # 4. If the state is the goal, return the number of moves\n            if state == \"123450\":\n                return moves\n            \n            # 5. Generate the neighbors\n            neighbors = self.getNeighbors(state)\n            \n            # 6. Enqueue the neighbors\n            queue.extend(neighbors)\n            \n        # 7. If the queue is empty, return -1\n        return -1\n    \n    def getNeighbors(self, state):\n        \"\"\"\n        :type state: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. Initialize the neighbors\n        neighbors = []\n        \n        # 2. Get the index of the 0\n        zero_index = state.index(\"0\")\n        \n        # 3. If the 0 is not on the last row, add the down state\n        if zero_index < 3:\n            down_state = state[:zero_index] + \"0\" + state[zero_index+1]\n            neighbors.append(down_state)\n        \n        # 4. If the 0 is not on the last column, add the right state\n        if zero_index % 3 != 2:\n            right_state = state[:zero_index] + \"0\" + state[zero_index+1]\n            neighbors.append(right_state)\n        \n        # 5. If the 0 is not on the first row, add the up state\n        if zero_index > 2:\n            up_state = state[:zero_index-3] + \"0\" + state[zero_index-3+1]\n            neighbors.append(up_state)\n        \n        # 6. If the 0 is not on the first column, add the left state\n        if zero_index % 3 != 0:\n            left_state = state[:zero_index-1] + \"0\" + state[zero_index-1+1]\n            neighbors.append(left_state)\n        \n        # 7. Return the neighbors\n        return neighbors"
        }
    ],
    "isomorphic-strings": [
        {
            "task_id": "isomorphic-strings",
            "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        if s == t:\n            return True\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_dict:\n                s_dict[s[i]] = t[i]\n            if t[i] not in t_dict:\n                t_dict[t[i]] = s[i]\n            if s_dict[s[i]] != t[i] or t_dict[t[i]] != s[i]:\n                return False\n        return True"
        },
        {
            "task_id": "isomorphic-strings",
            "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # Mapping of characters in s to characters in t\n        s_to_t = {}\n        t_to_s = {}\n        \n        # Iterate through the strings\n        for i in range(len(s)):\n            \n            # If the characters are not in the mapping, add them\n            if s[i] not in s_to_t:\n                s_to_t[s[i]] = t[i]\n            if t[i] not in t_to_s:\n                t_to_s[t[i]] = s[i]\n                \n            # If the characters are already in the mapping and don't match, return false\n            if s_to_t[s[i]] != t[i] or t_to_s[t[i]] != s[i]:\n                return False\n                \n        return True"
        },
        {
            "task_id": "isomorphic-strings",
            "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # Mapping of characters in s to characters in t\n        s_to_t = {}\n        t_to_s = {}\n        \n        # Iterate through each character in s and t\n        for i in range(len(s)):\n            \n            # If the character in s is not in the mapping, add it\n            if s[i] not in s_to_t:\n                s_to_t[s[i]] = t[i]\n                \n            # If the character in t is not in the mapping, add it\n            if t[i] not in t_to_s:\n                t_to_s[t[i]] = s[i]\n                \n            # If the character in s is already in the mapping and doesn't match the character in t\n            # or if the character in t is already in the mapping and doesn't match the character in s\n            if s_to_t[s[i]] != t[i] or t_to_s[t[i]] != s[i]:\n                return False\n                \n        return True"
        },
        {
            "task_id": "isomorphic-strings",
            "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # Mapping of characters from s to t\n        s_to_t = {}\n        # Mapping of characters from t to s\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_to_t:\n                if t[i] in t_to_s:\n                    return False\n                s_to_t[s[i]] = t[i]\n                t_to_s[t[i]] = s[i]\n            elif s_to_t[s[i]] != t[i]:\n                return False\n        return True"
        },
        {
            "task_id": "isomorphic-strings",
            "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize two empty dictionaries\n        d1 = {}\n        d2 = {}\n        \n        # Iterate over the strings\n        for i in range(len(s)):\n            \n            # If the characters are not in the dictionary\n            if s[i] not in d1 and t[i] not in d2:\n                \n                # Add the characters to the dictionary\n                d1[s[i]] = t[i]\n                d2[t[i]] = s[i]\n                \n            # If the characters are in the dictionary but don't match\n            elif d1[s[i]] != t[i] or d2[t[i]] != s[i]:\n                return False\n                \n        return True"
        }
    ],
    "search-in-rotated-sorted-array-ii": [
        {
            "task_id": "search-in-rotated-sorted-array-ii",
            "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0:\n            return False\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return True\n            else:\n                return False\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            \n            if nums[mid] == nums[left]:\n                left += 1\n                continue\n            \n            if nums[mid] > nums[left]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                    \n        return False"
        },
        {
            "task_id": "search-in-rotated-sorted-array-ii",
            "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0:\n            return False\n        \n        if len(nums) == 1:\n            return nums[0] == target\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            \n            if nums[mid] == nums[left]:\n                left += 1\n                continue\n            \n            if nums[mid] > nums[left]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                    \n        return False"
        },
        {
            "task_id": "search-in-rotated-sorted-array-ii",
            "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0:\n            return False\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return True\n            else:\n                return False\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] > nums[right]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False"
        },
        {
            "task_id": "search-in-rotated-sorted-array-ii",
            "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0:\n            return False\n        \n        if len(nums) == 1:\n            return nums[0] == target\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            \n            if nums[mid] == nums[left]:\n                left += 1\n                continue\n            \n            if nums[mid] > nums[left]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                    \n        return False"
        },
        {
            "task_id": "search-in-rotated-sorted-array-ii",
            "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0:\n            return False\n        \n        if len(nums) == 1:\n            return nums[0] == target\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            \n            if nums[mid] == nums[left]:\n                left += 1\n                continue\n            \n            if nums[mid] > nums[left]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                    \n        return False"
        }
    ],
    "unique-paths-ii": [
        {
            "task_id": "unique-paths-ii",
            "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"
        },
        {
            "task_id": "unique-paths-ii",
            "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"
        },
        {
            "task_id": "unique-paths-ii",
            "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"
        },
        {
            "task_id": "unique-paths-ii",
            "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"
        },
        {
            "task_id": "unique-paths-ii",
            "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"
        }
    ],
    "decode-ways-ii": [
        {
            "task_id": "decode-ways-ii",
            "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            if s[i - 1] != '*':\n                dp[i] += dp[i - 1]\n            else:\n                dp[i] += 9 * dp[i - 1]\n                \n            if i > 1 and s[i - 2] != '*' and int(s[i - 2] + s[i - 1]) <= 26:\n                dp[i] += dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] != '0':\n                dp[i] += 2 * dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] == '0':\n                dp[i] += dp[i - 2]\n                \n            dp[i] %= MOD\n            \n        return dp[n]"
        },
        {
            "task_id": "decode-ways-ii",
            "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            if s[i - 1] != '*':\n                dp[i] += dp[i - 1]\n            else:\n                dp[i] += 9 * dp[i - 1]\n                \n            if i > 1 and s[i - 2] != '*' and int(s[i - 2] + s[i - 1]) <= 26:\n                dp[i] += dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] != '0':\n                dp[i] += 2 * dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] == '0':\n                dp[i] += dp[i - 2]\n                \n            dp[i] %= MOD\n            \n        return dp[n]"
        },
        {
            "task_id": "decode-ways-ii",
            "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            if s[i - 1] != '*':\n                dp[i] += dp[i - 1]\n            else:\n                dp[i] += 9 * dp[i - 1]\n                \n            if i > 1 and s[i - 2] != '*' and int(s[i - 2] + s[i - 1]) <= 26:\n                dp[i] += dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] != '0':\n                dp[i] += 2 * dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] == '0':\n                dp[i] += dp[i - 2]\n                \n            dp[i] %= MOD\n            \n        return dp[n]"
        },
        {
            "task_id": "decode-ways-ii",
            "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            if s[i - 1] != '*':\n                dp[i] += dp[i - 1]\n            else:\n                dp[i] += 9 * dp[i - 1]\n                \n            if i > 1 and s[i - 2] != '*' and int(s[i - 2] + s[i - 1]) <= 26:\n                dp[i] += dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] != '0':\n                dp[i] += 2 * dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] == '0':\n                dp[i] += dp[i - 2]\n                \n            dp[i] %= MOD\n            \n        return dp[n]"
        },
        {
            "task_id": "decode-ways-ii",
            "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            if s[i - 1] != '*':\n                dp[i] += dp[i - 1]\n            else:\n                dp[i] += 9 * dp[i - 1]\n                \n            if i > 1 and s[i - 2] != '*' and int(s[i - 2] + s[i - 1]) <= 26:\n                dp[i] += dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] != '0':\n                dp[i] += 2 * dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] == '0':\n                dp[i] += dp[i - 2]\n                \n            dp[i] %= MOD\n            \n        return dp[n]"
        }
    ],
    "3sum-closest": [
        {
            "task_id": "3sum-closest",
            "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest_sum = 0\n        closest_diff = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        },
        {
            "task_id": "3sum-closest",
            "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        },
        {
            "task_id": "3sum-closest",
            "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        },
        {
            "task_id": "3sum-closest",
            "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        },
        {
            "task_id": "3sum-closest",
            "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        }
    ],
    "maximum-depth-of-binary-tree": [
        {
            "task_id": "maximum-depth-of-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            left_height = self.maxDepth(root.left)\n            right_height = self.maxDepth(root.right)\n            \n            return max(left_height, right_height) + 1"
        },
        {
            "task_id": "maximum-depth-of-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            left_height = self.maxDepth(root.left)\n            right_height = self.maxDepth(root.right)\n            \n            return max(left_height, right_height) + 1"
        },
        {
            "task_id": "maximum-depth-of-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            left_height = self.maxDepth(root.left)\n            right_height = self.maxDepth(root.right)\n            \n            return max(left_height, right_height) + 1"
        },
        {
            "task_id": "maximum-depth-of-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            left_height = self.maxDepth(root.left)\n            right_height = self.maxDepth(root.right)\n            \n            return max(left_height, right_height) + 1"
        },
        {
            "task_id": "maximum-depth-of-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            left_height = self.maxDepth(root.left)\n            right_height = self.maxDepth(root.right)\n            \n            return max(left_height, right_height) + 1"
        }
    ],
    "intersection-of-two-arrays-ii": [
        {
            "task_id": "intersection-of-two-arrays-ii",
            "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Sort both the arrays\n        nums1.sort()\n        nums2.sort()\n        \n        # Initialize the result array\n        result = []\n        \n        # Initialize the index of both arrays\n        i = 0\n        j = 0\n        \n        # Loop until any of the array gets completely traversed\n        while i < len(nums1) and j < len(nums2):\n            \n            # If the current element of nums1 is less than nums2, then increment i\n            if nums1[i] < nums2[j]:\n                i += 1\n            \n            # If the current element of nums2 is less than nums1, then increment j\n            elif nums2[j] < nums1[i]:\n                j += 1\n            \n            # If both the arrays have the same current element then store that element in result and increment both i and j\n            else:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return result"
        },
        {
            "task_id": "intersection-of-two-arrays-ii",
            "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Sorting the arrays\n        nums1.sort()\n        nums2.sort()\n        \n        # Initializing the result array\n        result = []\n        \n        # Looping through the arrays\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            \n            # If the elements are equal\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            \n            # If the element in nums1 is less than the element in nums2\n            elif nums1[i] < nums2[j]:\n                i += 1\n            \n            # If the element in nums1 is greater than the element in nums2\n            else:\n                j += 1\n        \n        return result"
        },
        {
            "task_id": "intersection-of-two-arrays-ii",
            "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Sort both the arrays\n        nums1.sort()\n        nums2.sort()\n        \n        # Initialize the result array\n        result = []\n        \n        # Initialize the index of both arrays\n        i = 0\n        j = 0\n        \n        # Loop until any of the array gets completely traversed\n        while i < len(nums1) and j < len(nums2):\n            \n            # If the current element of nums1 is less than nums2, then increment i\n            if nums1[i] < nums2[j]:\n                i += 1\n            \n            # If the current element of nums2 is less than nums1, then increment j\n            elif nums2[j] < nums1[i]:\n                j += 1\n            \n            # If both the arrays have the same current element then store that element in result and increment both i and j\n            else:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return result"
        },
        {
            "task_id": "intersection-of-two-arrays-ii",
            "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Sorting the arrays\n        nums1.sort()\n        nums2.sort()\n        \n        # Initializing the result array\n        result = []\n        \n        # Looping through the arrays\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                \n                # If the elements are equal\n                if nums1[i] == nums2[j]:\n                    \n                    # Appending the element to the result array\n                    result.append(nums1[i])\n                    \n                    # Removing the element from the second array\n                    nums2.remove(nums2[j])\n                    \n                    # Breaking the loop\n                    break\n                    \n        # Returning the result array\n        return result"
        },
        {
            "task_id": "intersection-of-two-arrays-ii",
            "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Sorting the arrays\n        nums1.sort()\n        nums2.sort()\n        \n        # Initializing the result array\n        result = []\n        \n        # Initializing the pointers for nums1 and nums2\n        i = 0\n        j = 0\n        \n        # Loop until any one of the array gets exhausted\n        while i < len(nums1) and j < len(nums2):\n            \n            # If the elements match\n            if nums1[i] == nums2[j]:\n                \n                # Append the element to the result array\n                result.append(nums1[i])\n                \n                # Increment both the pointers\n                i += 1\n                j += 1\n            \n            # If the element of nums1 is smaller\n            # then increment the pointer of nums1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            \n            # If the element of nums2 is smaller\n            # then increment the pointer of nums2\n            else:\n                j += 1\n        \n        # return the result\n        return result"
        }
    ],
    "minimum-absolute-difference-in-bst": [
        {
            "task_id": "minimum-absolute-difference-in-bst",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.arr.append(root.val)\n                inorder(root.right)\n        \n        self.arr = []\n        inorder(root)\n        return min(self.arr[i] - self.arr[i-1] for i in range(1, len(self.arr)))"
        },
        {
            "task_id": "minimum-absolute-difference-in-bst",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.arr.append(root.val)\n                inorder(root.right)\n        \n        self.arr = []\n        inorder(root)\n        return min(self.arr[i] - self.arr[i-1] for i in range(1, len(self.arr)))"
        },
        {
            "task_id": "minimum-absolute-difference-in-bst",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.arr.append(root.val)\n                inorder(root.right)\n        \n        self.arr = []\n        inorder(root)\n        return min(self.arr[i] - self.arr[i-1] for i in range(1, len(self.arr)))"
        },
        {
            "task_id": "minimum-absolute-difference-in-bst",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.arr.append(root.val)\n                inorder(root.right)\n        \n        self.arr = []\n        inorder(root)\n        return min(self.arr[i] - self.arr[i-1] for i in range(1, len(self.arr)))"
        },
        {
            "task_id": "minimum-absolute-difference-in-bst",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.arr.append(root.val)\n                inorder(root.right)\n        \n        self.arr = []\n        inorder(root)\n        return min(self.arr[i] - self.arr[i-1] for i in range(1, len(self.arr)))"
        }
    ],
    "find-mode-in-binary-search-tree": [
        {
            "task_id": "find-mode-in-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        self.count = 1\n        self.prev = None\n        self.ans = []\n        self.max_freq = 0\n        \n        def inorder(node):\n            if node:\n                inorder(node.left)\n                self.update(node.val)\n                inorder(node.right)\n        \n        inorder(root)\n        return self.ans\n    \n    def update(self, val):\n        if self.prev == val:\n            self.count += 1\n        else:\n            self.count = 1\n        \n        if self.count > self.max_freq:\n            self.max_freq = self.count\n            self.ans = [val]\n        elif self.count == self.max_freq:\n            self.ans.append(val)\n        \n        self.prev = val"
        },
        {
            "task_id": "find-mode-in-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        stack.append(root)\n        count = 0\n        max_count = 0\n        modes = []\n        prev = None\n        \n        while stack:\n            node = stack.pop()\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n            \n            if prev is None:\n                prev = node\n                count = 1\n            elif prev.val == node.val:\n                count += 1\n            else:\n                if count > max_count:\n                    max_count = count\n                    modes = [prev.val]\n                elif count == max_count:\n                    modes.append(prev.val)\n                count = 1\n                prev = node\n        \n        if count > max_count:\n            max_count = count\n            modes = [prev.val]\n        elif count == max_count:\n            modes.append(prev.val)\n        \n        return modes"
        },
        {
            "task_id": "find-mode-in-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        stack.append(root)\n        count = 0\n        max_count = 0\n        modes = []\n        prev = None\n        \n        while stack:\n            node = stack.pop()\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n            \n            if prev is None:\n                prev = node\n                count = 1\n            elif prev.val == node.val:\n                count += 1\n            else:\n                if count > max_count:\n                    max_count = count\n                    modes = [prev.val]\n                elif count == max_count:\n                    modes.append(prev.val)\n                prev = node\n                count = 1\n        \n        if count > max_count:\n            max_count = count\n            modes = [prev.val]\n        elif count == max_count:\n            modes.append(prev.val)\n        \n        return modes"
        },
        {
            "task_id": "find-mode-in-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        self.count = 1\n        self.prev = None\n        self.ans = []\n        self.max_freq = 0\n        \n        def inorder(node):\n            if node:\n                inorder(node.left)\n                self.update(node.val)\n                inorder(node.right)\n        \n        inorder(root)\n        return self.ans\n    \n    def update(self, val):\n        if self.prev == val:\n            self.count += 1\n        else:\n            self.count = 1\n        \n        if self.count > self.max_freq:\n            self.max_freq = self.count\n            self.ans = [val]\n        elif self.count == self.max_freq:\n            self.ans.append(val)\n        \n        self.prev = val"
        },
        {
            "task_id": "find-mode-in-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        self.count = 1\n        self.prev = None\n        self.ans = []\n        self.max_freq = 0\n        \n        def inorder(node):\n            if node:\n                inorder(node.left)\n                self.update(node.val)\n                inorder(node.right)\n        \n        inorder(root)\n        return self.ans\n    \n    def update(self, val):\n        if self.prev == val:\n            self.count += 1\n        else:\n            self.count = 1\n        \n        if self.count > self.max_freq:\n            self.max_freq = self.count\n            self.ans = [val]\n        elif self.count == self.max_freq:\n            self.ans.append(val)\n        \n        self.prev = val"
        }
    ],
    "find-the-index-of-the-first-occurrence-in-a-string": [
        {
            "task_id": "find-the-index-of-the-first-occurrence-in-a-string",
            "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1"
        },
        {
            "task_id": "find-the-index-of-the-first-occurrence-in-a-string",
            "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        else:\n            for i in range(len(haystack)):\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n            return -1"
        },
        {
            "task_id": "find-the-index-of-the-first-occurrence-in-a-string",
            "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1"
        },
        {
            "task_id": "find-the-index-of-the-first-occurrence-in-a-string",
            "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        else:\n            for i in range(len(haystack)):\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n            return -1"
        },
        {
            "task_id": "find-the-index-of-the-first-occurrence-in-a-string",
            "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1"
        }
    ],
    "strong-password-checker": [
        {
            "task_id": "strong-password-checker",
            "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Check if password is strong\n        # 2. If not strong, check for the missing conditions\n        # 3. If missing conditions are 3, then return 6 - len(password)\n        # 4. If missing conditions are 2, then return 5 - len(password)\n        # 5. If missing conditions are 1, then return 4 - len(password)\n        # 6. If missing conditions are 0, then return 3 - len(password)\n        \n        # 1. Check if password is strong\n        if len(password) < 6 or len(password) > 20:\n            return 0\n        if not any(char.islower() for char in password):\n            return 0\n        if not any(char.isupper() for char in password):\n            return 0\n        if not any(char.isdigit() for char in password):\n            return 0\n        if '!' in password or '.' in password:\n            return 0\n        \n        # 2. If not strong, check for the missing conditions\n        missing_conditions = 0\n        if not any(char.islower() for char in password):\n            missing_conditions += 1\n        if not any(char.isupper() for char in password):\n            missing_conditions += 1\n        if not any(char.isdigit() for char in password):\n            missing_conditions += 1\n        \n        # 3. If missing conditions are 3, then return 6 - len(password)\n        if missing_conditions == 3:\n            return 6 - len(password)\n        \n        # 4. If missing conditions are 2, then return 5 - len(password)\n        if missing_conditions == 2:\n            return 5 - len(password)\n        \n        # 5. If missing conditions are 1, then return 4 - len(password)\n        if missing_conditions == 1:\n            return 4 - len(password)\n        \n        # 6. If missing conditions are 0, then return 3 - len(password)\n        if missing_conditions == 0:\n            return 3 - len(password)"
        },
        {
            "task_id": "strong-password-checker",
            "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Check for length\n        # 2. Check for lowercase\n        # 3. Check for uppercase\n        # 4. Check for digit\n        # 5. Check for repeating characters\n        \n        # 1. Check for length\n        if len(password) < 6:\n            return 6 - len(password)\n        elif len(password) > 20:\n            return 20 - len(password)\n        \n        # 2. Check for lowercase\n        if not any(c.islower() for c in password):\n            return max(1, len(password) - 20) + 1\n        \n        # 3. Check for uppercase\n        if not any(c.isupper() for c in password):\n            return max(1, len(password) - 20) + 1\n        \n        # 4. Check for digit\n        if not any(c.isdigit() for c in password):\n            return max(1, len(password) - 20) + 1\n        \n        # 5. Check for repeating characters\n        i = 2\n        count = 1\n        while i < len(password):\n            if password[i] == password[i-1]:\n                count += 1\n                if count == 3:\n                    return len(password) - 2\n            else:\n                count = 1\n            i += 1\n        \n        return max(0, 3 - len(password))"
        },
        {
            "task_id": "strong-password-checker",
            "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        length = len(password)\n        has_lower = False\n        has_upper = False\n        has_digit = False\n        has_three = False\n        replace = 0\n        delete = 0\n        add = 0\n        \n        # Check for length\n        if length < 6:\n            add = 6 - length\n        elif length > 20:\n            delete = length - 20\n        else:\n            add = 0\n            delete = 0\n        \n        # Check for characters\n        for i in range(length):\n            if password[i].islower():\n                has_lower = True\n            elif password[i].isupper():\n                has_upper = True\n            elif password[i].isdigit():\n                has_digit = True\n            if i < length - 2:\n                if password[i] == password[i+1] == password[i+2]:\n                    has_three = True\n        \n        # Check for three repeating characters\n        if has_three:\n            replace = 1\n        \n        # Return minimum number of steps\n        return max(add, delete, replace)"
        },
        {
            "task_id": "strong-password-checker",
            "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Check if password is strong\n        # 2. If not, check if it is weak\n        # 3. If not, check if it is medium\n        # 4. If not, check if it is strong\n        \n        # 1. Check if password is strong\n        if len(password) >= 6 and len(password) <= 20:\n            if self.check_lowercase(password) and self.check_uppercase(password) and self.check_digit(password):\n                return 0\n        \n        # 2. If not, check if it is weak\n        if len(password) < 6:\n            return 6 - len(password)\n        \n        # 3. If not, check if it is medium\n        if len(password) > 20:\n            return self.check_medium(password)\n        \n        # 4. If not, check if it is strong\n        return self.check_strong(password)\n        \n    def check_lowercase(self, password):\n        for i in range(len(password)):\n            if password[i].islower():\n                return True\n        return False\n        \n    def check_uppercase(self, password):\n        for i in range(len(password)):\n            if password[i].isupper():\n                return True\n        return False\n        \n    def check_digit(self, password):\n        for i in range(len(password)):\n            if password[i].isdigit():\n                return True\n        return False\n        \n    def check_medium(self, password):\n        count = 0\n        for i in range(len(password)):\n            if password[i].islower():\n                count += 1\n            elif password[i].isupper():\n                count += 1\n            elif password[i].isdigit():\n                count += 1\n            else:\n                count += 2\n        return count\n        \n    def check_strong(self, password):\n        count = 0\n        for i in range(len(password)):\n            if password[i].islower():\n                count += 1\n            elif password[i].isupper():\n                count += 1\n            elif password[i].isdigit():\n                count += 1\n            else:\n                count += 2\n        return count"
        },
        {
            "task_id": "strong-password-checker",
            "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Check if password is strong\n        # 2. If not strong, check if it is weak\n        # 3. If not weak, check if it is medium\n        # 4. If not medium, check if it is strong\n        \n        # 1. Check if password is strong\n        if len(password) >= 6 and len(password) <= 20:\n            if self.check_lowercase(password) and self.check_uppercase(password) and self.check_digit(password):\n                return 0\n        \n        # 2. If not strong, check if it is weak\n        if len(password) < 6:\n            return 6 - len(password)\n        \n        # 3. If not weak, check if it is medium\n        if len(password) > 20:\n            return len(password) - 20\n        \n        # 4. If not medium, check if it is strong\n        if not self.check_lowercase(password):\n            return 1\n        if not self.check_uppercase(password):\n            return 1\n        if not self.check_digit(password):\n            return 1\n        \n        # 5. If not strong, check if it is weak\n        if len(password) < 6:\n            return 6 - len(password)\n        \n        # 6. If not weak, check if it is medium\n        if len(password) > 20:\n            return len(password) - 20\n        \n        # 7. If not medium, check if it is strong\n        if not self.check_lowercase(password):\n            return 1\n        if not self.check_uppercase(password):\n            return 1\n        if not self.check_digit(password):\n            return 1\n        \n        # 8. If not strong, check if it is weak\n        if len(password) < 6:\n            return 6 - len(password)\n        \n        # 9. If not weak, check if it is medium\n        if len(password) > 20:\n            return len(password) - 20\n        \n        # 10. If not medium, check if it is strong\n        if not self.check_lowercase(password):\n            return 1\n        if not self.check_uppercase(password):\n            return 1\n        if not self.check_digit(password):\n            return 1\n        \n        # 11. If not strong, check if it is weak\n        if len(password) < 6:\n            return 6 - len(password)\n        \n        # 12. If not weak, check if it is medium\n        if len(password) > 20:\n            return len(password) - 20\n        \n        # 13. If not medium, check if it is strong\n        if not self.check_lowercase(password):\n            return 1\n        if not self.check_uppercase(password):\n            return 1\n        if not self.check_digit(password):\n            return 1\n        \n        # 14. If not strong, check if it is weak\n        if len(password) < 6:\n            return 6 - len(password)\n        \n        # 15. If not weak, check if it is medium\n        if len(password) > 20:\n            return len(password) - 20\n        \n        # 16. If not medium, check if it is strong\n        if not self.check_lowercase(password):\n            return 1\n        if not self.check_uppercase(password):\n            return 1\n        if not self.check_digit(password):\n            return 1\n        \n        # 17. If not strong, check if it is weak\n        if len(password) < 6:\n            return 6 - len(password)\n        \n        # 18. If not weak, check if it is medium\n        if len(password) > 20:\n            return len(password) - 20\n        \n        # 19. If not medium, check if it is strong\n        if not self.check_lowercase(password):\n            return 1\n        if not self.check_uppercase(password):\n            return 1\n        if not self.check_digit(password):\n            return 1"
        }
    ],
    "factorial-trailing-zeroes": [
        {
            "task_id": "factorial-trailing-zeroes",
            "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        else:\n            return n/5 + self.trailingZeroes(n/5)"
        },
        {
            "task_id": "factorial-trailing-zeroes",
            "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        else:\n            return n/5 + self.trailingZeroes(n/5)"
        },
        {
            "task_id": "factorial-trailing-zeroes",
            "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        else:\n            return n/5 + self.trailingZeroes(n/5)"
        },
        {
            "task_id": "factorial-trailing-zeroes",
            "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        else:\n            return n/5 + self.trailingZeroes(n/5)"
        },
        {
            "task_id": "factorial-trailing-zeroes",
            "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        else:\n            count = 0\n            while n > 0:\n                n = n // 5\n                count += n\n            return count"
        }
    ],
    "zigzag-conversion": [
        {
            "task_id": "zigzag-conversion",
            "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        # create a list of strings\n        # each string is a row\n        rows = [''] * numRows\n        \n        # current row\n        cur_row = 0\n        \n        # current direction\n        # 1 means down, -1 means up\n        direction = 1\n        \n        for char in s:\n            rows[cur_row] += char\n            if cur_row == 0 or cur_row == numRows - 1:\n                direction = -direction\n            cur_row += direction\n        \n        return ''.join(rows)"
        },
        {
            "task_id": "zigzag-conversion",
            "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        row = 0\n        down = False\n        \n        for char in s:\n            rows[row] += char\n            if row == 0 or row == numRows - 1:\n                down = not down\n            row += 1 if down else -1\n        \n        return ''.join(rows)"
        },
        {
            "task_id": "zigzag-conversion",
            "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        row = 0\n        down = False\n        \n        for char in s:\n            rows[row] += char\n            if row == 0 or row == numRows - 1:\n                down = not down\n            row += 1 if down else -1\n        \n        return ''.join(rows)"
        },
        {
            "task_id": "zigzag-conversion",
            "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        direction = 1\n        row = 0\n        \n        for char in s:\n            rows[row] += char\n            if row == numRows - 1 or row == 0:\n                direction *= -1\n            row += direction\n            \n        return ''.join(rows)"
        },
        {
            "task_id": "zigzag-conversion",
            "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        direction = 1\n        row = 0\n        \n        for char in s:\n            rows[row] += char\n            if row == numRows - 1 or row == 0:\n                direction = -direction\n            row += direction\n            \n        return ''.join(rows)"
        }
    ],
    "trapping-rain-water": [
        {
            "task_id": "trapping-rain-water",
            "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        left = 0\n        right = len(height) - 1\n        water = 0\n        left_max = 0\n        right_max = 0\n        \n        # Loop until the two pointers meet\n        while left < right:\n            \n            # Calculate the water accumulated between the left and right pointers\n            if height[left] < height[right]:\n                if height[left] > left_max:\n                    left_max = height[left]\n                else:\n                    water += left_max - height[left]\n                left += 1\n            else:\n                if height[right] > right_max:\n                    right_max = height[right]\n                else:\n                    water += right_max - height[right]\n                right -= 1\n                \n        return water"
        },
        {
            "task_id": "trapping-rain-water",
            "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        left = 0\n        right = len(height) - 1\n        water = 0\n        left_max = 0\n        right_max = 0\n        \n        # Loop until the two pointers meet\n        while left < right:\n            \n            # Calculate the water accumulated between the left and right pointers\n            if height[left] < height[right]:\n                if height[left] > left_max:\n                    left_max = height[left]\n                else:\n                    water += left_max - height[left]\n                left += 1\n            else:\n                if height[right] > right_max:\n                    right_max = height[right]\n                else:\n                    water += right_max - height[right]\n                right -= 1\n                \n        return water"
        },
        {
            "task_id": "trapping-rain-water",
            "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        left = 0\n        right = len(height) - 1\n        water = 0\n        left_max = 0\n        right_max = 0\n        \n        # Loop until the two pointers meet\n        while left < right:\n            \n            # Calculate the water accumulated between the left and right pointers\n            if height[left] < height[right]:\n                if height[left] > left_max:\n                    left_max = height[left]\n                else:\n                    water += left_max - height[left]\n                left += 1\n            else:\n                if height[right] > right_max:\n                    right_max = height[right]\n                else:\n                    water += right_max - height[right]\n                right -= 1\n                \n        return water"
        },
        {
            "task_id": "trapping-rain-water",
            "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        left = 0\n        right = len(height) - 1\n        water = 0\n        left_max = 0\n        right_max = 0\n        \n        # Loop until the two pointers meet\n        while left < right:\n            \n            # Calculate the water trapped between the left and right bars\n            if height[left] < height[right]:\n                if height[left] > left_max:\n                    left_max = height[left]\n                else:\n                    water += left_max - height[left]\n                left += 1\n            else:\n                if height[right] > right_max:\n                    right_max = height[right]\n                else:\n                    water += right_max - height[right]\n                right -= 1\n                \n        return water"
        },
        {
            "task_id": "trapping-rain-water",
            "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        left = 0\n        right = len(height) - 1\n        water = 0\n        left_max = 0\n        right_max = 0\n        \n        # Loop until the two pointers meet\n        while left < right:\n            \n            # Calculate the water accumulated between the left and right pointers\n            if height[left] < height[right]:\n                if height[left] > left_max:\n                    left_max = height[left]\n                else:\n                    water += left_max - height[left]\n                left += 1\n            else:\n                if height[right] > right_max:\n                    right_max = height[right]\n                else:\n                    water += right_max - height[right]\n                right -= 1\n                \n        return water"
        }
    ],
    "find-all-numbers-disappeared-in-an-array": [
        {
            "task_id": "find-all-numbers-disappeared-in-an-array",
            "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        #initialize an empty list\n        result = []\n        \n        #loop through the list\n        for i in range(len(nums)):\n            \n            #if the number is not in the list\n            if nums[i] not in nums:\n                \n                #append the number to the list\n                result.append(nums[i])\n                \n        #return the list\n        return result"
        },
        {
            "task_id": "find-all-numbers-disappeared-in-an-array",
            "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        #initialize an empty list\n        result = []\n        \n        #loop through the list\n        for i in range(len(nums)):\n            \n            #if the number is not in the list\n            if nums[i] not in nums:\n                \n                #add the number to the list\n                result.append(nums[i])\n                \n        #return the list\n        return result"
        },
        {
            "task_id": "find-all-numbers-disappeared-in-an-array",
            "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        #initialize an empty list to store the missing numbers\n        missing_numbers = []\n        \n        #create a set of the given array\n        s = set(nums)\n        \n        #loop through the range of numbers\n        for i in range(1, len(nums)+1):\n            \n            #if the number is not in the set then add it to the missing numbers list\n            if i not in s:\n                missing_numbers.append(i)\n                \n        return missing_numbers"
        },
        {
            "task_id": "find-all-numbers-disappeared-in-an-array",
            "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        #initialize a list to store the missing numbers\n        missing_numbers = []\n        \n        #create a set of the given numbers\n        given_numbers = set(nums)\n        \n        #create a set of numbers that should be in the list\n        real_numbers = set(range(1, len(nums)+1))\n        \n        #find the symmetric difference of the two sets\n        #and convert it to a list\n        missing_numbers = list(real_numbers - given_numbers)\n        \n        return missing_numbers"
        },
        {
            "task_id": "find-all-numbers-disappeared-in-an-array",
            "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        #initialize an empty list\n        result = []\n        \n        #loop through the list\n        for i in range(len(nums)):\n            \n            #if the number is not in the list\n            if nums[i] not in nums:\n                \n                #append the number to the list\n                result.append(nums[i])\n                \n        #return the list\n        return result"
        }
    ],
    "count-of-smaller-numbers-after-self": [
        {
            "task_id": "count-of-smaller-numbers-after-self",
            "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize an empty list to store the sorted array\n        sorted_array = []\n        \n        # Initialize an empty list to store the count of smaller elements\n        count = []\n        \n        # Loop through the input array\n        for i in range(len(nums)):\n            \n            # Initialize a variable to store the count of smaller elements\n            smaller_count = 0\n            \n            # Loop through the sorted array\n            for j in range(len(sorted_array)):\n                \n                # Check if the current element in the sorted array is smaller than the current element in the input array\n                if sorted_array[j] < nums[i]:\n                    \n                    # Increment the count of smaller elements\n                    smaller_count += 1\n                    \n            # Add the count of smaller elements to the count list\n            count.append(smaller_count)\n            \n            # Add the current element in the input array to the sorted array\n            sorted_array.append(nums[i])\n            \n        # Return the count list\n        return count"
        },
        {
            "task_id": "count-of-smaller-numbers-after-self",
            "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize an empty list to store the sorted array\n        sorted_nums = []\n        \n        # Initialize an empty list to store the count of smaller elements\n        count = []\n        \n        # Loop through the input array\n        for num in nums:\n            \n            # Find the index to insert the current element in the sorted array\n            # such that the sorted array remains sorted\n            index = self.find_index(sorted_nums, num)\n            \n            # Insert the current element at the found index\n            sorted_nums.insert(index, num)\n            \n            # Insert the count of smaller elements before the current element\n            # in the count array\n            count.insert(index, index)\n            \n            # If the current element is not inserted at the end of the sorted array\n            # increment all the elements in the count array after the found index\n            if index != len(sorted_nums) - 1:\n                for i in range(index + 1, len(sorted_nums)):\n                    count[i] += 1\n                    \n        return count\n    \n    def find_index(self, sorted_nums, num):\n        \"\"\"\n        Find the index to insert the current element in the sorted array\n        such that the sorted array remains sorted\n        \"\"\"\n        \n        # If the sorted array is empty, return 0\n        if not sorted_nums:\n            return 0\n        \n        # Initialize the start and end indices of the sorted array\n        start = 0\n        end = len(sorted_nums) - 1\n        \n        # Loop until the start index is greater than the end index\n        while start <= end:\n            \n            # Find the middle index\n            mid = (start + end) // 2\n            \n            # If the current element is greater than the element at the middle index\n            # the middle index is the correct index, return it\n            if num > sorted_nums[mid]:\n                return mid + 1\n            \n            # If the current element is less than the element at the middle index\n            # the correct index is less than the middle index\n            # make the end index the middle index - 1\n            elif num <= sorted_nums[mid]:\n                end = mid - 1\n                \n        # Return the start index\n        return start"
        },
        {
            "task_id": "count-of-smaller-numbers-after-self",
            "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize an empty list to store the sorted array\n        sorted_nums = []\n        \n        # Initialize an empty list to store the count of smaller elements\n        count = []\n        \n        # Loop through the input array\n        for num in nums:\n            \n            # Find the index to insert the current element in the sorted array\n            # such that the sorted array remains sorted\n            index = self.find_index(sorted_nums, num)\n            \n            # Insert the current element at the found index\n            sorted_nums.insert(index, num)\n            \n            # Insert the count of smaller elements before the current element\n            # in the count array\n            count.insert(index, index)\n            \n            # If the current element is not inserted at the end of the sorted array\n            # increment all the elements in the count array after the found index\n            if index != len(sorted_nums) - 1:\n                for i in range(index + 1, len(sorted_nums)):\n                    count[i] += 1\n                    \n        return count\n    \n    def find_index(self, sorted_nums, num):\n        \"\"\"\n        Find the index to insert the current element in the sorted array\n        such that the sorted array remains sorted\n        \"\"\"\n        \n        # If the sorted array is empty, return 0\n        if not sorted_nums:\n            return 0\n        \n        # Initialize the start and end indices of the sorted array\n        start = 0\n        end = len(sorted_nums) - 1\n        \n        # Loop until the start index is greater than the end index\n        while start <= end:\n            \n            # Find the middle index\n            mid = (start + end) // 2\n            \n            # If the current element is greater than the element at the middle index\n            # the smallest element is to the right of the middle index\n            if num > sorted_nums[mid]:\n                start = mid + 1\n            \n            # If the current element is less than or equal to the element at the middle index\n            # the smallest element is to the left of the middle index or the current element\n            # is the smallest\n            else:\n                end = mid - 1\n        \n        return start"
        },
        {
            "task_id": "count-of-smaller-numbers-after-self",
            "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        #initialize an empty list to store the count of smaller elements\n        count = []\n        \n        #sort the list in descending order\n        nums.sort(reverse = True)\n        \n        #initialize a variable to store the count\n        count_val = 0\n        \n        #loop through the list\n        for i in range(len(nums)):\n            \n            #if the current element is not equal to the previous element\n            if i > 0 and nums[i] != nums[i-1]:\n                \n                #reset the count\n                count_val = 0\n            \n            #append the count to the list\n            count.append(count_val)\n            \n            #increment the count by 1\n            count_val += 1\n        \n        #return the list\n        return count"
        },
        {
            "task_id": "count-of-smaller-numbers-after-self",
            "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        #initialize an empty list to store the count of smaller elements\n        count = []\n        \n        #initialize an empty list to store the sorted elements\n        sorted_list = []\n        \n        #loop through the nums list\n        for i in nums:\n            \n            #initialize a variable to store the count of smaller elements\n            count_smaller = 0\n            \n            #loop through the sorted_list\n            for j in sorted_list:\n                \n                #if the element in the sorted_list is smaller than the element in the nums list\n                if j < i:\n                    \n                    #increment the count of smaller elements\n                    count_smaller += 1\n                    \n            #append the count of smaller elements to the count list\n            count.append(count_smaller)\n            \n            #append the element in the nums list to the sorted_list\n            sorted_list.append(i)\n            \n        #return the count list\n        return count"
        }
    ],
    "set-intersection-size-at-least-two": [
        {
            "task_id": "set-intersection-size-at-least-two",
            "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[0])\n        ans = 0\n        i = 0\n        while i < len(intervals):\n            ans += 2\n            start = intervals[i][0]\n            end = intervals[i][1]\n            while i < len(intervals) and intervals[i][0] <= end:\n                i += 1\n            if i < len(intervals) and intervals[i][0] <= end + 1:\n                ans -= 1\n            if start > 1:\n                ans -= 1\n        return ans"
        },
        {
            "task_id": "set-intersection-size-at-least-two",
            "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[0])\n        ans = 0\n        i = 0\n        while i < len(intervals):\n            ans += 2\n            start = intervals[i][0]\n            end = intervals[i][1]\n            i += 1\n            while i < len(intervals) and intervals[i][0] <= end:\n                end = max(end, intervals[i][1])\n                i += 1\n        return ans"
        },
        {
            "task_id": "set-intersection-size-at-least-two",
            "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[0])\n        ans = 0\n        i = 0\n        while i < len(intervals):\n            ans += 2\n            start = intervals[i][0]\n            end = intervals[i][1]\n            i += 1\n            while i < len(intervals) and intervals[i][0] <= end:\n                end = max(end, intervals[i][1])\n                i += 1\n        return ans"
        },
        {
            "task_id": "set-intersection-size-at-least-two",
            "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key = lambda x: x[0])\n        ans = 0\n        for i in range(len(intervals)):\n            if i == 0:\n                ans += 2\n            else:\n                if intervals[i][0] <= intervals[i-1][1] + 1:\n                    ans += 1\n                else:\n                    ans += 2\n        return ans"
        },
        {
            "task_id": "set-intersection-size-at-least-two",
            "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[0])\n        ans = 0\n        i = 0\n        while i < len(intervals):\n            ans += 2\n            start = intervals[i][0]\n            end = intervals[i][1]\n            i += 1\n            while i < len(intervals) and intervals[i][0] <= end:\n                end = max(end, intervals[i][1])\n                i += 1\n        return ans"
        }
    ],
    "symmetric-tree": [
        {
            "task_id": "symmetric-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        def check(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            if left.val != right.val:\n                return False\n            return check(left.left, right.right) and check(left.right, right.left)\n        \n        return check(root.left, root.right)"
        },
        {
            "task_id": "symmetric-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        if left is None and right is None:\n            return True\n        if left is None or right is None:\n            return False\n        return left.val == right.val and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"
        },
        {
            "task_id": "symmetric-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        return self.isSymmetricHelper(root.left, root.right)\n        \n    def isSymmetricHelper(self, left, right):\n        if left is None and right is None:\n            return True\n        if left is None or right is None:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isSymmetricHelper(left.left, right.right) and self.isSymmetricHelper(left.right, right.left)"
        },
        {
            "task_id": "symmetric-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        if left is None and right is None:\n            return True\n        if left is None or right is None:\n            return False\n        return left.val == right.val and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"
        },
        {
            "task_id": "symmetric-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root.left, root.right)"
        }
    ],
    "number-of-atoms": [
        {
            "task_id": "number-of-atoms",
            "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in range(len(formula)):\n            if formula[i] == '(':\n                stack.append(formula[i])\n            elif formula[i] == ')':\n                while stack[-1] != '(':\n                    stack.pop()\n                stack.pop()\n            else:\n                stack.append(formula[i])\n        print(stack)\n        stack.reverse()\n        print(stack)\n        return stack"
        },
        {
            "task_id": "number-of-atoms",
            "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in range(len(formula)):\n            if formula[i] == '(':\n                stack.append(formula[i])\n            elif formula[i] == ')':\n                while stack[-1] != '(':\n                    stack.pop()\n                stack.pop()\n            else:\n                stack.append(formula[i])\n        return ''.join(stack)"
        },
        {
            "task_id": "number-of-atoms",
            "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # stack to store the current element and its count\n        stack = []\n        \n        # current element and its count\n        curEle = \"\"\n        curCount = 0\n        \n        # result map\n        result = {}\n        \n        for i in range(len(formula)):\n            if formula[i].isalpha():\n                # if the current char is a letter\n                # if the current element is not empty\n                # add the current element to the stack\n                if curEle != \"\":\n                    stack.append([curEle, curCount])\n                \n                # update the current element\n                curEle = formula[i]\n                curCount = 0\n                \n            elif formula[i].isdigit():\n                # if the current char is a digit\n                # update the current count\n                curCount = curCount * 10 + int(formula[i])\n                \n            elif formula[i] == \"(\":\n                # if the current char is \"(\"\n                # add the current element and count to the stack\n                stack.append([curEle, curCount])\n                \n                # reset the current element and count\n                curEle = \"\"\n                curCount = 0\n                \n            elif formula[i] == \")\":\n                # if the current char is \")\"\n                # pop an element from the stack\n                # and multiply the count\n                topEle, topCount = stack.pop()\n                curCount *= topCount\n                \n                # add the current element to the stack\n                stack.append([topEle, curCount])\n                \n                # reset the current element and count\n                curEle = \"\"\n                curCount = 0\n                \n        # add the last element to the stack\n        stack.append([curEle, curCount])\n        \n        # iterate the stack\n        while stack:\n            # pop an element from the stack\n            curEle, curCount = stack.pop()\n            \n            # if the element is already in the result\n            if curEle in result:\n                # add the count\n                result[curEle] += curCount\n            else:\n                # add the element to the result\n                result[curEle] = curCount\n                \n        # sort the result\n        sortedResult = sorted(result.items(), key=lambda x: x[0])\n        \n        # initialize the answer\n        ans = \"\"\n        \n        # iterate the sorted result\n        for ele, count in sortedResult:\n            # add the element and its count to the answer\n            ans += ele\n            if count > 1:\n                ans += str(count)\n                \n        return ans"
        },
        {
            "task_id": "number-of-atoms",
            "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in range(len(formula)):\n            if formula[i] == '(':\n                stack.append(formula[i])\n            elif formula[i] == ')':\n                while stack[-1] != '(':\n                    stack.pop()\n                stack.pop()\n            else:\n                stack.append(formula[i])\n        print(stack)\n        stack.reverse()\n        print(stack)\n        return stack"
        },
        {
            "task_id": "number-of-atoms",
            "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # stack to store the current element and its count\n        stack = []\n        \n        # current element and its count\n        cur_element = \"\"\n        cur_count = 0\n        \n        # result map\n        result = {}\n        \n        for i in range(len(formula)):\n            if formula[i].islower():\n                cur_element += formula[i]\n            elif formula[i].isdigit():\n                cur_count = int(formula[i])\n            elif formula[i] == \"(\":\n                stack.append([cur_element, cur_count])\n                cur_element = \"\"\n                cur_count = 0\n            elif formula[i] == \")\":\n                count = stack.pop()[1]\n                if cur_count > 0:\n                    count *= cur_count\n                cur_count = count\n            else:\n                if cur_element != \"\":\n                    if cur_element not in result:\n                        result[cur_element] = 0\n                    result[cur_element] += cur_count\n                cur_element = formula[i]\n                cur_count = 1\n        \n        # handle last element\n        if cur_element != \"\":\n            if cur_element not in result:\n                result[cur_element] = 0\n            result[cur_element] += cur_count\n        \n        # build the answer\n        answer = \"\"\n        for element in sorted(result.keys()):\n            answer += element\n            if result[element] > 1:\n                answer += str(result[element])\n        return answer"
        }
    ],
    "binary-tree-preorder-traversal": [
        {
            "task_id": "binary-tree-preorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        else:\n            return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)"
        },
        {
            "task_id": "binary-tree-preorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        else:\n            return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)"
        },
        {
            "task_id": "binary-tree-preorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        else:\n            return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)"
        },
        {
            "task_id": "binary-tree-preorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        else:\n            return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)"
        },
        {
            "task_id": "binary-tree-preorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        else:\n            return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)"
        }
    ],
    "power-of-four": [
        {
            "task_id": "power-of-four",
            "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n % 4 == 0:\n            return self.isPowerOfFour(n/4)\n        else:\n            return False"
        },
        {
            "task_id": "power-of-four",
            "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n%4 != 0:\n            return False\n        else:\n            return self.isPowerOfFour(n/4)"
        },
        {
            "task_id": "power-of-four",
            "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n%4 != 0:\n            return False\n        if n == 4:\n            return True\n        return self.isPowerOfFour(n/4)"
        },
        {
            "task_id": "power-of-four",
            "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n % 4 == 0:\n            return self.isPowerOfFour(n/4)\n        else:\n            return False"
        },
        {
            "task_id": "power-of-four",
            "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n%4 != 0:\n            return False\n        if n == 4:\n            return True\n        return self.isPowerOfFour(n/4)"
        }
    ],
    "invert-binary-tree": [
        {
            "task_id": "invert-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root"
        },
        {
            "task_id": "invert-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root"
        },
        {
            "task_id": "invert-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root"
        },
        {
            "task_id": "invert-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        else:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n            return root"
        },
        {
            "task_id": "invert-binary-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        else:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n            return root"
        }
    ],
    "generate-parentheses": [
        {
            "task_id": "generate-parentheses",
            "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(A = [], left = 0, right = 0, n = n):\n            if len(A) == 2*n:\n                yield \"\".join(A)\n            if left < n:\n                A.append(\"(\")\n                for g in generate(A, left+1, right, n):\n                    yield g\n                A.pop()\n            if right < left:\n                A.append(\")\")\n                for g in generate(A, left, right+1, n):\n                    yield g\n                A.pop()\n        return [i for i in generate()]"
        },
        {
            "task_id": "generate-parentheses",
            "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(A = [], left = 0, right = 0, n = n):\n            if len(A) == 2*n:\n                yield \"\".join(A)\n                return\n            if left < n:\n                A.append(\"(\")\n                for g in generate(A, left+1, right, n):\n                    yield g\n                A.pop()\n            if right < left:\n                A.append(\")\")\n                for g in generate(A, left, right+1, n):\n                    yield g\n                A.pop()\n        return [i for i in generate()]"
        },
        {
            "task_id": "generate-parentheses",
            "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(A = [], left = 0, right = 0, n = n):\n            if len(A) == 2*n:\n                yield \"\".join(A)\n                return\n            if left < n:\n                A.append(\"(\")\n                for g in generate(A, left+1, right, n):\n                    yield g\n                A.pop()\n            if right < left:\n                A.append(\")\")\n                for g in generate(A, left, right+1, n):\n                    yield g\n                A.pop()\n        return [i for i in generate()]"
        },
        {
            "task_id": "generate-parentheses",
            "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(A = [], left = 0, right = 0, n = n):\n            if len(A) == 2*n:\n                yield \"\".join(A)\n            if left < n:\n                A.append(\"(\")\n                for g in generate(A, left+1, right, n):\n                    yield g\n                A.pop()\n            if right < left:\n                A.append(\")\")\n                for g in generate(A, left, right+1, n):\n                    yield g\n                A.pop()\n        return [i for i in generate()]"
        },
        {
            "task_id": "generate-parentheses",
            "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(A = [], left = 0, right = 0, n = n):\n            if len(A) == 2*n:\n                yield \"\".join(A)\n                return\n            if left < n:\n                A.append(\"(\")\n                for g in generate(A, left+1, right, n):\n                    yield g\n                A.pop()\n            if right < left:\n                A.append(\")\")\n                for g in generate(A, left, right+1, n):\n                    yield g\n                A.pop()\n        return [i for i in generate()]"
        }
    ],
    "patching-array": [
        {
            "task_id": "patching-array",
            "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the patches counter\n        patches = 0\n        \n        # Initialize the current sum\n        curr_sum = 1\n        \n        # Initialize the index\n        index = 0\n        \n        # Loop until the current sum is greater than n\n        while curr_sum <= n:\n            \n            # If the index is valid and the current sum is less than the number at the index\n            if index < len(nums) and curr_sum < nums[index]:\n                \n                # Increment the current sum\n                curr_sum += nums[index]\n                \n                # Increment the index\n                index += 1\n            \n            # Otherwise\n            else:\n                \n                # Increment the patches counter\n                patches += 1\n                \n                # Increment the current sum by twice\n                curr_sum *= 2\n        \n        # Return the patches counter\n        return patches"
        },
        {
            "task_id": "patching-array",
            "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the patches counter\n        patches = 0\n        \n        # Initialize the current sum\n        curr_sum = 1\n        \n        # Initialize the index\n        index = 0\n        \n        # Loop until we reach the end of the array\n        while curr_sum <= n:\n            \n            # If we have reached the end of the array\n            if index == len(nums):\n                \n                # Add the missing number and increment the patches counter\n                curr_sum += curr_sum\n                patches += 1\n                \n            # If the current sum is less than the current number\n            elif curr_sum < nums[index]:\n                \n                # Add the missing number and increment the patches counter\n                curr_sum += curr_sum\n                patches += 1\n                \n            # If the current sum is greater than or equal to the current number\n            else:\n                \n                # Increment the current sum\n                curr_sum += nums[index]\n                \n                # Increment the index\n                index += 1\n                \n        return patches"
        },
        {
            "task_id": "patching-array",
            "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the patches counter\n        patches = 0\n        \n        # Initialize the current sum\n        curr_sum = 1\n        \n        # Initialize the index\n        index = 0\n        \n        # Loop until the current sum is greater than n\n        while curr_sum <= n:\n            \n            # If the current sum is not in the nums array\n            if index == len(nums) or curr_sum < nums[index]:\n                \n                # Add the patch\n                patches += 1\n                \n                # Update the current sum\n                curr_sum *= 2\n                \n            # If the current sum is in the nums array\n            else:\n                \n                # Update the current sum\n                curr_sum += nums[index]\n                \n                # Update the index\n                index += 1\n                \n        return patches"
        },
        {
            "task_id": "patching-array",
            "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the patches counter\n        patches = 0\n        \n        # Initialize the current sum\n        curr_sum = 1\n        \n        # Initialize the index\n        index = 0\n        \n        # Loop until the current sum is greater than n\n        while curr_sum <= n:\n            \n            # If the index is valid and the current sum is less than the number at the index\n            if index < len(nums) and curr_sum < nums[index]:\n                \n                # Increment the current sum by the number at the index\n                curr_sum += nums[index]\n                \n                # Increment the index\n                index += 1\n            \n            # Otherwise\n            else:\n                \n                # Increment the current sum by the current sum\n                curr_sum *= 2\n                \n                # Increment the patches counter\n                patches += 1\n        \n        # Return the patches counter\n        return patches"
        },
        {
            "task_id": "patching-array",
            "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the patches counter\n        patches = 0\n        \n        # Initialize the current sum\n        curr_sum = 1\n        \n        # Initialize the index\n        index = 0\n        \n        # Loop until we reach the end of the array\n        while curr_sum <= n:\n            \n            # If we are at the end of the array\n            if index == len(nums):\n                \n                # Add the missing number and increment the patches counter\n                curr_sum += curr_sum\n                patches += 1\n                \n            # If the current sum is less than the current number\n            elif curr_sum < nums[index]:\n                \n                # Add the missing number and increment the patches counter\n                curr_sum += curr_sum\n                patches += 1\n                \n            # If the current sum is greater than or equal to the current number\n            else:\n                \n                # Increment the current sum\n                curr_sum += nums[index]\n                \n                # Increment the index\n                index += 1\n                \n        return patches"
        }
    ],
    "longest-valid-parentheses": [
        {
            "task_id": "longest-valid-parentheses",
            "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a stack\n        stack = []\n        max_len = 0\n        last_index = -1\n        \n        # Iterate through the string\n        for i in range(len(s)):\n            \n            # If the current character is a '('\n            if s[i] == '(':\n                stack.append(i)\n            \n            # If the current character is a ')'\n            else:\n                \n                # If the stack is not empty, then pop from the stack\n                # This will give us the index of the matching '('\n                if stack:\n                    stack.pop()\n                \n                # If the stack is empty\n                else:\n                    \n                    # Update last_index\n                    last_index = i\n                \n                # If the stack is not empty\n                if stack:\n                    \n                    # Get the length of the current valid substring\n                    curr_len = i - stack[-1]\n                    \n                    # Update max_len\n                    max_len = max(max_len, curr_len)\n                    \n                # If the stack is empty\n                else:\n                    \n                    # Get the length of the current valid substring\n                    curr_len = i - last_index\n                    \n                    # Update max_len\n                    max_len = max(max_len, curr_len)\n                    \n        return max_len"
        },
        {
            "task_id": "longest-valid-parentheses",
            "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a stack\n        stack = []\n        # Initialize the maximum length of valid parentheses\n        max_len = 0\n        # Iterate over the string\n        for char in s:\n            # If the current character is an opening parenthesis then push it to the stack\n            if char == '(':\n                stack.append(char)\n            # If the current character is a closing parenthesis\n            else:\n                # If the stack is not empty and the top element is an opening parenthesis\n                if stack and stack[-1] == '(':\n                    # Pop the top element\n                    stack.pop()\n                    # Increment the maximum length\n                    max_len += 2\n                # If the stack is empty or the top element is not an opening parenthesis\n                else:\n                    # Push the current character to the stack\n                    stack.append(char)\n        # Return the maximum length\n        return max_len"
        },
        {
            "task_id": "longest-valid-parentheses",
            "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a stack\n        stack = []\n        \n        # Initialize a variable max_len to store the maximum length of valid substring\n        max_len = 0\n        \n        # Iterate over the string\n        for i in range(len(s)):\n            \n            # If the current element is a starting bracket\n            if s[i] == '(':\n                \n                # Push it to the stack\n                stack.append(i)\n            \n            # If the current element is an ending bracket\n            else:\n                \n                # If the stack is not empty, then pop from the stack\n                if stack:\n                    stack.pop()\n                \n                # If the stack is empty, then push the current element's index to the stack\n                else:\n                    stack.append(i)\n        \n        # If the stack is not empty, then update max_len\n        if not stack:\n            max_len = len(s)\n        \n        # Else, iterate over the stack\n        else:\n            for i in range(len(stack)):\n                \n                # Update max_len\n                max_len = max(max_len, i - stack[i])\n        \n        # Return max_len\n        return max_len"
        },
        {
            "task_id": "longest-valid-parentheses",
            "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a stack\n        stack = []\n        \n        # Initialize a variable max_len to store the maximum length of valid parentheses substring\n        max_len = 0\n        \n        # Iterate over the string\n        for i in range(len(s)):\n            \n            # If the current character is an opening bracket then push it to the stack\n            if s[i] == '(':\n                stack.append(i)\n            \n            # If the current character is a closing bracket\n            else:\n                \n                # If the stack is not empty, then pop from the stack\n                # This will give us the position of the matching opening bracket\n                if stack:\n                    stack.pop()\n                \n                # If the stack is empty, then this is a valid substring\n                # So calculate the length of the substring and compare it with max_len\n                # Update max_len if the current length is greater than max_len\n                else:\n                    max_len = max(max_len, i + 1)\n                    \n        # After iterating over the entire string, the stack will have the positions of all the unmatched opening brackets\n        # We need to find the distance of each unmatched opening bracket from the end of the string\n        # To calculate the distance we can subtract the position of the unmatched opening bracket from the length of the string\n        for i in range(len(stack)):\n            max_len = max(max_len, len(s) - stack[i])\n            \n        return max_len"
        },
        {
            "task_id": "longest-valid-parentheses",
            "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a stack\n        stack = []\n        # Initialize the maximum length of valid parentheses\n        max_len = 0\n        # Iterate over the string\n        for char in s:\n            # If the current character is an opening parenthesis\n            if char == '(':\n                # Push it onto the stack\n                stack.append(char)\n            # If the current character is a closing parenthesis\n            elif char == ')':\n                # If the stack is not empty\n                if stack:\n                    # Pop the top element\n                    stack.pop()\n                    # If the stack is now empty\n                    if not stack:\n                        # Update the maximum length\n                        max_len = max(max_len, len(s) - 1)\n                    # If the stack is not empty\n                    else:\n                        # Update the maximum length\n                        max_len = max(max_len, len(s) - stack[-1])\n                # If the stack is empty\n                else:\n                    # Update the maximum length\n                    max_len = max(max_len, len(s))\n        # Return the maximum length\n        return max_len"
        }
    ],
    "fraction-to-recurring-decimal": [
        {
            "task_id": "fraction-to-recurring-decimal",
            "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = \"-\"\n        elif numerator > 0 and denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        whole = str(numerator // denominator)\n        fraction = str(numerator % denominator)\n        \n        if fraction == \"0\":\n            return sign + whole\n        \n        fraction_dict = {}\n        fraction_list = []\n        while fraction not in fraction_dict:\n            fraction_dict[fraction] = len(fraction_list)\n            fraction = str(int(fraction) * 10)\n            fraction_list.append(fraction)\n        \n        fraction_string = \"\".join(fraction_list)\n        fraction_string = fraction_string[:fraction_dict[fraction]] + \"(\" + fraction_string[fraction_dict[fraction]:] + \")\"\n        \n        return sign + whole + \".\" + fraction_string"
        },
        {
            "task_id": "fraction-to-recurring-decimal",
            "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        res = \"\"\n        if numerator < 0 ^ denominator < 0:\n            res += \"-\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        res += str(numerator // denominator)\n        \n        if numerator % denominator == 0:\n            return res\n        \n        res += \".\"\n        \n        numerator %= denominator\n        \n        hashmap = {}\n        \n        while numerator % denominator != 0:\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n            \n            if numerator in hashmap:\n                res = res[:hashmap[numerator]] + \"(\" + res[hashmap[numerator]:] + \")\"\n                break\n            else:\n                hashmap[numerator] = len(res)\n                \n        return res"
        },
        {
            "task_id": "fraction-to-recurring-decimal",
            "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = \"-\"\n        elif numerator > 0 and denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        whole = str(numerator // denominator)\n        fraction = str(numerator % denominator)\n        \n        if fraction == \"0\":\n            return sign + whole\n        \n        fraction_dict = {}\n        fraction_list = []\n        while fraction != \"0\":\n            if fraction in fraction_dict:\n                fraction_list.insert(fraction_dict[fraction], \"(\")\n                fraction_list.append(\")\")\n                break\n            else:\n                fraction_dict[fraction] = len(fraction_list)\n                fraction = str(10 * int(fraction))\n                fraction_list.append(fraction[0])\n        \n        return sign + whole + \".\" + \"\".join(fraction_list)"
        },
        {
            "task_id": "fraction-to-recurring-decimal",
            "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        if denominator == 0:\n            return \"NaN\"\n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        if numerator < 0 and denominator > 0 or numerator > 0 and denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        integer = str(numerator // denominator)\n        fraction = str(numerator % denominator)\n        if fraction == \"0\":\n            return sign + integer\n        else:\n            fraction_dict = {}\n            fraction_list = []\n            while fraction not in fraction_dict:\n                fraction_dict[fraction] = len(fraction_list)\n                fraction = str(int(fraction) * 10 // denominator)\n                fraction_list.append(fraction)\n            if fraction == \"0\":\n                return sign + integer + \".\" + \"\".join(fraction_list)\n            else:\n                return sign + integer + \".\" + \"\".join(fraction_list) + \"(\" + fraction + \")\""
        },
        {
            "task_id": "fraction-to-recurring-decimal",
            "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = \"-\"\n        elif numerator > 0 and denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        whole = str(numerator // denominator)\n        fraction = str(numerator % denominator)\n        \n        if fraction == \"0\":\n            return sign + whole\n        \n        fraction_dict = {}\n        fraction_list = []\n        while fraction not in fraction_dict:\n            fraction_dict[fraction] = len(fraction_list)\n            fraction = str(int(fraction) * 10)\n            fraction_list.append(fraction)\n        \n        fraction_string = \"\".join(fraction_list)\n        fraction_string = fraction_string[:fraction_dict[fraction]] + \"(\" + fraction_string[fraction_dict[fraction]:] + \")\"\n        \n        return sign + whole + \".\" + fraction_string"
        }
    ],
    "sort-list": [
        {
            "task_id": "sort-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast is not None and fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode(0)\n        cur = dummy\n        \n        while left is not None and right is not None:\n            if left.val < right.val:\n                cur.next = left\n                left = left.next\n            else:\n                cur.next = right\n                right = right.next\n            cur = cur.next\n        \n        cur.next = left if left is not None else right\n        \n        return dummy.next"
        },
        {
            "task_id": "sort-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast is not None and fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode(0)\n        cur = dummy\n        \n        while left is not None and right is not None:\n            if left.val < right.val:\n                cur.next = left\n                left = left.next\n            else:\n                cur.next = right\n                right = right.next\n            cur = cur.next\n        \n        cur.next = left if left is not None else right\n        \n        return dummy.next"
        },
        {
            "task_id": "sort-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast is not None and fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode(0)\n        cur = dummy\n        \n        while left is not None and right is not None:\n            if left.val < right.val:\n                cur.next = left\n                left = left.next\n            else:\n                cur.next = right\n                right = right.next\n            cur = cur.next\n        \n        cur.next = left if left is not None else right\n        \n        return dummy.next"
        },
        {
            "task_id": "sort-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast is not None and fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode(0)\n        cur = dummy\n        \n        while left is not None and right is not None:\n            if left.val < right.val:\n                cur.next = left\n                left = left.next\n            else:\n                cur.next = right\n                right = right.next\n            cur = cur.next\n        \n        cur.next = left if left is not None else right\n        \n        return dummy.next"
        },
        {
            "task_id": "sort-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast is not None and fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode(0)\n        cur = dummy\n        \n        while left is not None and right is not None:\n            if left.val < right.val:\n                cur.next = left\n                left = left.next\n            else:\n                cur.next = right\n                right = right.next\n            cur = cur.next\n        \n        cur.next = left if left is not None else right\n        \n        return dummy.next"
        }
    ],
    "russian-doll-envelopes": [
        {
            "task_id": "russian-doll-envelopes",
            "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], x[1]))\n        \n        # Initialize the dp array\n        dp = [1] * len(envelopes)\n        \n        # Initialize the maximum height\n        max_height = 0\n        \n        # Loop through the envelopes\n        for i in range(len(envelopes)):\n            \n            # Get the current width and height\n            width = envelopes[i][0]\n            height = envelopes[i][1]\n            \n            # Loop through the previous envelopes\n            for j in range(i):\n                \n                # Get the previous width and height\n                prev_width = envelopes[j][0]\n                prev_height = envelopes[j][1]\n                \n                # Check if the current envelope can fit into the previous envelope\n                if width > prev_width and height > prev_height:\n                    \n                    # Update the maximum height\n                    max_height = max(max_height, height)\n                    \n                    # Update the dp value\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        # Return the maximum number of envelopes that can be Russian doll\n        return max(dp)"
        },
        {
            "task_id": "russian-doll-envelopes",
            "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key = lambda x: (x[0], x[1]))\n        \n        # Initialize the dp array\n        dp = [1] * len(envelopes)\n        \n        # Initialize the maximum height\n        max_height = 0\n        \n        # Loop through the envelopes\n        for i in range(len(envelopes)):\n            \n            # Get the current height\n            height = envelopes[i][1]\n            \n            # Update the maximum height\n            max_height = max(max_height, height)\n            \n            # Loop through the previous envelopes\n            for j in range(i):\n                \n                # Check if the current envelope can fit into the previous envelope\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    \n                    # Update the dp value\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        # Return the maximum number of envelopes\n        return max_height"
        },
        {
            "task_id": "russian-doll-envelopes",
            "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key = lambda x: (x[0], x[1]))\n        \n        # Initialize the dp array\n        dp = [1] * len(envelopes)\n        \n        # Initialize the maximum height\n        max_height = 0\n        \n        # Loop through the envelopes\n        for i in range(len(envelopes)):\n            \n            # Get the current height\n            height = envelopes[i][1]\n            \n            # Update the maximum height\n            max_height = max(max_height, height)\n            \n            # Loop through the previous envelopes\n            for j in range(i):\n                \n                # Check if the current envelope can fit into the previous envelope\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    \n                    # Update the dp value\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        # Return the maximum number of envelopes\n        return max_height"
        },
        {
            "task_id": "russian-doll-envelopes",
            "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key = lambda x: (x[0], x[1]))\n        \n        # Initialize the dp array\n        dp = [1] * len(envelopes)\n        \n        # Initialize the maximum height\n        max_height = 0\n        \n        # Loop through the envelopes\n        for i in range(len(envelopes)):\n            \n            # Get the current height\n            height = envelopes[i][1]\n            \n            # Update the maximum height\n            max_height = max(max_height, height)\n            \n            # Loop through the previous envelopes\n            for j in range(i):\n                \n                # Check if the current envelope can fit into the previous envelope\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    \n                    # Update the dp value\n                    dp[i] = max(dp[i], dp[j] + 1)\n                    \n        # Return the maximum number of envelopes\n        return max_height"
        },
        {
            "task_id": "russian-doll-envelopes",
            "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key = lambda x: (x[0], x[1]))\n        \n        # Initialize the dp array\n        dp = [1] * len(envelopes)\n        \n        # Initialize the maximum height\n        max_height = 0\n        \n        # Loop through the envelopes\n        for i in range(len(envelopes)):\n            \n            # Get the current height\n            height = envelopes[i][1]\n            \n            # Loop through the previous envelopes\n            for j in range(i):\n                \n                # Check if the current height is greater than the previous height\n                if height > envelopes[j][1]:\n                    \n                    # Update the maximum height\n                    max_height = max(max_height, dp[j] + 1)\n                    \n                    # Update the dp value\n                    dp[i] = max(dp[i], dp[j] + 1)\n                    \n        return max_height"
        }
    ],
    "set-matrix-zeroes": [
        {
            "task_id": "set-matrix-zeroes",
            "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # Initialize two boolean variables to keep track of rows and columns\n        row = False\n        col = False\n        \n        # Traverse the matrix and if an element is 0, set the corresponding row and column to True\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] == 0:\n                    row = True\n                    col = True\n                    break\n                    \n        # If the row is True, set all the elements in the row to 0\n        if row:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    matrix[i][j] = 0\n                    \n        # If the column is True, set all the elements in the column to 0\n        if col:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    matrix[j][i] = 0\n                    \n        # Return the matrix\n        return matrix"
        },
        {
            "task_id": "set-matrix-zeroes",
            "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # Initialize two boolean variables to keep track of rows and columns\n        row = False\n        col = False\n        \n        # Traverse the matrix and if an element is 0, set the corresponding row and column to True\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] == 0:\n                    row = True\n                    col = True\n                    break\n                    \n        # If row is True, set all elements in the current row to 0\n        if row:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    matrix[i][j] = 0\n                    \n        # If col is True, set all elements in the current column to 0\n        if col:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    matrix[j][i] = 0\n                    \n        # Return the matrix\n        return matrix"
        },
        {
            "task_id": "set-matrix-zeroes",
            "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # Initialize two boolean variables to keep track of rows and columns\n        row = False\n        col = False\n        \n        # Traverse the matrix and if an element is 0, set the corresponding row and column to True\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] == 0:\n                    row = True\n                    col = True\n                    break\n                    \n        # If row is True, set all elements in the current row to 0\n        if row:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    matrix[i][j] = 0\n                    \n        # If col is True, set all elements in the current column to 0\n        if col:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    matrix[j][i] = 0"
        },
        {
            "task_id": "set-matrix-zeroes",
            "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # Initialize two boolean variables to keep track of rows and columns\n        row = False\n        col = False\n        \n        # Traverse the matrix and if an element is 0, set the corresponding row and column to True\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] == 0:\n                    row = True\n                    col = True\n                    break\n                    \n        # If the row or column corresponding to an element is True, set all the elements in that row or column to 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if row and matrix[i][j] != 0:\n                    matrix[i][j] = 0\n                if col and matrix[j][i] != 0:\n                    matrix[j][i] = 0\n                    \n        # Return the matrix\n        return matrix"
        },
        {
            "task_id": "set-matrix-zeroes",
            "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # Initialize two boolean variables to keep track of rows and columns\n        row = False\n        col = False\n        \n        # Traverse the matrix and if an element is 0, set the corresponding row and column to True\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] == 0:\n                    row = True\n                    col = True\n                    break\n                    \n        # If row is True, set all elements in the current row to 0\n        if row:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    matrix[i][j] = 0\n                    \n        # If col is True, set all elements in the current column to 0\n        if col:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    matrix[j][i] = 0"
        }
    ],
    "remove-nth-node-from-end-of-list": [
        {
            "task_id": "remove-nth-node-from-end-of-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize two pointers\n        first = head\n        second = head\n        \n        # Move the second pointer n-1 steps ahead\n        for i in range(n-1):\n            second = second.next\n        \n        # If the second pointer is at the end, then\n        # the first node is to be deleted\n        if second.next is None:\n            head = head.next\n            return head\n        \n        # Move both pointers until second pointer\n        # reaches the end\n        while second.next is not None:\n            first = first.next\n            second = second.next\n        \n        # First must be pointing to the node\n        # to be deleted, so delete it\n        first.next = first.next.next\n        \n        return head"
        },
        {
            "task_id": "remove-nth-node-from-end-of-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize two pointers\n        first = head\n        second = head\n        \n        # Move the second pointer n-1 steps\n        for i in range(n-1):\n            second = second.next\n        \n        # If the second pointer is at the end,\n        # then delete the first node\n        if second.next == None:\n            head = head.next\n            return head\n        \n        # Move both pointers until second pointer\n        # reaches the end\n        while second.next != None:\n            first = first.next\n            second = second.next\n        \n        # First must be pointing to the nth node\n        # from the end, so delete it\n        first.next = first.next.next\n        \n        return head"
        },
        {
            "task_id": "remove-nth-node-from-end-of-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize two pointers\n        first = head\n        second = head\n        \n        # Move the second pointer n-1 steps ahead\n        for i in range(n-1):\n            second = second.next\n        \n        # If the second pointer is at the end, then\n        # the first pointer is at the (n-1)th node\n        if second.next == None:\n            head = head.next\n            return head\n        \n        # Move both pointers until the second pointer\n        # reaches the end\n        while second.next != None:\n            first = first.next\n            second = second.next\n        \n        # First must be pointing to the (n-1)th node\n        # So, delete the next node\n        first.next = first.next.next\n        \n        return head"
        },
        {
            "task_id": "remove-nth-node-from-end-of-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize two pointers\n        first = head\n        second = head\n        \n        # Move the second pointer n-1 steps\n        for i in range(n-1):\n            second = second.next\n        \n        # If the second pointer is at the end,\n        # then the first pointer is at the nth position\n        if second.next == None:\n            head = head.next\n            return head\n        \n        # Move both pointers until the second pointer\n        # reaches the end\n        while second.next != None:\n            first = first.next\n            second = second.next\n        \n        # First must be at the (n-1)th position\n        # First.next is the nth position\n        first.next = first.next.next\n        \n        return head"
        },
        {
            "task_id": "remove-nth-node-from-end-of-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize two pointers\n        first = head\n        second = head\n        \n        # Move the second pointer n-1 steps ahead\n        for i in range(n-1):\n            second = second.next\n        \n        # If the second pointer is at the end, then\n        # the first node is to be deleted\n        if second.next is None:\n            head = head.next\n            return head\n        \n        # Move both pointers until second pointer\n        # reaches the end\n        while second.next is not None:\n            first = first.next\n            second = second.next\n        \n        # First must be pointing to the node\n        # to be deleted, so delete it\n        first.next = first.next.next\n        \n        return head"
        }
    ],
    "intersection-of-two-arrays": [
        {
            "task_id": "intersection-of-two-arrays",
            "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1).intersection(set(nums2)))"
        },
        {
            "task_id": "intersection-of-two-arrays",
            "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1).intersection(set(nums2)))"
        },
        {
            "task_id": "intersection-of-two-arrays",
            "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1).intersection(set(nums2)))"
        },
        {
            "task_id": "intersection-of-two-arrays",
            "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1).intersection(set(nums2)))"
        },
        {
            "task_id": "intersection-of-two-arrays",
            "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1).intersection(set(nums2)))"
        }
    ],
    "super-washing-machines": [
        {
            "task_id": "super-washing-machines",
            "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Find the total number of dresses\n        total = sum(machines)\n        \n        # If total is odd, then it is not possible to make all washing machines have the same number of dresses\n        if total % 2 != 0:\n            return -1\n        \n        # Find the number of washing machines\n        n = len(machines)\n        \n        # Find the number of dresses each washing machine should have\n        target = total // n\n        \n        # Initialize the number of moves\n        moves = 0\n        \n        # Initialize the number of dresses in each washing machine\n        count = 0\n        \n        # Iterate over the washing machines\n        for i in range(n):\n            \n            # Add the number of dresses in the current washing machine to the total number of dresses\n            count += machines[i]\n            \n            # If the number of dresses in the current washing machine is greater than the target\n            if machines[i] > target:\n                \n                # Add the difference between the target and the number of dresses in the current washing machine to the number of moves\n                moves += machines[i] - target\n                \n            # If the number of dresses in the current washing machine is less than the target\n            elif machines[i] < target:\n                \n                # Subtract the difference between the target and the number of dresses in the current washing machine from the total number of dresses\n                count -= target - machines[i]\n                \n        # Return the number of moves\n        return moves"
        },
        {
            "task_id": "super-washing-machines",
            "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Find the total number of dresses\n        total = sum(machines)\n        \n        # If total is odd, then it is not possible to make all washing machines have the same number of dresses.\n        if total % len(machines) != 0:\n            return -1\n        \n        # Find the number of dresses each washing machine should have\n        target = total // len(machines)\n        \n        # Initialize the result\n        result = 0\n        \n        # Initialize the extra dresses\n        extra = 0\n        \n        # Iterate over the washing machines\n        for machine in machines:\n            \n            # Add the extra dresses to the current washing machine\n            machine += extra\n            \n            # If the number of dresses in the current washing machine is greater than the target\n            if machine > target:\n                \n                # Add the difference to the result\n                result += machine - target\n                \n                # Add the difference to the extra dresses\n                extra += machine - target\n                \n            # If the number of dresses in the current washing machine is less than the target\n            elif machine < target:\n                \n                # Add the difference to the result\n                result += target - machine\n                \n                # Subtract the difference from the extra dresses\n                extra -= target - machine\n                \n        return result"
        },
        {
            "task_id": "super-washing-machines",
            "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the total number of dresses\n        total = sum(machines)\n        \n        # find the number of washing machines\n        n = len(machines)\n        \n        # if the total number of dresses is not divisible by the number of washing machines\n        if total % n != 0:\n            return -1\n        \n        # find the number of dresses each washing machine should have\n        target = total // n\n        \n        # initialize the result\n        result = 0\n        \n        # initialize the extra number of dresses in each washing machine\n        extra = 0\n        \n        # loop through the washing machines\n        for i in range(n):\n            \n            # add the extra number of dresses in the current washing machine to the result\n            result += extra\n            \n            # find the number of dresses in the current washing machine\n            num = machines[i] - target\n            \n            # if the number of dresses is positive\n            if num > 0:\n                \n                # add the number to the extra number of dresses in each washing machine\n                extra += num\n                \n            # if the number of dresses is negative\n            elif num < 0:\n                \n                # subtract the number from the extra number of dresses in each washing machine\n                extra -= num\n                \n                # since we are moving the dresses from the current washing machine to the previous washing machines,\n                # we need to subtract the absolute value of the number from the result\n                result -= num\n                \n        # return the result\n        return result"
        },
        {
            "task_id": "super-washing-machines",
            "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the total number of dresses\n        total = sum(machines)\n        \n        # find the number of washing machines\n        n = len(machines)\n        \n        # if the total number of dresses is not divisible by the number of washing machines\n        if total % n != 0:\n            return -1\n        \n        # find the number of dresses each washing machine should have\n        target = total // n\n        \n        # initialize the result\n        result = 0\n        \n        # initialize the extra number of dresses in each washing machine\n        extra = 0\n        \n        # loop through the washing machines\n        for i in range(n):\n            \n            # add the extra number of dresses in the current washing machine to the result\n            result += extra\n            \n            # find the number of dresses in the current washing machine\n            num = machines[i] - target\n            \n            # if the number of dresses is positive\n            if num > 0:\n                \n                # add the number to the extra number of dresses in each washing machine\n                extra += num\n                \n            # if the number of dresses is negative\n            elif num < 0:\n                \n                # subtract the number from the extra number of dresses in each washing machine\n                extra -= num\n                \n                # since we are moving the dresses from the current washing machine to the previous washing machines,\n                # we need to subtract the absolute value of the number from the result\n                result -= num\n                \n        # return the result\n        return result"
        },
        {
            "task_id": "super-washing-machines",
            "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Find the total number of dresses\n        total = sum(machines)\n        \n        # If total is odd, then it is not possible to make all washing machines have the same number of dresses\n        if total % 2 != 0:\n            return -1\n        \n        # Find the number of washing machines\n        n = len(machines)\n        \n        # Find the number of dresses that each washing machine should have\n        target = total // n\n        \n        # Initialize the number of moves\n        moves = 0\n        \n        # Initialize the number of dresses in each washing machine\n        count = 0\n        \n        # Iterate over the washing machines\n        for i in range(n):\n            \n            # Add the number of dresses in the current washing machine to the total number of dresses\n            count += machines[i]\n            \n            # If the number of dresses in the current washing machine is greater than the target\n            if machines[i] > target:\n                \n                # Add the difference between the target and the number of dresses in the current washing machine to the number of moves\n                moves += machines[i] - target\n                \n            # If the number of dresses in the current washing machine is less than the target\n            elif machines[i] < target:\n                \n                # Add the difference between the target and the number of dresses in the current washing machine to the number of moves\n                moves += target - machines[i]\n                \n        # Return the number of moves\n        return moves"
        }
    ],
    "kth-smallest-number-in-multiplication-table": [
        {
            "task_id": "kth-smallest-number-in-multiplication-table",
            "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(mid):\n            count = 0\n            for i in range(1, m+1):\n                count += min(mid//i, n)\n            return count\n        \n        left = 1\n        right = m*n\n        while left < right:\n            mid = (left + right)//2\n            if count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
        },
        {
            "task_id": "kth-smallest-number-in-multiplication-table",
            "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(mid):\n            count = 0\n            for i in range(1, m+1):\n                count += min(mid//i, n)\n            return count\n        \n        left = 1\n        right = m*n\n        while left < right:\n            mid = (left + right)//2\n            if count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
        },
        {
            "task_id": "kth-smallest-number-in-multiplication-table",
            "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(mid):\n            count = 0\n            for i in range(1, m+1):\n                count += min(mid//i, n)\n            return count\n        \n        left = 1\n        right = m*n\n        while left < right:\n            mid = (left + right)//2\n            if count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
        },
        {
            "task_id": "kth-smallest-number-in-multiplication-table",
            "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(mid):\n            count = 0\n            for i in range(1, m+1):\n                count += min(mid//i, n)\n            return count\n        \n        left = 1\n        right = m*n\n        while left < right:\n            mid = (left + right)//2\n            if count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
        },
        {
            "task_id": "kth-smallest-number-in-multiplication-table",
            "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(mid):\n            count = 0\n            for i in range(1, m+1):\n                count += min(mid//i, n)\n            return count\n        \n        left = 1\n        right = m*n\n        while left < right:\n            mid = (left + right)//2\n            if count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
        }
    ],
    "convert-sorted-list-to-binary-search-tree": [
        {
            "task_id": "convert-sorted-list-to-binary-search-tree",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        slow = head\n        fast = head.next.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow.next\n        slow.next = None\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root"
        },
        {
            "task_id": "convert-sorted-list-to-binary-search-tree",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        slow = head\n        fast = head.next.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow.next\n        slow.next = None\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root"
        },
        {
            "task_id": "convert-sorted-list-to-binary-search-tree",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head.next.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        \n        return root"
        },
        {
            "task_id": "convert-sorted-list-to-binary-search-tree",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        slow = head\n        fast = head.next.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow.next\n        slow.next = None\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root"
        },
        {
            "task_id": "convert-sorted-list-to-binary-search-tree",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head.next.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        \n        return root"
        }
    ],
    "merge-two-sorted-lists": [
        {
            "task_id": "merge-two-sorted-lists",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"
        },
        {
            "task_id": "merge-two-sorted-lists",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"
        },
        {
            "task_id": "merge-two-sorted-lists",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"
        },
        {
            "task_id": "merge-two-sorted-lists",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"
        },
        {
            "task_id": "merge-two-sorted-lists",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"
        }
    ],
    "maximal-rectangle": [
        {
            "task_id": "maximal-rectangle",
            "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        heights = [0] * (cols + 1)\n        max_area = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n                    \n            # print(heights)\n            # print(max_area)\n            max_area = max(max_area, self.largestRectangleArea(heights))\n            \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not heights:\n            return 0\n        \n        heights.append(0)\n        n = len(heights)\n        max_area = 0\n        stack = []\n        \n        for i in range(n):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n                \n            stack.append(i)\n            \n        return max_area"
        },
        {
            "task_id": "maximal-rectangle",
            "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n                    \n            stack = []\n            for j in range(n + 1):\n                while stack and heights[stack[-1]] > heights[j]:\n                    h = heights[stack.pop()]\n                    w = j - stack[-1] - 1\n                    max_area = max(max_area, h * w)\n                    \n                stack.append(j)\n                \n        return max_area"
        },
        {
            "task_id": "maximal-rectangle",
            "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            # print(heights)\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        heights.append(0)\n        n = len(heights)\n        stack = []\n        max_area = 0\n        for i in range(n):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        return max_area"
        },
        {
            "task_id": "maximal-rectangle",
            "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        heights = [0] * (cols + 1)\n        max_area = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n                    \n            # print(heights)\n            stack = []\n            heights.append(0)\n            for j in range(len(heights)):\n                while stack and heights[stack[-1]] > heights[j]:\n                    h = heights[stack.pop()]\n                    w = j - stack[-1] - 1\n                    max_area = max(max_area, h * w)\n                stack.append(j)\n                \n        return max_area"
        },
        {
            "task_id": "maximal-rectangle",
            "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        heights = [0] * (cols + 1)\n        max_area = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n                    \n            # print(heights)\n            # print(max_area)\n            max_area = max(max_area, self.largestRectangleArea(heights))\n            \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        heights.append(0)\n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n                \n            stack.append(i)\n            \n        return max_area"
        }
    ],
    "subsets": [
        {
            "task_id": "subsets",
            "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Initialize the result with an empty list\n        result = [[]]\n        \n        # Iterate over the input array\n        for num in nums:\n            # Append num to each of the existing subsets\n            result += [subset + [num] for subset in result]\n        \n        # Return the result\n        return result"
        },
        {
            "task_id": "subsets",
            "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Initialize the result with an empty list\n        result = [[]]\n        \n        # Iterate over the input array\n        for num in nums:\n            # Append num to each of the existing subsets\n            result += [subset + [num] for subset in result]\n        \n        # Return the result\n        return result"
        },
        {
            "task_id": "subsets",
            "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Initialize the result with an empty list\n        result = [[]]\n        \n        # Iterate over the input array\n        for num in nums:\n            # Append num to each of the existing subsets\n            result += [subset + [num] for subset in result]\n        \n        return result"
        },
        {
            "task_id": "subsets",
            "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Initialize the result with an empty list\n        result = [[]]\n        \n        # Iterate over the input array\n        for num in nums:\n            # Append num to each of the existing subsets\n            result += [subset + [num] for subset in result]\n        \n        # Return the result\n        return result"
        },
        {
            "task_id": "subsets",
            "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Initialize the result with an empty list\n        result = [[]]\n        \n        # Iterate over the input array\n        for num in nums:\n            # Append num to each of the existing subsets\n            result += [subset + [num] for subset in result]\n        \n        # Return the result\n        return result"
        }
    ],
    "find-minimum-in-rotated-sorted-array-ii": [
        {
            "task_id": "find-minimum-in-rotated-sorted-array-ii",
            "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[left]"
        },
        {
            "task_id": "find-minimum-in-rotated-sorted-array-ii",
            "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[left]"
        },
        {
            "task_id": "find-minimum-in-rotated-sorted-array-ii",
            "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return nums[left]"
        },
        {
            "task_id": "find-minimum-in-rotated-sorted-array-ii",
            "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[left]"
        },
        {
            "task_id": "find-minimum-in-rotated-sorted-array-ii",
            "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return nums[left]"
        }
    ],
    "valid-number": [
        {
            "task_id": "valid-number",
            "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the string is empty\n        if len(s) == 0:\n            return False\n        \n        # check if the string is a valid number\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"
        },
        {
            "task_id": "valid-number",
            "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the string is empty\n        if len(s) == 0:\n            return False\n        \n        # check if the string is a valid number\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"
        },
        {
            "task_id": "valid-number",
            "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the string is empty\n        if len(s) == 0:\n            return False\n        \n        # check if the string is a valid number\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"
        },
        {
            "task_id": "valid-number",
            "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the string is empty\n        if len(s) == 0:\n            return False\n        \n        # check if the string is a valid number\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"
        },
        {
            "task_id": "valid-number",
            "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the string is empty\n        if len(s) == 0:\n            return False\n        \n        # check if the string is a valid number\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"
        }
    ],
    "integer-to-roman": [
        {
            "task_id": "integer-to-roman",
            "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_numerals = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_string = ''\n        \n        for key in roman_numerals.keys():\n            while num >= key:\n                roman_string += roman_numerals[key]\n                num -= key\n                \n        return roman_string"
        },
        {
            "task_id": "integer-to-roman",
            "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_numerals = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        result = ''\n        \n        for value in roman_numerals:\n            while num >= value:\n                result += roman_numerals[value]\n                num -= value\n                \n        return result"
        },
        {
            "task_id": "integer-to-roman",
            "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        result = ''\n        for key in roman.keys():\n            while num >= key:\n                result += roman[key]\n                num -= key\n        return result"
        },
        {
            "task_id": "integer-to-roman",
            "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_numerals = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_string = ''\n        \n        for key in roman_numerals.keys():\n            while num >= key:\n                roman_string += roman_numerals[key]\n                num -= key\n                \n        return roman_string"
        },
        {
            "task_id": "integer-to-roman",
            "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        result = ''\n        \n        for key in roman.keys():\n            while num >= key:\n                result += roman[key]\n                num -= key\n                \n        return result"
        }
    ],
    "find-the-difference": [
        {
            "task_id": "find-the-difference",
            "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR operation\n        # XOR operation is commutative and associative\n        # XOR operation is also idempotent\n        # XOR operation is also self-inverse\n        # XOR operation is also distributive over addition\n        \n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distributive over addition\n        # XOR operation is also distrib"
        },
        {
            "task_id": "find-the-difference",
            "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all the characters in s and t\n        # will give the extra character in t\n        return chr(reduce(operator.xor, map(ord, s + t)))"
        },
        {
            "task_id": "find-the-difference",
            "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all the characters in s and t\n        # will give the character which is not present in s\n        # but present in t\n        return chr(reduce(operator.xor, map(ord, s + t)))"
        },
        {
            "task_id": "find-the-difference",
            "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all characters in s and t\n        # will give the extra character in t\n        return chr(reduce(operator.xor, map(ord, s + t)))"
        },
        {
            "task_id": "find-the-difference",
            "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all characters in s and t\n        # will give the character which is not present in s\n        # but present in t\n        return chr(reduce(operator.xor, map(ord, s + t)))"
        }
    ],
    "sudoku-solver": [
        {
            "task_id": "sudoku-solver",
            "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def is_valid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3*(row//3)+i//3][3*(col//3)+i%3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == \".\":\n                        for num in range(1, 10):\n                            if is_valid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = \".\"\n                        return False\n            return True\n        \n        solve(board)"
        },
        {
            "task_id": "sudoku-solver",
            "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def is_valid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3*(row//3)+i//3][3*(col//3)+i%3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == \".\":\n                        for num in range(1, 10):\n                            if is_valid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = \".\"\n                        return False\n            return True\n        \n        solve(board)"
        },
        {
            "task_id": "sudoku-solver",
            "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def is_valid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3*(row//3)+i//3][3*(col//3)+i%3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if is_valid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"
        },
        {
            "task_id": "sudoku-solver",
            "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def is_valid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3*(row//3)+i//3][3*(col//3)+i%3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == \".\":\n                        for num in range(1, 10):\n                            if is_valid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = \".\"\n                        return False\n            return True\n        \n        solve(board)"
        },
        {
            "task_id": "sudoku-solver",
            "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def is_valid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3*(row//3)+i//3][3*(col//3)+i%3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == \".\":\n                        for num in range(1, 10):\n                            if is_valid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = \".\"\n                        return False\n            return True\n        \n        solve(board)"
        }
    ],
    "recover-binary-search-tree": [
        {
            "task_id": "recover-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # Find the two nodes\n        first = None\n        second = None\n        prev = None\n        current = root\n        \n        while current:\n            if current.left:\n                # Find the next node in the inorder traversal\n                next_node = current.left\n                while next_node.right and next_node.right != current:\n                    next_node = next_node.right\n                \n                # If next node is not current, then traverse down the left subtree\n                if next_node.right != current:\n                    next_node.right = current\n                    current = current.left\n                    continue\n                \n                # If next node is current, then traverse down the right subtree\n                else:\n                    next_node.right = None\n                    if prev and prev.val > current.val:\n                        if not first:\n                            first = prev\n                        second = current\n                    prev = current\n                    current = current.right\n                \n            # If current node does not have left child, then traverse down the right subtree\n            else:\n                if prev and prev.val > current.val:\n                    if not first:\n                        first = prev\n                    second = current\n                prev = current\n                current = current.right\n        \n        # Swap the values of the two nodes\n        first.val, second.val = second.val, first.val"
        },
        {
            "task_id": "recover-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # Find the two nodes\n        # Swap the values\n        \n        # Find the two nodes\n        first = None\n        second = None\n        prev = None\n        current = root\n        \n        while current:\n            if current.left:\n                # Find the inorder predecessor of current\n                prev = current.left\n                while prev.right and prev.right != current:\n                    prev = prev.right\n                \n                # If the inorder predecessor of current has a right child\n                # then we have found the first node\n                if prev.right:\n                    first = prev\n                    second = current\n                    break\n                else:\n                    # Make current as the right child of its inorder predecessor\n                    prev.right = current\n                    prev = current\n                    current = current.left\n            else:\n                # If the current does not have a left child\n                # then go to the right child\n                prev = current\n                current = current.right\n        \n        # Swap the values\n        first.val, second.val = second.val, first.val"
        },
        {
            "task_id": "recover-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # Find the two nodes\n        first = None\n        second = None\n        prev = None\n        current = root\n        \n        while current:\n            if current.left:\n                # Find the next node in the inorder traversal\n                next_node = current.left\n                while next_node.right and next_node.right != current:\n                    next_node = next_node.right\n                \n                # If next node is not current, then traverse down the left subtree\n                if next_node.right != current:\n                    next_node.right = current\n                    current = current.left\n                    continue\n                \n                # If next node is current, then traverse down the right subtree\n                next_node.right = None\n                \n                # Check if the current node is the first node\n                if not prev or prev.val < current.val:\n                    prev = current\n                    current = current.right\n                    continue\n                \n                # If the current node is not the first node, then this is the second node\n                second = current\n                current = current.right\n                \n                # Swap the values of the two nodes\n                first.val, second.val = second.val, first.val\n                break\n            \n            # If current node does not have a left child, then traverse down the right subtree\n            else:\n                if not prev or prev.val < current.val:\n                    prev = current\n                    current = current.right\n                    continue\n                \n                # If the current node is not the first node, then this is the second node\n                second = current\n                current = current.right\n                \n                # Swap the values of the two nodes\n                first.val, second.val = second.val, first.val\n                break\n        \n        # Return the root node\n        return root"
        },
        {
            "task_id": "recover-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # Find the two nodes\n        first = None\n        second = None\n        prev = None\n        current = root\n        while current:\n            if current.left:\n                # Find the next node in the inorder traversal\n                next_node = current.left\n                while next_node.right and next_node.right != current:\n                    next_node = next_node.right\n                \n                # If the right child exists and it's not pointing to the current node\n                if next_node.right == None:\n                    # Make the current node the right child of the next node\n                    next_node.right = current\n                    # Move the current node to the left child of the next node\n                    current = current.left\n                    continue\n                else:\n                    # The next node already visited the current node\n                    next_node.right = None\n                \n                # Check if the current node is the first node\n                if prev and prev.val > current.val:\n                    # If the first node is not found, set it to the current node\n                    if not first:\n                        first = prev\n                    # Set the second node to the current node\n                    second = current\n                \n                # Update the previous node\n                prev = current\n                \n                # Move the current node to the right child\n                current = current.right\n            else:\n                # Check if the current node is the first node\n                if prev and prev.val > current.val:\n                    # If the first node is not found, set it to the current node\n                    if not first:\n                        first = prev\n                    # Set the second node to the current node\n                    second = current\n                \n                # Update the previous node\n                prev = current\n                \n                # Move the current node to the right child\n                current = current.right\n        \n        # Swap the values of the two nodes\n        first.val, second.val = second.val, first.val"
        },
        {
            "task_id": "recover-binary-search-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # Find the two nodes\n        # Swap the values\n        \n        # Find the two nodes\n        first = None\n        second = None\n        prev = None\n        current = root\n        \n        while current:\n            if current.left:\n                # Find the inorder predecessor of current\n                prev = current.left\n                while prev.right and prev.right != current:\n                    prev = prev.right\n                \n                # If the inorder predecessor of current has a right child\n                # then we have found the first node\n                if prev.right:\n                    first = prev\n                    second = current\n                    break\n                else:\n                    # Make current as the right child of its inorder predecessor\n                    prev.right = current\n                    prev = current\n                    current = current.left\n            else:\n                # If the current does not have a left child\n                # then go to the right child\n                prev = current\n                current = current.right\n        \n        # Swap the values\n        first.val, second.val = second.val, first.val"
        }
    ],
    "palindrome-linked-list": [
        {
            "task_id": "palindrome-linked-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # Find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half\n        node = None\n        while slow:\n            temp = slow.next\n            slow.next = node\n            node = slow\n            slow = temp\n        \n        # Check whether or not there is a palindrome\n        while node:\n            if node.val != head.val:\n                return False\n            node = node.next\n            head = head.next\n        return True"
        },
        {
            "task_id": "palindrome-linked-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the middle of the list\n        # 2. Reverse the second half of the list\n        # 3. Check if the first half is the same as the reversed second half\n        \n        # Find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half of the list\n        node = None\n        while slow:\n            nxt = slow.next\n            slow.next = node\n            node = slow\n            slow = nxt\n        \n        # Check if the first half is the same as the reversed second half\n        while node:\n            if node.val != head.val:\n                return False\n            node = node.next\n            head = head.next\n        return True"
        },
        {
            "task_id": "palindrome-linked-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # Find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half\n        node = None\n        while slow:\n            temp = slow.next\n            slow.next = node\n            node = slow\n            slow = temp\n        \n        # Check whether or not there is a palindrome\n        while node:\n            if node.val != head.val:\n                return False\n            node = node.next\n            head = head.next\n        return True"
        },
        {
            "task_id": "palindrome-linked-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the middle of the list\n        # 2. Reverse the second half of the list\n        # 3. Check if the first half is the same as the reversed second half\n        \n        # Find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half of the list\n        node = None\n        while slow:\n            nxt = slow.next\n            slow.next = node\n            node = slow\n            slow = nxt\n        \n        # Check if the first half is the same as the reversed second half\n        while node:\n            if node.val != head.val:\n                return False\n            node = node.next\n            head = head.next\n        return True"
        },
        {
            "task_id": "palindrome-linked-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the middle of the list\n        # 2. Reverse the second half of the list\n        # 3. Check if the first half is the same as the reversed second half\n        \n        # Find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half of the list\n        node = None\n        while slow:\n            nxt = slow.next\n            slow.next = node\n            node = slow\n            slow = nxt\n        \n        # Check if the first half is the same as the reversed second half\n        while node:\n            if node.val != head.val:\n                return False\n            node = node.next\n            head = head.next\n        return True"
        }
    ],
    "valid-perfect-square": [
        {
            "task_id": "valid-perfect-square",
            "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        for i in range(2, num):\n            if i * i == num:\n                return True\n            elif i * i > num:\n                return False"
        },
        {
            "task_id": "valid-perfect-square",
            "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        for i in range(2, num):\n            if i * i == num:\n                return True\n            elif i * i > num:\n                return False"
        },
        {
            "task_id": "valid-perfect-square",
            "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        for i in range(1, num):\n            if i * i == num:\n                return True\n            elif i * i > num:\n                return False"
        },
        {
            "task_id": "valid-perfect-square",
            "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        for i in range(1, num):\n            if i * i == num:\n                return True\n            elif i * i > num:\n                return False"
        },
        {
            "task_id": "valid-perfect-square",
            "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        for i in range(1, num):\n            if i * i == num:\n                return True\n            elif i * i > num:\n                return False"
        }
    ],
    "counting-bits": [
        {
            "task_id": "counting-bits",
            "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i & i - 1] + 1\n        return ans"
        },
        {
            "task_id": "counting-bits",
            "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i & i - 1] + 1\n        return ans"
        },
        {
            "task_id": "counting-bits",
            "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i & i - 1] + 1\n        return ans"
        },
        {
            "task_id": "counting-bits",
            "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i & i - 1] + 1\n        return ans"
        },
        {
            "task_id": "counting-bits",
            "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i & i - 1] + 1\n        return ans"
        }
    ],
    "remove-linked-list-elements": [
        {
            "task_id": "remove-linked-list-elements",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        while head != None and head.val == val:\n            head = head.next\n        \n        if head == None:\n            return head\n        \n        prev = head\n        curr = head.next\n        \n        while curr != None:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return head"
        },
        {
            "task_id": "remove-linked-list-elements",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        while head is not None and head.val == val:\n            head = head.next\n        \n        if head is None:\n            return None\n        \n        current = head\n        \n        while current.next is not None:\n            if current.next.val == val:\n                current.next = current.next.next\n            else:\n                current = current.next\n        \n        return head"
        },
        {
            "task_id": "remove-linked-list-elements",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        while head != None and head.val == val:\n            head = head.next\n            \n        if head == None:\n            return head\n        \n        current = head\n        \n        while current.next != None:\n            if current.next.val == val:\n                current.next = current.next.next\n            else:\n                current = current.next\n                \n        return head"
        },
        {
            "task_id": "remove-linked-list-elements",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        while head != None and head.val == val:\n            head = head.next\n        \n        if head == None:\n            return head\n        \n        prev = head\n        curr = head.next\n        \n        while curr != None:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return head"
        },
        {
            "task_id": "remove-linked-list-elements",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        while head != None and head.val == val:\n            head = head.next\n        \n        if head == None:\n            return head\n        \n        prev = head\n        curr = head.next\n        \n        while curr != None:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return head"
        }
    ],
    "scramble-string": [
        {
            "task_id": "scramble-string",
            "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]) or self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n            \n        return False"
        },
        {
            "task_id": "scramble-string",
            "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if len(s1) == 1:\n            return s1 == s2\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False"
        },
        {
            "task_id": "scramble-string",
            "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if len(s1) == 1:\n            return s1 == s2\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False"
        },
        {
            "task_id": "scramble-string",
            "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]) or self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False"
        },
        {
            "task_id": "scramble-string",
            "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]) or self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n            \n        return False"
        }
    ],
    "simplify-path": [
        {
            "task_id": "simplify-path",
            "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # split the path into a list of directories\n        dirs = path.split('/')\n        \n        # create a stack to hold the directories\n        stack = []\n        \n        # loop through the list of directories\n        for dir in dirs:\n            \n            # if the directory is empty or a period, skip it\n            if dir == '' or dir == '.':\n                continue\n            \n            # if the directory is a double period, pop the top directory off the stack\n            elif dir == '..':\n                if len(stack) > 0:\n                    stack.pop()\n            \n            # otherwise, add the directory to the stack\n            else:\n                stack.append(dir)\n        \n        # join the directories in the stack with a slash\n        return '/' + '/'.join(stack)"
        },
        {
            "task_id": "simplify-path",
            "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        path = path.split('/')\n        stack = []\n        for i in path:\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i != '.' and i != '':\n                stack.append(i)\n        return '/' + '/'.join(stack)"
        },
        {
            "task_id": "simplify-path",
            "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        path = path.split('/')\n        stack = []\n        for i in path:\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i != '.' and i != '':\n                stack.append(i)\n        return '/' + '/'.join(stack)"
        },
        {
            "task_id": "simplify-path",
            "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # split the path into a list of directories\n        dirs = path.split('/')\n        \n        # create a stack to hold the directories\n        stack = []\n        \n        # loop through the list of directories\n        for dir in dirs:\n            \n            # if the directory is empty or a period, skip it\n            if dir == '' or dir == '.':\n                continue\n            \n            # if the directory is a double period, pop the top directory off the stack\n            elif dir == '..':\n                if len(stack) > 0:\n                    stack.pop()\n            \n            # otherwise, add the directory to the stack\n            else:\n                stack.append(dir)\n        \n        # join the directories in the stack with a slash\n        return '/' + '/'.join(stack)"
        },
        {
            "task_id": "simplify-path",
            "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        path = path.split('/')\n        stack = []\n        for i in path:\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i != '.' and i != '':\n                stack.append(i)\n        return '/' + '/'.join(stack)"
        }
    ],
    "word-search-ii": [
        {
            "task_id": "word-search-ii",
            "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a dictionary of words\n        word_dict = {}\n        for word in words:\n            word_dict[word] = 0\n        \n        # create a dictionary of board\n        board_dict = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in board_dict:\n                    board_dict[board[i][j]] = []\n                board_dict[board[i][j]].append([i,j])\n        \n        # find the words\n        found_words = []\n        for word in word_dict:\n            found = True\n            for letter in word:\n                if letter not in board_dict:\n                    found = False\n                    break\n            if found:\n                for letter in word:\n                    for loc in board_dict[letter]:\n                        if self.find_word(board, word, loc[0], loc[1]):\n                            found_words.append(word)\n                            break\n                    if word in found_words:\n                        break\n        return found_words\n    \n    def find_word(self, board, word, i, j):\n        if len(word) == 0:\n            return True\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or board[i][j] != word[0]:\n            return False\n        temp = board[i][j]\n        board[i][j] = \"#\"\n        \n        found = self.find_word(board, word[1:], i+1, j) or self.find_word(board, word[1:], i-1, j) or self.find_word(board, word[1:], i, j+1) or self.find_word(board, word[1:], i, j-1)\n        \n        board[i][j] = temp\n        return found"
        },
        {
            "task_id": "word-search-ii",
            "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the Trie\n        root = {}\n        for word in words:\n            current = root\n            for letter in word:\n                if letter not in current:\n                    current[letter] = {}\n                current = current[letter]\n            current['#'] = '#'\n            \n        # Initialize the answer\n        found_words = []\n        \n        # Iterate through the board\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                # Check if the current cell is the starting of any word\n                if board[i][j] in root:\n                    current = root[board[i][j]]\n                    self.dfs(i, j, board, current, found_words)\n                    \n        return found_words\n    \n    def dfs(self, i, j, board, current, found_words):\n        # If we have found the entire word, add it to the answer\n        if '#' in current:\n            found_words.append(board[i][j])\n            \n        # If the current cell is not a starting of any word, return\n        if board[i][j] not in current:\n            return\n        \n        # Temporarily mark the current cell as visited\n        board[i][j] = ' '\n        \n        # Recursively explore all the adjacent cells\n        if i > 0 and board[i - 1][j] != ' ':\n            self.dfs(i - 1, j, board, current[board[i - 1][j]], found_words)\n        if j > 0 and board[i][j - 1] != ' ':\n            self.dfs(i, j - 1, board, current[board[i][j - 1]], found_words)\n        if i < len(board) - 1 and board[i + 1][j] != ' ':\n            self.dfs(i + 1, j, board, current[board[i + 1][j]], found_words)\n        if j < len(board[0]) - 1 and board[i][j + 1] != ' ':\n            self.dfs(i, j + 1, board, current[board[i][j + 1]], found_words)\n            \n        # Backtrack\n        board[i][j] = current.keys()[0]"
        },
        {
            "task_id": "word-search-ii",
            "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a set of words\n        word_set = set(words)\n        \n        # create a set of words found in the board\n        found_words = set()\n        \n        # loop through the board\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                # create a string using the current letter and its neighbors\n                string = board[i][j]\n                # loop through the neighbors\n                for di in [-1, 0, 1]:\n                    for dj in [-1, 0, 1]:\n                        # if the neighbor exists and is not the same as the current letter\n                        if 0 <= i + di < len(board) and 0 <= j + dj < len(board[0]) and board[i + di][j + dj] != board[i][j]:\n                            # add the neighbor to the string\n                            string += board[i + di][j + dj]\n                \n                # if the string is in the word set\n                if string in word_set:\n                    # add the string to the found words set\n                    found_words.add(string)\n                    \n        # return the found words\n        return list(found_words)"
        },
        {
            "task_id": "word-search-ii",
            "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a set of words\n        word_set = set(words)\n        \n        # create a set of words found in the board\n        found_words = set()\n        \n        # loop through the board\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                # create a string using the current letter and its neighbors\n                # check if the string is in the word set\n                # if it is, add it to the found words set\n                for di in range(-1, 2):\n                    for dj in range(-1, 2):\n                        if 0 <= i + di < len(board) and 0 <= j + dj < len(board[0]):\n                            word = board[i][j]\n                            while board[i + di][j + dj] != ' ':\n                                word += board[i + di][j + dj]\n                                if word in word_set:\n                                    found_words.add(word)\n                                di += 1\n                                dj += 1\n                                if 0 <= i + di < len(board) and 0 <= j + dj < len(board[0]):\n                                    break\n                                \n        # return the found words                        \n        return list(found_words)"
        },
        {
            "task_id": "word-search-ii",
            "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a set of words\n        word_set = set(words)\n        \n        # create a set of words found in the board\n        found_words = set()\n        \n        # loop through the board\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                \n                # create a string using the current letter and its neighbors\n                string = board[i][j]\n                \n                # loop through the neighbors\n                for di in range(-1, 2):\n                    for dj in range(-1, 2):\n                        \n                        # if the neighbor is valid\n                        if 0 <= i + di < len(board) and 0 <= j + dj < len(board[0]) and board[i + di][j + dj] != ' ':\n                            \n                            # add the neighbor to the string\n                            string += board[i + di][j + dj]\n                            \n                # if the string is in the word set\n                if string in word_set:\n                    \n                    # add the string to the found words set\n                    found_words.add(string)\n                    \n        # return the found words\n        return list(found_words)"
        }
    ],
    "valid-anagram": [
        {
            "task_id": "valid-anagram",
            "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if length of s and t is not equal then return false\n        if len(s) != len(t):\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True\n        \n        # if s and t is not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t is equal then return true\n        if s == t:\n            return True"
        },
        {
            "task_id": "valid-anagram",
            "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the length of the strings are not equal, return false\n        if len(s) != len(t):\n            return False\n        \n        # create a dictionary to store the frequency of each character in string s\n        char_freq = {}\n        for char in s:\n            if char not in char_freq:\n                char_freq[char] = 1\n            else:\n                char_freq[char] += 1\n        \n        # iterate through string t\n        for char in t:\n            if char not in char_freq or char_freq[char] == 0:\n                return False\n            else:\n                char_freq[char] -= 1\n        \n        return True"
        },
        {
            "task_id": "valid-anagram",
            "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if length of s and t are not equal then return false\n        if len(s) != len(t):\n            return False\n        \n        # if length of s and t are equal then sort both the strings\n        s = sorted(s)\n        t = sorted(t)\n        \n        # if both the sorted strings are equal then return true\n        if s == t:\n            return True\n        else:\n            return False"
        },
        {
            "task_id": "valid-anagram",
            "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if length of s and t are not equal then they are not anagrams\n        if len(s) != len(t):\n            return False\n        \n        # if length of s and t are equal then we need to check if they are anagrams or not\n        else:\n            # we will use dictionary to store the frequency of each character in s\n            s_dict = {}\n            for i in s:\n                if i not in s_dict:\n                    s_dict[i] = 1\n                else:\n                    s_dict[i] += 1\n            \n            # we will use dictionary to store the frequency of each character in t\n            t_dict = {}\n            for i in t:\n                if i not in t_dict:\n                    t_dict[i] = 1\n                else:\n                    t_dict[i] += 1\n            \n            # if s_dict and t_dict are equal then they are anagrams\n            if s_dict == t_dict:\n                return True\n            else:\n                return False"
        },
        {
            "task_id": "valid-anagram",
            "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if length of s and t are not equal then return false\n        if len(s) != len(t):\n            return False\n        \n        # if s and t are equal then return true\n        if s == t:\n            return True\n        \n        # if s and t are not equal then return false\n        if s != t:\n            return False\n        \n        # if s and t are anagram then return true\n        if sorted(s) == sorted(t):\n            return True\n        \n        # if s and t are not anagram then return false\n        else:\n            return False"
        }
    ],
    "valid-sudoku": [
        {
            "task_id": "valid-sudoku",
            "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        #check rows\n        for row in board:\n            if not self.isValidList(row):\n                return False\n        \n        #check columns\n        for col in zip(*board):\n            if not self.isValidList(col):\n                return False\n        \n        #check 3x3 sub-boxes\n        for i in (0,3,6):\n            for j in (0,3,6):\n                box = [board[x][y] for x in range(i,i+3) for y in range(j,j+3)]\n                if not self.isValidList(box):\n                    return False\n        \n        return True\n    \n    def isValidList(self,myList):\n        mySet = set()\n        for i in myList:\n            if i != '.':\n                if i in mySet:\n                    return False\n                else:\n                    mySet.add(i)\n        return True"
        },
        {
            "task_id": "valid-sudoku",
            "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        #check rows\n        for row in board:\n            if not self.isValidList(row):\n                return False\n        \n        #check columns\n        for col in zip(*board):\n            if not self.isValidList(col):\n                return False\n        \n        #check 3x3 sub-boxes\n        for i in (0,3,6):\n            for j in (0,3,6):\n                box = [board[x][y] for x in range(i,i+3) for y in range(j,j+3)]\n                if not self.isValidList(box):\n                    return False\n        \n        return True\n    \n    def isValidList(self,myList):\n        mySet = set()\n        for i in myList:\n            if i != '.':\n                if i in mySet:\n                    return False\n                else:\n                    mySet.add(i)\n        return True"
        },
        {
            "task_id": "valid-sudoku",
            "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValidList(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValidList(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                box = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValidList(box):\n                    return False\n        \n        return True\n    \n    def isValidList(self, myList):\n        \"\"\"\n        :type myList: List[str]\n        :rtype: bool\n        \"\"\"\n        checkDuplicate = []\n        for i in myList:\n            if i != \".\":\n                if i in checkDuplicate:\n                    return False\n                checkDuplicate.append(i)\n        return True"
        },
        {
            "task_id": "valid-sudoku",
            "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValidList(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValidList(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                box = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValidList(box):\n                    return False\n        \n        return True\n    \n    def isValidList(self, myList):\n        \"\"\"\n        :type myList: List[str]\n        :rtype: bool\n        \"\"\"\n        checkDuplicate = []\n        for i in myList:\n            if i != \".\":\n                if i in checkDuplicate:\n                    return False\n                checkDuplicate.append(i)\n        return True"
        },
        {
            "task_id": "valid-sudoku",
            "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        #check rows\n        for row in board:\n            if not self.isValidList(row):\n                return False\n        \n        #check columns\n        for col in zip(*board):\n            if not self.isValidList(col):\n                return False\n        \n        #check 3x3 sub-boxes\n        for i in (0,3,6):\n            for j in (0,3,6):\n                box = [board[x][y] for x in range(i,i+3) for y in range(j,j+3)]\n                if not self.isValidList(box):\n                    return False\n        \n        return True\n    \n    def isValidList(self,myList):\n        mySet = set()\n        for i in myList:\n            if i != '.':\n                if i in mySet:\n                    return False\n                else:\n                    mySet.add(i)\n        return True"
        }
    ],
    "fizz-buzz": [
        {
            "task_id": "fizz-buzz",
            "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        result = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result"
        },
        {
            "task_id": "fizz-buzz",
            "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        result = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result"
        },
        {
            "task_id": "fizz-buzz",
            "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        result = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result"
        },
        {
            "task_id": "fizz-buzz",
            "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        result = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result"
        },
        {
            "task_id": "fizz-buzz",
            "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        result = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result"
        }
    ],
    "reverse-words-in-a-string": [
        {
            "task_id": "reverse-words-in-a-string",
            "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # reverse the list of words\n        words.reverse()\n        \n        # join the list of words into a string\n        return \" \".join(words)"
        },
        {
            "task_id": "reverse-words-in-a-string",
            "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # reverse the list of words\n        words.reverse()\n        \n        # join the list of words into a string\n        return \" \".join(words)"
        },
        {
            "task_id": "reverse-words-in-a-string",
            "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # reverse the list of words\n        words.reverse()\n        \n        # join the list of words into a string\n        return \" \".join(words)"
        },
        {
            "task_id": "reverse-words-in-a-string",
            "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # remove leading and trailing spaces\n        s = s.strip()\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the words\n        words.reverse()\n        \n        # join the words into a string\n        return \" \".join(words)"
        },
        {
            "task_id": "reverse-words-in-a-string",
            "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # reverse the list of words\n        words.reverse()\n        \n        # join the list of words into a string\n        return \" \".join(words)"
        }
    ],
    "excel-sheet-column-number": [
        {
            "task_id": "excel-sheet-column-number",
            "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize result\n        result = 0\n        \n        # Traverse columnTitle\n        for i in range(len(columnTitle)):\n            \n            # Find numerical value\n            # of current character\n            val = ord(columnTitle[i]) - 64\n            \n            # Multiply val with\n            # appropriate power of 26\n            result += val * pow(26, len(columnTitle) - i - 1)\n            \n        return result"
        },
        {
            "task_id": "excel-sheet-column-number",
            "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize result\n        result = 0\n        \n        # Iterate through all characters\n        for i in range(len(columnTitle)):\n            \n            # Find numerical value\n            # of current character\n            val = ord(columnTitle[i]) - 64\n            \n            # Multiply with\n            # appropriate power\n            # of 26\n            result += val * pow(26, len(columnTitle) - i - 1)\n            \n        return result"
        },
        {
            "task_id": "excel-sheet-column-number",
            "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize result\n        result = 0\n        \n        # Iterate through all characters\n        for i in range(len(columnTitle)):\n            \n            # Find numerical representation\n            # of current character\n            result += (ord(columnTitle[i]) - ord('A') + 1) * (26 ** (len(columnTitle) - i - 1))\n            \n        return result"
        },
        {
            "task_id": "excel-sheet-column-number",
            "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize result\n        result = 0\n        \n        # Iterate through all characters\n        for i in range(len(columnTitle)):\n            \n            # Find numerical value\n            # of current character\n            val = ord(columnTitle[i]) - 64\n            \n            # Multiply with\n            # appropriate power\n            # of 26\n            result += val * pow(26, len(columnTitle) - i - 1)\n            \n        return result"
        },
        {
            "task_id": "excel-sheet-column-number",
            "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize result\n        result = 0\n        \n        # Iterate through all characters\n        for i in range(len(columnTitle)):\n            \n            # Find numerical representation\n            # of current character\n            result += (ord(columnTitle[i]) - ord('A') + 1) * (26 ** (len(columnTitle) - i - 1))\n            \n        return result"
        }
    ],
    "candy": [
        {
            "task_id": "candy",
            "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n == 1:\n            return 1\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        return sum(candies)"
        },
        {
            "task_id": "candy",
            "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n == 1:\n            return 1\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        return sum(candies)"
        },
        {
            "task_id": "candy",
            "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n == 1:\n            return 1\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        return sum(candies)"
        },
        {
            "task_id": "candy",
            "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n == 1:\n            return 1\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        return sum(candies)"
        },
        {
            "task_id": "candy",
            "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n == 1:\n            return 1\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        return sum(candies)"
        }
    ],
    "same-tree": [
        {
            "task_id": "same-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"
        },
        {
            "task_id": "same-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"
        },
        {
            "task_id": "same-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"
        },
        {
            "task_id": "same-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"
        },
        {
            "task_id": "same-tree",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        else:\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"
        }
    ],
    "reorder-list": [
        {
            "task_id": "reorder-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if head is None:\n            return\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # merge the first and second half\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"
        },
        {
            "task_id": "reorder-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if head is None:\n            return\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # merge the first and second half of the list\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return"
        },
        {
            "task_id": "reorder-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if head is None:\n            return\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # merge the first and second half of the list\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        # handle the case when the length of the list is odd\n        if second != first:\n            first.next = second"
        },
        {
            "task_id": "reorder-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if head is None:\n            return\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # merge the first and second half\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        # handle the odd case\n        if second != first:\n            first.next = second"
        },
        {
            "task_id": "reorder-list",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if head is None:\n            return\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # merge the first and second half\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return"
        }
    ],
    "word-pattern": [
        {
            "task_id": "word-pattern",
            "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal return false\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to map the pattern and words\n        d = {}\n        \n        # loop through the pattern and words\n        for i in range(len(pattern)):\n            \n            # if the pattern is not in the dictionary add it\n            if pattern[i] not in d:\n                d[pattern[i]] = words[i]\n            \n            # if the pattern is in the dictionary and the word is not equal to the value return false\n            elif words[i] != d[pattern[i]]:\n                return False\n            \n        # return true\n        return True"
        },
        {
            "task_id": "word-pattern",
            "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal return false\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to map the pattern and words\n        d = {}\n        \n        # loop through the pattern and words\n        for i in range(len(pattern)):\n            \n            # if the pattern is not in the dictionary add it\n            if pattern[i] not in d:\n                d[pattern[i]] = words[i]\n            \n            # if the pattern is in the dictionary and the word is not equal to the value return false\n            elif words[i] != d[pattern[i]]:\n                return False\n        \n        # return true\n        return True"
        },
        {
            "task_id": "word-pattern",
            "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal return false\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to map the pattern and words\n        d = {}\n        \n        # loop through the pattern and words\n        for i in range(len(pattern)):\n            \n            # if the pattern is not in the dictionary add it\n            if pattern[i] not in d:\n                d[pattern[i]] = words[i]\n            \n            # if the pattern is in the dictionary and the word is not equal to the value return false\n            elif d[pattern[i]] != words[i]:\n                return False\n            \n        # return true\n        return True"
        },
        {
            "task_id": "word-pattern",
            "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal return false\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to map the pattern and words\n        d = {}\n        \n        # loop through the pattern and words\n        for i in range(len(pattern)):\n            \n            # if the pattern is not in the dictionary add it\n            if pattern[i] not in d:\n                d[pattern[i]] = words[i]\n            \n            # if the pattern is in the dictionary and the word is not equal to the value return false\n            elif words[i] != d[pattern[i]]:\n                return False\n        \n        # return true\n        return True"
        },
        {
            "task_id": "word-pattern",
            "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal return false\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to map the pattern and words\n        d = {}\n        \n        # loop through the pattern and words\n        for i in range(len(pattern)):\n            \n            # if the pattern is not in the dictionary add it\n            if pattern[i] not in d:\n                d[pattern[i]] = words[i]\n            \n            # if the pattern is in the dictionary and the word is not equal to the value return false\n            elif words[i] != d[pattern[i]]:\n                return False\n            \n        # return true\n        return True"
        }
    ],
    "permutations": [
        {
            "task_id": "permutations",
            "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        else:\n            result = []\n            for i in range(len(nums)):\n                for j in self.permute(nums[:i] + nums[i+1:]):\n                    result.append([nums[i]] + j)\n            return result"
        },
        {
            "task_id": "permutations",
            "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def permute_helper(nums, start, end, result):\n            if start == end:\n                result.append(nums[:])\n                return\n            \n            for i in range(start, end+1):\n                nums[start], nums[i] = nums[i], nums[start]\n                permute_helper(nums, start+1, end, result)\n                nums[start], nums[i] = nums[i], nums[start]\n        \n        result = []\n        permute_helper(nums, 0, len(nums)-1, result)\n        return result"
        },
        {
            "task_id": "permutations",
            "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        else:\n            result = []\n            for i in range(len(nums)):\n                for j in self.permute(nums[:i] + nums[i+1:]):\n                    result.append([nums[i]] + j)\n            return result"
        },
        {
            "task_id": "permutations",
            "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        else:\n            result = []\n            for i in range(len(nums)):\n                for j in self.permute(nums[:i] + nums[i+1:]):\n                    result.append([nums[i]] + j)\n            return result"
        },
        {
            "task_id": "permutations",
            "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def permute_helper(nums, start, end, result):\n            if start == end:\n                result.append(nums[:])\n            for i in range(start, end):\n                nums[start], nums[i] = nums[i], nums[start]\n                permute_helper(nums, start + 1, end, result)\n                nums[start], nums[i] = nums[i], nums[start]\n        \n        result = []\n        permute_helper(nums, 0, len(nums), result)\n        return result"
        }
    ],
    "search-a-2d-matrix": [
        {
            "task_id": "search-a-2d-matrix",
            "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix:\n            return False\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[m-1][n-1]:\n            return False\n        \n        i = 0\n        j = n-1\n        \n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] > target:\n                j -= 1\n            else:\n                i += 1\n                \n        return False"
        },
        {
            "task_id": "search-a-2d-matrix",
            "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return False\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            row = mid // n\n            col = mid % n\n            \n            if matrix[row][col] == target:\n                return True\n            \n            if matrix[row][col] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return False"
        },
        {
            "task_id": "search-a-2d-matrix",
            "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return False\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        i = 0\n        j = n - 1\n        \n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] > target:\n                j -= 1\n            else:\n                i += 1\n                \n        return False"
        },
        {
            "task_id": "search-a-2d-matrix",
            "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return False\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        i = 0\n        j = n - 1\n        \n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] > target:\n                j -= 1\n            else:\n                i += 1\n                \n        return False"
        },
        {
            "task_id": "search-a-2d-matrix",
            "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return False\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        i = 0\n        j = n - 1\n        \n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] > target:\n                j -= 1\n            else:\n                i += 1\n                \n        return False"
        }
    ],
    "add-two-numbers": [
        {
            "task_id": "add-two-numbers",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result node\n        result = ListNode()\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        \n        # Traverse the two linked lists\n        while l1 or l2 or carry:\n            # Calculate the sum of the two digits\n            # and add the carry\n            sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n            # Update the carry\n            carry = sum // 10\n            # Update the sum\n            sum = sum % 10\n            # Update the current node\n            current.val = sum\n            # Update the current node\n            current.next = ListNode()\n            # Update the current node\n            current = current.next\n            # Update the linked list\n            l1 = l1.next if l1 else None\n            # Update the linked list\n            l2 = l2.next if l2 else None\n            \n        # Return the result\n        return result"
        },
        {
            "task_id": "add-two-numbers",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result node\n        result = ListNode(0)\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        \n        # Loop until one of the lists is empty\n        while l1 or l2 or carry:\n            # Calculate the value for the current node\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            current.val = carry % 10\n            carry //= 10\n            # Create a new node and advance the current node\n            if l1 or l2 or carry:\n                current.next = ListNode(0)\n                current = current.next\n        return result"
        },
        {
            "task_id": "add-two-numbers",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result node\n        result = ListNode(0)\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        \n        # Loop until one of the lists is empty\n        while l1 or l2 or carry:\n            # Calculate the value for the current node\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            current.val = carry % 10\n            carry //= 10\n            # Create a new node and advance the current node\n            if l1 or l2 or carry:\n                current.next = ListNode(0)\n                current = current.next\n        return result"
        },
        {
            "task_id": "add-two-numbers",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result node\n        result = ListNode(0)\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        \n        # Loop until one of the lists is empty\n        while l1 or l2 or carry:\n            # Calculate the value for the current node\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            current.val = carry % 10\n            carry //= 10\n            # Create a new node and advance the current node\n            if l1 or l2 or carry:\n                current.next = ListNode(0)\n                current = current.next\n        \n        # Return the result node\n        return result"
        },
        {
            "task_id": "add-two-numbers",
            "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result node\n        result = ListNode(0)\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        \n        # Loop until one of the lists is empty\n        while l1 or l2 or carry:\n            # Calculate the value for the current node\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            current.val = carry % 10\n            carry //= 10\n            # Create a new node and advance the current node\n            if l1 or l2 or carry:\n                current.next = ListNode(0)\n                current = current.next\n        return result"
        }
    ],
    "number-complement": [
        {
            "task_id": "number-complement",
            "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # Convert num to binary\n        binary = bin(num)[2:]\n        \n        # Flip the bits\n        complement = \"\"\n        for bit in binary:\n            if bit == \"0\":\n                complement += \"1\"\n            else:\n                complement += \"0\"\n        \n        # Convert back to decimal\n        return int(complement, 2)"
        },
        {
            "task_id": "number-complement",
            "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert num to binary\n        binary = bin(num)[2:]\n        \n        # flip the binary\n        flipped = binary.replace('0', '2').replace('1', '0').replace('2', '1')\n        \n        # convert flipped binary to int\n        return int(flipped, 2)"
        },
        {
            "task_id": "number-complement",
            "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # Convert the number to binary\n        binary = bin(num)[2:]\n        \n        # Flip the bits\n        flipped = \"\"\n        for i in binary:\n            if i == \"0\":\n                flipped += \"1\"\n            else:\n                flipped += \"0\"\n        \n        # Convert the flipped binary to decimal\n        return int(flipped, 2)"
        },
        {
            "task_id": "number-complement",
            "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # Convert num to binary\n        binary = bin(num)[2:]\n        \n        # Flip the binary string\n        flipped = binary.replace('0', '2').replace('1', '0').replace('2', '1')\n        \n        # Convert flipped binary to decimal\n        return int(flipped, 2)"
        },
        {
            "task_id": "number-complement",
            "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # Convert the number to binary\n        binary = bin(num)[2:]\n        \n        # Flip the bits\n        flipped = \"\"\n        for i in binary:\n            if i == \"0\":\n                flipped += \"1\"\n            else:\n                flipped += \"0\"\n        \n        # Convert the flipped binary to decimal\n        return int(flipped, 2)"
        }
    ],
    "arithmetic-slices-ii-subsequence": [
        {
            "task_id": "arithmetic-slices-ii-subsequence",
            "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        dp = [0] * len(nums)\n        count = 0\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n                count += dp[i]\n                \n        return count"
        },
        {
            "task_id": "arithmetic-slices-ii-subsequence",
            "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        n = len(nums)\n        dp = [0] * n\n        count = 0\n        \n        # Edge case\n        if n < 3:\n            return 0\n        \n        # Loop through the list\n        for i in range(2, n):\n            \n            # Check if the difference is the same\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n                count += dp[i]\n                \n        return count"
        },
        {
            "task_id": "arithmetic-slices-ii-subsequence",
            "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        n = len(nums)\n        dp = [0] * n\n        count = 0\n        \n        # Edge case\n        if n < 3:\n            return 0\n        \n        # Loop through the list\n        for i in range(2, n):\n            \n            # Check if the difference is the same\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n                count += dp[i]\n                \n        return count"
        },
        {
            "task_id": "arithmetic-slices-ii-subsequence",
            "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        dp = [0] * len(nums)\n        count = 0\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n                count += dp[i]\n                \n        return count"
        },
        {
            "task_id": "arithmetic-slices-ii-subsequence",
            "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        dp = [0] * len(nums)\n        count = 0\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n                count += dp[i]\n                \n        return count"
        }
    ],
    "text-justification": [
        {
            "task_id": "text-justification",
            "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        n = len(words)\n        start = 0\n        while start < n:\n            end = start + 1\n            length = len(words[start])\n            while end < n and length + len(words[end]) + end - start <= maxWidth:\n                length += len(words[end])\n                end += 1\n            if end == n:\n                res.append(self.left_justify(words[start:end], maxWidth))\n                break\n            if end - start == 1:\n                res.append(self.left_justify(words[start:end], maxWidth))\n            else:\n                res.append(self.full_justify(words[start:end], maxWidth, length))\n            start = end\n        return res\n    \n    def left_justify(self, words, maxWidth):\n        return \" \".join(words) + \" \" * (maxWidth - len(\" \".join(words)))\n    \n    def full_justify(self, words, maxWidth, length):\n        num_spaces = maxWidth - length\n        num_words = len(words) - 1\n        if num_words == 0:\n            return words[0] + \" \" * num_spaces\n        else:\n            quotient, remainder = divmod(num_spaces, num_words)\n            return \" \".join([words[i] + \" \" * (quotient + (1 if i < remainder else 0)) for i in range(num_words + 1)])"
        },
        {
            "task_id": "text-justification",
            "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        n = len(words)\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            length = len(words[start])\n            \n            while end < n and length + len(words[end]) + end - start <= maxWidth:\n                length += len(words[end])\n                end += 1\n                \n            if end == n:\n                res.append(self.left_justify(words[start:end], maxWidth))\n                break\n                \n            if end - start == 1:\n                res.append(self.left_justify(words[start:end], maxWidth))\n            else:\n                res.append(self.full_justify(words[start:end], maxWidth, length))\n                \n            start = end\n            \n        return res\n    \n    def left_justify(self, words, maxWidth):\n        return \" \".join(words) + \" \" * (maxWidth - len(\" \".join(words)))\n    \n    def full_justify(self, words, maxWidth, length):\n        num_spaces = maxWidth - length\n        num_words = len(words) - 1\n        avg_spaces = num_spaces // num_words\n        extra_spaces = num_spaces % num_words\n        \n        res = \"\"\n        for i in range(len(words)):\n            res += words[i]\n            if i < num_words:\n                res += \" \" * (avg_spaces + 1)\n                if extra_spaces > 0:\n                    res += \" \"\n                    extra_spaces -= 1\n        return res"
        },
        {
            "task_id": "text-justification",
            "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        n = len(words)\n        start = 0\n        while start < n:\n            end = start + 1\n            length = len(words[start])\n            while end < n and length + len(words[end]) + end - start <= maxWidth:\n                length += len(words[end])\n                end += 1\n            if end == n:\n                res.append(self.left_justify(words[start:end], maxWidth))\n                break\n            if end - start == 1:\n                res.append(self.left_justify(words[start:end], maxWidth))\n            else:\n                res.append(self.full_justify(words[start:end], maxWidth, length))\n            start = end\n        return res\n\n    def left_justify(self, words, maxWidth):\n        return \" \".join(words) + \" \" * (maxWidth - len(\" \".join(words)))\n\n    def full_justify(self, words, maxWidth, length):\n        num_spaces = maxWidth - length\n        num_words = len(words) - 1\n        if num_words == 0:\n            return words[0] + \" \" * num_spaces\n        else:\n            quotient, remainder = divmod(num_spaces, num_words)\n            return \" \".join([words[i] + \" \" * (quotient + (1 if i < remainder else 0)) for i in range(num_words)]) + words[-1]"
        },
        {
            "task_id": "text-justification",
            "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        n = len(words)\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            length = len(words[start])\n            \n            while end < n and length + len(words[end]) + end - start <= maxWidth:\n                length += len(words[end])\n                end += 1\n                \n            if end == n:\n                res.append(self.left_justify(words[start:end], maxWidth))\n                break\n                \n            if end - start == 1:\n                res.append(self.left_justify(words[start:end], maxWidth))\n            else:\n                res.append(self.full_justify(words[start:end], maxWidth, length))\n                \n            start = end\n            \n        return res\n    \n    def left_justify(self, words, maxWidth):\n        return \" \".join(words) + \" \" * (maxWidth - len(\" \".join(words)))\n    \n    def full_justify(self, words, maxWidth, length):\n        num_spaces = maxWidth - length\n        num_words = len(words) - 1\n        avg_spaces = num_spaces // num_words\n        extra_spaces = num_spaces % num_words\n        \n        res = \"\"\n        for i in range(len(words)):\n            res += words[i]\n            if i < num_words:\n                res += \" \" * (avg_spaces + 1)\n                if extra_spaces > 0:\n                    res += \" \"\n                    extra_spaces -= 1\n        return res"
        },
        {
            "task_id": "text-justification",
            "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        n = len(words)\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            length = len(words[start])\n            \n            while end < n and length + len(words[end]) + end - start <= maxWidth:\n                length += len(words[end])\n                end += 1\n                \n            if end == n:\n                res.append(self.left_justify(words[start:end], maxWidth))\n                break\n                \n            if end - start == 1:\n                res.append(self.left_justify(words[start:end], maxWidth))\n            else:\n                res.append(self.full_justify(words[start:end], maxWidth, length))\n                \n            start = end\n            \n        return res\n    \n    def left_justify(self, words, maxWidth):\n        return \" \".join(words) + \" \" * (maxWidth - len(\" \".join(words)))\n    \n    def full_justify(self, words, maxWidth, length):\n        num_spaces = maxWidth - length\n        num_words = len(words) - 1\n        avg_spaces = num_spaces // num_words\n        extra_spaces = num_spaces % num_words\n        \n        res = \"\"\n        for i in range(len(words)):\n            res += words[i]\n            if i < num_words:\n                res += \" \" * (avg_spaces + 1)\n                if extra_spaces:\n                    res += \" \"\n                    extra_spaces -= 1\n        return res"
        }
    ],
    "binary-tree-postorder-traversal": [
        {
            "task_id": "binary-tree-postorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        stack.append(root)\n        result = []\n        \n        while stack:\n            root = stack.pop()\n            result.append(root.val)\n            if root.left:\n                stack.append(root.left)\n            if root.right:\n                stack.append(root.right)\n                \n        return result[::-1]"
        },
        {
            "task_id": "binary-tree-postorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        stack.append(root)\n        result = []\n        \n        while stack:\n            root = stack.pop()\n            result.append(root.val)\n            if root.left:\n                stack.append(root.left)\n            if root.right:\n                stack.append(root.right)\n                \n        return result[::-1]"
        },
        {
            "task_id": "binary-tree-postorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        else:\n            return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]"
        },
        {
            "task_id": "binary-tree-postorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        stack.append(root)\n        result = []\n        \n        while stack:\n            root = stack.pop()\n            result.append(root.val)\n            if root.left:\n                stack.append(root.left)\n            if root.right:\n                stack.append(root.right)\n        \n        return result[::-1]"
        },
        {
            "task_id": "binary-tree-postorder-traversal",
            "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        else:\n            left = self.postorderTraversal(root.left)\n            right = self.postorderTraversal(root.right)\n            return left + right + [root.val]"
        }
    ],
    "container-with-most-water": [
        {
            "task_id": "container-with-most-water",
            "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"
        },
        {
            "task_id": "container-with-most-water",
            "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"
        },
        {
            "task_id": "container-with-most-water",
            "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        # Loop until left is greater than right\n        while left < right:\n            \n            # Calculate area\n            area = (right - left) * min(height[left], height[right])\n            \n            # Update max_area\n            max_area = max(max_area, area)\n            \n            # Check which side is shorter, and move pointer in that direction\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"
        },
        {
            "task_id": "container-with-most-water",
            "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"
        },
        {
            "task_id": "container-with-most-water",
            "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        # Loop until left and right meet\n        while left < right:\n            \n            # Calculate area\n            area = (right - left) * min(height[left], height[right])\n            \n            # Update max_area\n            max_area = max(max_area, area)\n            \n            # Move pointers\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"
        }
    ],
    "concatenated-words": [
        {
            "task_id": "concatenated-words",
            "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list of words in descending order of length\n        words.sort(key=len, reverse=True)\n        \n        # Initialize a list to store the results\n        res = []\n        \n        # Iterate over the list of words\n        for w in words:\n            \n            # Check if the current word is a concatenated word\n            if self.isConcatenated(w, words):\n                res.append(w)\n                \n        return res\n    \n    def isConcatenated(self, word, words):\n        \n        # Base case\n        if not word:\n            return False\n        \n        # Iterate over the list of words\n        for w in words:\n            \n            # Check if the current word is a prefix of the given word\n            if word.startswith(w):\n                \n                # Recursively check if the suffix of the given word is concatenated\n                if self.isConcatenated(word[len(w):], words):\n                    return True\n                \n        return False"
        },
        {
            "task_id": "concatenated-words",
            "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list of words in descending order of length\n        words.sort(key=len, reverse=True)\n        \n        # Initialize a list to store the results\n        res = []\n        \n        # Iterate over the list of words\n        for w in words:\n            \n            # Check if the current word is a concatenated word\n            if self.isConcatenated(w, words):\n                res.append(w)\n                \n        return res\n    \n    def isConcatenated(self, word, words):\n        \n        # Base case\n        if not word:\n            return False\n        \n        # Iterate over the list of words\n        for w in words:\n            \n            # Check if the current word is a prefix of the given word\n            if word.startswith(w):\n                \n                # Recursive call\n                if self.isConcatenated(word[len(w):], words):\n                    return True\n                \n        return False"
        },
        {
            "task_id": "concatenated-words",
            "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list of words in descending order of length\n        words.sort(key=len, reverse=True)\n        \n        # Initialize a list to store the results\n        res = []\n        \n        # Iterate over the list of words\n        for w in words:\n            \n            # Check if the current word is a concatenated word\n            if self.isConcatenated(w, words):\n                res.append(w)\n                \n        return res\n    \n    def isConcatenated(self, word, words):\n        \n        # Base case\n        if not word:\n            return False\n        \n        # Iterate over the list of words\n        for w in words:\n            \n            # Check if the current word is a prefix of the given word\n            if word.startswith(w):\n                \n                # Recursive call\n                if self.isConcatenated(word[len(w):], words):\n                    return True\n                \n        return False"
        },
        {
            "task_id": "concatenated-words",
            "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list of words in descending order of length\n        words.sort(key=len, reverse=True)\n        \n        # Initialize a list to store the results\n        res = []\n        \n        # Iterate over the list of words\n        for w in words:\n            \n            # Check if the current word is a concatenated word\n            if self.isConcatenatedWord(w, words):\n                res.append(w)\n                \n        return res\n    \n    def isConcatenatedWord(self, word, words):\n        \n        # If the length of the word is 0 or 1, it is not a concatenated word\n        if len(word) <= 1:\n            return False\n        \n        # Iterate from the second character of the word to the last character\n        for i in range(1, len(word)):\n            \n            # If the substring from the second character to the last character\n            # is in the list of words, it means we can form a concatenated word\n            # by combining the substring with a word that comes before it in the list\n            if word[i:] in words:\n                \n                # If the substring from the beginning to the second last character\n                # is also in the list of words, it means we can form a concatenated word\n                # by combining the substring with a word that comes after it in the list\n                if word[:i] in words:\n                    return True\n                \n        # If no concatenated word can be formed, return False\n        return False"
        },
        {
            "task_id": "concatenated-words",
            "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list of words in descending order of length\n        words.sort(key=len, reverse=True)\n        \n        # Initialize a list to store the results\n        res = []\n        \n        # Iterate over the list of words\n        for w in words:\n            \n            # Check if the word can be formed by concatenating two other words\n            for i in range(1, len(w)):\n                if w[:i] in words and w[i:] in words:\n                    res.append(w)\n                    break\n                    \n        return res"
        }
    ],
    "base-7": [
        {
            "task_id": "base-7",
            "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        else:\n            return self.convertToBase7(num // 7) + str(num % 7)"
        },
        {
            "task_id": "base-7",
            "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        else:\n            return self.convertToBase7(num // 7) + str(num % 7)"
        },
        {
            "task_id": "base-7",
            "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        else:\n            return self.convertToBase7(num // 7) + str(num % 7)"
        },
        {
            "task_id": "base-7",
            "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        else:\n            return self.convertToBase7(num // 7) + str(num % 7)"
        },
        {
            "task_id": "base-7",
            "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        else:\n            return self.convertToBase7(num // 7) + str(num % 7)"
        }
    ],
    "nim-game": [
        {
            "task_id": "nim-game",
            "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"
        },
        {
            "task_id": "nim-game",
            "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"
        },
        {
            "task_id": "nim-game",
            "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n%4 == 0:\n            return False\n        else:\n            return True"
        },
        {
            "task_id": "nim-game",
            "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"
        },
        {
            "task_id": "nim-game",
            "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"
        }
    ],
    "n-queens-ii": [
        {
            "task_id": "n-queens-ii",
            "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 1:\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, n)):\n                if board[i][j] == 1:\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 1\n                    count += dfs(board, row + 1)\n                    board[row][col] = 0\n            return count\n        \n        board = [[0] * n for _ in range(n)]\n        return dfs(board, 0)"
        },
        {
            "task_id": "n-queens-ii",
            "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            for i, j in zip(range(row), range(col, -1, -1)):\n                if board[i][j] == 1:\n                    return False\n            for i, j in zip(range(row), range(col, n)):\n                if board[i][j] == 1:\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 1\n                    count += dfs(board, row + 1)\n                    board[row][col] = 0\n            return count\n        \n        board = [[0] * n for _ in range(n)]\n        return dfs(board, 0)"
        },
        {
            "task_id": "n-queens-ii",
            "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 1:\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, n)):\n                if board[i][j] == 1:\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 1\n                    count += dfs(board, row + 1)\n                    board[row][col] = 0\n            return count\n        \n        board = [[0] * n for _ in range(n)]\n        return dfs(board, 0)"
        },
        {
            "task_id": "n-queens-ii",
            "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            for i, j in zip(range(row), range(col, -1, -1)):\n                if board[i][j] == 1:\n                    return False\n            for i, j in zip(range(row), range(col, n)):\n                if board[i][j] == 1:\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 1\n                    count += dfs(board, row + 1)\n                    board[row][col] = 0\n            return count\n        \n        board = [[0] * n for _ in range(n)]\n        return dfs(board, 0)"
        },
        {
            "task_id": "n-queens-ii",
            "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 1:\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, n)):\n                if board[i][j] == 1:\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 1\n                    count += dfs(board, row + 1)\n                    board[row][col] = 0\n            return count\n        \n        board = [[0] * n for _ in range(n)]\n        return dfs(board, 0)"
        }
    ],
    "n-queens": [
        {
            "task_id": "n-queens",
            "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, n)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                result.append(board)\n                return\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 'Q'\n                    dfs(board, row + 1)\n                    board[row][col] = '.'\n        \n        result = []\n        board = [['.'] * n for _ in range(n)]\n        dfs(board, 0)\n        return result"
        },
        {
            "task_id": "n-queens",
            "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, n)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                result.append(board)\n                return\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 'Q'\n                    dfs(board, row + 1)\n                    board[row][col] = '.'\n        \n        result = []\n        board = [['.'] * n for _ in range(n)]\n        dfs(board, 0)\n        return result"
        },
        {
            "task_id": "n-queens",
            "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, n)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                result.append(board)\n                return\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 'Q'\n                    dfs(board, row + 1)\n                    board[row][col] = '.'\n        \n        result = []\n        board = [['.'] * n for _ in range(n)]\n        dfs(board, 0)\n        return result"
        },
        {
            "task_id": "n-queens",
            "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, n)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                result.append(board)\n                return\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 'Q'\n                    dfs(board, row + 1)\n                    board[row][col] = '.'\n        \n        result = []\n        board = [['.'] * n for _ in range(n)]\n        dfs(board, 0)\n        return result"
        },
        {
            "task_id": "n-queens",
            "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, n)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                result.append(board)\n                return\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 'Q'\n                    dfs(board, row + 1)\n                    board[row][col] = '.'\n        \n        result = []\n        board = [['.'] * n for _ in range(n)]\n        dfs(board, 0)\n        return result"
        }
    ],
    "word-search": [
        {
            "task_id": "word-search",
            "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if not, return False\n        \n        # check if"
        },
        {
            "task_id": "word-search",
            "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False"
        },
        {
            "task_id": "word-search",
            "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False"
        },
        {
            "task_id": "word-search",
            "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False"
        },
        {
            "task_id": "word-search",
            "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False"
        }
    ],
    "merge-sorted-array": [
        {
            "task_id": "merge-sorted-array",
            "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # Merge the two arrays\n        nums1[m:] = nums2\n        \n        # Sort the array\n        nums1.sort()\n        \n        # Return the sorted array\n        return nums1"
        },
        {
            "task_id": "merge-sorted-array",
            "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # Merge the two arrays into a single array\n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1]\n        # nums2 = []\n        # m = 1\n        # n = 0\n        # nums1 = [1]\n        \n        # nums1 = [0]\n        # nums2 = [1]\n        # m = 0\n        # n = 1\n        # nums1 = [1]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3,0,0,0]\n        # nums2 = [2,5,6]\n        # m = 3\n        # n = 3\n        # nums1 = [1,2,2,3,5,6]\n        \n        # nums1 = [1,2,3"
        },
        {
            "task_id": "merge-sorted-array",
            "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # Merge the two arrays\n        nums1[m:] = nums2\n        \n        # Sort the array\n        nums1.sort()"
        },
        {
            "task_id": "merge-sorted-array",
            "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # Merge the two arrays into a single array\n        nums1[m:] = nums2\n        \n        # Sort the array\n        nums1.sort()"
        },
        {
            "task_id": "merge-sorted-array",
            "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # Merge the two arrays\n        nums1[m:] = nums2\n        \n        # Sort the array\n        nums1.sort()"
        }
    ],
    "third-maximum-number": [
        {
            "task_id": "third-maximum-number",
            "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a set to store the unique elements\n        unique_nums = set()\n        \n        # Loop through the array and add the elements to the set\n        for num in nums:\n            unique_nums.add(num)\n        \n        # If the length of the set is less than or equal to 2, return the maximum element\n        if len(unique_nums) <= 2:\n            return max(unique_nums)\n        \n        # If the length of the set is greater than 2, return the third maximum element\n        else:\n            # Sort the set in descending order\n            sorted_unique_nums = sorted(unique_nums, reverse=True)\n            \n            # Return the third maximum element\n            return sorted_unique_nums[2]"
        },
        {
            "task_id": "third-maximum-number",
            "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a set to store the unique elements\n        unique_nums = set()\n        \n        # Loop through the array and add the elements to the set\n        for num in nums:\n            unique_nums.add(num)\n        \n        # If the length of the set is less than or equal to 2, return the maximum element\n        if len(unique_nums) <= 2:\n            return max(unique_nums)\n        \n        # If the length of the set is greater than 2, return the third maximum\n        else:\n            # Sort the set in descending order\n            sorted_unique_nums = sorted(unique_nums, reverse=True)\n            \n            # Return the third maximum\n            return sorted_unique_nums[2]"
        },
        {
            "task_id": "third-maximum-number",
            "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a set to store the unique elements\n        unique_nums = set()\n        \n        # Add elements to the set\n        for num in nums:\n            unique_nums.add(num)\n        \n        # If the length of the set is less than or equal to 2, return the maximum element\n        if len(unique_nums) <= 2:\n            return max(unique_nums)\n        \n        # If the length of the set is greater than 2, return the third maximum element\n        else:\n            # Sort the set in descending order\n            sorted_unique_nums = sorted(unique_nums, reverse=True)\n            \n            # Return the third maximum element\n            return sorted_unique_nums[2]"
        },
        {
            "task_id": "third-maximum-number",
            "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a set to store the unique elements\n        unique_nums = set()\n        \n        # Loop through the array and add the elements to the set\n        for num in nums:\n            unique_nums.add(num)\n        \n        # If the length of the set is less than or equal to 2, return the maximum element\n        if len(unique_nums) <= 2:\n            return max(unique_nums)\n        \n        # If the length of the set is greater than 2, return the third maximum\n        else:\n            # Sort the set in descending order\n            sorted_unique_nums = sorted(unique_nums, reverse=True)\n            \n            # Return the third maximum\n            return sorted_unique_nums[2]"
        },
        {
            "task_id": "third-maximum-number",
            "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a set to store the unique elements\n        unique_nums = set()\n        \n        # Add elements to the set\n        for num in nums:\n            unique_nums.add(num)\n        \n        # If the length of the set is less than or equal to 2, return the maximum element\n        if len(unique_nums) <= 2:\n            return max(unique_nums)\n        \n        # If the length of the set is greater than 2, return the third maximum\n        else:\n            # Sort the set in descending order\n            sorted_unique_nums = sorted(unique_nums, reverse=True)\n            \n            # Return the third maximum\n            return sorted_unique_nums[2]"
        }
    ]
}