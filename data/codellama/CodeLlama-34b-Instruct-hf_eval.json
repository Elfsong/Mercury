{"spiral-matrix": [{"slug_name": "spiral-matrix", "status": {"result": "passed", "runtime": 0.0002944469451904297, "index": 0}, "solution": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1\n        res = []\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n                \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n                \n        return res", "runtimes": [0.0002796649932861328, 0.0002880096435546875, 0.0002903938293457031, 0.00029349327087402344, 0.0002970695495605469, 0.0002980232238769531, 0.0002982616424560547, 0.0002987384796142578, 0.0003020763397216797, 0.0003020763397216797, 0.00033593177795410156, 0.0003571510314941406, 0.0003592967987060547, 0.00045680999755859375], "beyond_p": 0.9165545087483177}], "summary-ranges": [{"slug_name": "summary-ranges", "status": {"result": "passed", "runtime": 0.00028395652770996094, "index": 0}, "solution": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + '->' + str(end))\n                start = nums[i]\n                end = nums[i]\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + '->' + str(end))\n        return res", "runtimes": [0.0002722740173339844, 0.00028705596923828125, 0.0002887248992919922, 0.0002894401550292969, 0.00029277801513671875, 0.00029397010803222656, 0.00029468536376953125, 0.00029587745666503906, 0.0002963542938232422, 0.00029730796813964844, 0.0002987384796142578, 0.00030231475830078125, 0.0003058910369873047, 0.00030612945556640625, 0.0003421306610107422], "beyond_p": 0.8327645051194539}], "distinct-subsequences": [{"slug_name": "distinct-subsequences", "status": {"result": "passed", "runtime": 0.061532020568847656, "index": 0}, "solution": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for i in range(len(t)+1)] for j in range(len(s)+1)]\n        \n        for i in range(len(s)+1):\n            dp[i][0] = 1\n            \n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j]\n                    \n        return dp[len(s)][len(t)]", "runtimes": [0.004652738571166992, 0.005010366439819336, 0.007359504699707031, 0.007396221160888672, 0.008363485336303711, 0.009034156799316406, 0.009257316589355469, 0.009613990783691406, 0.00962376594543457, 0.009716987609863281, 0.009794235229492188, 0.009852886199951172, 0.009932756423950195, 0.010785102844238281, 0.012690305709838867, 0.022944927215576172, 0.029244422912597656, 0.032041311264038086, 0.046701669692993164, 0.04725813865661621, 0.05454230308532715, 0.05454254150390625, 0.05486416816711426, 0.05495715141296387, 0.05503988265991211, 0.06124472618103027, 0.07453703880310059, 0.12095093727111816, 0.12178301811218262, 0.1305370330810547], "beyond_p": 0.5481622054670765}], "first-missing-positive": [{"slug_name": "first-missing-positive", "status": {"result": "failed@cases", "runtime": 0.001146554946899414, "index": 0}, "solution": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Check if the first element is not 1\n        if nums[0] != 1:\n            return 1\n        \n        # 3. Check if the last element is not equal to the length of the array\n        if nums[-1] != len(nums):\n            return len(nums)\n        \n        # 4. Check if the array is sorted\n        for i in range(1, len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        # 5. If the array is sorted and the last element is equal to the length of the array, return the length of the array + 1\n        return len(nums) + 1", "runtimes": [0.0006895065307617188, 0.0008592605590820312, 0.0008790493011474609, 0.0008993148803710938, 0.0009083747863769531, 0.0009403228759765625, 0.0009815692901611328, 0.0009851455688476562, 0.0010046958923339844, 0.0010383129119873047, 0.0010933876037597656, 0.0011224746704101562, 0.001192331314086914, 0.0014185905456542969, 0.0014188289642333984, 0.001573801040649414, 0.0016138553619384766, 0.002307415008544922, 0.002764463424682617, 0.00878143310546875], "beyond_p": 0.0}], "permutation-sequence": [{"slug_name": "permutation-sequence", "status": {"result": "failed@cases", "runtime": 0.0003261566162109375, "index": 0}, "solution": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        def factorial(n):\n            if n == 0:\n                return 1\n            else:\n                return n * factorial(n-1)\n        \n        def get_permutation(n, k):\n            if n == 1:\n                return '1'\n            else:\n                f = factorial(n-1)\n                index = (k-1) // f\n                digit = str(index+1)\n                rest = k - index * f\n                return digit + get_permutation(n-1, rest)\n        \n        return get_permutation(n, k)", "runtimes": [0.00038623809814453125, 0.02053046226501465, 0.022593975067138672, 0.033556461334228516, 0.03867745399475098, 0.05720710754394531, 0.05841541290283203, 0.06991434097290039, 0.07266020774841309, 0.12587237358093262, 0.21768569946289062, 0.21859073638916016, 0.2306385040283203, 0.23481965065002441, 0.2577476501464844, 0.2624392509460449, 0.34875941276550293, 0.46038341522216797, 0.46381688117980957, 0.4740414619445801], "beyond_p": 0.0}], "two-sum-ii-input-array-is-sorted": [{"slug_name": "two-sum-ii-input-array-is-sorted", "status": {"result": "passed", "runtime": 0.0002956390380859375, "index": 0}, "solution": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize two pointers\n        left = 0\n        right = len(numbers) - 1\n        \n        # Loop until the pointers meet\n        while left < right:\n            \n            # Sum of the two elements at the pointers\n            current_sum = numbers[left] + numbers[right]\n            \n            # If the sum is equal to the target\n            if current_sum == target:\n                \n                # Return the indices of the elements\n                return [left + 1, right + 1]\n            \n            # If the sum is less than the target\n            elif current_sum < target:\n                \n                # Increment the left pointer\n                left += 1\n            \n            # If the sum is greater than the target\n            else:\n                \n                # Decrement the right pointer\n                right -= 1", "runtimes": [0.00029158592224121094, 0.000293731689453125, 0.00029778480529785156, 0.0003006458282470703, 0.0003006458282470703, 0.0003008842468261719, 0.000301361083984375, 0.0003025531768798828, 0.0003027915954589844, 0.0003037452697753906, 0.0003046989440917969, 0.00030541419982910156, 0.000308990478515625, 0.0003120899200439453, 0.00031495094299316406, 0.00031566619873046875, 0.0003399848937988281, 0.0003566741943359375, 0.0003743171691894531, 0.0004870891571044922], "beyond_p": 0.9792682926829268}], "expression-add-operators": [{"slug_name": "expression-add-operators", "status": {"result": "failed@cases", "runtime": 0.38621020317077637, "index": 0}, "solution": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, prev, res, path, idx):\n            if idx == len(num):\n                if prev == target:\n                    res.append(path)\n                return\n            \n            for i in range(idx, len(num)):\n                if i != idx and num[idx] == '0':\n                    break\n                val = int(num[idx:i+1])\n                if idx == 0:\n                    dfs(num, target, val, res, str(val), i+1)\n                else:\n                    dfs(num, target, prev+val, res, path + '+' + str(val), i+1)\n                    dfs(num, target, prev-val, res, path + '-' + str(val), i+1)\n                    dfs(num, target, prev*val, res, path + '*' + str(val), i+1)\n        \n        res = []\n        dfs(num, target, 0, res, \"\", 0)\n        return res", "runtimes": [1.7363803386688232, 4.516078948974609, 4.632242202758789], "beyond_p": 0.0}], "sum-root-to-leaf-numbers": [{"slug_name": "sum-root-to-leaf-numbers", "status": {"result": "passed", "runtime": 0.0003132820129394531, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return self.sumNumbersHelper(root, 0)\n        \n    def sumNumbersHelper(self, root, curr_sum):\n        if root is None:\n            return 0\n        \n        curr_sum = curr_sum * 10 + root.val\n        \n        if root.left is None and root.right is None:\n            return curr_sum\n        \n        return self.sumNumbersHelper(root.left, curr_sum) + self.sumNumbersHelper(root.right, curr_sum)", "runtimes": [0.0003097057342529297, 0.0003101825714111328, 0.00031113624572753906, 0.0003120899200439453, 0.0003147125244140625, 0.0003154277801513672, 0.00031685829162597656, 0.0003199577331542969, 0.00032401084899902344, 0.0003292560577392578, 0.00033164024353027344, 0.0003478527069091797, 0.0003612041473388672, 0.0005195140838623047, 0.0006833076477050781, 0.0006928443908691406], "beyond_p": 0.9906658369632856}], "license-key-formatting": [{"slug_name": "license-key-formatting", "status": {"result": "failed@cases", "runtime": 0.001085042953491211, "index": 0}, "solution": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s = \"\".join(s)\n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = list(s)\n        s.reverse()\n        s", "runtimes": [0.00030112266540527344, 0.0003032684326171875, 0.00030350685119628906, 0.0003066062927246094, 0.0005967617034912109, 0.0006401538848876953, 0.0006506443023681641, 0.0006899833679199219, 0.0007157325744628906, 0.0007505416870117188, 0.0007677078247070312, 0.0007748603820800781, 0.0007796287536621094, 0.0007989406585693359, 0.0008082389831542969, 0.0008232593536376953, 0.0008640289306640625, 0.0008826255798339844, 0.0009391307830810547, 0.0010190010070800781, 0.001352071762084961], "beyond_p": 0.0}], "gas-station": [{"slug_name": "gas-station", "status": {"result": "passed", "runtime": 0.0005691051483154297, "index": 0}, "solution": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        total_tank = 0\n        curr_tank = 0\n        starting_index = 0\n        \n        # Iterate through the list\n        for i in range(len(gas)):\n            total_tank += gas[i] - cost[i]\n            curr_tank += gas[i] - cost[i]\n            \n            # If the current tank dips below 0, then we need to reset the starting index\n            if curr_tank < 0:\n                starting_index = i + 1\n                curr_tank = 0\n                \n        # If the total tank is less than 0, then we cannot travel around the circuit\n        if total_tank < 0:\n            return -1\n        else:\n            return starting_index", "runtimes": [0.000316619873046875, 0.00031757354736328125, 0.0003178119659423828, 0.00032138824462890625, 0.00032591819763183594, 0.0003273487091064453, 0.0003287792205810547, 0.0003292560577392578, 0.00033164024353027344, 0.0003407001495361328, 0.00047588348388671875, 0.0004787445068359375, 0.00048613548278808594, 0.0005135536193847656, 0.0005474090576171875, 0.0005543231964111328, 0.0005743503570556641, 0.0005910396575927734, 0.0006575584411621094, 0.0007364749908447266, 0.0007977485656738281, 0.0009317398071289062, 0.0009903907775878906, 0.0014770030975341797, 0.0023496150970458984], "beyond_p": 0.8758062624604198}], "burst-balloons": [{"slug_name": "burst-balloons", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + [0] + nums\n        n = len(nums)\n        dp = [[0] * (n) for _ in range(n)]\n        \n        for i in range(2, n):\n            for left in range(n - i, -1, -1):\n                right = left + i\n                for k in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right], dp[left][k] + dp[k][right] + nums[left] * nums[k] * nums[right])\n                    \n        return dp[0][n - 1]", "runtimes": [0.5744912624359131, 0.5746965408325195, 0.7400398254394531, 0.7418763637542725, 1.2807047367095947, 1.3103604316711426, 1.5134119987487793, 1.5561540126800537, 1.5722079277038574, 1.6249451637268066, 1.7818219661712646, 1.8348808288574219, 2.0824079513549805, 2.235368490219116, 2.397188663482666, 2.4729743003845215, 2.6599059104919434, 2.7647206783294678, 2.8394711017608643, 2.8578929901123047, 2.95796275138855, 3.1966564655303955, 3.3984291553497314, 3.4539437294006348, 3.5124404430389404, 3.5387444496154785], "beyond_p": 0.0}], "plus-one": [{"slug_name": "plus-one", "status": {"result": "passed", "runtime": 0.00037217140197753906, "index": 0}, "solution": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Convert the list to a string\n        num = ''.join(map(str, digits))\n        \n        # Convert the string to an integer\n        num = int(num)\n        \n        # Increment the integer by 1\n        num += 1\n        \n        # Convert the integer to a string\n        num = str(num)\n        \n        # Convert the string to a list\n        num = list(map(int, num))\n        \n        return num", "runtimes": [0.0002675056457519531, 0.0002703666687011719, 0.0002713203430175781, 0.00027179718017578125, 0.00027251243591308594, 0.00027441978454589844, 0.0003533363342285156, 0.0003540515899658203, 0.0003814697265625, 0.0003840923309326172, 0.0003845691680908203, 0.00039577484130859375, 0.0004107952117919922, 0.0004222393035888672], "beyond_p": 0.3235747303543914}], "regular-expression-matching": [{"slug_name": "regular-expression-matching", "status": {"result": "passed", "runtime": 0.00042819976806640625, "index": 0}, "solution": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i][j] represents whether s[:i] matches p[:j]\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(p) + 1):\n            if p[i - 1] == '*':\n                dp[0][i] = dp[0][i - 2]\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.')\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1])\n        \n        return dp[-1][-1]", "runtimes": [0.0002777576446533203, 0.00028443336486816406, 0.00028586387634277344, 0.0002865791320800781, 0.0003020763397216797, 0.0003082752227783203, 0.0004425048828125, 0.0004456043243408203, 0.00045108795166015625, 0.00047326087951660156, 0.0005047321319580078, 0.00081634521484375, 0.0008625984191894531, 0.0009527206420898438, 0.000985860824584961, 0.001264810562133789], "beyond_p": 0.8475845410628019}], "create-maximum-number": [{"slug_name": "create-maximum-number", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def compare(a, b):\n            return [int(x) for x in str(int(a)) + str(int(b))]\n        \n        def max_merge(nums1, nums2, k):\n            res = []\n            for i in range(k):\n                a = nums1[i] if i < len(nums1) else 0\n                b = nums2[i] if i < len(nums2) else 0\n                res = compare(a, b) + res\n            return res\n        \n        def merge(nums1, nums2, k):\n            res = []\n            for i in range(k):\n                a = nums1[i] if i < len(nums1) else 0\n                b = nums2[i] if i < len(nums2) else 0\n                res.append(max(a, b))\n            return res\n        \n        def max_merge_k(nums1, nums2, k):\n            if len(nums1) + len(nums2) < k:\n                return []\n            if len(nums1) == 0:\n                return nums2[:k]\n            if len(nums2) == 0:\n                return nums1[:k]\n            for i in range(k, -1, -1):\n                merged = merge(nums1, nums2, i)\n                if merged == max_merge(nums1, nums2, i):\n                    return merged\n        \n        max_nums1 = []\n        for i in range(len(nums1)):\n            merged = max_merge_k(nums1[i:], nums2, k - i)\n            if merged:\n                max_nums1.append(merged)\n        \n        max_nums2 = []\n        for i in range(len(nums2)):\n            merged = max_merge_k(nums1, nums2[i:], k - i)\n            if merged:\n                max_nums2.append(merged)\n        \n        max_nums1 = max(max_nums1, key=lambda x: (str(x)[::-1]))\n        max_nums2 = max(max_nums2, key=lambda x: (str(x)[::-1]))\n        return max(max_nums1, max_nums2) if max_nums1 and max_nums2 else max_nums1 or max_nums2", "runtimes": [0.0004086494445800781, 0.0004107952117919922, 0.0004227161407470703, 0.0004265308380126953, 0.00043463706970214844, 0.0004398822784423828, 0.0004410743713378906, 0.0005042552947998047, 0.0005130767822265625, 0.0005528926849365234, 0.0005991458892822266, 0.0006442070007324219, 0.0007259845733642578, 0.0007390975952148438], "beyond_p": 0.0}], "perfect-number": [{"slug_name": "perfect-number", "status": {"result": "passed", "runtime": 0.0018489360809326172, "index": 0}, "solution": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = []\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if i * i != num:\n                    divisors.append(num // i)\n        \n        return sum(divisors) - num == num", "runtimes": [0.0018622875213623047, 0.010389566421508789, 1.0393071174621582, 1.0491738319396973, 1.0630459785461426, 1.5793719291687012, 1.9377756118774414, 2.581012010574341, 4.27493691444397, 4.3029656410217285, 4.310676097869873, 4.359498023986816, 4.554141998291016, 6.170315504074097, 6.263869047164917], "beyond_p": 0.15969321630961028}], "fibonacci-number": [{"slug_name": "fibonacci-number", "status": {"result": "passed", "runtime": 0.11706829071044922, "index": 0}, "solution": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n-1) + self.fib(n-2)", "runtimes": [0.00027489662170410156, 0.0002770423889160156, 0.0002803802490234375, 0.00028777122497558594, 0.0004894733428955078, 0.0005183219909667969, 0.0006456375122070312, 0.04910564422607422, 0.07369565963745117, 0.07378101348876953, 0.08138513565063477, 0.08324933052062988, 0.10401463508605957, 0.1048574447631836, 0.10523748397827148, 0.11426377296447754, 0.11523127555847168, 0.11525559425354004, 0.11705756187438965, 0.11706423759460449, 0.11727762222290039, 0.11730217933654785, 0.11762285232543945, 0.12474393844604492, 0.1600174903869629], "beyond_p": 0.2688650450964091}], "dungeon-game": [{"slug_name": "dungeon-game", "status": {"result": "failed@cases", "runtime": 0.0004010200500488281, "index": 0}, "solution": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        \n        dp[m][n-1] = 1\n        dp[m-1][n] = 1\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j])\n                \n        return dp[0][0]", "runtimes": [0.0003998279571533203, 0.0004048347473144531, 0.00040602684020996094, 0.00040721893310546875, 0.0004115104675292969, 0.0004143714904785156, 0.00045609474182128906, 0.0005106925964355469, 0.0005249977111816406, 0.0006916522979736328, 0.0007619857788085938, 0.0008199214935302734, 0.0008380413055419922, 0.0009307861328125, 0.0024526119232177734, 0.0024580955505371094, 0.002540111541748047, 0.0029916763305664062, 0.003403902053833008, 0.0035796165466308594], "beyond_p": 0.0}], "find-k-th-smallest-pair-distance": [{"slug_name": "find-k-th-smallest-pair-distance", "status": {"result": "failed@cases", "runtime": 0.00038433074951171875, "index": 0}, "solution": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        d = [nums[i+1] - nums[i] for i in range(n-1)]\n        d.append(10**6)\n        d = sorted(d)\n        for i in range(k):\n            if d[i] >= nums[i+1] - nums[i]:\n                return i\n        return k-1", "runtimes": [0.0013141632080078125, 0.001314401626586914, 0.001318216323852539, 0.0013360977172851562, 0.0013506412506103516, 0.0015332698822021484, 0.0015761852264404297, 0.0016257762908935547, 0.0016469955444335938, 0.001794576644897461, 0.0018167495727539062, 0.0019326210021972656, 0.002008199691772461, 0.0025565624237060547, 0.0026204586029052734, 0.0026543140411376953, 0.002659320831298828, 0.0026748180389404297, 0.0029516220092773438], "beyond_p": 0.0}], "number-of-segments-in-a-string": [{"slug_name": "number-of-segments-in-a-string", "status": {"result": "passed", "runtime": 0.0002562999725341797, "index": 0}, "solution": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # split the string by space\n        # and count the number of non-empty strings\n        return len(list(filter(None, s.split(' '))))", "runtimes": [0.0002391338348388672, 0.00024008750915527344, 0.0002422332763671875, 0.00024366378784179688, 0.00024437904357910156, 0.0002503395080566406, 0.0002601146697998047, 0.0003070831298828125, 0.0003540515899658203], "beyond_p": 0.8506224066390041}], "reverse-vowels-of-a-string": [{"slug_name": "reverse-vowels-of-a-string", "status": {"result": "passed", "runtime": 0.0014805793762207031, "index": 0}, "solution": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u']\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i].lower() in vowels:\n                if s[j].lower() in vowels:\n                    s[i], s[j] = s[j], s[i]\n                    i += 1\n                    j -= 1\n                else:\n                    j -= 1\n            else:\n                i += 1\n        return ''.join(s)", "runtimes": [0.0007703304290771484, 0.0008068084716796875, 0.0008723735809326172, 0.0009174346923828125, 0.0009489059448242188, 0.0009529590606689453, 0.0009827613830566406, 0.0011563301086425781, 0.0011887550354003906, 0.0012443065643310547, 0.0012497901916503906, 0.001268625259399414, 0.0014688968658447266, 0.001798391342163086, 0.0018544197082519531, 0.0020241737365722656, 0.0020780563354492188, 0.002089977264404297, 0.002300739288330078, 0.002366781234741211, 0.002942323684692383, 0.003380298614501953, 0.0037152767181396484, 0.003902912139892578], "beyond_p": 0.7732704163178324}], "longest-consecutive-sequence": [{"slug_name": "longest-consecutive-sequence", "status": {"result": "passed", "runtime": 0.0008113384246826172, "index": 0}, "solution": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # create a set of nums\n        nums_set = set(nums)\n        max_len = 0\n        \n        # loop through each number in nums\n        for num in nums_set:\n            \n            # if num-1 not in nums_set, then it is the start of a sequence\n            if num-1 not in nums_set:\n                \n                # set current_num to num\n                current_num = num\n                \n                # loop until current_num+1 not in nums_set\n                while current_num+1 in nums_set:\n                    current_num += 1\n                \n                # update max_len\n                max_len = max(max_len, current_num-num+1)\n                \n        return max_len", "runtimes": [0.0006508827209472656, 0.0007619857788085938, 0.0007739067077636719, 0.0007767677307128906, 0.0007865428924560547, 0.0007953643798828125, 0.0008139610290527344, 0.0008330345153808594, 0.0008358955383300781, 0.0008387565612792969, 0.0008718967437744141, 0.0008797645568847656, 0.000885009765625, 0.0008873939514160156, 0.0009486675262451172, 0.0010247230529785156, 0.0010585784912109375, 0.0011668205261230469, 0.0012390613555908203, 0.0012881755828857422, 0.0015382766723632812, 0.00165557861328125, 0.002795696258544922], "beyond_p": 0.9251889728768341}], "missing-number": [{"slug_name": "missing-number", "status": {"result": "passed", "runtime": 0.0002963542938232422, "index": 0}, "solution": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all numbers from 0 to n\n        # XOR of all numbers in the array\n        # The result will be the missing number\n        \n        n = len(nums)\n        total = 0\n        for i in range(n+1):\n            total ^= i\n            \n        for i in nums:\n            total ^= i\n            \n        return total", "runtimes": [0.00026488304138183594, 0.0002651214599609375, 0.00026869773864746094, 0.0002701282501220703, 0.00027179718017578125, 0.0002734661102294922, 0.00027680397033691406, 0.00028324127197265625, 0.0002849102020263672, 0.0002849102020263672, 0.00028967857360839844, 0.0002906322479248047, 0.0002913475036621094, 0.00029277801513671875, 0.0002932548522949219, 0.00029540061950683594, 0.0003056526184082031, 0.00030994415283203125, 0.0003147125244140625, 0.0005676746368408203], "beyond_p": 0.8960629921259843}], "word-ladder": [{"slug_name": "word-ladder", "status": {"result": "failed@cases", "runtime": 0.00292205810546875, "index": 0}, "solution": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        queue = collections.deque([beginWord])\n        wordList = set(wordList)\n        wordList.add(endWord)\n        distance = 0\n        \n        while queue:\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                if word == endWord:\n                    return distance + 1\n                for i in range(len(word)):\n                    for c in string.ascii_lowercase:\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in wordList:\n                            queue.append(new_word)\n                            wordList.remove(new_word)\n            distance += 1\n        return 0", "runtimes": [0.00025582313537597656, 0.0002799034118652344, 0.00028514862060546875, 0.00028777122497558594, 0.0003032684326171875, 0.0003173351287841797, 0.00032901763916015625, 0.000339508056640625, 0.0003476142883300781, 0.0004165172576904297, 0.0004417896270751953, 0.0004475116729736328, 0.0004878044128417969, 0.0007801055908203125, 0.0013644695281982422, 0.0013918876647949219, 0.001424551010131836, 0.0015308856964111328, 0.0015544891357421875, 0.0018849372863769531, 0.001998424530029297, 0.0023195743560791016, 0.004637241363525391], "beyond_p": 0.0}], "add-binary": [{"slug_name": "add-binary", "status": {"result": "passed", "runtime": 0.000263214111328125, "index": 0}, "solution": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # Convert the binary strings to integers\n        a_int = int(a, 2)\n        b_int = int(b, 2)\n        \n        # Add the integers\n        sum_int = a_int + b_int\n        \n        # Convert the sum back to a binary string\n        return bin(sum_int)[2:]", "runtimes": [0.00025391578674316406, 0.0002579689025878906, 0.00026035308837890625, 0.00026702880859375, 0.00102996826171875, 0.0012238025665283203, 0.001973390579223633, 0.00199127197265625, 0.00199127197265625, 0.0032262802124023438], "beyond_p": 0.9968717413972888}], "find-first-and-last-position-of-element-in-sorted-array": [{"slug_name": "find-first-and-last-position-of-element-in-sorted-array", "status": {"result": "passed", "runtime": 0.0002796649932861328, "index": 0}, "solution": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [-1, -1]\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                break\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if left > right or nums[mid] != target:\n            return [-1, -1]\n        left = mid\n        right = mid\n        while left - 1 >= 0 and nums[left - 1] == target:\n            left -= 1\n        while right + 1 < len(nums) and nums[right + 1] == target:\n            right += 1\n        return [left, right]", "runtimes": [0.0002739429473876953, 0.0002815723419189453, 0.00028443336486816406, 0.0002853870391845703, 0.00028586387634277344, 0.0002872943878173828, 0.0002875328063964844, 0.00028824806213378906, 0.0002894401550292969, 0.0002913475036621094, 0.00029158592224121094, 0.0002918243408203125, 0.00029206275939941406, 0.0002925395965576172, 0.00029277801513671875, 0.0002932548522949219, 0.000293731689453125, 0.00029730796813964844, 0.00030040740966796875, 0.0003056526184082031, 0.0006325244903564453], "beyond_p": 0.9840425531914894}], "remove-duplicates-from-sorted-array": [{"slug_name": "remove-duplicates-from-sorted-array", "status": {"result": "passed", "runtime": 0.0008327960968017578, "index": 0}, "solution": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        else:\n            i = 0\n            while i < len(nums) - 1:\n                if nums[i] == nums[i + 1]:\n                    nums.pop(i + 1)\n                else:\n                    i += 1\n            return len(nums)", "runtimes": [0.0003695487976074219, 0.0004839897155761719, 0.0005567073822021484, 0.0005717277526855469, 0.0006127357482910156, 0.0006492137908935547, 0.0006723403930664062, 0.0007042884826660156, 0.0007717609405517578, 0.0007746219635009766, 0.0008058547973632812, 0.0008103847503662109, 0.0011649131774902344], "beyond_p": 0.41756594724220625}], "jump-game-ii": [{"slug_name": "jump-game-ii", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        n = len(nums)\n        jumps = 0\n        max_reach = 0\n        i = 0\n        \n        # Iterate through the array\n        while i < n-1:\n            jumps += 1\n            max_reach = max(max_reach, i+nums[i])\n            if i == max_reach:\n                return -1\n            while i <= max_reach and i+1 <= n-1 and nums[i] == 0:\n                i += 1\n        return jumps", "runtimes": [0.00024008750915527344, 0.0002944469451904297, 0.0003066062927246094, 0.00030994415283203125, 0.00032782554626464844, 0.00034046173095703125, 0.0003695487976074219, 0.00040721893310546875, 0.0004131793975830078, 0.0006468296051025391, 0.0027866363525390625, 0.0028924942016601562, 0.0032176971435546875, 0.003460407257080078, 0.0035314559936523438, 0.003607511520385742, 0.007016658782958984, 0.011564970016479492, 0.011889219284057617, 0.017878293991088867, 0.02003645896911621, 0.048575639724731445, 0.055620670318603516, 0.07206416130065918], "beyond_p": 0.0}], "best-time-to-buy-and-sell-stock-iv": [{"slug_name": "best-time-to-buy-and-sell-stock-iv", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        n = len(prices)\n        if k >= n//2:\n            return sum(max(prices[i+1:]-prices[i]) for i in range(n-1))\n        \n        dp = [[0]*(k+1) for _ in range(n)]\n        for i in range(1, n):\n            for j in range(1, k+1):\n                dp[i][j] = max(dp[i-1][j-1] + prices[i] - prices[i-1], dp[i-1][j] + max(prices[i] - prices[i-1], 0))\n        return dp[-1][-1]", "runtimes": [0.0011365413665771484, 0.02014756202697754, 0.05208754539489746, 0.05863547325134277, 0.06128978729248047, 0.0659024715423584, 0.06975412368774414, 0.07254433631896973, 0.08744168281555176, 0.08770060539245605, 0.10091161727905273, 0.1384575366973877, 0.14734959602355957, 0.14925479888916016, 0.19536614418029785, 0.20026612281799316, 0.21497488021850586, 0.21715044975280762, 0.2297191619873047, 0.24842429161071777, 0.27195215225219727, 0.2839019298553467, 0.4045717716217041], "beyond_p": 0.0}], "convert-a-number-to-hexadecimal": [{"slug_name": "convert-a-number-to-hexadecimal", "status": {"result": "passed", "runtime": 0.0003108978271484375, "index": 0}, "solution": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            num = 2**32 + num\n        hex_string = \"\"\n        hex_digits = \"0123456789abcdef\"\n        while num > 0:\n            hex_string = hex_digits[num % 16] + hex_string\n            num //= 16\n        return hex_string", "runtimes": [0.00024080276489257812, 0.00024318695068359375, 0.000247955322265625, 0.0002484321594238281, 0.00025010108947753906, 0.0002510547637939453, 0.0002512931823730469, 0.00025343894958496094, 0.00025391578674316406, 0.0002541542053222656, 0.0002543926239013672, 0.0002560615539550781, 0.0002574920654296875, 0.0002598762512207031, 0.00026035308837890625, 0.0002608299255371094, 0.00026607513427734375, 0.0002694129943847656, 0.0003058910369873047, 0.00041413307189941406], "beyond_p": 0.5955983493810179}], "first-unique-character-in-a-string": [{"slug_name": "first-unique-character-in-a-string", "status": {"result": "passed", "runtime": 0.0007715225219726562, "index": 0}, "solution": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the count of each character\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 1\n            else:\n                char_count[char] += 1\n        \n        # Iterate through the string and find the first character with count 1\n        for i in range(len(s)):\n            if char_count[s[i]] == 1:\n                return i\n        \n        # If no character with count 1 is found, return -1\n        return -1", "runtimes": [0.0004570484161376953, 0.0013153553009033203, 0.0015747547149658203, 0.002015829086303711, 0.002025127410888672, 0.002027273178100586, 0.0020384788513183594, 0.002089977264404297, 0.002094745635986328, 0.0020983219146728516, 0.0020990371704101562, 0.002106904983520508, 0.0021219253540039062, 0.002136707305908203, 0.0035507678985595703, 0.003819704055786133, 0.0050411224365234375, 0.006208181381225586, 0.006268978118896484, 0.018983125686645508, 0.0207974910736084], "beyond_p": 0.9845394659727594}], "contains-duplicate-iii": [{"slug_name": "contains-duplicate-iii", "status": {"result": "passed", "runtime": 0.0002906322479248047, "index": 0}, "solution": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0 or len(nums) == 1:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n                    return True\n        return False", "runtimes": [0.0002715587615966797, 0.00027823448181152344, 0.0002810955047607422, 0.00028395652770996094, 0.0003540515899658203, 0.000423431396484375, 0.0004782676696777344, 0.0004966259002685547, 0.0005030632019042969, 0.0011837482452392578, 0.0012319087982177734], "beyond_p": 0.9801390268123138}], "sort-colors": [{"slug_name": "sort-colors", "status": {"result": "failed@cases", "runtime": 0.00024056434631347656, "index": 0}, "solution": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,", "runtimes": [0.00028324127197265625, 0.0003006458282470703, 0.00031638145446777344, 0.0003333091735839844, 0.0003361701965332031, 0.0003380775451660156, 0.0003428459167480469, 0.00034737586975097656, 0.0003592967987060547, 0.0003643035888671875, 0.00036978721618652344, 0.00037097930908203125, 0.0004184246063232422, 0.0017812252044677734, 0.0019445419311523438, 0.002221345901489258, 0.014922380447387695], "beyond_p": 0.0}], "max-consecutive-ones": [{"slug_name": "max-consecutive-ones", "status": {"result": "passed", "runtime": 0.0006730556488037109, "index": 0}, "solution": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        max_count = 0\n        \n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            else:\n                max_count = max(max_count, count)\n                count = 0\n                \n        return max(max_count, count)", "runtimes": [0.0003452301025390625, 0.00034809112548828125, 0.0003788471221923828, 0.0004134178161621094, 0.00041794776916503906, 0.00044274330139160156, 0.0005278587341308594, 0.0005660057067871094, 0.00058746337890625, 0.0006947517395019531, 0.0007143020629882812, 0.0007560253143310547, 0.0007715225219726562, 0.0007781982421875, 0.0007841587066650391, 0.0008404254913330078, 0.0008478164672851562, 0.0009007453918457031, 0.0010864734649658203], "beyond_p": 0.5577356063042779}], "count-complete-tree-nodes": [{"slug_name": "count-complete-tree-nodes", "status": {"result": "passed", "runtime": 0.0003619194030761719, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)", "runtimes": [0.0003345012664794922, 0.00033473968505859375, 0.00033736228942871094, 0.0003376007080078125, 0.00034308433532714844, 0.00034332275390625, 0.00034546852111816406, 0.00034618377685546875, 0.0003464221954345703, 0.0003476142883300781, 0.00034928321838378906, 0.0003533363342285156, 0.00035500526428222656, 0.00036644935607910156, 0.00036787986755371094, 0.00037169456481933594, 0.00037598609924316406, 0.00039887428283691406, 0.0004057884216308594, 0.0004291534423828125], "beyond_p": 0.7103274559193955}], "add-strings": [{"slug_name": "add-strings", "status": {"result": "failed@cases", "runtime": 0.0020759105682373047, "index": 0}, "solution": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the carry\n        carry = 0\n        \n        # Initialize the result\n        result = \"\"\n        \n        # Traverse both strings\n        for i in range(max(len(num1), len(num2))):\n            \n            # Calculate the sum of the two digits\n            # and add the carry\n            sum = carry\n            if i < len(num1):\n                sum += int(num1[i])\n            if i < len(num2):\n                sum += int(num2[i])\n                \n            # Calculate the carry\n            carry = sum // 10\n            \n            # Calculate the current digit\n            sum = sum % 10\n            \n            # Append the current digit to the result\n            result += str(sum)\n            \n        # If there is still a carry\n        # append it to the result\n        if carry:\n            result += str(carry)\n            \n        return result[::-1]", "runtimes": [0.00034427642822265625, 0.0003590583801269531, 0.00036144256591796875, 0.0015544891357421875, 0.0016140937805175781, 0.0018572807312011719, 0.001886129379272461, 0.0019145011901855469, 0.001928091049194336, 0.0019447803497314453, 0.0019898414611816406, 0.0019989013671875, 0.0020194053649902344, 0.002096891403198242, 0.002175569534301758, 0.0024175643920898438, 0.0026204586029052734, 0.0036525726318359375], "beyond_p": 0.0}], "basic-calculator": [{"slug_name": "basic-calculator", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = 1 if s[i] == '+' else -1\n            elif s[i] == '(':\n                stack.append(num)\n                stack.append(sign)\n                num = 0\n                sign = 1\n            elif s[i] == ')':\n                num *= sign\n                stack.append(num)\n                num = 0\n                sign = stack.pop()\n                num = sum(stack.pop() for _ in range(stack.pop()))\n        num *= sign\n        stack.append(num)\n        return sum(stack.pop() for _ in range(len(stack)))", "runtimes": [0.00032830238342285156, 0.0003323554992675781, 0.00034046173095703125, 0.0003409385681152344, 0.00035262107849121094, 0.00035572052001953125, 0.00036835670471191406, 0.0003712177276611328, 0.0004057884216308594, 0.0004138946533203125, 0.0004253387451171875, 0.00043082237243652344, 0.00043511390686035156, 0.00044727325439453125, 0.00044918060302734375, 0.00045013427734375, 0.0004956722259521484, 0.0004978179931640625, 0.000499725341796875, 0.0005004405975341797, 0.0009665489196777344], "beyond_p": 0.0}], "ipo": [{"slug_name": "ipo", "status": {"result": "failed@cases", "runtime": 0.0015900135040283203, "index": 0}, "solution": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the projects by capital\n        projects = sorted(zip(capital, profits))\n        \n        # Initialize the max heap\n        heap = []\n        \n        # Initialize the total capital\n        total = w\n        \n        # Initialize the number of projects\n        count = 0\n        \n        # Loop through the projects\n        for i in range(len(projects)):\n            \n            # If the current project is feasible\n            if projects[i][0] <= total:\n                \n                # Add the project to the heap\n                heapq.heappush(heap, -projects[i][1])\n                \n                # Increment the number of projects\n                count += 1\n                \n                # If the number of projects is greater than k\n                if count > k:\n                    \n                    # Get the maximum profit\n                    profit = -heapq.heappop(heap)\n                    \n                    # Increment the total capital\n                    total += profit\n                    \n                    # Decrement the number of projects\n                    count -= 1\n                    \n        # While the heap is not empty\n        while heap:\n            \n            # Get the maximum profit\n            profit = -heapq.heappop(heap)\n            \n            # Increment the total capital\n            total += profit\n            \n        # Return the total capital\n        return total", "runtimes": [0.0014247894287109375, 0.0014500617980957031, 0.001531362533569336, 0.0016112327575683594, 0.0016596317291259766, 0.0016672611236572266, 0.0016918182373046875, 0.0017349720001220703, 0.0017771720886230469, 0.0017848014831542969, 0.0018706321716308594, 0.0018870830535888672, 0.0019850730895996094, 0.0020258426666259766, 0.0020971298217773438, 0.0025634765625, 0.002805948257446289, 0.0031135082244873047, 0.0054132938385009766, 0.005598783493041992, 0.005934238433837891, 0.01243138313293457], "beyond_p": 0.0}], "valid-parentheses": [{"slug_name": "valid-parentheses", "status": {"result": "passed", "runtime": 0.0002751350402832031, "index": 0}, "solution": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '[' or i == '{':\n                stack.append(i)\n            elif i == ')' or i == ']' or i == '}':\n                if len(stack) == 0:\n                    return False\n                else:\n                    top = stack.pop()\n                    if i == ')' and top != '(':\n                        return False\n                    elif i == ']' and top != '[':\n                        return False\n                    elif i == '}' and top != '{':\n                        return False\n        if len(stack) != 0:\n            return False\n        return True", "runtimes": [0.0002722740173339844, 0.0002739429473876953, 0.0002741813659667969, 0.000274658203125, 0.00027680397033691406, 0.00028061866760253906, 0.0002810955047607422, 0.0002810955047607422, 0.00028324127197265625, 0.0002846717834472656, 0.00028705596923828125, 0.0002884864807128906, 0.0002884864807128906, 0.00028896331787109375, 0.00028967857360839844, 0.00028967857360839844, 0.0002923011779785156, 0.00029468536376953125, 0.00029754638671875, 0.00031185150146484375, 0.00036334991455078125, 0.00036978721618652344, 0.0003788471221923828, 0.00038695335388183594, 0.00038886070251464844, 0.00042724609375, 0.0005116462707519531, 0.0005886554718017578, 0.0006663799285888672, 0.0006763935089111328, 0.0007281303405761719, 0.0018687248229980469, 0.0019576549530029297], "beyond_p": 0.9983024473051351}], "next-permutation": [{"slug_name": "next-permutation", "status": {"result": "passed", "runtime": 0.0002853870391845703, "index": 0}, "solution": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first element from the right which is not in the correct position\n        # If no such element is found, then the array is sorted in descending order\n        # and we need to reverse it to get the next permutation\n        # If such element is found, then find the smallest element on the right\n        # which is greater than the element at first_element_not_in_position\n        # Swap the two elements\n        # Now sort the elements on the right of first_element_not_in_position\n        # in ascending order\n        \n        # Find the first element from the right which is not in the correct position\n        first_element_not_in_position = -1\n        for i in range(len(nums)-2, -1, -1):\n            if nums[i] < nums[i+1]:\n                first_element_not_in_position = i\n                break\n        \n        # If no such element is found, then the array is sorted in descending order\n        # and we need to reverse it to get the next permutation\n        if first_element_not_in_position == -1:\n            nums.reverse()\n            return\n        \n        # Find the smallest element on the right which is greater than the element at first_element_not_in_position\n        smallest_greater_element = float('inf')\n        smallest_greater_element_index = -1\n        for i in range(first_element_not_in_position+1, len(nums)):\n            if nums[i] > nums[first_element_not_in_position] and nums[i] < smallest_greater_element:\n                smallest_greater_element = nums[i]\n                smallest_greater_element_index = i\n        \n        # Swap the two elements\n        nums[first_element_not_in_position], nums[smallest_greater_element_index] = nums[smallest_greater_element_index], nums[first_element_not_in_position]\n        \n        # Now sort the elements on the right of first_element_not_in_position\n        # in ascending order\n        nums[first_element_not_in_position+1:] = sorted(nums[first_element_not_in_position+1:])", "runtimes": [0.00026702880859375, 0.0002715587615966797, 0.0002720355987548828, 0.00027370452880859375, 0.0002741813659667969, 0.00027942657470703125, 0.0002808570861816406, 0.0002827644348144531, 0.0002830028533935547, 0.00028324127197265625, 0.0002849102020263672, 0.0002853870391845703, 0.0002865791320800781, 0.00028824806213378906, 0.0002892017364501953, 0.0002903938293457031, 0.00029277801513671875], "beyond_p": 0.28703703703703703}], "contains-duplicate-ii": [{"slug_name": "contains-duplicate-ii", "status": {"result": "failed@cases", "runtime": 0.00041866302490234375, "index": 0}, "solution": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Create a dictionary to map the elements of the list to their indices\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        dict = {}\n        for i in range(len(nums)):\n            dict[nums[i]] = i\n        \n        # Iterate through the list\n        # Time complexity: O(n)\n        for i in range(len(nums)):\n            # Check if the element is already in the dictionary\n            # Time complexity: O(1)\n            if nums[i] in dict and abs(dict[nums[i]] - i) <= k:\n                return True\n        return False", "runtimes": [0.0003581047058105469, 0.0004227161407470703, 0.0004260540008544922, 0.00042629241943359375, 0.00042819976806640625, 0.0004334449768066406, 0.00043487548828125, 0.0004353523254394531, 0.0004382133483886719, 0.0004477500915527344, 0.0004520416259765625, 0.0004570484161376953, 0.0004744529724121094, 0.00047707557678222656, 0.0004928112030029297, 0.0005083084106445312, 0.0005347728729248047, 0.0006258487701416016, 0.0006847381591796875, 0.0006902217864990234, 0.0006985664367675781, 0.0007104873657226562], "beyond_p": 0.0}], "maximum-gap": [{"slug_name": "maximum-gap", "status": {"result": "passed", "runtime": 0.0011055469512939453, "index": 0}, "solution": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        \n        max_diff = 0\n        for i in range(len(nums)-1):\n            max_diff = max(max_diff, nums[i+1]-nums[i])\n            \n        return max_diff", "runtimes": [0.0006568431854248047, 0.0007722377777099609, 0.0010492801666259766, 0.0010788440704345703, 0.0010814666748046875, 0.0010876655578613281, 0.001119375228881836, 0.0019876956939697266, 0.0020499229431152344, 0.0020678043365478516, 0.002428770065307617, 0.003189563751220703, 0.003446340560913086, 0.003448963165283203, 0.0034782886505126953, 0.003844022750854492, 0.003856182098388672, 0.004321575164794922, 0.005348682403564453, 0.006070137023925781, 0.00625920295715332, 0.006453514099121094, 0.007213592529296875, 0.0075986385345458984, 0.01652812957763672], "beyond_p": 0.9717285823731767}], "binary-tree-level-order-traversal": [{"slug_name": "binary-tree-level-order-traversal", "status": {"result": "passed", "runtime": 0.000926971435546875, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                \n            result.append(level)\n            \n        return result", "runtimes": [0.0008826255798339844, 0.0009016990661621094, 0.0009138584136962891, 0.0009143352508544922, 0.0009150505065917969, 0.0009157657623291016, 0.0009224414825439453, 0.0009243488311767578, 0.0009276866912841797, 0.0009293556213378906, 0.0011038780212402344, 0.0031371116638183594, 0.0031828880310058594], "beyond_p": 0.9807213930348259}], "couples-holding-hands": [{"slug_name": "couples-holding-hands", "status": {"result": "failed@cases", "runtime": 0.00025391578674316406, "index": 0}, "solution": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize an empty dictionary to store the couples\n        couples = {}\n        \n        # Iterate over the row and add the couples to the dictionary\n        for i in range(0, len(row), 2):\n            couples[row[i]] = row[i+1]\n            couples[row[i+1]] = row[i]\n            \n        # Initialize the number of swaps\n        swaps = 0\n        \n        # Iterate over the row\n        for i in range(0, len(row), 2):\n            \n            # If the current person is not sitting with their partner\n            if row[i] != couples[row[i+1]]:\n                \n                # Swap the current person with their partner\n                row[i], row[row.index(couples[row[i+1]])] = row[row.index(couples[row[i+1]])], row[i]\n                \n                # Increment the number of swaps\n                swaps += 1\n                \n        # Return the number of swaps\n        return swaps", "runtimes": [0.00026679039001464844, 0.00027370452880859375, 0.0002758502960205078, 0.0002765655517578125, 0.00028204917907714844, 0.00028228759765625, 0.0002837181091308594, 0.00029349327087402344, 0.00029540061950683594, 0.0002980232238769531, 0.00029921531677246094, 0.00030541419982910156, 0.00032329559326171875, 0.00032639503479003906, 0.0003399848937988281, 0.00034809112548828125, 0.00035762786865234375, 0.0004277229309082031], "beyond_p": 0.0}], "interleaving-string": [{"slug_name": "interleaving-string", "status": {"result": "failed@cases", "runtime": 0.0002810955047607422, "index": 0}, "solution": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s1) + len(s2) != len(s3):\n        #     return False\n        \n        # dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        # dp[0][0] = True\n        \n        # for i in range(1, len(s1) + 1):\n        #     dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        # for j in range(1, len(s2) + 1):\n        #     dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        # for i in range(1, len(s1) + 1):\n        #     for j in range(1, len(s2) + 1):\n        #         dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        # return dp[len(s1)][len(s2)]\n\n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [False for _ in range(len(s2) + 1)]\n        \n        dp[0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s2)]", "runtimes": [0.00028252601623535156, 0.0002911090850830078, 0.0002942085266113281, 0.0002961158752441406, 0.0002963542938232422, 0.0002980232238769531, 0.0002982616424560547, 0.00029850006103515625, 0.0002987384796142578, 0.0003008842468261719, 0.0003027915954589844, 0.00030303001403808594, 0.00030922889709472656, 0.00032019615173339844, 0.0003287792205810547, 0.00032973289489746094, 0.0003371238708496094, 0.0003371238708496094, 0.0003452301025390625, 0.0003554821014404297, 0.00039315223693847656, 0.0004630088806152344], "beyond_p": 0.0}], "assign-cookies": [{"slug_name": "assign-cookies", "status": {"result": "passed", "runtime": 0.0005381107330322266, "index": 0}, "solution": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i", "runtimes": [0.0004775524139404297, 0.00048804283142089844, 0.0004949569702148438, 0.0005433559417724609, 0.0005459785461425781, 0.0005514621734619141, 0.0005540847778320312, 0.0005710124969482422, 0.0006086826324462891, 0.0006310939788818359, 0.0006501674652099609, 0.0006515979766845703, 0.0006778240203857422, 0.0006799697875976562, 0.0006885528564453125, 0.0007352828979492188, 0.0007386207580566406, 0.0007398128509521484, 0.0007429122924804688, 0.0007886886596679688, 0.0008592605590820312, 0.0008752346038818359], "beyond_p": 0.8477218225419664}], "keyboard-row": [{"slug_name": "keyboard-row", "status": {"result": "failed@cases", "runtime": 0.00030803680419921875, "index": 0}, "solution": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first_row = \"qwertyuiop\"\n        second_row = \"asdfghjkl\"\n        third_row = \"zxcvbnm\"\n        \n        result = []\n        \n        for word in words:\n            word = word.lower()\n            if word[0] in first_row:\n                for i in range(1, len(word)):\n                    if word[i] not in first_row:\n                        break\n                else:\n                    result.append(word)\n            elif word[0] in second_row:\n                for i in range(1, len(word)):\n                    if word[i] not in second_row:\n                        break\n                else:\n                    result.append(word)\n            elif word[0] in third_row:\n                for i in range(1, len(word)):\n                    if word[i] not in third_row:\n                        break\n                else:\n                    result.append(word)\n                    \n        return result", "runtimes": [0.0003192424774169922, 0.00032901763916015625, 0.00033926963806152344, 0.00036978721618652344, 0.00037169456481933594, 0.0003802776336669922, 0.00041985511779785156, 0.0005190372467041016, 0.0005359649658203125, 0.0005881786346435547, 0.0005962848663330078, 0.0006542205810546875, 0.0009684562683105469], "beyond_p": 0.0}], "reverse-linked-list-ii": [{"slug_name": "reverse-linked-list-ii", "status": {"result": "passed", "runtime": 0.0023212432861328125, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        \n        for i in range(left-1):\n            pre = pre.next\n        \n        cur = pre.next\n        for i in range(left, right):\n            tmp = cur.next\n            cur.next = tmp.next\n            tmp.next = pre.next\n            pre.next = tmp\n        \n        return dummy.next", "runtimes": [0.0022106170654296875, 0.0022706985473632812, 0.002270936965942383, 0.0022721290588378906, 0.0022737979888916016, 0.002296924591064453, 0.0023009777069091797, 0.0023233890533447266, 0.0023272037506103516, 0.002339601516723633, 0.002437114715576172, 0.002527952194213867, 0.002603769302368164, 0.002810239791870117, 0.0029213428497314453, 0.003183126449584961], "beyond_p": 0.8862466290757539}], "shortest-palindrome": [{"slug_name": "shortest-palindrome", "status": {"result": "failed@cases", "runtime": 0.000385284423828125, "index": 0}, "solution": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Find the longest prefix which is also a suffix.\n        l = len(s)\n        for i in range(l//2):\n            if s[:l-i] == s[i+1:]:\n                break\n        else:\n            i = l\n        \n        # Build the palindrome around it.\n        return s[l-i:][::-1] + s", "runtimes": [0.0003540515899658203, 0.00036334991455078125, 0.00036454200744628906, 0.00036716461181640625, 0.0007174015045166016, 0.0007283687591552734, 0.0007662773132324219, 0.0007905960083007812, 0.00080108642578125, 0.0008137226104736328, 0.0008494853973388672, 0.0008907318115234375, 0.0009083747863769531, 0.0012557506561279297, 0.001407623291015625, 0.001669168472290039, 0.0019462108612060547, 0.00196075439453125, 0.0020983219146728516], "beyond_p": 0.0}], "minimum-window-substring": [{"slug_name": "minimum-window-substring", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the dictionary with all the characters of t.\n        window = {i:0 for i in t}\n        \n        # Initialize the counter to keep track of the characters to be found.\n        count = len(t)\n        \n        # Left and right pointer\n        left = 0\n        right = 0\n        \n        # answer tuple\n        ans = (0,0)\n        \n        # Loop through the string s\n        while right < len(s):\n            \n            # If the character is in t, decrement the count.\n            if s[right] in window:\n                window[s[right]] += 1\n                \n                # If the count is 0, it means the character is found.\n                if window[s[right]] == 1:\n                    count -= 1\n            \n            # If the count is 0, it means all the characters are found.\n            if count == 0:\n                \n                # Move the left pointer until we find a character not in t.\n                while left < len(s) and s[left] in window:\n                    window[s[left]] -= 1\n                    left += 1\n                \n                # If this is the first window or the length of the window is less than the previous window, update the answer.\n                if ans == (0,0) or right - left + 1 < ans[1] - ans[0] + 1:\n                    ans = (left, right)\n                \n                # Move the left pointer back.\n                window[s[left]] += 1\n                count += 1\n                left += 1\n            \n            # Increment the right pointer.\n            right += 1\n        \n        # If no window is found, return empty string.\n        if ans == (0,0):\n            return \"\"\n        \n        # Return the substring.\n        return s[ans[0]:ans[1]+1]", "runtimes": [0.0005612373352050781, 0.0005762577056884766, 0.0005919933319091797, 0.0006012916564941406, 0.0006792545318603516, 0.0007212162017822266, 0.00096893310546875, 0.000993490219116211, 0.0009999275207519531, 0.001031637191772461, 0.0011982917785644531, 0.002392292022705078, 0.0025327205657958984], "beyond_p": 0.0}], "self-crossing": [{"slug_name": "self-crossing", "status": {"result": "passed", "runtime": 0.0002810955047607422, "index": 0}, "solution": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) <= 3:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            if i >= 5 and distance[i-2] - distance[i-4] <= distance[i] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] >= distance[i-3] - distance[i-5] and distance[i-1] <= distance[i-3]:\n                return True\n        return False", "runtimes": [0.0002789497375488281, 0.0002810955047607422, 0.0002815723419189453, 0.0002827644348144531, 0.0002892017364501953, 0.0002906322479248047, 0.00029778480529785156, 0.00030493736267089844, 0.0003097057342529297, 0.0003151893615722656, 0.0003247261047363281, 0.0003330707550048828, 0.00035691261291503906, 0.00035834312438964844, 0.0003597736358642578, 0.0003666877746582031], "beyond_p": 0.9755434782608695}], "remove-duplicates-from-sorted-list": [{"slug_name": "remove-duplicates-from-sorted-list", "status": {"result": "failed@cases", "runtime": 0.000553131103515625, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            while head.next is not None and head.val == head.next.val:\n                head = head.next\n            return self.deleteDuplicates(head.next)\n        else:\n            head.next = self.deleteDuplicates(head.next)\n            return head", "runtimes": [0.0005347728729248047, 0.0005385875701904297, 0.00055694580078125, 0.0005652904510498047, 0.0005695819854736328, 0.0005743503570556641, 0.0005772113800048828, 0.0005807876586914062, 0.0005841255187988281, 0.0005846023559570312, 0.0005872249603271484, 0.0005879402160644531, 0.0005886554718017578, 0.000591278076171875, 0.0005924701690673828, 0.0006022453308105469, 0.0006091594696044922, 0.0006418228149414062, 0.0007119178771972656], "beyond_p": 0.0}], "longest-palindrome": [{"slug_name": "longest-palindrome", "status": {"result": "failed@cases", "runtime": 0.0005617141723632812, "index": 0}, "solution": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store the count of each character in the string\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 0\n            char_count[char] += 1\n        \n        # Initialize a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # Iterate through the characters in the string\n        for char in char_count:\n            # If the character appears an even number of times, we can include all of them in the palindrome\n            if char_count[char] % 2 == 0:\n                longest_palindrome += char_count[char]\n            # If the character appears an odd number of times, we can include all of them except one in the palindrome\n            else:\n                longest_palindrome += char_count[char] - 1\n        \n        # Return the length of the longest palindrome\n        return longest_palindrome", "runtimes": [0.00042247772216796875, 0.000484466552734375, 0.0005071163177490234, 0.0005092620849609375, 0.0005254745483398438, 0.000530242919921875, 0.000530242919921875, 0.0005404949188232422, 0.0011408329010009766, 0.002331256866455078], "beyond_p": 0.0}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"slug_name": "construct-binary-tree-from-inorder-and-postorder-traversal", "status": {"result": "passed", "runtime": 0.004647254943847656, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root", "runtimes": [0.004138469696044922, 0.004240989685058594, 0.0043413639068603516, 0.004354715347290039, 0.004389047622680664, 0.004393100738525391, 0.00447535514831543, 0.004487514495849609, 0.0045201778411865234, 0.004542112350463867, 0.004546642303466797, 0.004566669464111328, 0.004580497741699219, 0.004589080810546875, 0.004620790481567383, 0.004628419876098633, 0.004632711410522461, 0.004683256149291992, 0.004720449447631836, 0.0047206878662109375, 0.004810333251953125, 0.004834890365600586, 0.004873752593994141, 0.004973649978637695, 0.005063056945800781], "beyond_p": 0.44971634863331617}], "cut-off-trees-for-golf-event": [{"slug_name": "cut-off-trees-for-golf-event", "status": {"result": "failed@cases", "runtime": 0.0007920265197753906, "index": 0}, "solution": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # find the shortest path to the tree with the smallest height\n        # cut it off\n        # repeat until all trees are cut off\n        # return the number of steps\n        \n        # find the smallest tree\n        smallest_tree = min(tree for row in forest for tree in row if tree > 0)\n        \n        # find the smallest tree's position\n        smallest_tree_position = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] == smallest_tree:\n                    smallest_tree_position = [i, j]\n                    break\n            if smallest_tree_position:\n                break\n        \n        # BFS\n        queue = collections.deque([smallest_tree_position])\n        visited = set(smallest_tree_position)\n        distance = 0\n        \n        while queue:\n            for _ in range(len(queue)):\n                position = queue.popleft()\n                i, j = position\n                for new_position in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                    new_i, new_j = new_position\n                    if 0 <= new_i < len(forest) and 0 <= new_j < len(forest[0]) and forest[new_i][new_j] > 0 and new_position not in visited:\n                        if forest[new_i][new_j] == smallest_tree:\n                            return distance\n                        visited.add(new_position)\n                        queue.append(new_position)\n            distance += 1\n        \n        return -1", "runtimes": [0.11583948135375977, 0.1160893440246582, 0.1443953514099121, 1.1483640670776367, 2.9891834259033203, 3.3057637214660645, 3.539468765258789, 4.068413972854614, 4.174273729324341, 4.54785418510437, 4.711941957473755, 5.091231107711792, 5.176794528961182, 5.285937786102295, 5.961956977844238], "beyond_p": 0.0}], "minimum-depth-of-binary-tree": [{"slug_name": "minimum-depth-of-binary-tree", "status": {"result": "passed", "runtime": 0.0003807544708251953, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))", "runtimes": [0.00036215782165527344, 0.0003705024719238281, 0.00037384033203125, 0.0003750324249267578, 0.00037550926208496094, 0.00037598609924316406, 0.000377655029296875, 0.0003800392150878906, 0.0003809928894042969, 0.0003821849822998047, 0.0003821849822998047, 0.0003840923309326172, 0.0003864765167236328, 0.0003867149353027344, 0.0003886222839355469, 0.00039315223693847656, 0.00039315223693847656, 0.0003948211669921875, 0.00039839744567871094, 0.00040030479431152344, 0.00040078163146972656, 0.00040531158447265625, 0.0004203319549560547, 0.00042319297790527344, 0.00043582916259765625, 0.0004372596740722656, 0.00044274330139160156, 0.0004649162292480469], "beyond_p": 0.8190255220417634}], "count-of-range-sum": [{"slug_name": "count-of-range-sum", "status": {"result": "failed@cases", "runtime": 0.012630701065063477, "index": 0}, "solution": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Merge Sort\n        def mergeSort(nums):\n            if len(nums) > 1:\n                mid = len(nums) // 2\n                L = nums[:mid]\n                R = nums[mid:]\n                mergeSort(L)\n                mergeSort(R)\n                i = j = k = 0\n                while i < len(L) and j < len(R):\n                    if L[i] < R[j]:\n                        nums[k] = L[i]\n                        i += 1\n                    else:\n                        nums[k] = R[j]\n                        j += 1\n                    k += 1\n\n                while i < len(L):\n                    nums[k] = L[i]\n                    i += 1\n                    k += 1\n\n                while j < len(R):\n                    nums[k] = R[j]\n                    j += 1\n                    k += 1\n\n        # Binary Search\n        def binarySearch(nums, target):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n\n        # Count Range Sum\n        def countRangeSum(nums, lower, upper):\n            n = len(nums)\n            if n == 0:\n                return 0\n            presum = [0] * (n + 1)\n            for i in range(n):\n                presum[i + 1] = presum[i] + nums[i]\n            mergeSort(presum)\n            count = 0\n            for i in range(n + 1):\n                if i == 0:\n                    count += binarySearch(presum, upper + 1)\n                else:\n                    count += binarySearch(presum, upper + 1) - binarySearch(presum, lower + presum[i])\n            return count\n\n        return countRangeSum(nums, lower, upper)", "runtimes": [0.0019421577453613281, 0.003283262252807617, 0.004566669464111328, 0.00463104248046875, 0.0047075748443603516, 0.004954338073730469, 0.005644798278808594, 0.006908416748046875, 0.007404804229736328, 0.00945425033569336, 0.009458065032958984, 0.010433435440063477, 0.01081538200378418, 0.013717412948608398, 0.014235734939575195, 0.014469385147094727, 0.016696453094482422, 0.02994680404663086], "beyond_p": 0.0}], "arranging-coins": [{"slug_name": "arranging-coins", "status": {"result": "passed", "runtime": 0.03298377990722656, "index": 0}, "solution": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Complete this function\n        # For loop to iterate from 1 to n\n        # Calculate the number of coins in each row\n        # If the number of coins in a row is greater than n, return the previous row\n        # Else, return the current row\n        \n        for i in range(1, n+1):\n            if i * (i+1) / 2 > n:\n                return i-1\n        return i", "runtimes": [0.000247955322265625, 0.0002586841583251953, 0.008789539337158203, 0.012299776077270508, 0.0123443603515625, 0.012393951416015625, 0.01547551155090332, 0.015819311141967773, 0.01585865020751953, 0.017217397689819336, 0.01844310760498047, 0.019928932189941406, 0.021193265914916992, 0.021225452423095703, 0.021729707717895508, 0.022657155990600586, 0.024247169494628906, 0.024971723556518555, 0.025435686111450195, 0.026628732681274414, 0.02884078025817871, 0.03231310844421387], "beyond_p": 0.0}], "longest-uncommon-subsequence-i": [{"slug_name": "longest-uncommon-subsequence-i", "status": {"result": "passed", "runtime": 0.0002663135528564453, "index": 0}, "solution": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))", "runtimes": [0.0002608299255371094, 0.0002639293670654297, 0.0002658367156982422, 0.0002665519714355469, 0.0002665519714355469, 0.00026702880859375, 0.0002684593200683594, 0.000270843505859375, 0.0002713203430175781, 0.0002837181091308594], "beyond_p": 0.7604166666666666}], "binary-tree-level-order-traversal-ii": [{"slug_name": "binary-tree-level-order-traversal-ii", "status": {"result": "passed", "runtime": 0.0005171298980712891, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = collections.deque([root])\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.popleft()\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result[::-1]", "runtimes": [0.0004811286926269531, 0.0004899501800537109, 0.0004994869232177734, 0.0005109310150146484, 0.0005109310150146484, 0.0005118846893310547, 0.0005152225494384766, 0.0005254745483398438, 0.0005354881286621094, 0.0005867481231689453, 0.0015454292297363281], "beyond_p": 0.9661738351254481}], "palindrome-number": [{"slug_name": "palindrome-number", "status": {"result": "passed", "runtime": 0.0002655982971191406, "index": 0}, "solution": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        else:\n            return str(x) == str(x)[::-1]", "runtimes": [0.0002608299255371094, 0.00026416778564453125, 0.0002646446228027344, 0.0002646446228027344, 0.00026488304138183594, 0.0002655982971191406, 0.0002663135528564453, 0.0002665519714355469, 0.00026702880859375, 0.00026726722717285156, 0.0002682209014892578, 0.0002696514129638672, 0.0002701282501220703, 0.0002734661102294922, 0.00027441978454589844, 0.000274658203125, 0.0002753734588623047, 0.00027871131896972656, 0.0002868175506591797, 0.00029659271240234375], "beyond_p": 0.8666666666666667}], "decode-ways": [{"slug_name": "decode-ways", "status": {"result": "passed", "runtime": 0.0004127025604248047, "index": 0}, "solution": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize dp array\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        \n        # Initialize dp[1]\n        if s[0] == '0':\n            dp[1] = 0\n        else:\n            dp[1] = 1\n        \n        # Fill in the rest of dp array\n        for i in range(2, len(s) + 1):\n            if s[i - 1] == '0':\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n            \n            if int(s[i - 2:i]) <= 26 and s[i - 2] != '0':\n                dp[i] += dp[i - 2]\n        \n        return dp[len(s)]", "runtimes": [0.00029015541076660156, 0.00029087066650390625, 0.00029468536376953125, 0.0003266334533691406, 0.0003285408020019531, 0.0003533363342285156, 0.0003638267517089844, 0.0003650188446044922, 0.0003693103790283203, 0.00039076805114746094, 0.0003914833068847656, 0.00039505958557128906, 0.00039577484130859375, 0.0003991127014160156, 0.00041484832763671875], "beyond_p": 0.017208413001912046}], "is-subsequence": [{"slug_name": "is-subsequence", "status": {"result": "passed", "runtime": 0.0014977455139160156, "index": 0}, "solution": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        \n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False", "runtimes": [0.0006279945373535156, 0.0007891654968261719, 0.0008025169372558594, 0.0011997222900390625, 0.0014100074768066406, 0.0014393329620361328, 0.0014536380767822266, 0.0014767646789550781, 0.0014891624450683594, 0.0014896392822265625, 0.0014958381652832031, 0.0014982223510742188, 0.0015075206756591797, 0.0015156269073486328, 0.001623392105102539, 0.008925676345825195, 0.28403663635253906, 0.8344337940216064], "beyond_p": 0.9989568902289951}], "gray-code": [{"slug_name": "gray-code", "status": {"result": "failed@cases", "runtime": 0.0008897781372070312, "index": 0}, "solution": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def grayCodeHelper(n, prefix):\n            if n == 0:\n                return [prefix]\n            else:\n                result = []\n                for i in range(2):\n                    for code in grayCodeHelper(n-1, prefix*2 + i):\n                        result.append(code)\n                return result\n        \n        return grayCodeHelper(n, 0)", "runtimes": [0.0003094673156738281, 0.0003192424774169922, 0.0003325939178466797, 0.0003345012664794922, 0.00033736228942871094, 0.00033783912658691406, 0.0003535747528076172, 0.0003573894500732422, 0.000362396240234375, 0.0004684925079345703, 0.0010013580322265625, 0.00110626220703125, 0.0012407302856445312, 0.0012862682342529297, 0.0015859603881835938, 0.0019519329071044922, 0.002345561981201172], "beyond_p": 0.0}], "climbing-stairs": [{"slug_name": "climbing-stairs", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return self.climbStairs(n-1) + self.climbStairs(n-2)", "runtimes": [0.00023484230041503906, 0.00024056434631347656, 0.00024080276489257812, 0.0002410411834716797, 0.000244140625, 0.0002474784851074219, 0.00024819374084472656, 0.0002529621124267578, 0.0002868175506591797, 0.0002942085266113281, 0.00030112266540527344, 0.0003292560577392578], "beyond_p": 0.0}], "word-break": [{"slug_name": "word-break", "status": {"result": "failed@cases", "runtime": 0.028021812438964844, "index": 0}, "solution": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the dp array with False\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        # Loop through the string\n        for i in range(1, len(s) + 1):\n            \n            # Loop through the wordDict\n            for word in wordDict:\n                \n                # Check if the word is a prefix of the string\n                if s[:i] == word:\n                    \n                    # If the word is a prefix, set the dp value to True\n                    dp[i] = True\n                    \n                    # Break the inner loop\n                    break\n                    \n        return dp[len(s)]", "runtimes": [0.0007090568542480469, 0.0009660720825195312, 0.0012540817260742188, 0.0012845993041992188, 0.0013461112976074219, 0.0013644695281982422, 0.0023016929626464844, 0.0023097991943359375, 0.002362966537475586, 0.0026934146881103516, 0.0036356449127197266, 0.0057752132415771484, 0.017513751983642578, 0.018364667892456055, 0.09924626350402832, 0.11351466178894043, 0.14796733856201172], "beyond_p": 0.0}], "validate-binary-search-tree": [{"slug_name": "validate-binary-search-tree", "status": {"result": "passed", "runtime": 0.0003790855407714844, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTHelper(root, minValue, maxValue):\n            if root is None:\n                return True\n            if root.val <= minValue or root.val >= maxValue:\n                return False\n            return isValidBSTHelper(root.left, minValue, root.val) and isValidBSTHelper(root.right, root.val, maxValue)\n        return isValidBSTHelper(root, float('-inf'), float('inf'))", "runtimes": [0.00035691261291503906, 0.0003662109375, 0.0003705024719238281, 0.0003712177276611328, 0.0003712177276611328, 0.00037217140197753906, 0.00037479400634765625, 0.000377655029296875, 0.00037789344787597656, 0.00037860870361328125, 0.0003800392150878906, 0.0003867149353027344, 0.00039315223693847656, 0.00039505958557128906, 0.0004074573516845703, 0.0004076957702636719, 0.0005686283111572266], "beyond_p": 0.8952702702702703}], "insert-interval": [{"slug_name": "insert-interval", "status": {"result": "passed", "runtime": 0.0002620220184326172, "index": 0}, "solution": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is not empty and intervals is not empty\n        # find the index where newInterval should be inserted\n        index = 0\n        while index < len(intervals) and newInterval[0] > intervals[index][0]:\n            index += 1\n        \n        # insert newInterval at index\n        intervals.insert(index, newInterval)\n        \n        # merge intervals\n        result = []\n        for interval in intervals:\n            if not result or result[-1][1] < interval[0]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        \n        return result", "runtimes": [0.0002524852752685547, 0.0002532005310058594, 0.00025463104248046875, 0.0002551078796386719, 0.000255584716796875, 0.000255584716796875, 0.00025582313537597656, 0.0002562999725341797, 0.00026154518127441406, 0.00026297569274902344, 0.0002636909484863281, 0.0002655982971191406, 0.0002658367156982422, 0.0002663135528564453, 0.0002665519714355469, 0.00026869773864746094, 0.00026869773864746094, 0.0002689361572265625, 0.0002720355987548828, 0.0002753734588623047, 0.0002770423889160156, 0.00028324127197265625, 0.00029778480529785156, 0.00030732154846191406], "beyond_p": 0.8260869565217391}], "palindrome-partitioning": [{"slug_name": "palindrome-partitioning", "status": {"result": "passed", "runtime": 0.00044083595275878906, "index": 0}, "solution": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def helper(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    helper(s[i:], path+[s[:i]], res)\n        \n        res = []\n        helper(s, [], res)\n        return res", "runtimes": [0.0003426074981689453, 0.0003457069396972656, 0.00035190582275390625, 0.000354766845703125, 0.00035643577575683594, 0.00036406517028808594, 0.0003650188446044922, 0.0003666877746582031, 0.0003674030303955078, 0.0003733634948730469, 0.0003752708435058594, 0.0004029273986816406, 0.00041747093200683594, 0.00042128562927246094, 0.00043582916259765625, 0.00044226646423339844, 0.0004489421844482422, 0.0004489421844482422, 0.0004520416259765625, 0.0004975795745849609, 0.0005033016204833984, 0.0005438327789306641, 0.0006401538848876953, 0.0006470680236816406, 0.0013167858123779297, 0.04520535469055176, 0.08208966255187988, 0.0889425277709961, 0.09301900863647461], "beyond_p": 0.998940092047346}], "smallest-range-covering-elements-from-k-lists": [{"slug_name": "smallest-range-covering-elements-from-k-lists", "status": {"result": "failed@cases", "runtime": 0.002399921417236328, "index": 0}, "solution": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the heap\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i][0], i, 0))\n        \n        # Initialize the min range\n        min_range = [float('inf'), float('-inf')]\n        \n        # Loop until the heap is empty\n        while heap:\n            # Get the smallest number\n            smallest = heapq.heappop(heap)\n            \n            # If the current range is smaller than the min range\n            if smallest[0] - min_range[0] < min_range[1] - min_range[0]:\n                min_range = [min_range[0], smallest[0]]\n            \n            # Add the next number from the list\n            if smallest[2] + 1 < len(nums[smallest[1]]):\n                heapq.heappush(heap, (nums[smallest[1]][smallest[2] + 1], smallest[1], smallest[2] + 1))\n        \n        return min_range", "runtimes": [0.001129150390625, 0.0012650489807128906, 0.0012733936309814453, 0.001310586929321289, 0.0013413429260253906, 0.0013527870178222656, 0.0013730525970458984, 0.0014705657958984375, 0.0015227794647216797, 0.0016450881958007812, 0.0028028488159179688, 0.003373861312866211, 0.003452777862548828, 0.0046842098236083984, 0.005066633224487305, 0.011603593826293945, 0.013187885284423828, 0.019295454025268555], "beyond_p": 0.0}], "poor-pigs": [{"slug_name": "poor-pigs", "status": {"result": "failed@cases", "runtime": 0.00023627281188964844, "index": 0}, "solution": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if buckets == 1:\n            return 0\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 30\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 60\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 1000\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 4\n        \n        # minutesToDie = 15\n        # minutesToTest = 15\n        # buckets = 10", "runtimes": [0.0002319812774658203, 0.00023651123046875, 0.00024127960205078125, 0.00024175643920898438, 0.00024771690368652344, 0.0002593994140625, 0.00026535987854003906, 0.0002696514129638672, 0.0002942085266113281, 0.0002963542938232422, 0.0003032684326171875, 0.0003199577331542969, 0.00040602684020996094], "beyond_p": 0.0}], "swim-in-rising-water": [{"slug_name": "swim-in-rising-water", "status": {"result": "failed@cases", "runtime": 0.0018138885498046875, "index": 0}, "solution": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time O(n^2)\n        # Space O(n^2)\n        \n        n = len(grid)\n        visited = set()\n        queue = collections.deque([(0, 0)])\n        visited.add((0, 0))\n        max_height = 0\n        \n        while queue:\n            row, col = queue.popleft()\n            max_height = max(max_height, grid[row][col])\n            if row == n-1 and col == n-1:\n                return max_height\n            \n            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n                if 0 <= r < n and 0 <= c < n and (r, c) not in visited:\n                    visited.add((r, c))\n                    queue.append((r, c))\n                    \n        return -1", "runtimes": [0.0018985271453857422, 0.002361774444580078, 0.002582550048828125, 0.003264904022216797, 0.0037763118743896484, 0.004063606262207031, 0.0046083927154541016, 0.004862785339355469, 0.004942178726196289, 0.005425214767456055, 0.005914926528930664, 0.006372928619384766, 0.00640106201171875, 0.007330417633056641, 0.0077593326568603516, 0.007914066314697266, 0.008137941360473633, 0.010081768035888672, 0.013060808181762695, 0.013411521911621094], "beyond_p": 0.0}], "unique-paths": [{"slug_name": "unique-paths", "status": {"result": "failed@cases", "runtime": 0.0003228187561035156, "index": 0}, "solution": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp table with 1's.\n        dp = [[1]*n for _ in range(m)]\n        \n        # Fill in the values for the first row.\n        for i in range(1, m):\n            for j in range(n):\n                dp[i][j] = dp[i-1][j]\n        \n        # Fill in the values for the first column.\n        for i in range(m):\n            for j in range(1, n):\n                dp[i][j] = dp[i][j-1]\n        \n        return dp[m-1][n-1]", "runtimes": [0.0002543926239013672, 0.0003018379211425781, 0.0003199577331542969, 0.0003447532653808594, 0.0003504753112792969, 0.0003509521484375, 0.0003845691680908203, 0.0004150867462158203, 0.00046515464782714844, 0.0004665851593017578, 0.00046825408935546875, 0.0004715919494628906, 0.00047397613525390625, 0.0004794597625732422, 0.0005154609680175781, 0.0006110668182373047, 0.0007226467132568359], "beyond_p": 0.0}], "multiply-strings": [{"slug_name": "multiply-strings", "status": {"result": "failed@cases", "runtime": 0.008324384689331055, "index": 0}, "solution": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        result = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)-1, -1, -1):\n            for j in range(len(num2)-1, -1, -1):\n                result[i+j+1] += int(num1[i]) * int(num2[j])\n                \n        carry = 0\n        for i in range(len(result)-1, -1, -1):\n            result[i] += carry\n            carry = result[i] // 10\n            result[i] %= 10\n            \n        if carry != 0:\n            result = [carry] + result\n            \n        return ''.join(map(str, result))", "runtimes": [0.0002510547637939453, 0.00025272369384765625, 0.00025582313537597656, 0.0003707408905029297, 0.00039315223693847656, 0.0006744861602783203, 0.008580446243286133, 0.008585929870605469, 0.008592844009399414, 0.008596420288085938, 0.00865936279296875, 0.00872349739074707, 0.009400367736816406, 0.009422063827514648, 0.009932518005371094, 0.010163545608520508, 0.011257410049438477, 0.01128840446472168, 0.011420488357543945, 0.012969493865966797, 0.016387939453125, 0.021161317825317383, 0.02400684356689453, 0.025067567825317383], "beyond_p": 0.0}], "best-time-to-buy-and-sell-stock-iii": [{"slug_name": "best-time-to-buy-and-sell-stock-iii", "status": {"result": "passed", "runtime": 0.001905679702758789, "index": 0}, "solution": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        buy1 = float('inf')\n        buy2 = float('inf')\n        sell1 = 0\n        sell2 = 0\n        \n        for price in prices:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2", "runtimes": [0.0007293224334716797, 0.000997781753540039, 0.001962900161743164, 0.0020678043365478516, 0.0024902820587158203, 0.002620220184326172, 0.002664804458618164, 0.0030105113983154297, 0.00308990478515625, 0.0032918453216552734, 0.0033812522888183594, 0.003389120101928711, 0.004918098449707031, 0.005216121673583984, 0.006719112396240234, 0.007108926773071289, 0.007177591323852539, 0.007505655288696289, 0.00865030288696289, 0.00944662094116211, 0.0095367431640625, 0.009787321090698242, 0.009824037551879883, 0.009827375411987305, 0.009951114654541016, 0.01002955436706543, 0.010368108749389648, 0.010517358779907227, 0.011287450790405273, 0.011350154876708984], "beyond_p": 0.889240577367724}], "combination-sum-ii": [{"slug_name": "combination-sum-ii", "status": {"result": "failed@cases", "runtime": 0.01239776611328125, "index": 0}, "solution": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # List to store the final result\n        result = []\n        \n        # List to store the combination\n        combination = []\n        \n        # Call the helper function\n        self.helper(candidates, 0, target, combination, result)\n        \n        return result\n    \n    def helper(self, candidates, index, target, combination, result):\n        # Base case\n        if target == 0:\n            result.append(combination[:])\n            return\n        \n        # Edge case\n        if index == len(candidates) or target < 0:\n            return\n        \n        # First option\n        self.helper(candidates, index + 1, target, combination, result)\n        \n        # Second option\n        combination.append(candidates[index])\n        self.helper(candidates, index + 1, target - candidates[index], combination, result)\n        \n        # Backtracking\n        combination.pop()", "runtimes": [0.0004425048828125, 0.00045609474182128906, 0.0004744529724121094, 0.0011670589447021484, 0.0012583732604980469, 0.0014913082122802734, 0.0017614364624023438, 0.0017993450164794922, 0.0018582344055175781, 0.002034425735473633, 0.002147197723388672, 0.002150297164916992, 0.003347158432006836, 0.003391742706298828, 0.003937721252441406, 0.004569530487060547, 0.005993366241455078], "beyond_p": 0.0}], "detect-capital": [{"slug_name": "detect-capital", "status": {"result": "passed", "runtime": 0.00023674964904785156, "index": 0}, "solution": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or (word.istitle() and word[0].isupper()):\n            return True\n        else:\n            return False", "runtimes": [0.0002334117889404297, 0.0002338886260986328, 0.00023508071899414062, 0.00023937225341796875, 0.00024509429931640625, 0.0002474784851074219, 0.0002486705780029297, 0.00024962425231933594, 0.00025177001953125, 0.0002639293670654297, 0.0002753734588623047], "beyond_p": 0.9204545454545454}], "best-time-to-buy-and-sell-stock": [{"slug_name": "best-time-to-buy-and-sell-stock", "status": {"result": "passed", "runtime": 0.0005128383636474609, "index": 0}, "solution": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        min_price = 10**10\n        \n        # Loop through the list of prices.\n        for price in prices:\n            \n            # If the current price is less than the minimum price,\n            # then the minimum price is updated.\n            if price < min_price:\n                min_price = price\n                \n            # If the maximum profit is less than the difference between the current price and the minimum price,\n            # then the maximum profit is updated.\n            elif max_profit < price - min_price:\n                max_profit = price - min_price\n                \n        # Return the maximum profit.\n        return max_profit", "runtimes": [0.0004055500030517578, 0.0004723072052001953, 0.0004889965057373047, 0.0005030632019042969, 0.0005078315734863281, 0.0005130767822265625, 0.0005958080291748047, 0.0007414817810058594, 0.0008223056793212891, 0.0010733604431152344, 0.0011341571807861328, 0.0012226104736328125, 0.0012421607971191406, 0.0012433528900146484, 0.00128936767578125, 0.00146484375, 0.001817464828491211, 0.0020325183868408203], "beyond_p": 0.9340562719812426}], "binary-tree-inorder-traversal": [{"slug_name": "binary-tree-inorder-traversal", "status": {"result": "passed", "runtime": 0.0006341934204101562, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        current = root\n        \n        while current is not None or len(stack) > 0:\n            while current is not None:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            result.append(current.val)\n            current = current.right\n            \n        return result", "runtimes": [0.0005884170532226562, 0.0005929470062255859, 0.0005974769592285156, 0.0006024837493896484, 0.0006067752838134766, 0.0006124973297119141, 0.0006184577941894531, 0.0006196498870849609, 0.0006210803985595703, 0.0006258487701416016, 0.0006263256072998047, 0.0006270408630371094, 0.0006277561187744141, 0.0006339550018310547, 0.0006361007690429688, 0.0006372928619384766, 0.0006399154663085938, 0.0006437301635742188, 0.0006463527679443359, 0.0006475448608398438, 0.0007734298706054688], "beyond_p": 0.7525773195876289}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"slug_name": "construct-binary-tree-from-preorder-and-inorder-traversal", "status": {"result": "passed", "runtime": 0.006119489669799805, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root", "runtimes": [0.0047380924224853516, 0.0048105716705322266, 0.005095005035400391, 0.005128145217895508, 0.005232334136962891, 0.005235195159912109, 0.0052471160888671875, 0.005278110504150391, 0.0053253173828125, 0.005430936813354492, 0.00543522834777832, 0.005466461181640625, 0.005468606948852539, 0.005522251129150391, 0.005540609359741211, 0.005583047866821289, 0.005584001541137695, 0.005602359771728516, 0.0056302547454833984, 0.005658864974975586, 0.0056629180908203125, 0.0057370662689208984, 0.005983114242553711, 0.007152080535888672, 0.011946916580200195], "beyond_p": 0.8083741235613177}], "remove-invalid-parentheses": [{"slug_name": "remove-invalid-parentheses", "status": {"result": "failed@cases", "runtime": 0.0002639293670654297, "index": 0}, "solution": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty\n        \n        # BFS\n        # 1. find the first valid string\n        # 2. find all the next valid strings\n        # 3. add them to the queue\n        # 4. repeat step 2 until the queue is empty", "runtimes": [0.0003070831298828125, 0.0003719329833984375], "beyond_p": 0.0}], "merge-k-sorted-lists": [{"slug_name": "merge-k-sorted-lists", "status": {"result": "passed", "runtime": 0.0028083324432373047, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # if not lists:\n        #     return None\n        # head = point = ListNode(0)\n        # nodes = []\n        # for l in lists:\n        #     while l:\n        #         nodes.append(l.val)\n        #         l = l.next\n        # nodes.sort()\n        # for n in nodes:\n        #     point.next = ListNode(n)\n        #     point = point.next\n        # return head.next\n        \n        if not lists:\n            return None\n        head = point = ListNode(0)\n        nodes = []\n        for l in lists:\n            while l:\n                nodes.append(l)\n                l = l.next\n        nodes.sort(key=lambda x: x.val)\n        for n in nodes:\n            point.next = n\n            point = point.next\n        return head.next", "runtimes": [0.0031211376190185547, 0.003139495849609375, 0.003147602081298828, 0.003244638442993164, 0.0032532215118408203, 0.0032699108123779297, 0.0032868385314941406, 0.003434896469116211, 0.0034487247467041016, 0.003554105758666992, 0.0036203861236572266, 0.003768444061279297, 0.003940105438232422, 0.00394892692565918, 0.003957033157348633, 0.0041272640228271484, 0.004617452621459961, 0.0047757625579833984, 0.0048143863677978516, 0.005734443664550781, 0.01705169677734375, 0.025825977325439453, 0.16666889190673828], "beyond_p": 1.0019126228736284}], "palindrome-partitioning-ii": [{"slug_name": "palindrome-partitioning-ii", "status": {"result": "failed@cases", "runtime": 0.08234572410583496, "index": 0}, "solution": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array\n        dp = [i-1 for i in range(len(s)+1)]\n        \n        # Initialize the palindrome partitioning\n        palindrome_partitioning = [[False for i in range(len(s))] for j in range(len(s))]\n        \n        # Fill the diagonal elements for palindrome partitioning\n        for i in range(len(s)):\n            palindrome_partitioning[i][i] = True\n        \n        # Fill the remaining elements for palindrome partitioning\n        for j in range(1, len(s)):\n            for i in range(j):\n                if s[i] == s[j] and (j-i < 2 or palindrome_partitioning[i+1][j-1]):\n                    palindrome_partitioning[i][j] = True\n        \n        # Fill the dp array\n        for i in range(1, len(s)):\n            if palindrome_partitioning[0][i]:\n                dp[i] = 0\n            else:\n                for j in range(1, i+1):\n                    if palindrome_partitioning[j][i]:\n                        dp[i] = min(dp[i], dp[j-1] + 1)\n                        \n        return dp[-1]", "runtimes": [0.0016543865203857422, 0.0020051002502441406, 0.005002737045288086, 0.0512692928314209, 0.05276846885681152, 0.05716872215270996, 0.0628969669342041, 0.06815862655639648, 0.08482503890991211, 0.09365248680114746, 0.11769342422485352, 0.16675186157226562, 0.1670842170715332, 0.16778969764709473, 0.17792558670043945, 0.18416142463684082, 0.18977046012878418, 0.19634342193603516, 0.22103357315063477, 0.22835659980773926, 0.23008322715759277, 0.23287701606750488, 0.24632978439331055, 0.2505764961242676, 0.3015115261077881, 0.3242604732513428], "beyond_p": 0.0}], "preimage-size-of-factorial-zeroes-function": [{"slug_name": "preimage-size-of-factorial-zeroes-function", "status": {"result": "failed@cases", "runtime": 0.00026345252990722656, "index": 0}, "solution": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5\n        # 10^4\n        # 10^3\n        # 10^2\n        # 10^1\n        # 10^0\n        \n        # 10^9\n        # 10^8\n        # 10^7\n        # 10^6\n        # 10^5", "runtimes": [0.00028324127197265625, 0.0002892017364501953, 0.0002925395965576172, 0.0003325939178466797, 0.000335693359375, 0.0005233287811279297, 0.0005266666412353516, 0.0005996227264404297, 0.0006258487701416016, 0.0008745193481445312, 0.002043485641479492, 0.002585172653198242], "beyond_p": 0.0}], "palindrome-pairs": [{"slug_name": "palindrome-pairs", "status": {"result": "failed@cases", "runtime": 0.0015690326690673828, "index": 0}, "solution": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Runtime: 108 ms, faster than 99.79% of Python online submissions for Palindrome Pairs.\n        # Memory Usage: 14.8 MB, less than 100.00% of Python online submissions for Palindrome Pairs.\n        \n        # Time complexity: O(sum of words[i].length)\n        # Space complexity: O(sum of words[i].length)\n        \n        # Create a dictionary to store the words and their indices\n        word_indices = {}\n        for i in range(len(words)):\n            word_indices[words[i]] = i\n        \n        # Initialize an empty list to store the palindrome pairs\n        pairs = []\n        \n        # Iterate through each word\n        for i in range(len(words)):\n            # Get the current word\n            word1 = words[i]\n            \n            # Iterate through the length of the current word\n            for j in range(len(word1) + 1):\n                # Get the first part of the word\n                first_part = word1[:j]\n                \n                # Get the second part of the word\n                second_part = word1[j:]\n                \n                # Check if the first part is a palindrome\n                if first_part == first_part[::-1]:\n                    # Check if the second part is in word_indices\n                    # and if the index is not equal to i\n                    if second_part in word_indices and word_indices[second_part] != i:\n                        pairs.append([i, word_indices[second_part]])\n                \n                # Check if the second part is a palindrome\n                if second_part == second_part[::-1]:\n                    # Check if the first part is in word_indices\n                    # and if the index is not equal to i\n                    if first_part in word_indices and word_indices[first_part] != i:\n                        pairs.append([word_indices[first_part], i])\n                \n        return pairs", "runtimes": [0.0013003349304199219, 0.0013127326965332031, 0.0013179779052734375, 0.001613616943359375, 0.001664876937866211, 0.0018608570098876953, 0.0019741058349609375, 0.0021691322326660156, 0.0021963119506835938, 0.0024721622467041016, 0.0029709339141845703, 0.0034313201904296875, 0.003849506378173828, 0.00456690788269043, 0.0045773983001708984, 0.004727363586425781, 0.004831075668334961, 0.004868268966674805, 0.00522613525390625, 0.005293607711791992, 0.005364418029785156, 0.005548238754272461, 0.0071773529052734375, 0.007252693176269531], "beyond_p": 0.0}], "convert-sorted-array-to-binary-search-tree": [{"slug_name": "convert-sorted-array-to-binary-search-tree", "status": {"result": "passed", "runtime": 0.0040683746337890625, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        mid = len(nums)//2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root", "runtimes": [0.003306865692138672, 0.0033721923828125, 0.0033762454986572266, 0.0034322738647460938, 0.0035037994384765625, 0.0035543441772460938, 0.003756999969482422, 0.003772258758544922, 0.0038678646087646484, 0.003990650177001953], "beyond_p": 0.0}], "contain-virus": [{"slug_name": "contain-virus", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if 0 <= i < m and 0 <= j < n and isInfected[i][j] == 1:\n                isInfected[i][j] = 2\n                dfs(i + 1, j)\n                dfs(i - 1, j)\n                dfs(i, j + 1)\n                dfs(i, j - 1)\n        \n        m = len(isInfected)\n        n = len(isInfected[0])\n        walls = 0\n        while True:\n            infected = []\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.append((i, j))\n            if not infected:\n                break\n            for i, j in infected:\n                isInfected[i][j] = 2\n            for i, j in infected:\n                dfs(i, j)\n            new_infected = set()\n            for i, j in infected:\n                for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 2:\n                        new_infected.add((ni, nj))\n            for i, j in new_infected:\n                isInfected[i][j] = 1\n            walls += len(new_infected)\n        return walls", "runtimes": [0.013199806213378906, 0.01395869255065918, 0.016732215881347656, 0.018070220947265625, 0.022105932235717773, 0.024558544158935547, 0.02585625648498535, 0.027414321899414062, 0.027533292770385742, 0.029376983642578125, 0.03009343147277832, 0.03217506408691406, 0.033063411712646484, 0.059181928634643555], "beyond_p": 0.0}], "longest-increasing-path-in-a-matrix": [{"slug_name": "longest-increasing-path-in-a-matrix", "status": {"result": "passed", "runtime": 0.0010280609130859375, "index": 0}, "solution": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        ans = 0\n        \n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, self.dfs(matrix, i, j, dp))\n                \n        return ans\n    \n    def dfs(self, matrix, i, j, dp):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_len = 1\n        \n        if i > 0 and matrix[i][j] > matrix[i-1][j]:\n            max_len = max(max_len, self.dfs(matrix, i-1, j, dp) + 1)\n        if i < m-1 and matrix[i][j] > matrix[i+1][j]:\n            max_len = max(max_len, self.dfs(matrix, i+1, j, dp) + 1)\n        if j > 0 and matrix[i][j] > matrix[i][j-1]:\n            max_len = max(max_len, self.dfs(matrix, i, j-1, dp) + 1)\n        if j < n-1 and matrix[i][j] > matrix[i][j+1]:\n            max_len = max(max_len, self.dfs(matrix, i, j+1, dp) + 1)\n        \n        dp[i][j] = max_len\n        return max_len", "runtimes": [0.0010585784912109375, 0.0011179447174072266, 0.0011453628540039062, 0.0011985301971435547, 0.0011992454528808594, 0.0012192726135253906, 0.0013282299041748047, 0.0013804435729980469, 0.0013854503631591797, 0.0014317035675048828, 0.0014324188232421875, 0.0014529228210449219, 0.0014569759368896484, 0.0015518665313720703, 0.0017516613006591797, 0.0017528533935546875, 0.0018095970153808594, 0.001821279525756836, 0.0018756389617919922, 0.0018892288208007812, 0.002003192901611328, 0.0020627975463867188, 0.002313852310180664, 0.0023834705352783203, 0.002389192581176758, 0.0024216175079345703, 0.002494335174560547, 0.004102230072021484, 0.004688262939453125, 0.004922628402709961, 0.0051729679107666016], "beyond_p": 1.0074172799443704}], "number-of-digit-one": [{"slug_name": "number-of-digit-one", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        count = 0\n        for i in range(1, n+1):\n            count += str(i).count('1')\n        return count", "runtimes": [0.0003006458282470703, 0.00030684471130371094, 0.0003108978271484375, 0.0003211498260498047, 0.00034689903259277344, 0.0003631114959716797, 0.0003643035888671875, 0.00042891502380371094, 0.0004627704620361328, 0.0009281635284423828, 0.0014472007751464844], "beyond_p": 0.0}], "word-break-ii": [{"slug_name": "word-break-ii", "status": {"result": "failed@cases", "runtime": 0.0005941390991210938, "index": 0}, "solution": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the dictionary\n        d = {}\n        d[0] = []\n        \n        # Initialize the result\n        result = []\n        \n        # Loop through the string\n        for i in range(1, len(s) + 1):\n            \n            # Check if the substring is in the dictionary\n            if s[:i] in wordDict:\n                \n                # If it is, add it to the dictionary\n                d[i] = [s[:i]]\n                \n                # If there is a word that can be added to it\n                if i in d:\n                    \n                    # Add the word to the result\n                    for word in d[i]:\n                        result.append(word + \" \")\n                        \n            # If the substring is not in the dictionary\n            else:\n                \n                # Check if there is a word that can be added to it\n                if i in d:\n                    \n                    # Add the word to the result\n                    for word in d[i]:\n                        result[len(word)] = word + \" \"\n                        \n        # Return the result\n        return result", "runtimes": [0.0008530616760253906, 0.0008828639984130859, 0.0009012222290039062, 0.0009093284606933594, 0.0015480518341064453, 0.0018527507781982422, 0.0020799636840820312, 0.0021419525146484375, 0.002150297164916992, 0.0023162364959716797, 0.0024352073669433594, 0.0043752193450927734, 0.004922628402709961, 0.00813603401184082], "beyond_p": 0.0}], "binary-tree-zigzag-level-order-traversal": [{"slug_name": "binary-tree-zigzag-level-order-traversal", "status": {"result": "passed", "runtime": 0.006132841110229492, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = collections.deque([root])\n        result = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                    \n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 1:\n                current_level.reverse()\n                \n            result.append(current_level)\n            level += 1\n            \n        return result", "runtimes": [0.005838632583618164, 0.005903005599975586, 0.0060541629791259766, 0.006328582763671875, 0.0063304901123046875, 0.006880521774291992, 0.00699162483215332, 0.007011890411376953, 0.007040739059448242, 0.007451057434082031], "beyond_p": 0.817536596185125}], "binary-watch": [{"slug_name": "binary-watch", "status": {"result": "failed@cases", "runtime": 0.0003528594970703125, "index": 0}, "solution": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(hour, minute):\n            return str(hour) + ':' + ('0' + str(minute) if minute < 10 else str(minute))\n        \n        def get_hours(num):\n            return [i for i in range(12) if bin(i).count('1') == num]\n        \n        def get_minutes(num):\n            return [i for i in range(60) if bin(i).count('1') == num]\n        \n        hours = get_hours(turnedOn)\n        minutes = get_minutes(turnedOn - 4)\n        return [get_time(h, m) for h in hours for m in minutes]", "runtimes": [0.0018007755279541016, 0.001829385757446289, 0.0022203922271728516, 0.002228975296020508, 0.0022292137145996094, 0.002232789993286133, 0.003170490264892578, 0.004314899444580078], "beyond_p": 0.0}], "pascals-triangle": [{"slug_name": "pascals-triangle", "status": {"result": "passed", "runtime": 0.00031304359436035156, "index": 0}, "solution": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        else:\n            result = [[1],[1,1]]\n            for i in range(2,numRows):\n                temp = [1]\n                for j in range(1,i):\n                    temp.append(result[i-1][j-1]+result[i-1][j])\n                temp.append(1)\n                result.append(temp)\n            return result", "runtimes": [0.00030922889709472656, 0.0003101825714111328, 0.0003104209899902344, 0.00031447410583496094, 0.0003199577331542969, 0.0003223419189453125, 0.0003228187561035156, 0.00032448768615722656, 0.0003342628479003906, 0.0003387928009033203, 0.0003428459167480469, 0.0003476142883300781, 0.00035309791564941406, 0.0003676414489746094, 0.00038433074951171875], "beyond_p": 0.9492063492063492}], "power-of-three": [{"slug_name": "power-of-three", "status": {"result": "passed", "runtime": 0.0002739429473876953, "index": 0}, "solution": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n%3 == 0:\n            return self.isPowerOfThree(n/3)\n        else:\n            return False", "runtimes": [0.0002598762512207031, 0.00026035308837890625, 0.00026035308837890625, 0.0002624988555908203, 0.0002624988555908203, 0.00026702880859375, 0.0002677440643310547, 0.00026798248291015625, 0.0002739429473876953, 0.00027751922607421875, 0.00027823448181152344, 0.0002796649932861328, 0.0002810955047607422, 0.0002815723419189453, 0.0002849102020263672, 0.0002849102020263672, 0.00028586387634277344, 0.000301361083984375, 0.00031828880310058594, 0.0004608631134033203], "beyond_p": 0.930011862396204}], "binary-tree-maximum-path-sum": [{"slug_name": "binary-tree-maximum-path-sum", "status": {"result": "passed", "runtime": 0.0033583641052246094, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_sum(node):\n            if not node:\n                return 0\n            left = max(max_sum(node.left), 0)\n            right = max(max_sum(node.right), 0)\n            self.max_sum = max(self.max_sum, left + right + node.val)\n            return node.val + max(left, right)\n        \n        self.max_sum = float('-inf')\n        max_sum(root)\n        return self.max_sum", "runtimes": [0.0028443336486816406, 0.002965211868286133, 0.0029878616333007812, 0.0030562877655029297, 0.003101825714111328, 0.0031080245971679688, 0.0031113624572753906, 0.0031499862670898438, 0.0031964778900146484, 0.003255128860473633, 0.00336456298828125, 0.0034072399139404297, 0.003422260284423828, 0.0035400390625, 0.0036089420318603516, 0.0037755966186523438, 0.0038836002349853516, 0.00437164306640625, 0.00449061393737793, 0.004630327224731445, 0.006281375885009766], "beyond_p": 0.8504439511653719}], "trapping-rain-water-ii": [{"slug_name": "trapping-rain-water-ii", "status": {"result": "failed@cases", "runtime": 0.0038614273071289062, "index": 0}, "solution": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Find the bounding rectangle\n        R = len(heightMap)\n        C = len(heightMap[0])\n        visited = [[False] * C for _ in range(R)]\n        q = []\n        for r in range(R):\n            for c in range(C):\n                if r in [0, R-1] or c in [0, C-1]:\n                    q.append((r, c))\n                    visited[r][c] = True\n        \n        # BFS\n        ans = 0\n        while q:\n            cell = q.pop(0)\n            for nr, nc in [(cell[0]-1, cell[1]), (cell[0]+1, cell[1]), (cell[0], cell[1]-1), (cell[0], cell[1]+1)]:\n                if 0 <= nr < R and 0 <= nc < C and not visited[nr][nc]:\n                    visited[nr][nc] = True\n                    height = heightMap[nr][nc]\n                    if height < heightMap[cell[0]][cell[1]]:\n                        ans += heightMap[cell[0]][cell[1]] - height\n                    q.append((nr, nc))\n        return ans", "runtimes": [0.0048978328704833984, 0.004899024963378906, 0.005447864532470703, 0.00599360466003418, 0.006310224533081055, 0.006398200988769531, 0.006421327590942383, 0.0067560672760009766, 0.007303953170776367, 0.007852554321289062, 0.00851130485534668, 0.008877754211425781, 0.010351896286010742, 0.010951519012451172, 0.013121604919433594, 0.014577150344848633, 0.015531301498413086], "beyond_p": 0.0}], "valid-palindrome": [{"slug_name": "valid-palindrome", "status": {"result": "passed", "runtime": 0.00046181678771972656, "index": 0}, "solution": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = ''.join(filter(str.isalnum, s))\n        return s == s[::-1]", "runtimes": [0.0004248619079589844, 0.00043129920959472656, 0.0004317760467529297, 0.00043201446533203125, 0.0004398822784423828, 0.0004410743713378906, 0.00044226646423339844, 0.0004467964172363281, 0.0004470348358154297, 0.0004475116729736328, 0.0004508495330810547, 0.0004532337188720703, 0.0004534721374511719, 0.0004544258117675781, 0.0004546642303466797, 0.00045609474182128906, 0.00045800209045410156, 0.00045871734619140625, 0.0004603862762451172, 0.0004608631134033203, 0.0004630088806152344, 0.00047850608825683594, 0.0004940032958984375, 0.0006580352783203125], "beyond_p": 0.8415132924335378}], "sliding-window-median": [{"slug_name": "sliding-window-median", "status": {"result": "failed@cases", "runtime": 0.002617359161376953, "index": 0}, "solution": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the result array\n        result = []\n        \n        # 2. Initialize the window\n        window = []\n        \n        # 3. Loop through the array\n        for i in range(len(nums)):\n            \n            # 4. Add the current element to the window\n            window.append(nums[i])\n            \n            # 5. If the window size is greater than k, remove the first element\n            if len(window) > k:\n                window.pop(0)\n            \n            # 6. If the window size is equal to k, add the median to the result array\n            if len(window) == k:\n                result.append(self.getMedian(window))\n        \n        # 7. Return the result array\n        return result\n    \n    def getMedian(self, window):\n        \"\"\"\n        :type window: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # 1. Sort the window\n        window.sort()\n        \n        # 2. If the window size is even, return the mean of the middle two elements\n        if len(window) % 2 == 0:\n            return (window[len(window) // 2 - 1] + window[len(window) // 2]) / 2\n        \n        # 3. If the window size is odd, return the middle element\n        else:\n            return window[len(window) // 2]", "runtimes": [0.0012061595916748047, 0.0012726783752441406, 0.0013298988342285156, 0.0019655227661132812, 0.0019719600677490234, 0.0020263195037841797, 0.002028942108154297, 0.0020313262939453125, 0.0023653507232666016, 0.0023679733276367188, 0.0024826526641845703, 0.003368377685546875, 0.004369258880615234, 0.005598545074462891, 0.006047487258911133, 0.013988733291625977, 0.019990921020507812, 0.039229393005371094, 0.039530038833618164], "beyond_p": 0.0}], "rotate-list": [{"slug_name": "rotate-list", "status": {"result": "failed@cases", "runtime": 0.0005583763122558594, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        \n        # find the length of the list\n        length = 0\n        temp = head\n        while temp is not None:\n            length += 1\n            temp = temp.next\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k % length):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = head\n        for i in range(length - 1):\n            new_tail = new_tail.next\n        \n        # make the new tail point to the head\n        new_tail.next = head\n        \n        # make the new head point to None\n        new_head.next = None\n        \n        return new_head", "runtimes": [0.0005879402160644531, 0.0005919933319091797, 0.0005953311920166016, 0.0005996227264404297, 0.0006043910980224609, 0.0006072521209716797, 0.0006098747253417969, 0.0006101131439208984, 0.0006365776062011719, 0.0006365776062011719, 0.0006415843963623047, 0.0006916522979736328, 0.0009436607360839844, 0.0009713172912597656], "beyond_p": 0.0}], "ugly-number": [{"slug_name": "ugly-number", "status": {"result": "passed", "runtime": 0.00028204917907714844, "index": 0}, "solution": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n % 2 == 0:\n            return self.isUgly(n/2)\n        if n % 3 == 0:\n            return self.isUgly(n/3)\n        if n % 5 == 0:\n            return self.isUgly(n/5)\n        return False", "runtimes": [0.0002541542053222656, 0.0002627372741699219, 0.0002639293670654297, 0.0002644062042236328, 0.00026679039001464844, 0.0002675056457519531, 0.0002677440643310547, 0.00026869773864746094, 0.000270843505859375, 0.000270843505859375, 0.0002791881561279297, 0.0002808570861816406, 0.00028204917907714844, 0.0002830028533935547, 0.00029850006103515625], "beyond_p": 0.3709677419354839}], "falling-squares": [{"slug_name": "falling-squares", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize variables\n        max_height = 0\n        heights = {}\n        ans = []\n        \n        # Loop through each position\n        for i in range(len(positions)):\n            \n            # Get the current position\n            left, side_length = positions[i]\n            \n            # Get the current height\n            height = 0\n            \n            # Loop through each position in the heights dictionary\n            for j in range(left, left + side_length):\n                height = max(height, heights.get(j, 0))\n            \n            # Update the height\n            height += side_length\n            \n            # Update the max height\n            max_height = max(max_height, height)\n            \n            # Update the heights dictionary\n            for j in range(left, left + side_length):\n                heights[j] = height\n            \n            # Add the max height to the answer\n            ans.append(max_height)\n            \n        return ans", "runtimes": [0.0006146430969238281, 0.0011980533599853516, 0.0012159347534179688, 0.0015108585357666016, 0.0025320053100585938, 0.003118276596069336, 0.00386810302734375, 0.004685401916503906, 0.005129337310791016, 0.012797832489013672, 0.03436636924743652], "beyond_p": 0.0}], "sum-of-left-leaves": [{"slug_name": "sum-of-left-leaves", "status": {"result": "passed", "runtime": 0.0032927989959716797, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)", "runtimes": [0.0031561851501464844, 0.0032553672790527344, 0.003279447555541992, 0.0033075809478759766, 0.0033245086669921875, 0.003489255905151367, 0.003500699996948242, 0.0035271644592285156, 0.003543853759765625, 0.0035822391510009766, 0.003640890121459961, 0.0036497116088867188], "beyond_p": 0.7231884057971014}], "max-sum-of-rectangle-no-larger-than-k": [{"slug_name": "max-sum-of-rectangle-no-larger-than-k", "status": {"result": "failed@cases", "runtime": 0.000835418701171875, "index": 0}, "solution": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maximum sum to be 0\n        max_sum = 0\n        \n        # Loop through each row of the matrix\n        for i in range(len(matrix)):\n            \n            # Initialize a list to store the prefix sum\n            prefix_sum = [0] * len(matrix[i])\n            \n            # Loop through each column of the matrix\n            for j in range(i, len(matrix)):\n                \n                # Calculate the prefix sum\n                for l in range(len(matrix[j])):\n                    prefix_sum[l] += matrix[j][l]\n                \n                # Initialize two pointers for binary search\n                left, right = 0, len(prefix_sum) - 1\n                \n                # Loop through each prefix sum\n                for m in range(len(prefix_sum)):\n                    \n                    # Check if the prefix sum is less than k\n                    if prefix_sum[m] <= k:\n                        \n                        # Binary search to find the largest rectangle\n                        while left < right:\n                            if prefix_sum[right] - prefix_sum[m] > k:\n                                right -= 1\n                            else:\n                                break\n                        \n                        # Update the maximum sum\n                        max_sum = max(max_sum, prefix_sum[right] - prefix_sum[m])\n                    \n                    # If the prefix sum is greater than k\n                    else:\n                        \n                        # Binary search to find the smallest rectangle\n                        while left < right:\n                            if prefix_sum[left + 1] - prefix_sum[m] <= k:\n                                left += 1\n                            else:\n                                break\n                        \n                        # Update the maximum sum\n                        max_sum = max(max_sum, prefix_sum[left] - prefix_sum[m])\n                \n        return max_sum", "runtimes": [0.0009920597076416016, 0.0010955333709716797, 0.001299142837524414, 0.001306772232055664, 0.0013380050659179688, 0.0014891624450683594, 0.0015614032745361328, 0.0016884803771972656, 0.0020155906677246094, 0.0031211376190185547, 0.0036334991455078125, 0.004111051559448242, 0.004225015640258789, 0.004880189895629883, 0.0073926448822021484], "beyond_p": 0.0}], "divide-two-integers": [{"slug_name": "divide-two-integers", "status": {"result": "passed", "runtime": 0.0002524852752685547, "index": 0}, "solution": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if divisor == -1:\n            return -dividend\n        \n        sign = 1\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0):\n            sign = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        quotient = 0\n        while dividend >= divisor:\n            temp = divisor\n            i = 0\n            while dividend >= temp:\n                dividend -= temp\n                quotient += 2**i\n                i += 1\n                temp <<= 1\n                \n        if sign == -1:\n            quotient = -quotient\n        \n        if quotient >= 2**31 - 1:\n            return 2**31 - 1\n        if quotient <= -2**31:\n            return -2**31\n        \n        return quotient", "runtimes": [0.00023102760314941406, 0.0002338886260986328, 0.00024056434631347656, 0.0002422332763671875, 0.00024437904357910156, 0.0002446174621582031, 0.00024580955505371094, 0.00024771690368652344, 0.0002491474151611328, 0.0002543926239013672, 0.00025582313537597656, 0.00025653839111328125, 0.0002598762512207031, 0.00026798248291015625, 0.0002689361572265625], "beyond_p": 0.4339622641509434}], "surrounded-regions": [{"slug_name": "surrounded-regions", "status": {"result": "passed", "runtime": 0.0004885196685791016, "index": 0}, "solution": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        rows = len(board)\n        cols = len(board[0])\n        \n        def dfs(r, c):\n            if 0 <= r < rows and 0 <= c < cols and board[r][c] == 'O':\n                board[r][c] = 'A'\n                dfs(r-1, c)\n                dfs(r+1, c)\n                dfs(r, c-1)\n                dfs(r, c+1)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if i == 0 or i == rows-1 or j == 0 or j == cols-1:\n                    dfs(i, j)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'", "runtimes": [0.00038933753967285156, 0.0004036426544189453, 0.00040411949157714844, 0.0004634857177734375, 0.00048732757568359375, 0.0004875659942626953, 0.0004887580871582031, 0.0004913806915283203, 0.0005049705505371094, 0.0005068778991699219, 0.0005121231079101562, 0.0005197525024414062, 0.0005204677581787109, 0.0005271434783935547, 0.0005338191986083984, 0.0005402565002441406, 0.0005538463592529297, 0.0005548000335693359, 0.0005848407745361328, 0.0006034374237060547, 0.0006222724914550781], "beyond_p": 0.5742067553735927}], "two-sum": [{"slug_name": "two-sum", "status": {"result": "passed", "runtime": 0.00026416778564453125, "index": 0}, "solution": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i]+nums[j]==target:\n                    return [i,j]", "runtimes": [0.00026226043701171875, 0.00026226043701171875, 0.0002636909484863281, 0.0002639293670654297, 0.0002646446228027344, 0.00026607513427734375, 0.00026679039001464844, 0.00026726722717285156, 0.0002684593200683594, 0.0002696514129638672, 0.00026988983154296875, 0.00027060508728027344, 0.0002713203430175781, 0.0002722740173339844, 0.000274658203125, 0.0002803802490234375, 0.0002827644348144531, 0.00028514862060546875, 0.00028967857360839844, 0.0003001689910888672], "beyond_p": 0.949685534591195}], "24-game": [{"slug_name": "24-game", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def solve(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i+1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    rest = cards[:i] + cards[i+1:j] + cards[j+1:]\n                    if solve(rest + [a+b, a-b, a*b, b-a, a/b, b/a]):\n                        return True\n            return False\n        return solve(cards)", "runtimes": [0.0030896663665771484, 0.008093833923339844, 0.01071619987487793, 0.024008512496948242, 0.03816652297973633, 0.04826712608337402, 0.08198714256286621, 0.09071826934814453, 0.10068178176879883, 0.10096549987792969, 0.10180997848510742], "beyond_p": 0.0}], "wildcard-matching": [{"slug_name": "wildcard-matching", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # If pattern is empty then return False if string is not empty\n        if p == \"\":\n            return s == \"\"\n        \n        # If pattern is not empty and string is empty then return False\n        if s == \"\":\n            return False\n        \n        # If last character of pattern is '*' then remove it\n        if p[-1] == \"*\":\n            p = p[:-1]\n        \n        # If last character of string is not '*' then remove it\n        if s[-1] != \"*\":\n            s = s[:-1]\n        \n        # If last character of pattern is '?' or last character of both pattern and string are same then remove last character from both\n        if p[-1] == \"?\" or p[-1] == s[-1]:\n            p = p[:-1]\n            s = s[:-1]\n        \n        # If pattern is empty then return True\n        if p == \"\":\n            return True\n        \n        # If string is empty then return False\n        if s == \"\":\n            return False\n        \n        # If last character of pattern is '*' then True\n        if p[-1] == \"*\":\n            return True\n        \n        # If last character of string is not '*' then return False\n        if s[-1] != \"*\":\n            return False\n        \n        # If last character of both pattern and string are same then return True\n        if p[-1] == s[-1]:\n            return True\n        \n        # If last character of pattern is '?' then return True\n        if p[-1] == \"?\":\n            return True\n        \n        # Else return False\n        return False", "runtimes": [0.0002741813659667969, 0.0002760887145996094, 0.00027632713317871094, 0.00028061866760253906, 0.0002880096435546875, 0.0003285408020019531, 0.0003421306610107422, 0.000354766845703125, 0.0004417896270751953, 0.0005638599395751953, 0.0006198883056640625, 0.000766754150390625, 0.014548301696777344, 0.015726566314697266, 0.02013397216796875, 0.06107497215270996, 0.6302249431610107, 1.2995474338531494, 1.3343396186828613, 1.36012864112854, 1.4366590976715088, 1.4623749256134033, 1.8837080001831055, 3.628636121749878], "beyond_p": 0.0}], "majority-element": [{"slug_name": "majority-element", "status": {"result": "passed", "runtime": 0.0004000663757324219, "index": 0}, "solution": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a dictionary to store the count of each element\n        count = {}\n        \n        # Loop through the array\n        for i in nums:\n            if i in count:\n                count[i] += 1\n            else:\n                count[i] = 1\n        \n        # Find the element with the highest count\n        max_count = max(count.values())\n        \n        # Return the element with the highest count\n        for key, value in count.items():\n            if value == max_count:\n                return key", "runtimes": [0.0003273487091064453, 0.00033211708068847656, 0.0003323554992675781, 0.0003337860107421875, 0.0003368854522705078, 0.00033783912658691406, 0.0003399848937988281, 0.0003402233123779297, 0.0003414154052734375, 0.00035381317138671875, 0.0003795623779296875, 0.0003829002380371094, 0.0003943443298339844, 0.00040149688720703125, 0.0004048347473144531, 0.0004582405090332031, 0.00046181678771972656, 0.00048232078552246094, 0.0004856586456298828, 0.0004901885986328125, 0.0008628368377685547, 0.002893686294555664], "beyond_p": 0.9716648086213303}], "reconstruct-itinerary": [{"slug_name": "reconstruct-itinerary", "status": {"result": "failed@cases", "runtime": 0.0002307891845703125, "index": 0}, "solution": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Create a dictionary to store the itinerary\n        itinerary = {}\n        \n        # Create a dictionary to store the lexical order\n        lexical_order = {}\n        \n        # Create a dictionary to store the number of tickets\n        ticket_count = {}\n        \n        # Create a list to store the itinerary\n        itinerary_list = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the itinerary\n        itinerary_list_final_final_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the lexical order\n        lexical_order_list_final_final_final_final_final_final_final_final_final = []\n        \n        # Create a list to store the number of tickets\n        ticket_count_list_final", "runtimes": [0.0002734661102294922, 0.0002772808074951172, 0.000278472900390625, 0.0002892017364501953, 0.00030231475830078125, 0.0003082752227783203, 0.00032258033752441406, 0.0003235340118408203, 0.00033783912658691406, 0.0003399848937988281, 0.0003478527069091797, 0.0003616809844970703, 0.00036525726318359375, 0.0003654956817626953, 0.00036644935607910156, 0.0003705024719238281, 0.0003724098205566406], "beyond_p": 0.0}], "4sum": [{"slug_name": "4sum", "status": {"result": "passed", "runtime": 0.24500441551208496, "index": 0}, "solution": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j>i+1 and nums[j] == nums[j-1]:\n                    continue\n                low = j+1\n                high = len(nums)-1\n                while low < high:\n                    if nums[i] + nums[j] + nums[low] + nums[high] == target:\n                        res.append([nums[i], nums[j], nums[low], nums[high]])\n                        low += 1\n                        high -= 1\n                        while low < high and nums[low] == nums[low-1]:\n                            low += 1\n                        while low < high and nums[high] == nums[high+1]:\n                            high -= 1\n                    elif nums[i] + nums[j] + nums[low] + nums[high] > target:\n                        high -= 1\n                    else:\n                        low += 1\n        return res", "runtimes": [0.06050586700439453, 0.09101223945617676, 0.09948897361755371, 0.10982871055603027, 0.11513113975524902, 0.1224062442779541, 0.1372370719909668, 0.14409756660461426, 0.1465587615966797, 0.14667439460754395, 0.1944899559020996, 0.20119118690490723, 0.23067235946655273, 0.2653357982635498, 0.2915334701538086], "beyond_p": 0.20140041279669763}], "the-skyline-problem": [{"slug_name": "the-skyline-problem", "status": {"result": "failed@cases", "runtime": 0.0005233287811279297, "index": 0}, "solution": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. Sort the buildings by their right endpoint,\n        #    and sort the buildings with the same right endpoint by their height.\n        # 2. Use a heap to store the current buildings in the skyline.\n        #    If a building has a height that is currently in the heap,\n        #    we remove the height and add the new height.\n        # 3. Iterate through the buildings, maintain a variable prev\n        #    to store the previous height in the skyline.\n        #    If the current height is different from prev, we add the point\n        #    to the skyline.\n        # 4. The skyline is then constructed by merging the heights and the x-coordinates.\n        \n        # Sort by right endpoint, then by height.\n        buildings.sort(key=lambda x: (x[1], x[2]))\n        \n        res = []\n        heap = [(0, float('inf'))]\n        prev = 0\n        \n        for building in buildings:\n            while heap[0][1] <= building[0]:\n                heapq.heappop(heap)\n            if heap[0][0] != building[2]:\n                res.append([building[0], building[2]])\n                prev = building[2]\n            heapq.heappush(heap, (building[2], building[1]))\n        \n        return res", "runtimes": [0.0005362033843994141, 0.0007302761077880859, 0.0007889270782470703, 0.0008263587951660156, 0.000949859619140625, 0.0010018348693847656, 0.0010561943054199219, 0.0013082027435302734, 0.0013878345489501953, 0.002302885055541992, 0.002309083938598633, 0.002386808395385742, 0.0023946762084960938, 0.0024824142456054688, 0.0029816627502441406, 0.0035140514373779297, 0.0036902427673339844, 0.003709554672241211], "beyond_p": 0.0}], "reverse-string": [{"slug_name": "reverse-string", "status": {"result": "passed", "runtime": 0.00042057037353515625, "index": 0}, "solution": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # Two pointer approach\n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1", "runtimes": [0.00025653839111328125, 0.0002887248992919922, 0.0002911090850830078, 0.00029158592224121094, 0.00030231475830078125, 0.0003147125244140625, 0.0004115104675292969, 0.00041794776916503906, 0.0004189014434814453, 0.000423431396484375, 0.00042557716369628906, 0.00043082237243652344, 0.0004317760467529297, 0.0004379749298095703, 0.0004398822784423828, 0.0004401206970214844, 0.00044655799865722656, 0.00044727325439453125, 0.0004513263702392578, 0.00045990943908691406, 0.0005469322204589844, 0.0006458759307861328, 0.0009558200836181641], "beyond_p": 0.7654278895329014}], "reverse-linked-list": [{"slug_name": "reverse-linked-list", "status": {"result": "passed", "runtime": 0.00033855438232421875, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        else:\n            current = head\n            previous = None\n            while current is not None:\n                next = current.next\n                current.next = previous\n                previous = current\n                current = next\n            return previous", "runtimes": [0.0003094673156738281, 0.0003147125244140625, 0.0003159046173095703, 0.00031757354736328125, 0.00031828880310058594, 0.00031876564025878906, 0.0003190040588378906, 0.00031948089599609375, 0.00031948089599609375, 0.0003223419189453125, 0.00032639503479003906, 0.00032806396484375, 0.00032830238342285156, 0.000331878662109375, 0.0003414154052734375], "beyond_p": 0.08955223880597014}], "triangle": [{"slug_name": "triangle", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array with the first row\n        dp = triangle[0]\n        \n        # Loop through the rest of the rows\n        for row in triangle[1:]:\n            # Initialize the new row\n            new_row = [0] * len(row)\n            \n            # Loop through the current row\n            for i in range(len(row)):\n                # Calculate the minimum path sum\n                new_row[i] = min(dp[i], dp[i-1]) + row[i]\n                \n            # Update the dp array\n            dp = new_row\n            \n        # Return the minimum path sum\n        return min(dp)", "runtimes": [0.0003476142883300781, 0.0003552436828613281, 0.0003650188446044922, 0.0003654956817626953, 0.00036907196044921875, 0.0003752708435058594, 0.0003757476806640625, 0.0003764629364013672, 0.00038361549377441406, 0.0003991127014160156, 0.00040531158447265625, 0.00044083595275878906, 0.0004487037658691406, 0.00045561790466308594, 0.0004749298095703125, 0.00048041343688964844, 0.0005006790161132812, 0.0005772113800048828, 0.0006885528564453125, 0.0007431507110595703], "beyond_p": 0.0}], "integer-to-english-words": [{"slug_name": "integer-to-english-words", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return numbers[num] + \" \"\n            elif num < 100:\n                return helper(num - num % 10) + numbers[num] + \" \"\n            elif num < 1000:\n                return helper(num // 100) + \"Hundred \" + helper(num % 100)\n            elif num < 1000000:\n                return helper(num // 1000) + \"Thousand \" + helper(num % 1000)\n            elif num < 1000000000:\n                return helper(num // 1000000) + \"Million \" + helper(num % 1000000)\n            else:\n                return helper(num // 1000000000) + \"Billion \" + helper(num % 1000000000)\n        \n        numbers = ['', 'One ', 'Two ', 'Three ', 'Four ', 'Five ', 'Six ', 'Seven ', 'Eight ', 'Nine ', 'Ten ', 'Eleven ', 'Twelve ', 'Thirteen ', 'Fourteen ', 'Fifteen ', 'Sixteen ', 'Seventeen ', 'Eighteen ', 'Nineteen ']\n        numbers2 = ['', '', 'Twenty ', 'Thirty ', 'Forty ', 'Fifty ', 'Sixty ', 'Seventy ', 'Eighty ', 'Ninety ']\n        \n        return helper(num).strip()", "runtimes": [0.0002841949462890625, 0.00029158592224121094, 0.00029468536376953125, 0.00029468536376953125, 0.0002956390380859375, 0.0002970695495605469, 0.0003001689910888672, 0.00030612945556640625, 0.0003070831298828125, 0.0003077983856201172, 0.0003108978271484375, 0.0003409385681152344, 0.0003666877746582031, 0.00037598609924316406], "beyond_p": 0.0}], "k-inverse-pairs-array": [{"slug_name": "k-inverse-pairs-array", "status": {"result": "failed@cases", "runtime": 0.24066495895385742, "index": 0}, "solution": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n                if i >= 2:\n                    dp[i][j] = (dp[i][j] - dp[i-2][j-1] + MOD) % MOD\n        return dp[n][k]", "runtimes": [0.1092386245727539, 0.11138081550598145, 0.11203145980834961, 0.14353466033935547, 0.14605975151062012, 0.1583540439605713, 0.17345809936523438, 0.19068670272827148, 0.21047258377075195, 0.223710298538208, 0.23826336860656738, 0.30243730545043945, 0.31754088401794434, 0.3833131790161133, 0.42995738983154297, 0.43890953063964844, 0.6241693496704102, 0.7205395698547363, 0.8042428493499756], "beyond_p": 0.0}], "swap-nodes-in-pairs": [{"slug_name": "swap-nodes-in-pairs", "status": {"result": "passed", "runtime": 0.0005364418029785156, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead", "runtimes": [0.0005154609680175781, 0.0005199909210205078, 0.0005207061767578125, 0.0005235671997070312, 0.0005238056182861328, 0.0005276203155517578, 0.0005283355712890625, 0.0005283355712890625, 0.0005288124084472656, 0.0005323886871337891, 0.0005340576171875, 0.0005342960357666016, 0.0005364418029785156, 0.0005364418029785156, 0.000537872314453125, 0.0005409717559814453, 0.0005409717559814453, 0.0005409717559814453, 0.0005433559417724609, 0.0005452632904052734, 0.000545501708984375, 0.0005457401275634766, 0.0005476474761962891, 0.0005490779876708984, 0.0005497932434082031, 0.000553131103515625, 0.0005631446838378906, 0.0005698204040527344, 0.0005710124969482422, 0.0005850791931152344, 0.0005915164947509766], "beyond_p": 0.7241379310344828}], "path-sum": [{"slug_name": "path-sum", "status": {"result": "passed", "runtime": 0.0007395744323730469, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)", "runtimes": [0.0007305145263671875, 0.0007374286651611328, 0.0007417201995849609, 0.0007426738739013672, 0.0007472038269042969, 0.0007476806640625, 0.0007498264312744141, 0.0007517337799072266, 0.0007607936859130859, 0.0007607936859130859, 0.0007686614990234375, 0.0007696151733398438, 0.0007703304290771484, 0.0007774829864501953, 0.0007891654968261719, 0.000789642333984375, 0.0008072853088378906, 0.0008287429809570312, 0.0009524822235107422, 0.002151966094970703], "beyond_p": 0.9936262998993626}], "partition-list": [{"slug_name": "partition-list", "status": {"result": "passed", "runtime": 0.0008869171142578125, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        less = ListNode(0)\n        greater = ListNode(0)\n        lessHead = less\n        greaterHead = greater\n        \n        while head:\n            if head.val < x:\n                less.next = head\n                less = less.next\n            else:\n                greater.next = head\n                greater = greater.next\n            head = head.next\n        \n        less.next = greaterHead.next\n        greater.next = None\n        \n        return lessHead.next", "runtimes": [0.0008592605590820312, 0.000865936279296875, 0.0008816719055175781, 0.0008823871612548828, 0.0008966922760009766, 0.0009036064147949219, 0.0009081363677978516, 0.0009090900421142578, 0.0009157657623291016, 0.000919342041015625, 0.0009200572967529297, 0.00092315673828125, 0.0010929107666015625, 0.0010943412780761719, 0.0021588802337646484, 0.0022339820861816406], "beyond_p": 0.9798820672910163}], "redundant-connection-ii": [{"slug_name": "redundant-connection-ii", "status": {"result": "failed@cases", "runtime": 0.0011897087097167969, "index": 0}, "solution": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize a dictionary to keep track of all the nodes\n        # and their parents.\n        parents = {}\n        \n        # Initialize a dictionary to keep track of all the nodes\n        # and their children.\n        children = {}\n        \n        # Initialize a set to keep track of all the nodes\n        # that have multiple parents.\n        multiple_parents = set()\n        \n        # Initialize a set to keep track of all the nodes\n        # that have multiple children.\n        multiple_children = set()\n        \n        # Iterate over all the edges in the graph.\n        for edge in edges:\n            \n            # If the child is already in the dictionary of parents,\n            # then we have found a cycle in the graph.\n            if edge[1] in parents:\n                \n                # If the parent of the child is not the same as the\n                # new parent, then we have found a redundant edge.\n                if parents[edge[1]] != edge[0]:\n                    return edge\n                \n                # If the parent of the child is the same as the new\n                # parent, then we have found a redundant edge.\n                else:\n                    return [parents[edge[1]], edge[1]]\n            \n            # If the child is not in the dictionary of parents, then\n            # we add the child to the dictionary of parents.\n            else:\n                parents[edge[1]] = edge[0]\n            \n            # If the parent is already in the dictionary of children,\n            # then we have found a node with multiple children.\n            if edge[0] in children:\n                \n                # If the child is not already in the list of children,\n                # then we add the child to the list of children.\n                if edge[1] not in children[edge[0]]:\n                    children[edge[0]].append(edge[1])\n                \n                # If the child is already in the list of children, then\n                # we have found a node with multiple parents.\n                else:\n                    multiple_parents.add(edge[1])\n                    multiple_children.add(edge[0])\n            \n            # If the parent is not in the dictionary of children, then\n            # we add the parent to the dictionary of children.\n            else:\n                children[edge[0]] = [edge[1]]\n        \n        # If there are no nodes with multiple parents, then we return\n        # the last edge in the graph.\n        if not multiple_parents:\n            return edges[-1]\n        \n        # If there are nodes with multiple parents, then we iterate\n        # over all the nodes with multiple parents.\n        for node in multiple_parents:\n            \n            # If the node is also a node with multiple children, then\n            # we return the edge between the node and its parent.\n            if node in multiple_children:\n                return [parents[node], node]", "runtimes": [0.0013630390167236328, 0.0026328563690185547, 0.0029151439666748047, 0.0030684471130371094, 0.003329038619995117, 0.003419637680053711, 0.004365682601928711, 0.0044384002685546875, 0.005157470703125, 0.005451679229736328, 0.031371355056762695, 0.03204822540283203, 0.05643606185913086, 0.15896153450012207, 0.15977787971496582, 0.16025376319885254, 0.16834259033203125, 2.7307703495025635], "beyond_p": 0.0}], "permutations-ii": [{"slug_name": "permutations-ii", "status": {"result": "passed", "runtime": 0.0003647804260253906, "index": 0}, "solution": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Create a list to store the permutations\n        permutations = []\n        \n        # Create a list to mark the elements as visited\n        visited = [False] * len(nums)\n        \n        # Call the helper function to generate the permutations\n        self.generate_permutations(nums, permutations, visited, [])\n        \n        return permutations\n    \n    def generate_permutations(self, nums, permutations, visited, current):\n        # If the length of the 'current' array is equal to the length of the 'nums' array,\n        # then we have reached the end of the permutation\n        if len(current) == len(nums):\n            permutations.append(current[:])\n            return\n        \n        # Iterate over the elements of the 'nums' array\n        for i in range(len(nums)):\n            \n            # If the element is already visited, then continue to the next iteration\n            if visited[i]:\n                continue\n            \n            # If the previous element is the same as the current element,\n            # and the previous element is not visited, then continue to the next iteration\n            if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                continue\n            \n            # Mark the element as visited\n            visited[i] = True\n            \n            # Add the element to the 'current' array\n            current.append(nums[i])\n            \n            # Call the helper function recursively\n            self.generate_permutations(nums, permutations, visited, current)\n            \n            # Remove the element from the 'current' array\n            current.pop()\n            \n            # Mark the element as not visited\n            visited[i] = False", "runtimes": [0.0002753734588623047, 0.00030493736267089844, 0.0003151893615722656, 0.00032448768615722656, 0.0003261566162109375, 0.0003266334533691406, 0.0003323554992675781, 0.00033473968505859375, 0.0003361701965332031, 0.0003571510314941406, 0.00037860870361328125, 0.00038743019104003906, 0.00039315223693847656, 0.00039386749267578125, 0.00040841102600097656, 0.0004134178161621094, 0.0004222393035888672, 0.00042510032653808594, 0.0004372596740722656, 0.0004508495330810547, 0.0004703998565673828, 0.0008246898651123047], "beyond_p": 0.8372395833333334}], "add-digits": [{"slug_name": "add-digits", "status": {"result": "passed", "runtime": 0.00025725364685058594, "index": 0}, "solution": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num-1)%9+1", "runtimes": [0.0002307891845703125, 0.00023126602172851562, 0.00023245811462402344, 0.00023746490478515625, 0.00023889541625976562, 0.00023937225341796875, 0.00024127960205078125, 0.00024247169494628906, 0.0002472400665283203, 0.0002529621124267578, 0.000255584716796875, 0.0002570152282714844, 0.0002646446228027344, 0.0002665519714355469], "beyond_p": 0.26}], "single-number": [{"slug_name": "single-number", "status": {"result": "passed", "runtime": 0.00035190582275390625, "index": 0}, "solution": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # a XOR a = 0\n        # a XOR 0 = a\n        # a XOR b XOR a = (a XOR a) XOR b = 0 XOR b = b\n        # a XOR b XOR c XOR a = (a XOR a) XOR b XOR c = 0 XOR b XOR c = b XOR c\n        # a XOR b XOR c XOR d XOR a = (a XOR a) XOR b XOR c XOR d = 0 XOR b XOR c XOR d = b XOR c XOR d\n        # ...\n        # a XOR b XOR c XOR d XOR ... XOR n XOR a = (a XOR a) XOR b XOR c XOR d XOR ... XOR n = 0 XOR b XOR c XOR d XOR ... XOR n = b XOR c XOR d XOR ... XOR n\n        # So, if we XOR all elements together, the result will be the single number.\n        \n        result = 0\n        for num in nums:\n            result ^= num\n        return result", "runtimes": [0.0003616809844970703, 0.0004150867462158203, 0.00043082237243652344, 0.00044417381286621094, 0.00046324729919433594, 0.0004658699035644531, 0.0004825592041015625, 0.00048542022705078125, 0.00048661231994628906, 0.0005586147308349609, 0.0005915164947509766, 0.0006067752838134766, 0.0006427764892578125, 0.0006453990936279297, 0.0006575584411621094, 0.0006678104400634766, 0.0006749629974365234, 0.0006844997406005859, 0.0007138252258300781, 0.0007236003875732422, 0.0007262229919433594, 0.0007312297821044922, 0.0007426738739013672, 0.0007536411285400391], "beyond_p": 1.0249391727493917}], "length-of-last-word": [{"slug_name": "length-of-last-word", "status": {"result": "passed", "runtime": 0.0006825923919677734, "index": 0}, "solution": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = s.strip()\n        if len(s) == 0:\n            return 0\n        else:\n            return len(s.split()[-1])", "runtimes": [0.0002846717834472656, 0.0002911090850830078, 0.0004889965057373047, 0.0004913806915283203, 0.000492095947265625, 0.0004971027374267578, 0.0005011558532714844, 0.0005090236663818359, 0.0005130767822265625, 0.0005202293395996094, 0.0005257129669189453, 0.0005729198455810547, 0.0006353855133056641, 0.0018754005432128906], "beyond_p": 0.7498501199040767}], "cherry-pickup": [{"slug_name": "cherry-pickup", "status": {"result": "failed@cases", "runtime": 0.00023174285888671875, "index": 0}, "solution": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j][k] represents the maximum number of cherries you can collect by following the rules below:\n        # Starting at the position (0, 0) and reaching (i, j) by moving right or down through valid path cells (cells with value 0 or 1).\n        # After reaching (i, j), returning to (0, 0) by moving left or up through valid path cells.\n        # When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\n        # If there is no valid path between (0, 0) and (i, j), then dp[i][j][k] is -1.\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k], dp[i][j-1][k-1], dp[i][j][k-1], dp[i-1][j-1][k-2], dp[i-1][j][k-2], dp[i-1][j-1][k-2], dp[i][j-1][k-2])\n        # dp[i][j][k] = max(dp[i-1][j-1][k-1], dp[i-1][j][k-1], dp[i-1][j-1][k", "runtimes": [0.0007810592651367188, 0.0009546279907226562, 0.0009789466857910156, 0.0010306835174560547, 0.0010595321655273438, 0.0011990070343017578, 0.0012853145599365234, 0.0013005733489990234, 0.001306772232055664, 0.0013604164123535156, 0.001383066177368164, 0.001621246337890625, 0.0017309188842773438, 0.001743316650390625, 0.0019195079803466797, 0.0019316673278808594, 0.017061710357666016, 0.01810145378112793, 0.019754648208618164, 0.026942968368530273], "beyond_p": 0.0}], "student-attendance-record-ii": [{"slug_name": "student-attendance-record-ii", "status": {"result": "failed@cases", "runtime": 0.07473492622375488, "index": 0}, "solution": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 3\n        \n        for i in range(2, n+1):\n            dp[i] = (dp[i-1] * 3 + dp[i-2] * 2) % MOD\n            \n        return dp[n]", "runtimes": [0.006976127624511719, 0.008493900299072266, 0.11278438568115234, 0.21056675910949707, 0.6993510723114014, 0.8751211166381836, 0.9568586349487305, 1.0147161483764648, 1.2592353820800781, 1.338545799255371, 2.1226983070373535, 2.1282448768615723, 2.1929023265838623, 2.3077211380004883, 2.5005741119384766, 3.0594067573547363], "beyond_p": 0.0}], "happy-number": [{"slug_name": "happy-number", "status": {"result": "passed", "runtime": 0.00030684471130371094, "index": 0}, "solution": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_sum(n):\n            sum = 0\n            while n > 0:\n                sum += (n % 10) ** 2\n                n //= 10\n            return sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_sum(n)\n        return n == 1", "runtimes": [0.00026679039001464844, 0.00030493736267089844, 0.00030875205993652344, 0.00031113624572753906, 0.0003161430358886719, 0.0003204345703125, 0.0003294944763183594, 0.00033473968505859375, 0.00033926963806152344, 0.0003399848937988281, 0.0003414154052734375, 0.0003457069396972656, 0.000347137451171875, 0.0003490447998046875, 0.0003540515899658203, 0.0004553794860839844, 0.0004742145538330078, 0.0008685588836669922], "beyond_p": 0.9334389857369255}], "search-insert-position": [{"slug_name": "search-insert-position", "status": {"result": "passed", "runtime": 0.0002694129943847656, "index": 0}, "solution": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)", "runtimes": [0.0002620220184326172, 0.00026726722717285156, 0.00026798248291015625, 0.0002682209014892578, 0.0002689361572265625, 0.0002694129943847656, 0.0002694129943847656, 0.0002703666687011719, 0.000270843505859375, 0.0002715587615966797, 0.0002715587615966797, 0.0002722740173339844, 0.0002727508544921875, 0.0002732276916503906, 0.0002739429473876953, 0.0002739429473876953, 0.0002741813659667969, 0.0002751350402832031, 0.0002751350402832031, 0.0002770423889160156, 0.00027751922607421875, 0.00027942657470703125, 0.00028061866760253906, 0.0002846717834472656], "beyond_p": 0.6736842105263158}], "jump-game": [{"slug_name": "jump-game", "status": {"result": "passed", "runtime": 0.00023865699768066406, "index": 0}, "solution": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the maximum reachable index\n        maxReach = 0\n        \n        # Iterate over the array\n        for i in range(len(nums)):\n            \n            # If the current index is greater than the maximum reachable index,\n            # we can reach the current index from the previous index\n            if i <= maxReach:\n                \n                # Update the maximum reachable index\n                maxReach = max(maxReach, i + nums[i])\n                \n                # If the maximum reachable index is greater than or equal to the\n                # length of the array, we can reach the last index\n                if maxReach >= len(nums) - 1:\n                    return True\n                    \n        return False", "runtimes": [0.0002372264862060547, 0.0002503395080566406, 0.00025534629821777344, 0.0002646446228027344, 0.0002696514129638672, 0.00027108192443847656, 0.0002715587615966797, 0.00027251243591308594, 0.0002951622009277344, 0.0002956390380859375, 0.00029754638671875, 0.00030517578125, 0.0003097057342529297, 0.0003139972686767578, 0.0003216266632080078, 0.0003306865692138672, 0.0003380775451660156, 0.00034928321838378906, 0.00034999847412109375, 0.00035500526428222656, 0.0003752708435058594, 0.0003886222839355469], "beyond_p": 0.9905511811023622}], "minimum-path-sum": [{"slug_name": "minimum-path-sum", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp array with the first row\n        dp = grid[0]\n        \n        # Initialize the first column\n        for i in range(1, len(grid)):\n            dp[i] += dp[i-1]\n            \n        # Fill the rest of the dp table\n        for i in range(1, len(grid)):\n            for j in range(len(grid[i])):\n                if j == 0:\n                    dp[j] += dp[j]\n                else:\n                    dp[j] = min(dp[j], dp[j-1]) + grid[i][j]\n                    \n        return dp[-1]", "runtimes": [0.003072500228881836, 0.003086566925048828, 0.0031049251556396484, 0.0031080245971679688, 0.0031156539916992188, 0.003190279006958008, 0.0033142566680908203, 0.0034101009368896484, 0.0035309791564941406, 0.003635883331298828, 0.003833293914794922, 0.003942251205444336, 0.00671076774597168, 0.006812334060668945, 0.006852626800537109, 0.007907629013061523, 0.008586645126342773, 0.010343790054321289, 0.014853715896606445, 0.01588582992553711, 0.017912626266479492], "beyond_p": 0.0}], "count-and-say": [{"slug_name": "count-and-say", "status": {"result": "passed", "runtime": 0.0011093616485595703, "index": 0}, "solution": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        else:\n            prev = self.countAndSay(n-1)\n            count = 1\n            result = ''\n            for i in range(len(prev)-1):\n                if prev[i] == prev[i+1]:\n                    count += 1\n                else:\n                    result += str(count) + prev[i]\n                    count = 1\n            result += str(count) + prev[-1]\n            return result", "runtimes": [0.0007913112640380859, 0.0009355545043945312, 0.0009522438049316406, 0.0009648799896240234, 0.0010159015655517578, 0.0010366439819335938, 0.0010848045349121094, 0.0011589527130126953, 0.0012307167053222656, 0.001241445541381836, 0.0012972354888916016, 0.0013957023620605469, 0.0015521049499511719, 0.0015959739685058594, 0.0017366409301757812, 0.0017750263214111328, 0.0018100738525390625, 0.0020418167114257812, 0.004230022430419922], "beyond_p": 0.9075088400471469}], "split-array-largest-sum": [{"slug_name": "split-array-largest-sum", "status": {"result": "passed", "runtime": 0.003408670425415039, "index": 0}, "solution": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, mid):\n            cnt = 0\n            s = 0\n            for i in range(len(nums)):\n                s += nums[i]\n                if s > mid:\n                    cnt += 1\n                    s = nums[i]\n            cnt += 1\n            return cnt <= k\n        \n        def check_mid(nums, k, mid):\n            cnt = 0\n            s = 0\n            for i in range(len(nums)):\n                s += nums[i]\n                if s > mid:\n                    cnt += 1\n                    s = nums[i]\n            cnt += 1\n            return cnt\n        \n        l = max(nums)\n        r = sum(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if check(nums, k, mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "runtimes": [0.003556966781616211, 0.027626514434814453, 0.4258854389190674, 0.44832754135131836, 0.4534013271331787, 0.4699058532714844, 0.5532469749450684, 0.5627191066741943, 0.5765604972839355, 0.6012184619903564, 0.678635835647583, 0.874053955078125, 2.7405176162719727, 4.0803704261779785, 4.599152326583862, 5.162804841995239, 5.515106201171875, 6.360270023345947, 8.943416357040405, 10.415017127990723, 20.58179545402527], "beyond_p": 0.048595024332131004}], "search-in-rotated-sorted-array": [{"slug_name": "search-in-rotated-sorted-array", "status": {"result": "passed", "runtime": 0.0003597736358642578, "index": 0}, "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > nums[right]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1", "runtimes": [0.00034356117248535156, 0.0003504753112792969, 0.0003540515899658203, 0.0003559589385986328, 0.0003571510314941406, 0.00035881996154785156, 0.0003669261932373047, 0.0003695487976074219, 0.0003695487976074219, 0.0003719329833984375, 0.00037670135498046875, 0.0003829002380371094, 0.0006210803985595703, 0.0006237030029296875, 0.0007770061492919922, 0.0009737014770507812, 0.0016508102416992188], "beyond_p": 0.9875980302753967}], "letter-combinations-of-a-phone-number": [{"slug_name": "letter-combinations-of-a-phone-number", "status": {"result": "passed", "runtime": 0.0003597736358642578, "index": 0}, "solution": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        result = []\n        self.backtrack(digits, mapping, \"\", result)\n        return result\n    \n    def backtrack(self, digits, mapping, combination, result):\n        if len(digits) == 0:\n            result.append(combination)\n            return\n        \n        for letter in mapping[digits[0]]:\n            self.backtrack(digits[1:], mapping, combination + letter, result)", "runtimes": [0.00030994415283203125, 0.00032067298889160156, 0.0003418922424316406, 0.0003428459167480469, 0.00034332275390625, 0.0003440380096435547, 0.00034546852111816406, 0.00034880638122558594, 0.0003533363342285156, 0.0003535747528076172, 0.0003559589385986328, 0.00036072731018066406, 0.0003609657287597656, 0.0003628730773925781, 0.0003669261932373047, 0.00036907196044921875, 0.0003695487976074219, 0.0003695487976074219, 0.00038051605224609375, 0.00039196014404296875, 0.0003986358642578125, 0.00039887428283691406, 0.0004210472106933594, 0.0005152225494384766, 0.0005593299865722656, 0.000576019287109375], "beyond_p": 0.8127240143369175}], "combination-sum": [{"slug_name": "combination-sum", "status": {"result": "failed@cases", "runtime": 0.0010936260223388672, "index": 0}, "solution": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list in ascending order\n        candidates.sort()\n        \n        # Initialize an empty list to store the combinations\n        combinations = []\n        \n        # Call the helper function to find the combinations\n        self.helper(candidates, target, combinations, [], 0)\n        \n        return combinations\n    \n    def helper(self, candidates, target, combinations, current, index):\n        # If the target is 0, then the current combination is a valid answer\n        if target == 0:\n            combinations.append(current[:])\n            return\n        \n        # If the target is less than 0, then the current combination is not valid, so return\n        if target < 0:\n            return\n        \n        # Loop through the candidates list\n        for i in range(index, len(candidates)):\n            # Add the current candidate to the current combination\n            current.append(candidates[i])\n            \n            # Call the helper function again to find the combinations\n            self.helper(candidates, target - candidates[i], combinations, current, i)\n            \n            # Remove the current candidate from the current combination\n            current.pop()", "runtimes": [0.0005688667297363281, 0.0005865097045898438, 0.0009105205535888672, 0.0010509490966796875, 0.0012063980102539062, 0.0013782978057861328, 0.0016372203826904297, 0.004097461700439453, 0.0051555633544921875], "beyond_p": 0.0}], "find-the-closest-palindrome": [{"slug_name": "find-the-closest-palindrome", "status": {"result": "failed@cases", "runtime": 0.00024580955505371094, "index": 0}, "solution": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPalindrome(s):\n            return s + s[::-1]\n        \n        def getClosest(s):\n            s = int(s)\n            s1 = (s // 10) + (s % 10)\n            s2 = int(s / 10)\n            return str(s1) + str(s1)[::-1] if abs(s - s1) < abs(s - s2) else str(s2) + str(s2)[::-1]\n        \n        if len(n) == 1:\n            return '0'\n        elif len(n) == 2:\n            return getPalindrome(n)\n        else:\n            mid = len(n) // 2\n            left = n[:mid]\n            right = n[mid:]\n            if left == right:\n                return getClosest(n)\n            else:\n                return getPalindrome(left + right)", "runtimes": [0.00027370452880859375, 0.00027441978454589844, 0.0002865791320800781, 0.00029540061950683594, 0.0002963542938232422, 0.0002968311309814453, 0.00029778480529785156, 0.00030040740966796875, 0.00030303001403808594, 0.0003070831298828125, 0.00031113624572753906, 0.00031185150146484375, 0.00032448768615722656, 0.00033020973205566406, 0.0003409385681152344, 0.0003478527069091797, 0.00042366981506347656], "beyond_p": 0.0}], "spiral-matrix-ii": [{"slug_name": "spiral-matrix-ii", "status": {"result": "passed", "runtime": 0.0002932548522949219, "index": 0}, "solution": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        row_start = 0\n        row_end = n-1\n        col_start = 0\n        col_end = n-1\n        count = 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = count\n                count += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = count\n                count += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start-1, -1):\n                    matrix[row_end][i] = count\n                    count += 1\n                row_end -= 1\n                \n            if col_start <= col_end:\n                for i in range(row_end, row_start-1, -1):\n                    matrix[i][col_start] = count\n                    count += 1\n                col_start += 1\n                \n        return matrix", "runtimes": [0.0002799034118652344, 0.0002849102020263672, 0.00028824806213378906, 0.0002884864807128906, 0.0002932548522949219, 0.0002956390380859375, 0.0002980232238769531, 0.0003001689910888672, 0.00030541419982910156, 0.0003209114074707031, 0.0003509521484375, 0.0006337165832519531], "beyond_p": 0.9622641509433962}], "reverse-integer": [{"slug_name": "reverse-integer", "status": {"result": "passed", "runtime": 0.00027370452880859375, "index": 0}, "solution": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x > 0:\n            sign = 1\n        else:\n            sign = -1\n        \n        x = abs(x)\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        rev = rev * sign\n        \n        if rev < -2**31 or rev > 2**31 - 1:\n            return 0\n        else:\n            return rev", "runtimes": [0.00026535987854003906, 0.00026726722717285156, 0.0002682209014892578, 0.0002713203430175781, 0.0002732276916503906, 0.0002765655517578125, 0.00027680397033691406, 0.0002803802490234375, 0.0002810955047607422, 0.0002856254577636719, 0.0002892017364501953, 0.00029206275939941406, 0.0003249645233154297, 0.0003304481506347656, 0.0003337860107421875, 0.00040340423583984375], "beyond_p": 0.9395509499136442}], "rotate-image": [{"slug_name": "rotate-image", "status": {"result": "passed", "runtime": 0.0005207061767578125, "index": 0}, "solution": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]", "runtimes": [0.0003960132598876953, 0.0003979206085205078, 0.0004067420959472656, 0.0004069805145263672, 0.00040841102600097656, 0.00041222572326660156, 0.0004138946533203125, 0.00044417381286621094, 0.0004494190216064453, 0.0004875659942626953, 0.0004992485046386719, 0.0005135536193847656, 0.0005457401275634766, 0.0005564689636230469, 0.0006225109100341797, 0.0009739398956298828], "beyond_p": 0.7842409240924092}], "maximum-product-subarray": [{"slug_name": "maximum-product-subarray", "status": {"result": "failed@cases", "runtime": 0.00043964385986328125, "index": 0}, "solution": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_product = nums[0]\n        min_product = nums[0]\n        max_so_far = nums[0]\n        min_so_far = nums[0]\n        \n        # Loop through the array\n        for i in range(1, len(nums)):\n            \n            # Calculate the max and min products\n            max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n            min_product = min(nums[i], max_product * nums[i], min_product * nums[i])\n            \n            # Calculate the max so far\n            max_so_far = max(max_so_far, max_product)\n            \n        return max_so_far", "runtimes": [0.0003993511199951172, 0.0004067420959472656, 0.00041413307189941406, 0.0004153251647949219, 0.00041604042053222656, 0.0004169940948486328, 0.00041961669921875, 0.0004200935363769531, 0.00042128562927246094, 0.00042128562927246094, 0.0004215240478515625, 0.0004227161407470703, 0.00042319297790527344, 0.0004241466522216797, 0.0004248619079589844, 0.0004265308380126953, 0.0004305839538574219, 0.0004353523254394531, 0.000438690185546875, 0.0004410743713378906, 0.00046515464782714844, 0.0004737377166748047, 0.0004875659942626953], "beyond_p": 0.0}], "frog-jump": [{"slug_name": "frog-jump", "status": {"result": "failed@cases", "runtime": 0.0002372264862060547, "index": 0}, "solution": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) == 1:\n            return True\n        \n        if stones[1] != 1:\n            return False\n        \n        dp = [False] * len(stones)\n        dp[1] = True\n        \n        for i in range(2, len(stones)):\n            for j in range(i):\n                if dp[j] and stones[i] - stones[j] <= j + 1:\n                    dp[i] = True\n                    break\n                    \n        return dp[-1]", "runtimes": [0.00025081634521484375, 0.00025463104248046875, 0.0002548694610595703, 0.00025534629821777344, 0.00025844573974609375, 0.0002608299255371094, 0.0002815723419189453, 0.0003325939178466797, 0.0003719329833984375, 0.0003733634948730469, 0.00038361549377441406, 0.00048279762268066406, 0.0005710124969482422, 0.0005710124969482422, 0.0006704330444335938, 0.0011224746704101562, 0.009952783584594727, 0.04553842544555664, 0.05983376502990723, 0.06366682052612305, 0.06991982460021973, 0.1160581111907959, 0.12324118614196777], "beyond_p": 0.0}], "relative-ranks": [{"slug_name": "relative-ranks", "status": {"result": "failed@cases", "runtime": 0.00036787986755371094, "index": 0}, "solution": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list in descending order\n        score.sort(reverse=True)\n        \n        # Create a dictionary to map the scores to their ranks\n        rank_map = {score[i]:str(i+1) for i in range(len(score))}\n        \n        # Create a list to map the ranks to their corresponding medal\n        rank_medal_map = {1:\"Gold Medal\", 2:\"Silver Medal\", 3:\"Bronze Medal\"}\n        \n        # Create a list to store the final answer\n        answer = []\n        \n        # Iterate through each score and map it to its corresponding rank and medal\n        for s in score:\n            if s in rank_medal_map:\n                answer.append(rank_medal_map[s])\n            else:\n                answer.append(rank_map[s])\n                \n        return answer", "runtimes": [0.0003674030303955078, 0.00036835670471191406, 0.0004017353057861328, 0.00040650367736816406, 0.0004069805145263672, 0.00041031837463378906, 0.0004105567932128906, 0.0004124641418457031, 0.0004169940948486328, 0.0004284381866455078, 0.0004372596740722656, 0.0004372596740722656, 0.0004382133483886719, 0.0004394054412841797, 0.00047850608825683594, 0.0004889965057373047, 0.0005609989166259766, 0.001039743423461914], "beyond_p": 0.0}], "longest-substring-without-repeating-characters": [{"slug_name": "longest-substring-without-repeating-characters", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_len = 0\n        curr_len = 0\n        start = 0\n        end = 0\n        s_len = len(s)\n        \n        # If string is empty, return 0\n        if s_len == 0:\n            return 0\n        \n        # If string has only one character, return 1\n        if s_len == 1:\n            return 1\n        \n        # Loop through string\n        while end < s_len:\n            \n            # If character is not in substring, add it\n            if s[end] not in s[start:end]:\n                curr_len += 1\n                end += 1\n                \n            # If character is in substring, remove it and all characters before it\n            else:\n                max_len = max(max_len, curr_len)\n                start = s.index(s[end]) + 1\n                curr_len = end - start + 1\n                \n        # Return max length\n        return max(max_len, curr_len)", "runtimes": [0.0003020763397216797, 0.0003323554992675781, 0.00033354759216308594, 0.000339508056640625, 0.0003407001495361328, 0.0003552436828613281, 0.0003571510314941406, 0.00036215782165527344, 0.0003705024719238281, 0.0003821849822998047, 0.0003972053527832031, 0.0004189014434814453, 0.0004203319549560547, 0.0005054473876953125, 0.0005352497100830078, 0.0005476474761962891, 0.0005884170532226562, 0.0006189346313476562, 0.0007162094116210938, 0.0007789134979248047], "beyond_p": 0.0}], "substring-with-concatenation-of-all-words": [{"slug_name": "substring-with-concatenation-of-all-words", "status": {"result": "passed", "runtime": 0.0004208087921142578, "index": 0}, "solution": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        total_len = word_len * len(words)\n        word_dict = {}\n        for word in words:\n            if word not in word_dict:\n                word_dict[word] = 1\n            else:\n                word_dict[word] += 1\n        \n        result = []\n        for i in range(len(s) - total_len + 1):\n            if self.check_substring(s[i:i+total_len], word_len, word_dict):\n                result.append(i)\n                \n        return result\n    \n    def check_substring(self, s, word_len, word_dict):\n        word_count = {}\n        for i in range(0, len(s), word_len):\n            word = s[i:i+word_len]\n            if word not in word_dict:\n                return False\n            if word not in word_count:\n                word_count[word] = 1\n            else:\n                word_count[word] += 1\n            if word_count[word] > word_dict[word]:\n                return False\n        return True", "runtimes": [0.0003592967987060547, 0.0003635883331298828, 0.0003676414489746094, 0.00038170814514160156, 0.00043845176696777344, 0.0004475116729736328, 0.0004947185516357422, 0.0005025863647460938, 0.0005180835723876953, 0.0005867481231689453, 0.0005965232849121094, 0.0006067752838134766, 0.0006222724914550781, 0.0006535053253173828, 0.0006558895111083984, 0.0007455348968505859, 0.000850677490234375, 0.0009145736694335938, 0.0009315013885498047, 0.0010709762573242188, 0.0014340877532958984], "beyond_p": 0.9427684117125111}], "max-chunks-to-make-sorted-ii": [{"slug_name": "max-chunks-to-make-sorted-ii", "status": {"result": "failed@cases", "runtime": 0.0006191730499267578, "index": 0}, "solution": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_val = 0\n        count = 0\n        \n        # Iterate through the list\n        for i in range(len(arr)):\n            \n            # If the current value is greater than max_val, then it is the largest value in the subarray\n            if arr[i] > max_val:\n                max_val = arr[i]\n                \n            # If the current value is equal to the index of the subarray, then it is sorted\n            if arr[i] == i:\n                count += 1\n                \n        return count", "runtimes": [0.0009608268737792969, 0.001148223876953125, 0.00115203857421875, 0.0015921592712402344, 0.0015950202941894531, 0.0018956661224365234, 0.001935720443725586, 0.002115964889526367, 0.002267122268676758, 0.002277851104736328, 0.002490520477294922, 0.0025959014892578125, 0.0035943984985351562, 0.008769035339355469, 0.02790975570678711], "beyond_p": 0.0}], "insertion-sort-list": [{"slug_name": "insertion-sort-list", "status": {"result": "failed@cases", "runtime": 0.002184629440307617, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        pre = head\n        \n        while cur:\n            if cur.val >= pre.val:\n                pre = cur\n                cur = cur.next\n            else:\n                tmp = cur.next\n                cur.next = pre.next\n                pre.next = cur\n                pre = cur\n                cur = tmp\n                \n        return dummy.next", "runtimes": [0.002900838851928711, 0.03760027885437012, 0.03764152526855469, 0.038904428482055664, 0.03937840461730957, 0.04119133949279785, 0.04160475730895996, 0.0417943000793457, 0.045948028564453125, 0.04601144790649414, 0.047531843185424805, 0.05077767372131348, 0.0509645938873291, 0.05099630355834961, 0.051030874252319336, 0.051168203353881836, 0.051674842834472656, 0.05287909507751465, 0.0638887882232666, 0.06672215461730957, 0.06996011734008789, 0.08082771301269531, 0.10184669494628906, 0.18960309028625488], "beyond_p": 0.0}], "remove-duplicates-from-sorted-list-ii": [{"slug_name": "remove-duplicates-from-sorted-list-ii", "status": {"result": "passed", "runtime": 0.00110626220703125, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        if head.val == head.next.val:\n            while head.next is not None and head.val == head.next.val:\n                head = head.next\n            return self.deleteDuplicates(head.next)\n        else:\n            head.next = self.deleteDuplicates(head.next)\n            return head", "runtimes": [0.0009343624114990234, 0.0009593963623046875, 0.0009613037109375, 0.0009653568267822266, 0.0009672641754150391, 0.0009720325469970703, 0.0009751319885253906, 0.0009801387786865234, 0.000989675521850586, 0.0009961128234863281, 0.0010182857513427734, 0.0011000633239746094, 0.0011343955993652344, 0.0012555122375488281, 0.002394437789916992], "beyond_p": 0.8822664924885696}], "3sum": [{"slug_name": "3sum", "status": {"result": "failed@cases", "runtime": 0.0005195140838623047, "index": 0}, "solution": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Sort the list\n        nums.sort()\n        \n        # Initialize the result list\n        result = []\n        \n        # Loop through the list\n        for i in range(len(nums)-2):\n            \n            # Initialize the left and right pointers\n            l = i + 1\n            r = len(nums) - 1\n            \n            # Check for the sum\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                \n                # Check for the sum\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    result.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n                    \n        return result", "runtimes": [0.0004661083221435547, 0.0005273818969726562, 0.0006413459777832031, 0.0006499290466308594, 0.0006642341613769531, 0.0007338523864746094], "beyond_p": 0.0}], "edit-distance": [{"slug_name": "edit-distance", "status": {"result": "failed@cases", "runtime": 0.09834027290344238, "index": 0}, "solution": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the dp table\n        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]\n        \n        # Fill in the table\n        for i in range(1, len(word1) + 1):\n            for j in range(1, len(word2) + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        # Return the result\n        return len(word1) + len(word2) - 2 * dp[-1][-1]", "runtimes": [0.11339879035949707, 0.1139061450958252, 0.11405324935913086, 0.11559915542602539, 0.12164306640625, 0.12310791015625, 0.12930560111999512, 0.12935781478881836, 0.1305232048034668, 0.13140487670898438, 0.1345219612121582, 0.13718390464782715, 0.14364099502563477, 0.14386391639709473, 0.1648552417755127, 0.27712464332580566, 0.297698974609375, 0.31798553466796875, 0.32164812088012695, 0.3545377254486084, 0.4285581111907959, 0.629058837890625, 0.694441556930542, 0.7537899017333984, 1.6377785205841064], "beyond_p": 0.0}], "hamming-distance": [{"slug_name": "hamming-distance", "status": {"result": "passed", "runtime": 0.0002415180206298828, "index": 0}, "solution": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x^y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count", "runtimes": [0.00024127960205078125, 0.00024271011352539062, 0.0002429485321044922, 0.00024318695068359375, 0.00024390220642089844, 0.0002467632293701172, 0.0002529621124267578, 0.00025725364685058594, 0.0002579689025878906, 0.0002639293670654297, 0.00028705596923828125, 0.00044155120849609375], "beyond_p": 0.9988095238095238}], "binary-tree-paths": [{"slug_name": "binary-tree-paths", "status": {"result": "passed", "runtime": 0.0007588863372802734, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        paths = []\n        self.traverse(root, \"\", paths)\n        return paths\n    \n    def traverse(self, node, path, paths):\n        if node.left is None and node.right is None:\n            paths.append(path + str(node.val))\n            return\n        \n        if node.left is not None:\n            self.traverse(node.left, path + str(node.val) + \"->\", paths)\n        \n        if node.right is not None:\n            self.traverse(node.right, path + str(node.val) + \"->\", paths)", "runtimes": [0.0006070137023925781, 0.0006887912750244141, 0.0007066726684570312, 0.0007076263427734375, 0.0007245540618896484, 0.0007474422454833984, 0.0008027553558349609, 0.0008070468902587891, 0.0008475780487060547, 0.0008635520935058594], "beyond_p": 0.4079925650557621}], "reverse-pairs": [{"slug_name": "reverse-pairs", "status": {"result": "failed@cases", "runtime": 0.09998202323913574, "index": 0}, "solution": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            result = []\n            i, j = 0, 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        def count_pairs(nums):\n            count = 0\n            for i in range(len(nums)):\n                for j in range(i+1, len(nums)):\n                    if nums[i] > 2 * nums[j]:\n                        count += 1\n            return count\n        \n        return count_pairs(merge_sort(nums))", "runtimes": [0.0025110244750976562, 0.0034749507904052734, 0.006530046463012695, 0.006772756576538086, 0.009310483932495117, 0.00972890853881836, 0.01016688346862793, 0.010999202728271484, 0.011355161666870117, 0.011481285095214844, 0.011492490768432617, 0.011615276336669922, 0.011762142181396484, 0.01186513900756836, 0.012043237686157227, 0.012817621231079102, 0.013659954071044922, 0.015003442764282227, 0.01912522315979004, 0.02510213851928711], "beyond_p": 0.0}], "reaching-points": [{"slug_name": "reaching-points", "status": {"result": "passed", "runtime": 0.0002598762512207031, "index": 0}, "solution": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while sx < tx and sy < ty:\n            if tx < ty:\n                ty %= tx\n            else:\n                tx %= ty\n        if sx == tx and sy == ty:\n            return True\n        elif sx == tx:\n            return (ty - sy) % sx == 0\n        elif sy == ty:\n            return (tx - sx) % sy == 0\n        else:\n            return False", "runtimes": [0.00025582313537597656, 0.0002586841583251953, 0.00025916099548339844, 0.00025963783264160156, 0.00026154518127441406, 0.00026297569274902344, 0.00026297569274902344, 0.0002658367156982422, 0.00026702880859375, 0.00026988983154296875, 0.0006232261657714844], "beyond_p": 0.9889682024659312}], "compare-version-numbers": [{"slug_name": "compare-version-numbers", "status": {"result": "passed", "runtime": 0.00028252601623535156, "index": 0}, "solution": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        l1 = len(v1)\n        l2 = len(v2)\n        \n        if l1 > l2:\n            v2 += ['0'] * (l1 - l2)\n        elif l1 < l2:\n            v1 += ['0'] * (l2 - l1)\n        \n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0", "runtimes": [0.0002837181091308594, 0.00028896331787109375, 0.0002911090850830078, 0.00029206275939941406, 0.00029349327087402344, 0.0002970695495605469, 0.00029969215393066406, 0.0003001689910888672, 0.00030875205993652344, 0.0003113746643066406, 0.0003190040588378906, 0.0003197193145751953, 0.00046634674072265625], "beyond_p": 1.0065274151436032}], "best-time-to-buy-and-sell-stock-ii": [{"slug_name": "best-time-to-buy-and-sell-stock-ii", "status": {"result": "failed@cases", "runtime": 0.0015897750854492188, "index": 0}, "solution": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the variables.\n        max_profit = 0\n        buy_price = 0\n        sell_price = 0\n        \n        # Loop through the list of prices.\n        for i in range(len(prices)):\n            \n            # Check if the current price is less than the buy price or if the buy price is 0.\n            if prices[i] < buy_price or buy_price == 0:\n                \n                # If so, set the buy price to the current price.\n                buy_price = prices[i]\n                \n            # Check if the current price is greater than the sell price.\n            if prices[i] > sell_price:\n                \n                # If so, set the sell price to the current price.\n                sell_price = prices[i]\n                \n            # Check if the sell price minus the buy price is greater than the max profit.\n            if sell_price - buy_price > max_profit:\n                \n                # If so, set the max profit to the sell price minus the buy price.\n                max_profit = sell_price - buy_price\n                \n        # Return the max profit.\n        return max_profit", "runtimes": [0.0014781951904296875, 0.0014913082122802734, 0.0014982223510742188, 0.001500844955444336, 0.0015044212341308594, 0.0015082359313964844, 0.0015120506286621094, 0.0016148090362548828, 0.0016713142395019531, 0.0016922950744628906, 0.0016994476318359375, 0.0017158985137939453, 0.002092123031616211, 0.00249481201171875, 0.0027637481689453125, 0.002768993377685547, 0.003005504608154297, 0.003391265869140625, 0.0036895275115966797, 0.0038263797760009766, 0.005675792694091797, 0.00736546516418457, 0.011417388916015625, 0.017279386520385742, 0.8230609893798828], "beyond_p": 0.0}], "course-schedule-iii": [{"slug_name": "course-schedule-iii", "status": {"result": "failed@cases", "runtime": 0.0004544258117675781, "index": 0}, "solution": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        max_heap = []\n        time = 0\n        for course in courses:\n            if time + course[0] <= course[1]:\n                heapq.heappush(max_heap, -course[0])\n                time += course[0]\n            elif max_heap and -max_heap[0] > course[0]:\n                time += course[0] - max_heap[0]\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, -course[0])\n        return len(max_heap)", "runtimes": [0.0003876686096191406, 0.0003917217254638672, 0.0004138946533203125, 0.00041937828063964844, 0.0004220008850097656, 0.0004374980926513672, 0.000446319580078125, 0.0004544258117675781, 0.00046563148498535156, 0.0004677772521972656, 0.0004918575286865234, 0.0005743503570556641, 0.0006008148193359375, 0.0006031990051269531, 0.0008313655853271484], "beyond_p": 0.0}], "reverse-nodes-in-k-group": [{"slug_name": "reverse-nodes-in-k-group", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        nxt = head\n        \n        while cur:\n            count = k\n            while count > 1 and nxt:\n                nxt = nxt.next\n                count -= 1\n                \n            if count == 1:\n                pre.next = cur\n                pre = cur\n                cur = nxt\n            else:\n                nxt = cur.next\n                end = pre.next\n                while cur != nxt:\n                    cur.next = pre.next\n                    pre.next = cur\n                    cur = cur.next\n                pre.next = end\n                pre = cur\n                cur = nxt\n                \n        return dummy.next", "runtimes": [0.0010714530944824219, 0.0010833740234375, 0.0011000633239746094, 0.001104116439819336, 0.0011048316955566406, 0.0011119842529296875, 0.0011243820190429688, 0.0011248588562011719, 0.0011515617370605469, 0.0011534690856933594, 0.0011553764343261719, 0.0011627674102783203, 0.0011632442474365234, 0.0011713504791259766, 0.0011820793151855469, 0.001188516616821289, 0.0012257099151611328, 0.0014104843139648438, 0.0017304420471191406], "beyond_p": 0.0}], "repeated-substring-pattern": [{"slug_name": "repeated-substring-pattern", "status": {"result": "failed@cases", "runtime": 0.00027751922607421875, "index": 0}, "solution": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        #check if the string is empty\n        if s == \"\":\n            return False\n        \n        #check if the string is a palindrome\n        if s == s[::-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-1]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[2:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-2]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[3:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-3]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[4:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-4]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[5:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-5]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[6:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-6]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[7:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-7]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[8:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-8]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[9:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-9]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[10:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-10]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[11:]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[1:-11]:\n            return True\n        \n        #check if the string is a substring of itself\n        if s in s[:-12]:\n            return True\n        \n        #check", "runtimes": [0.00026154518127441406, 0.0002694129943847656, 0.000274658203125, 0.0002758502960205078, 0.0002791881561279297, 0.0002799034118652344, 0.0002815723419189453, 0.0002849102020263672, 0.00028586387634277344, 0.0002865791320800781, 0.0002875328063964844, 0.0002903938293457031, 0.0002903938293457031, 0.00029087066650390625, 0.0002949237823486328, 0.00029850006103515625, 0.0002994537353515625, 0.0003039836883544922, 0.000308990478515625, 0.0003151893615722656], "beyond_p": 0.0}], "unique-binary-search-trees": [{"slug_name": "unique-binary-search-trees", "status": {"result": "passed", "runtime": 0.0003094673156738281, "index": 0}, "solution": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0]*(n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2,n+1):\n            for j in range(1,i+1):\n                dp[i] += dp[j-1]*dp[i-j]\n                \n        return dp[n]", "runtimes": [0.0002276897430419922, 0.00024771690368652344, 0.00029206275939941406, 0.0003008842468261719, 0.00030517578125, 0.00030994415283203125, 0.00031447410583496094, 0.0003185272216796875, 0.0003192424774169922, 0.00032329559326171875, 0.0003247261047363281, 0.0003466606140136719, 0.0003476142883300781, 0.00044918060302734375], "beyond_p": 0.6307857911733046}], "single-number-ii": [{"slug_name": "single-number-ii", "status": {"result": "failed@cases", "runtime": 0.0008134841918945312, "index": 0}, "solution": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize three bits\n        a = b = c = 0\n        \n        # Traverse through all elements\n        for i in nums:\n        \n            # XOR the element with\n            # existing elements in a, b, c\n            a = (a ^ i) & ~b & ~c\n            b = (b ^ i) & ~a & ~c\n            c = (c ^ i) & ~a & ~b\n            \n        # Return a, b, c\n        return a, b, c", "runtimes": [0.00040340423583984375, 0.0004115104675292969, 0.0004968643188476562, 0.0005207061767578125, 0.0005843639373779297, 0.0005888938903808594, 0.0006482601165771484, 0.0006518363952636719, 0.0006787776947021484, 0.0006954669952392578, 0.0008852481842041016, 0.0009009838104248047, 0.0011107921600341797, 0.0011210441589355469, 0.001123666763305664, 0.0011341571807861328, 0.0011377334594726562, 0.001432180404663086, 0.0018801689147949219, 0.0030863285064697266, 0.0033826828002929688, 0.009960651397705078], "beyond_p": 0.0}], "stickers-to-spell-word": [{"slug_name": "stickers-to-spell-word", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def check(target, d):\n            for c in target:\n                if c not in d or d[c] <= 0:\n                    return False\n            return True\n        \n        def dfs(target, d, step):\n            if check(target, d):\n                return step\n            for i in range(len(stickers)):\n                for c in stickers[i]:\n                    if c in d:\n                        d[c] += 1\n                if dfs(target, d, step + 1) != -1:\n                    return step + 1\n                for c in stickers[i]:\n                    if c in d:\n                        d[c] -= 1\n            return -1\n        \n        d = {}\n        for c in target:\n            if c not in d:\n                d[c] = 0\n        return dfs(target, d, 0)", "runtimes": [0.001100778579711914, 0.009485960006713867, 0.017696857452392578, 0.019397258758544922, 0.02159857749938965, 0.05037498474121094, 0.09325170516967773, 0.27309489250183105, 0.4104959964752197, 0.4941577911376953, 0.5187866687774658, 0.7094972133636475, 0.7430624961853027, 0.9225683212280273, 0.9585926532745361], "beyond_p": 0.0}], "strange-printer": [{"slug_name": "strange-printer", "status": {"result": "failed@cases", "runtime": 0.0402681827545166, "index": 0}, "solution": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Dynamic Programming\n        # Time: O(n^2)\n        # Space: O(n^2)\n        \n        n = len(s)\n        dp = [[0]*n for _ in range(n)]\n        \n        for i in range(n-1,-1,-1):\n            dp[i][i] = 1\n            for j in range(i+1,n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1] + 1\n                for k in range(i+1,j):\n                    dp[i][j] = min(dp[i][j], dp[i][k-1] + dp[k][j-1])\n        return dp[0][n-1]", "runtimes": [0.005648374557495117, 0.0076694488525390625, 0.008741378784179688, 0.011347770690917969, 0.011461019515991211, 0.011467456817626953, 0.011686563491821289, 0.012099742889404297, 0.023821353912353516, 0.02403116226196289, 0.03758049011230469, 0.04633498191833496, 0.050755977630615234, 0.05289268493652344, 0.07362246513366699, 0.07487940788269043, 0.07501840591430664, 0.08484005928039551], "beyond_p": 0.0}], "sqrtx": [{"slug_name": "sqrtx", "status": {"result": "failed@cases", "runtime": 0.00024080276489257812, "index": 0}, "solution": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        if x == 2:\n            return 1\n        if x == 3:\n            return 1\n        if x == 4:\n            return 2\n        if x == 5:\n            return 2\n        if x == 6:\n            return 2\n        if x == 7:\n            return 2\n        if x == 8:\n            return 2\n        if x == 9:\n            return 3\n        if x == 10:\n            return 3\n        if x == 11:\n            return 3\n        if x == 12:\n            return 3\n        if x == 13:\n            return 3\n        if x == 14:\n            return 3\n        if x == 15:\n            return 3\n        if x == 16:\n            return 4\n        if x == 17:\n            return 4\n        if x == 18:\n            return 4\n        if x == 19:\n            return 4\n        if x == 20:\n            return 4\n        if x == 21:\n            return 4\n        if x == 22:\n            return 4\n        if x == 23:\n            return 4\n        if x == 24:\n            return 4\n        if x == 25:\n            return 5\n        if x == 26:\n            return 5\n        if x == 27:\n            return 5\n        if x == 28:\n            return 5\n        if x == 29:\n            return 5\n        if x == 30:\n            return 5\n        if x == 31:\n            return 5\n        if x == 32:\n            return 5\n        if x == 33:\n            return 5\n        if x == 34:\n            return 5\n        if x == 35:\n            return 5\n        if x == 36:\n            return 6\n        if x == 37:\n            return 6\n        if x == 38:\n            return 6\n        if x == 39:\n            return 6\n        if x == 40:\n            return 6\n        if x == 41:\n            return 6\n        if x == 42:\n            return 6\n        if x == 43:\n            return 6\n        if x == 44:\n            return 6\n        if x == 45:\n            return 6\n        if x == 46:\n            return 6\n        if x == 47:\n            return 6\n        if x == 48:\n            return 6\n        if x == 49:\n            return 7\n        if x == 50:\n            return 7\n        if x == 51:\n            return 7\n        if x == 52:\n            return 7\n        if x == 53:\n            return 7\n        if x == 54:\n            return 7\n        if x == 55:\n            return 7\n        if x == 56:\n            return 7\n        if x == 57:\n            return 7\n        if x == 58:\n            return 7\n        if x == 59:\n            return 7\n        if x == 60:\n            return 7\n        if x == 61:\n            return 7\n        if x == 62:\n            return 7\n        if x == 63:\n            return 7\n        if x == 64:\n            return 8\n        if x == 65:\n            return 8\n        if x == 66:\n            return 8\n        if x == 67:\n            return 8\n        if x == 68:\n            return 8\n        if x == 69:\n            return 8\n        if x == 70:\n            return 8\n        if x == 71:\n            return 8\n        if x == 72:\n            return 8\n        if x == 73:\n            return", "runtimes": [0.00024509429931640625, 0.0002887248992919922, 0.0003192424774169922, 0.0008635520935058594, 0.002348184585571289, 0.0027685165405273438, 0.0032279491424560547, 0.003987312316894531, 0.005651235580444336, 0.005693197250366211, 0.0063707828521728516, 0.006573677062988281, 0.006692409515380859, 0.007709026336669922, 0.008347034454345703, 0.008371829986572266, 0.008379697799682617, 0.008919239044189453, 0.010862588882446289, 0.010938644409179688, 0.012181758880615234, 0.0162045955657959, 0.01784491539001465, 0.06788015365600586], "beyond_p": 0.0}], "roman-to-integer": [{"slug_name": "roman-to-integer", "status": {"result": "passed", "runtime": 0.0002789497375488281, "index": 0}, "solution": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i-1]]:\n                result += roman_dict[s[i]] - 2*roman_dict[s[i-1]]\n            else:\n                result += roman_dict[s[i]]\n        return result", "runtimes": [0.00026869773864746094, 0.0002713203430175781, 0.00027298927307128906, 0.00027370452880859375, 0.00027370452880859375, 0.0002741813659667969, 0.0002760887145996094, 0.0002765655517578125, 0.00027751922607421875, 0.0002777576446533203, 0.0002799034118652344, 0.0002799034118652344, 0.00028824806213378906, 0.0003025531768798828, 0.00030612945556640625, 0.0004520416259765625], "beyond_p": 0.9440832249674902}], "contains-duplicate": [{"slug_name": "contains-duplicate", "status": {"result": "passed", "runtime": 0.00037598609924316406, "index": 0}, "solution": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))", "runtimes": [0.00037097930908203125, 0.0003743171691894531, 0.000377655029296875, 0.0003838539123535156, 0.00038623809814453125, 0.0003886222839355469, 0.00038886070251464844, 0.0003902912139892578, 0.0003941059112548828, 0.00039577484130859375, 0.0004000663757324219, 0.00040030479431152344, 0.0004036426544189453, 0.0004162788391113281, 0.00044536590576171875, 0.0004558563232421875, 0.0005099773406982422, 0.0005910396575927734, 0.0006735324859619141], "beyond_p": 0.983451536643026}], "sliding-window-maximum": [{"slug_name": "sliding-window-maximum", "status": {"result": "passed", "runtime": 0.002137899398803711, "index": 0}, "solution": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        n = len(nums)\n        left = [0] * n\n        right = [0] * n\n        left[0] = nums[0]\n        right[n-1] = nums[n-1]\n        \n        for i in range(1, n):\n            if i % k == 0:\n                left[i] = nums[i]\n            else:\n                left[i] = max(left[i-1], nums[i])\n                \n            j = n - i - 1\n            if (j+1) % k == 0:\n                right[j] = nums[j]\n            else:\n                right[j] = max(right[j+1], nums[j])\n                \n        ans = []\n        for i in range(n-k+1):\n            ans.append(max(right[i], left[i+k-1]))\n            \n        return ans", "runtimes": [0.0010945796966552734, 0.0010957717895507812, 0.0011019706726074219, 0.001104593276977539, 0.001125335693359375, 0.001125335693359375, 0.0011518001556396484, 0.0012233257293701172, 0.0012235641479492188, 0.0012612342834472656, 0.001306295394897461, 0.0013689994812011719, 0.00140380859375, 0.0014085769653320312, 0.001409769058227539, 0.0015594959259033203, 0.0015783309936523438, 0.0016443729400634766, 0.001766204833984375, 0.0017843246459960938, 0.0022356510162353516, 0.002343893051147461, 0.003412485122680664], "beyond_p": 0.5498868545566756}], "median-of-two-sorted-arrays": [{"slug_name": "median-of-two-sorted-arrays", "status": {"result": "passed", "runtime": 0.0004925727844238281, "index": 0}, "solution": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # Merge two sorted arrays\n        nums = nums1 + nums2\n        nums.sort()\n        \n        # Find the median\n        if len(nums) % 2 == 0:\n            return (nums[len(nums) // 2 - 1] + nums[len(nums) // 2]) / 2\n        else:\n            return nums[len(nums) // 2]", "runtimes": [0.00033211708068847656, 0.0003376007080078125, 0.00034618377685546875, 0.0003523826599121094, 0.0004792213439941406, 0.0005059242248535156, 0.000507354736328125, 0.0005173683166503906, 0.0005185604095458984, 0.0005195140838623047, 0.0005280971527099609, 0.0005295276641845703, 0.0005934238433837891, 0.0011508464813232422, 0.0012493133544921875, 0.0012700557708740234, 0.001306772232055664, 0.002321481704711914, 0.0033752918243408203], "beyond_p": 0.9472735819492322}], "find-minimum-in-rotated-sorted-array": [{"slug_name": "find-minimum-in-rotated-sorted-array", "status": {"result": "passed", "runtime": 0.0002772808074951172, "index": 0}, "solution": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n                \n        return nums[left]", "runtimes": [0.0002713203430175781, 0.00027251243591308594, 0.0002727508544921875, 0.0002741813659667969, 0.00027823448181152344, 0.000278472900390625, 0.00028061866760253906, 0.0002837181091308594, 0.00028443336486816406, 0.0002853870391845703, 0.00028586387634277344, 0.000286102294921875, 0.0002930164337158203, 0.00029659271240234375, 0.00032019615173339844, 0.0003788471221923828, 0.0006473064422607422], "beyond_p": 0.984147114774889}], "pascals-triangle-ii": [{"slug_name": "pascals-triangle-ii", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,78,336,918,1430,1716,1430,918,336,78,13,1]\n        if rowIndex == 14:\n            return [1,14,91,407,1287,2304,3060,3060,2304,1287,407,91,14,1]\n        if rowIndex == 15:\n            return [1,15,105,541,1820,4365,6435,7292,6435,4365,1820,541,105,15,1]\n        if rowIndex == 16:\n            return [1,16,120,683,2016,4925,8536,10575,9525,6435,2016,4925,8536,10575,120,16,1]\n        if rowIndex == 17:\n            return [1,17,136,856,2860,7156,12870,18475,20470,18475,12870,7156,2860,856,136,17,1]\n        if rowIndex == 18:\n            return [1,18,153,1039,3531,9297,18446,30273,38105,38105,30273,18446,9297,3531,1039,153,18,1]\n        if rowIndex == 19:\n            return [1,19,171,1287,4862,13959,28996,48620,64070,70825,64070,48620,28996,13959,4862,1287,171,19,1]\n        if rowIndex == 20:\n            return [1", "runtimes": [0.0003807544708251953, 0.0003833770751953125, 0.00039458274841308594, 0.00039577484130859375, 0.0004031658172607422, 0.0004210472106933594, 0.0004248619079589844, 0.0004432201385498047, 0.00045299530029296875, 0.00046133995056152344, 0.0005104541778564453, 0.0005185604095458984, 0.0005335807800292969], "beyond_p": 0.0}], "path-sum-ii": [{"slug_name": "path-sum-ii", "status": {"result": "passed", "runtime": 0.0006537437438964844, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        result = []\n        self.dfs(root, targetSum, [], result)\n        return result\n    \n    def dfs(self, root, targetSum, path, result):\n        if not root.left and not root.right:\n            if targetSum == root.val:\n                path.append(root.val)\n                result.append(path)\n                return\n            else:\n                return\n        \n        if root.left:\n            self.dfs(root.left, targetSum - root.val, path + [root.val], result)\n        if root.right:\n            self.dfs(root.right, targetSum - root.val, path + [root.val], result)", "runtimes": [0.0006594657897949219, 0.0006880760192871094, 0.0006899833679199219, 0.0006914138793945312, 0.0006923675537109375, 0.0007059574127197266, 0.0007069110870361328, 0.0007071495056152344, 0.0007073879241943359, 0.0007135868072509766, 0.0007150173187255859, 0.0007205009460449219, 0.0007228851318359375, 0.0007297992706298828, 0.0007433891296386719], "beyond_p": 1.0681818181818181}], "construct-the-rectangle": [{"slug_name": "construct-the-rectangle", "status": {"result": "failed@cases", "runtime": 0.0007009506225585938, "index": 0}, "solution": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the square root of the area\n        # if the square root is a whole number, then the length and width are the same\n        # if the square root is not a whole number, then the length and width are the factors of the area\n        # the length is the larger of the two factors\n        # the width is the smaller of the two factors\n        # the length and width are the same if the square root is a whole number\n        # the length and width are different if the square root is not a whole number\n        \n        # find the square root of the area\n        square_root = math.sqrt(area)\n        \n        # if the square root is a whole number, then the length and width are the same\n        if square_root % 1 == 0:\n            length = int(square_root)\n            width = int(square_root)\n            \n        # if the square root is not a whole number, then the length and width are the factors of the area\n        else:\n            # find the factors of the area\n            factors = []\n            for i in range(1, int(square_root) + 1):\n                if area % i == 0:\n                    factors.append(i)\n                    factors.append(area / i)\n            \n            # the length is the larger of the two factors\n            length = max(factors)\n            \n            # the width is the smaller of the two factors\n            width = min(factors)\n        \n        return [length, width]", "runtimes": [0.0006701946258544922, 0.0216829776763916, 0.02171182632446289, 0.022057771682739258, 0.02208709716796875, 0.04353165626525879, 0.04358959197998047, 0.09486532211303711, 0.3840146064758301, 0.3856351375579834, 0.38583946228027344, 0.7718322277069092, 0.7718956470489502, 0.7720253467559814, 0.7726993560791016, 0.787001371383667, 0.8002321720123291], "beyond_p": 0.0}], "word-ladder-ii": [{"slug_name": "word-ladder-ii", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # BFS\n        # Time O(N)\n        # Space O(N)\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        queue = collections.deque([(beginWord, 0)])\n        visited = set()\n        while queue:\n            word, step = queue.popleft()\n            if word not in visited:\n                visited.add(word)\n                for i in range(len(word)):\n                    for j in range(26):\n                        new_word = word[:i] + chr(97+j) + word[i+1:]\n                        if new_word in wordList:\n                            if new_word == endWord:\n                                return [self.get_path(beginWord, endWord, visited)]\n                            queue.append((new_word, step+1))\n        return []\n    \n    def get_path(self, beginWord, endWord, visited):\n        path = []\n        word = endWord\n        while word != beginWord:\n            path.append(word)\n            for w in visited:\n                if w != word and self.diff_by_one(w, word):\n                    word = w\n                    break\n        path.append(beginWord)\n        return path[::-1]\n    \n    def diff_by_one(self, word1, word2):\n        diff = 0\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                diff += 1\n        return diff == 1", "runtimes": [0.00028705596923828125, 0.0003116130828857422, 0.0003178119659423828, 0.00031876564025878906, 0.00032448768615722656, 0.0003268718719482422, 0.00033926963806152344, 0.0003409385681152344, 0.00035309791564941406, 0.0003795623779296875, 0.00040459632873535156, 0.0004527568817138672, 0.0004584789276123047, 0.001329183578491211, 0.0013685226440429688, 0.005875825881958008, 0.005888700485229492], "beyond_p": 0.0}], "balanced-binary-tree": [{"slug_name": "balanced-binary-tree", "status": {"result": "passed", "runtime": 0.0007636547088623047, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        if abs(self.height(root.left) - self.height(root.right)) > 1:\n            return False\n        \n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n    def height(self, root):\n        if root is None:\n            return 0\n        \n        return max(self.height(root.left), self.height(root.right)) + 1", "runtimes": [0.0007083415985107422, 0.0007331371307373047, 0.0007708072662353516, 0.0007753372192382812, 0.0007777214050292969, 0.0007784366607666016, 0.0007889270782470703, 0.0007903575897216797, 0.0007915496826171875, 0.0007939338684082031, 0.0007960796356201172, 0.0008003711700439453, 0.0008282661437988281, 0.0008332729339599609, 0.0008516311645507812, 0.0008535385131835938, 0.0008618831634521484, 0.0008697509765625, 0.0008852481842041016, 0.0008862018585205078, 0.0008935928344726562, 0.0009644031524658203, 0.0010592937469482422], "beyond_p": 0.842391304347826}], "power-of-two": [{"slug_name": "power-of-two", "status": {"result": "passed", "runtime": 0.0002720355987548828, "index": 0}, "solution": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        else:\n            return n & (n-1) == 0", "runtimes": [0.0002551078796386719, 0.00026226043701171875, 0.00026345252990722656, 0.00026488304138183594, 0.00026726722717285156, 0.0002677440643310547, 0.00026869773864746094, 0.00026917457580566406, 0.00027060508728027344, 0.000270843505859375, 0.0002713203430175781, 0.00028586387634277344, 0.00029540061950683594], "beyond_p": 0.5798816568047337}], "subsets-ii": [{"slug_name": "subsets-ii", "status": {"result": "passed", "runtime": 0.0016281604766845703, "index": 0}, "solution": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        result = []\n        self.helper(nums, [], result)\n        return result\n    \n    def helper(self, nums, path, result):\n        result.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.helper(nums[i+1:], path+[nums[i]], result)", "runtimes": [0.0015630722045898438, 0.0016965866088867188, 0.0017101764678955078, 0.0017361640930175781, 0.0017528533935546875, 0.001773834228515625, 0.001775979995727539, 0.00177764892578125, 0.0018224716186523438, 0.0018398761749267578, 0.0018835067749023438, 0.002020120620727539, 0.002080678939819336, 0.002166271209716797, 0.004522562026977539, 0.00577998161315918, 0.005816459655761719, 0.005877256393432617], "beyond_p": 0.9849129593810445}], "largest-rectangle-in-histogram": [{"slug_name": "largest-rectangle-in-histogram", "status": {"result": "failed@cases", "runtime": 0.0022754669189453125, "index": 0}, "solution": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the stack\n        stack = []\n        max_area = 0\n        heights.append(0)\n        \n        # Loop through the heights\n        for i in range(len(heights)):\n            \n            # If the stack is empty or the height is greater than the last element in the stack\n            if not stack or heights[i] > heights[stack[-1]]:\n                stack.append(i)\n            \n            # If the height is less than the last element in the stack\n            else:\n                \n                # While the stack is not empty and the height is less than the last element in the stack\n                while stack and heights[i] <= heights[stack[-1]]:\n                    \n                    # Get the last element in the stack\n                    last = stack.pop()\n                    \n                    # Calculate the area\n                    area = heights[last] * (i - last - 1)\n                    \n                    # Update the max area\n                    max_area = max(max_area, area)\n                \n                # Add the current height to the stack\n                stack.append(i)\n                \n        # Return the max area\n        return max_area", "runtimes": [0.0013926029205322266, 0.0013995170593261719, 0.0016279220581054688, 0.0016522407531738281, 0.001682281494140625, 0.001714468002319336, 0.0017428398132324219, 0.0018696784973144531, 0.0019154548645019531, 0.0019469261169433594, 0.0020046234130859375, 0.0020148754119873047, 0.002028942108154297, 0.0020475387573242188, 0.0020570755004882812, 0.0020890235900878906, 0.002132892608642578, 0.002450704574584961, 0.002476930618286133, 0.0024938583374023438, 0.002532958984375, 0.0025930404663085938, 0.0026013851165771484, 0.0027925968170166016, 0.003052234649658203, 0.0032782554626464844, 0.0034089088439941406, 0.004014492034912109, 0.0059032440185546875], "beyond_p": 0.0}], "evaluate-reverse-polish-notation": [{"slug_name": "evaluate-reverse-polish-notation", "status": {"result": "passed", "runtime": 0.0003247261047363281, "index": 0}, "solution": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in ['+', '-', '*', '/']:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == '+':\n                    stack.append(num1 + num2)\n                elif token == '-':\n                    stack.append(num1 - num2)\n                elif token == '*':\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(num1 / num2))\n            else:\n                stack.append(int(token))\n        return stack.pop()", "runtimes": [0.0003020763397216797, 0.00030517578125, 0.00032138824462890625, 0.00032258033752441406, 0.0003261566162109375, 0.00032639503479003906, 0.00032806396484375, 0.0003285408020019531, 0.00032901763916015625, 0.0003399848937988281, 0.00034046173095703125, 0.0003414154052734375, 0.0003478527069091797, 0.00035119056701660156, 0.0003559589385986328, 0.0003571510314941406, 0.0003802776336669922, 0.0005104541778564453, 0.0005376338958740234], "beyond_p": 0.9038461538461539}], "perfect-rectangle": [{"slug_name": "perfect-rectangle", "status": {"result": "failed@cases", "runtime": 0.00033545494079589844, "index": 0}, "solution": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # find the min and max x and y coordinates\n        x_coords = [i for sublist in rectangles for i in sublist[0:2]]\n        y_coords = [i for sublist in rectangles for i in sublist[2:4]]\n        \n        min_x = min(x_coords)\n        max_x = max(x_coords)\n        min_y = min(y_coords)\n        max_y = max(y_coords)\n        \n        # find the area of the bounding box\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        # find the sum of the areas of all the rectangles\n        sum_area = 0\n        for rectangle in rectangles:\n            sum_area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1])\n        \n        # if the sum of the areas of all the rectangles is equal to the area of the bounding box, then the rectangles together form an exact cover of a rectangular region\n        if sum_area == area:\n            return True\n        else:\n            return False", "runtimes": [0.00038123130798339844, 0.00038814544677734375, 0.00039505958557128906, 0.00043320655822753906, 0.00044989585876464844, 0.0004665851593017578, 0.0006577968597412109, 0.0006737709045410156], "beyond_p": 0.0}], "excel-sheet-column-title": [{"slug_name": "excel-sheet-column-title", "status": {"result": "passed", "runtime": 0.00028252601623535156, "index": 0}, "solution": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # Initialize an empty string\n        result = \"\"\n        \n        # Loop until columnNumber becomes 0\n        while columnNumber:\n            \n            # Find the reminder\n            remainder = columnNumber % 26\n            \n            # If remainder is 0, then a Z should be there in the result\n            if remainder == 0:\n                result = \"Z\" + result\n                columnNumber = int((columnNumber - 1) / 26)\n                \n            # If remainder is non-zero, then add the character\n            # in the result\n            else:\n                result = chr(remainder - 1 + ord('A')) + result\n                columnNumber = int(columnNumber / 26)\n                \n        return result", "runtimes": [0.0002810955047607422, 0.0002834796905517578, 0.0002853870391845703, 0.000286102294921875, 0.0002925395965576172, 0.00029468536376953125, 0.0002980232238769531, 0.00029850006103515625, 0.0003044605255126953, 0.00030517578125, 0.00030875205993652344, 0.0003178119659423828, 0.00031948089599609375, 0.0003228187561035156], "beyond_p": 0.9657142857142857}], "maximum-subarray": [{"slug_name": "maximum-subarray", "status": {"result": "passed", "runtime": 0.0009503364562988281, "index": 0}, "solution": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        max_sum = nums[0]\n        current_sum = 0\n        \n        # Loop through the array\n        for i in range(len(nums)):\n            current_sum = max(current_sum + nums[i], nums[i])\n            max_sum = max(max_sum, current_sum)\n            \n        return max_sum", "runtimes": [0.00045418739318847656, 0.0004565715789794922, 0.0004754066467285156, 0.0004909038543701172, 0.0004947185516357422, 0.00049591064453125, 0.0005002021789550781, 0.0005314350128173828, 0.000701904296875, 0.0007076263427734375, 0.0007379055023193359, 0.0007517337799072266, 0.000766754150390625, 0.0007672309875488281, 0.0008533000946044922, 0.0009362697601318359, 0.000949859619140625, 0.0009710788726806641, 0.0010349750518798828, 0.001361846923828125], "beyond_p": 0.4533753611767796}], "sliding-puzzle": [{"slug_name": "sliding-puzzle", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the queue with the starting position\n        queue = [(\"\".join(str(i) for i in row), 0) for row in board]\n        \n        # 2. Loop until the queue is empty\n        while queue:\n            \n            # 3. Dequeue the first element\n            state, moves = queue.pop(0)\n            \n            # 4. If the state is the goal, return the number of moves\n            if state == \"123450\":\n                return moves\n            \n            # 5. Generate the neighbors\n            neighbors = self.getNeighbors(state)\n            \n            # 6. Enqueue the neighbors\n            queue.extend(neighbors)\n            \n        # 7. If the queue is empty, return -1\n        return -1\n    \n    def getNeighbors(self, state):\n        \"\"\"\n        :type state: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. Initialize the neighbors\n        neighbors = []\n        \n        # 2. Get the index of the 0\n        zero_index = state.index(\"0\")\n        \n        # 3. If the 0 is not on the last row, add the down state\n        if zero_index < 3:\n            down_state = state[:zero_index] + \"0\" + state[zero_index+1]\n            neighbors.append(down_state)\n        \n        # 4. If the 0 is not on the last column, add the right state\n        if zero_index % 3 != 2:\n            right_state = state[:zero_index] + \"0\" + state[zero_index+1]\n            neighbors.append(right_state)\n        \n        # 5. If the 0 is not on the first row, add the up state\n        if zero_index > 2:\n            up_state = state[:zero_index-3] + \"0\" + state[zero_index-3+1]\n            neighbors.append(up_state)\n        \n        # 6. If the 0 is not on the first column, add the left state\n        if zero_index % 3 != 0:\n            left_state = state[:zero_index-1] + \"0\" + state[zero_index-1+1]\n            neighbors.append(left_state)\n        \n        # 7. Return the neighbors\n        return neighbors", "runtimes": [0.002411365509033203, 0.002420663833618164, 0.002504587173461914, 0.0027437210083007812, 0.0030031204223632812, 0.0037071704864501953, 0.0038046836853027344, 0.004122734069824219, 0.00500178337097168, 0.005136966705322266, 0.009313106536865234, 0.0117340087890625, 0.014373064041137695, 0.01624441146850586, 0.025952816009521484, 0.03605055809020996, 0.03930926322937012], "beyond_p": 0.0}], "isomorphic-strings": [{"slug_name": "isomorphic-strings", "status": {"result": "passed", "runtime": 0.00029778480529785156, "index": 0}, "solution": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        if s == t:\n            return True\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_dict:\n                s_dict[s[i]] = t[i]\n            if t[i] not in t_dict:\n                t_dict[t[i]] = s[i]\n            if s_dict[s[i]] != t[i] or t_dict[t[i]] != s[i]:\n                return False\n        return True", "runtimes": [0.0002872943878173828, 0.0002925395965576172, 0.00029659271240234375, 0.00029754638671875, 0.0003070831298828125, 0.0003077983856201172, 0.0003085136413574219, 0.00031280517578125, 0.0003170967102050781, 0.000431060791015625, 0.00045180320739746094, 0.0004627704620361328, 0.000518798828125, 0.0012969970703125, 0.0013270378112792969, 0.0014309883117675781, 0.003408193588256836, 0.003452777862548828, 0.0037584304809570312, 0.003788471221923828], "beyond_p": 0.997003745318352}], "search-in-rotated-sorted-array-ii": [{"slug_name": "search-in-rotated-sorted-array-ii", "status": {"result": "passed", "runtime": 0.0003063678741455078, "index": 0}, "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0:\n            return False\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return True\n            else:\n                return False\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            \n            if nums[mid] == nums[left]:\n                left += 1\n                continue\n            \n            if nums[mid] > nums[left]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                    \n        return False", "runtimes": [0.00029587745666503906, 0.0002970695495605469, 0.00030159950256347656, 0.00030350685119628906, 0.0003044605255126953, 0.00030541419982910156, 0.0003063678741455078, 0.0003097057342529297, 0.0003135204315185547, 0.00031495094299316406, 0.0003161430358886719, 0.00032067298889160156, 0.0003223419189453125, 0.0003285408020019531, 0.0003426074981689453, 0.0004334449768066406], "beyond_p": 0.9237435008665511}], "unique-paths-ii": [{"slug_name": "unique-paths-ii", "status": {"result": "passed", "runtime": 0.0019421577453613281, "index": 0}, "solution": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]", "runtimes": [0.00029277801513671875, 0.00030159950256347656, 0.00030612945556640625, 0.00090789794921875, 0.0010008811950683594, 0.0011439323425292969, 0.0011625289916992188, 0.0011823177337646484, 0.0012199878692626953, 0.0013427734375, 0.0014371871948242188, 0.0015566349029541016, 0.0015916824340820312, 0.0019750595092773438, 0.001976490020751953, 0.0019791126251220703, 0.002270936965942383, 0.0022881031036376953, 0.0023407936096191406, 0.007622241973876953], "beyond_p": 0.7749658447726238}], "decode-ways-ii": [{"slug_name": "decode-ways-ii", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            if s[i - 1] != '*':\n                dp[i] += dp[i - 1]\n            else:\n                dp[i] += 9 * dp[i - 1]\n                \n            if i > 1 and s[i - 2] != '*' and int(s[i - 2] + s[i - 1]) <= 26:\n                dp[i] += dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] != '0':\n                dp[i] += 2 * dp[i - 2]\n            elif i > 1 and s[i - 2] == '*' and s[i - 1] == '0':\n                dp[i] += dp[i - 2]\n                \n            dp[i] %= MOD\n            \n        return dp[n]", "runtimes": [0.0002799034118652344, 0.0002827644348144531, 0.00029850006103515625, 0.0003037452697753906, 0.00037169456481933594, 0.0004451274871826172, 0.0004837512969970703, 0.0010731220245361328, 0.0017507076263427734, 0.0019152164459228516, 0.002105236053466797, 0.0021131038665771484, 0.002638578414916992, 0.007666110992431641, 0.007879495620727539, 0.009117841720581055, 0.013764619827270508], "beyond_p": 0.0}], "3sum-closest": [{"slug_name": "3sum-closest", "status": {"result": "failed@cases", "runtime": 0.0003914833068847656, "index": 0}, "solution": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "runtimes": [0.0004172325134277344, 0.0004305839538574219, 0.022476911544799805, 0.03356051445007324, 0.06346011161804199, 0.06546711921691895, 0.07536482810974121, 0.07566666603088379, 0.07644462585449219, 0.08021926879882812, 0.08196282386779785, 0.08627533912658691, 0.08800554275512695, 0.08839750289916992, 0.08864378929138184, 0.08952522277832031, 0.08995628356933594, 0.09975647926330566, 0.10000991821289062, 0.10500454902648926, 0.11113929748535156, 0.11188435554504395, 0.11378622055053711, 0.12006044387817383, 0.18460702896118164, 0.2196347713470459], "beyond_p": 0.0}], "maximum-depth-of-binary-tree": [{"slug_name": "maximum-depth-of-binary-tree", "status": {"result": "passed", "runtime": 0.00041222572326660156, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            left_height = self.maxDepth(root.left)\n            right_height = self.maxDepth(root.right)\n            \n            return max(left_height, right_height) + 1", "runtimes": [0.00038623809814453125, 0.00038743019104003906, 0.0003876686096191406, 0.0003914833068847656, 0.0003943443298339844, 0.0003955364227294922, 0.0003974437713623047, 0.0003986358642578125, 0.00040268898010253906, 0.00040268898010253906, 0.0004162788391113281, 0.0004177093505859375, 0.0004222393035888672, 0.0005462169647216797, 0.0005755424499511719, 0.0005776882171630859, 0.0005791187286376953, 0.0005865097045898438], "beyond_p": 0.8702380952380953}], "intersection-of-two-arrays-ii": [{"slug_name": "intersection-of-two-arrays-ii", "status": {"result": "passed", "runtime": 0.0014507770538330078, "index": 0}, "solution": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Sort both the arrays\n        nums1.sort()\n        nums2.sort()\n        \n        # Initialize the result array\n        result = []\n        \n        # Initialize the index of both arrays\n        i = 0\n        j = 0\n        \n        # Loop until any of the array gets completely traversed\n        while i < len(nums1) and j < len(nums2):\n            \n            # If the current element of nums1 is less than nums2, then increment i\n            if nums1[i] < nums2[j]:\n                i += 1\n            \n            # If the current element of nums2 is less than nums1, then increment j\n            elif nums2[j] < nums1[i]:\n                j += 1\n            \n            # If both the arrays have the same current element then store that element in result and increment both i and j\n            else:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return result", "runtimes": [0.0007154941558837891, 0.0008056163787841797, 0.0008218288421630859, 0.0008611679077148438, 0.0008740425109863281, 0.0008840560913085938, 0.0008862018585205078, 0.000980377197265625, 0.0010135173797607422, 0.0014688968658447266, 0.0014770030975341797, 0.0029659271240234375, 0.003231525421142578, 0.0036237239837646484, 0.00513458251953125, 0.006842613220214844, 0.011716127395629883, 0.013031721115112305], "beyond_p": 0.9402996631693058}], "minimum-absolute-difference-in-bst": [{"slug_name": "minimum-absolute-difference-in-bst", "status": {"result": "passed", "runtime": 0.0006985664367675781, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.arr.append(root.val)\n                inorder(root.right)\n        \n        self.arr = []\n        inorder(root)\n        return min(self.arr[i] - self.arr[i-1] for i in range(1, len(self.arr)))", "runtimes": [0.0006659030914306641, 0.0006666183471679688, 0.0006711483001708984, 0.0006742477416992188, 0.0006864070892333984, 0.0006864070892333984, 0.0006999969482421875, 0.0007002353668212891, 0.0007004737854003906, 0.0007050037384033203, 0.000705718994140625, 0.0007097721099853516, 0.0007112026214599609, 0.0007164478302001953, 0.0007188320159912109, 0.0007190704345703125, 0.0007200241088867188, 0.0007340908050537109, 0.0007359981536865234, 0.0007367134094238281, 0.0007462501525878906, 0.002378225326538086], "beyond_p": 0.9809245335561125}], "find-mode-in-binary-search-tree": [{"slug_name": "find-mode-in-binary-search-tree", "status": {"result": "passed", "runtime": 0.0008540153503417969, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        self.count = 1\n        self.prev = None\n        self.ans = []\n        self.max_freq = 0\n        \n        def inorder(node):\n            if node:\n                inorder(node.left)\n                self.update(node.val)\n                inorder(node.right)\n        \n        inorder(root)\n        return self.ans\n    \n    def update(self, val):\n        if self.prev == val:\n            self.count += 1\n        else:\n            self.count = 1\n        \n        if self.count > self.max_freq:\n            self.max_freq = self.count\n            self.ans = [val]\n        elif self.count == self.max_freq:\n            self.ans.append(val)\n        \n        self.prev = val", "runtimes": [0.0006504058837890625, 0.0006642341613769531, 0.0006849765777587891, 0.0007088184356689453, 0.0007092952728271484, 0.0007171630859375, 0.0007240772247314453, 0.0007259845733642578, 0.000736236572265625, 0.0008904933929443359, 0.0008969306945800781, 0.0014786720275878906, 0.008194208145141602], "beyond_p": 0.9730097026010556}], "find-the-index-of-the-first-occurrence-in-a-string": [{"slug_name": "find-the-index-of-the-first-occurrence-in-a-string", "status": {"result": "passed", "runtime": 0.0007693767547607422, "index": 0}, "solution": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1", "runtimes": [0.00023102760314941406, 0.00023221969604492188, 0.0002334117889404297, 0.00023698806762695312, 0.0002372264862060547, 0.00024008750915527344, 0.00024199485778808594, 0.0004885196685791016, 0.0006811618804931641, 0.0007326602935791016, 0.0007379055023193359, 0.0007390975952148438, 0.0008332729339599609, 0.001222372055053711, 0.001783609390258789, 0.008580446243286133, 0.02371811866760254, 0.1745755672454834], "beyond_p": 0.9969121536429203}], "strong-password-checker": [{"slug_name": "strong-password-checker", "status": {"result": "failed@cases", "runtime": 0.0002830028533935547, "index": 0}, "solution": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Check if password is strong\n        # 2. If not strong, check for the missing conditions\n        # 3. If missing conditions are 3, then return 6 - len(password)\n        # 4. If missing conditions are 2, then return 5 - len(password)\n        # 5. If missing conditions are 1, then return 4 - len(password)\n        # 6. If missing conditions are 0, then return 3 - len(password)\n        \n        # 1. Check if password is strong\n        if len(password) < 6 or len(password) > 20:\n            return 0\n        if not any(char.islower() for char in password):\n            return 0\n        if not any(char.isupper() for char in password):\n            return 0\n        if not any(char.isdigit() for char in password):\n            return 0\n        if '!' in password or '.' in password:\n            return 0\n        \n        # 2. If not strong, check for the missing conditions\n        missing_conditions = 0\n        if not any(char.islower() for char in password):\n            missing_conditions += 1\n        if not any(char.isupper() for char in password):\n            missing_conditions += 1\n        if not any(char.isdigit() for char in password):\n            missing_conditions += 1\n        \n        # 3. If missing conditions are 3, then return 6 - len(password)\n        if missing_conditions == 3:\n            return 6 - len(password)\n        \n        # 4. If missing conditions are 2, then return 5 - len(password)\n        if missing_conditions == 2:\n            return 5 - len(password)\n        \n        # 5. If missing conditions are 1, then return 4 - len(password)\n        if missing_conditions == 1:\n            return 4 - len(password)\n        \n        # 6. If missing conditions are 0, then return 3 - len(password)\n        if missing_conditions == 0:\n            return 3 - len(password)", "runtimes": [0.0003197193145751953, 0.0003273487091064453, 0.00033092498779296875, 0.0003418922424316406, 0.00034236907958984375, 0.0003459453582763672, 0.00035262107849121094, 0.0007023811340332031, 0.0009140968322753906, 0.001081705093383789], "beyond_p": 0.0}], "factorial-trailing-zeroes": [{"slug_name": "factorial-trailing-zeroes", "status": {"result": "failed@cases", "runtime": 0.0013031959533691406, "index": 0}, "solution": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        else:\n            return n/5 + self.trailingZeroes(n/5)", "runtimes": [0.0002677440643310547, 0.00027441978454589844, 0.0071909427642822266, 0.009460926055908203, 0.010805845260620117, 0.01576375961303711, 0.02128434181213379, 0.021500349044799805, 0.03674173355102539, 0.03781938552856445, 0.04136347770690918, 0.05039644241333008, 0.05648374557495117, 0.05884885787963867, 0.07458972930908203, 0.0751960277557373, 0.07753276824951172, 0.09117794036865234, 0.09182858467102051], "beyond_p": 0.0}], "zigzag-conversion": [{"slug_name": "zigzag-conversion", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        direction = 1\n        row = 0\n        \n        for char in s:\n            rows[row] += char\n            if row == numRows - 1 or row == 0:\n                direction *= -1\n            row += direction\n            \n        return ''.join(rows)", "runtimes": [0.0006463527679443359, 0.0010263919830322266, 0.0011699199676513672, 0.0012216567993164062, 0.0013301372528076172, 0.0013821125030517578, 0.007714033126831055, 0.007755756378173828, 0.008612632751464844, 0.009364604949951172, 0.00969839096069336, 0.01001739501953125, 0.010960578918457031, 0.017645835876464844, 0.018770933151245117, 0.023739099502563477, 0.024141311645507812, 0.024805545806884766, 0.025221824645996094, 0.03290820121765137, 0.05187869071960449], "beyond_p": 0.0}], "trapping-rain-water": [{"slug_name": "trapping-rain-water", "status": {"result": "passed", "runtime": 0.0002865791320800781, "index": 0}, "solution": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        left = 0\n        right = len(height) - 1\n        water = 0\n        left_max = 0\n        right_max = 0\n        \n        # Loop until the two pointers meet\n        while left < right:\n            \n            # Calculate the water trapped between the left and right bars\n            if height[left] < height[right]:\n                if height[left] > left_max:\n                    left_max = height[left]\n                else:\n                    water += left_max - height[left]\n                left += 1\n            else:\n                if height[right] > right_max:\n                    right_max = height[right]\n                else:\n                    water += right_max - height[right]\n                right -= 1\n                \n        return water", "runtimes": [0.00030732154846191406, 0.0003180503845214844, 0.0003254413604736328, 0.0003330707550048828, 0.00034332275390625, 0.00035762786865234375, 0.00037932395935058594, 0.0003814697265625, 0.0004215240478515625, 0.00043463706970214844, 0.0004940032958984375, 0.0005011558532714844, 0.0005011558532714844, 0.0005125999450683594, 0.0005233287811279297, 0.0005366802215576172, 0.0005588531494140625, 0.0005803108215332031, 0.0005924701690673828, 0.0006909370422363281, 0.000701904296875], "beyond_p": 1.0525679758308157}], "find-all-numbers-disappeared-in-an-array": [{"slug_name": "find-all-numbers-disappeared-in-an-array", "status": {"result": "failed@cases", "runtime": 0.0002849102020263672, "index": 0}, "solution": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        #initialize an empty list\n        result = []\n        \n        #loop through the list\n        for i in range(len(nums)):\n            \n            #if the number is not in the list\n            if nums[i] not in nums:\n                \n                #add the number to the list\n                result.append(nums[i])\n                \n        #return the list\n        return result", "runtimes": [0.0002620220184326172, 0.00026869773864746094, 0.0002703666687011719, 0.0002703666687011719, 0.00027108192443847656, 0.0002727508544921875, 0.0002741813659667969, 0.0002808570861816406, 0.0002925395965576172, 0.0003032684326171875, 0.0003056526184082031, 0.00031566619873046875, 0.00031685829162597656, 0.0003190040588378906, 0.0003230571746826172, 0.0003249645233154297, 0.00032520294189453125, 0.00032639503479003906, 0.0003323554992675781, 0.0003402233123779297, 0.0003409385681152344, 0.0003662109375, 0.0003688335418701172], "beyond_p": 0.0}], "count-of-smaller-numbers-after-self": [{"slug_name": "count-of-smaller-numbers-after-self", "status": {"result": "failed@cases", "runtime": 0.0006079673767089844, "index": 0}, "solution": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        #initialize an empty list to store the count of smaller elements\n        count = []\n        \n        #initialize an empty list to store the sorted elements\n        sorted_list = []\n        \n        #loop through the nums list\n        for i in nums:\n            \n            #initialize a variable to store the count of smaller elements\n            count_smaller = 0\n            \n            #loop through the sorted_list\n            for j in sorted_list:\n                \n                #if the element in the sorted_list is smaller than the element in the nums list\n                if j < i:\n                    \n                    #increment the count of smaller elements\n                    count_smaller += 1\n                    \n            #append the count of smaller elements to the count list\n            count.append(count_smaller)\n            \n            #append the element in the nums list to the sorted_list\n            sorted_list.append(i)\n            \n        #return the count list\n        return count", "runtimes": [0.0003712177276611328, 0.00038743019104003906, 0.00040531158447265625, 0.00040650367736816406, 0.0007700920104980469, 0.0008416175842285156, 0.0008459091186523438, 0.0010406970977783203, 0.001190185546875, 0.001191854476928711, 0.0012691020965576172, 0.0012712478637695312, 0.0017037391662597656, 0.0018839836120605469, 0.0019114017486572266, 0.0023584365844726562, 0.005418539047241211, 0.005588054656982422, 0.007394552230834961, 0.013303995132446289], "beyond_p": 0.0}], "set-intersection-size-at-least-two": [{"slug_name": "set-intersection-size-at-least-two", "status": {"result": "failed@cases", "runtime": 0.0015192031860351562, "index": 0}, "solution": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key = lambda x: x[0])\n        ans = 0\n        for i in range(len(intervals)):\n            if i == 0:\n                ans += 2\n            else:\n                if intervals[i][0] <= intervals[i-1][1] + 1:\n                    ans += 1\n                else:\n                    ans += 2\n        return ans", "runtimes": [0.0012450218200683594, 0.0012559890747070312, 0.0013930797576904297, 0.001926422119140625, 0.0032172203063964844, 0.003837108612060547, 0.004658699035644531, 0.004771232604980469, 0.0052337646484375, 0.00670313835144043, 0.0072956085205078125], "beyond_p": 0.0}], "symmetric-tree": [{"slug_name": "symmetric-tree", "status": {"result": "passed", "runtime": 0.0003800392150878906, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        return self.isSymmetricHelper(root.left, root.right)\n        \n    def isSymmetricHelper(self, left, right):\n        if left is None and right is None:\n            return True\n        if left is None or right is None:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isSymmetricHelper(left.left, right.right) and self.isSymmetricHelper(left.right, right.left)", "runtimes": [0.0003635883331298828, 0.0003669261932373047, 0.0003676414489746094, 0.0003688335418701172, 0.0003714561462402344, 0.00037550926208496094, 0.0003845691680908203, 0.0003864765167236328, 0.00038743019104003906, 0.0003886222839355469, 0.0004410743713378906, 0.00048232078552246094, 0.0005004405975341797, 0.0005180835723876953, 0.0005970001220703125], "beyond_p": 0.9295199182839632}], "number-of-atoms": [{"slug_name": "number-of-atoms", "status": {"result": "failed@cases", "runtime": 0.0015211105346679688, "index": 0}, "solution": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in range(len(formula)):\n            if formula[i] == '(':\n                stack.append(formula[i])\n            elif formula[i] == ')':\n                while stack[-1] != '(':\n                    stack.pop()\n                stack.pop()\n            else:\n                stack.append(formula[i])\n        print(stack)\n        stack.reverse()\n        print(stack)\n        return stack", "runtimes": [0.002141714096069336, 0.010527610778808594, 0.016402721405029297], "beyond_p": 0.0}], "binary-tree-preorder-traversal": [{"slug_name": "binary-tree-preorder-traversal", "status": {"result": "passed", "runtime": 0.0004024505615234375, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        else:\n            return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)", "runtimes": [0.0004787445068359375, 0.0004820823669433594, 0.0004830360412597656, 0.0004885196685791016, 0.0005023479461669922, 0.0005064010620117188, 0.0005097389221191406, 0.0005199909210205078, 0.0006473064422607422, 0.0006511211395263672, 0.0006706714630126953, 0.0008549690246582031], "beyond_p": 1.202788339670469}], "power-of-four": [{"slug_name": "power-of-four", "status": {"result": "passed", "runtime": 0.0002853870391845703, "index": 0}, "solution": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n % 4 == 0:\n            return self.isPowerOfFour(n/4)\n        else:\n            return False", "runtimes": [0.0002715587615966797, 0.0002837181091308594, 0.0002930164337158203, 0.00031828880310058594, 0.00032258033752441406, 0.0003247261047363281, 0.0003573894500732422, 0.0003612041473388672, 0.00036215782165527344, 0.0003628730773925781, 0.0003638267517089844, 0.000385284423828125], "beyond_p": 0.8784067085953878}], "invert-binary-tree": [{"slug_name": "invert-binary-tree", "status": {"result": "passed", "runtime": 0.0006351470947265625, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        else:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n            return root", "runtimes": [0.00048804283142089844, 0.0004904270172119141, 0.0004966259002685547, 0.0004980564117431641, 0.0006322860717773438, 0.0006382465362548828, 0.0006425380706787109, 0.0006427764892578125, 0.0006427764892578125, 0.0006487369537353516, 0.0006592273712158203, 0.0006647109985351562, 0.0006690025329589844, 0.0008428096771240234], "beyond_p": 0.5853494623655914}], "generate-parentheses": [{"slug_name": "generate-parentheses", "status": {"result": "passed", "runtime": 0.0006210803985595703, "index": 0}, "solution": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(A = [], left = 0, right = 0, n = n):\n            if len(A) == 2*n:\n                yield \"\".join(A)\n            if left < n:\n                A.append(\"(\")\n                for g in generate(A, left+1, right, n):\n                    yield g\n                A.pop()\n            if right < left:\n                A.append(\")\")\n                for g in generate(A, left, right+1, n):\n                    yield g\n                A.pop()\n        return [i for i in generate()]", "runtimes": [0.0004825592041015625, 0.0005118846893310547, 0.0005125999450683594, 0.0005145072937011719, 0.0005211830139160156, 0.0005252361297607422, 0.0005407333374023438, 0.0005595684051513672, 0.0005650520324707031, 0.0005934238433837891, 0.0006024837493896484, 0.0006277561187744141, 0.0006287097930908203, 0.00067138671875, 0.0007417201995849609, 0.0008487701416015625, 0.000957489013671875, 0.0013492107391357422, 0.0016548633575439453], "beyond_p": 0.8818385194224121}], "patching-array": [{"slug_name": "patching-array", "status": {"result": "failed@cases", "runtime": 0.0003027915954589844, "index": 0}, "solution": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the patches counter\n        patches = 0\n        \n        # Initialize the current sum\n        curr_sum = 1\n        \n        # Initialize the index\n        index = 0\n        \n        # Loop until the current sum is greater than n\n        while curr_sum <= n:\n            \n            # If the index is valid and the current sum is less than the number at the index\n            if index < len(nums) and curr_sum < nums[index]:\n                \n                # Increment the current sum by the number at the index\n                curr_sum += nums[index]\n                \n                # Increment the index\n                index += 1\n            \n            # Otherwise\n            else:\n                \n                # Increment the current sum by the current sum\n                curr_sum *= 2\n                \n                # Increment the patches counter\n                patches += 1\n        \n        # Return the patches counter\n        return patches", "runtimes": [0.0005178451538085938, 0.0006878376007080078, 0.0007338523864746094, 0.0007340908050537109, 0.0007350444793701172, 0.0007910728454589844, 0.0007956027984619141, 0.0008044242858886719, 0.0008864402770996094, 0.007946252822875977], "beyond_p": 0.0}], "longest-valid-parentheses": [{"slug_name": "longest-valid-parentheses", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a stack\n        stack = []\n        # Initialize the maximum length of valid parentheses\n        max_len = 0\n        # Iterate over the string\n        for char in s:\n            # If the current character is an opening parenthesis\n            if char == '(':\n                # Push it onto the stack\n                stack.append(char)\n            # If the current character is a closing parenthesis\n            elif char == ')':\n                # If the stack is not empty\n                if stack:\n                    # Pop the top element\n                    stack.pop()\n                    # If the stack is now empty\n                    if not stack:\n                        # Update the maximum length\n                        max_len = max(max_len, len(s) - 1)\n                    # If the stack is not empty\n                    else:\n                        # Update the maximum length\n                        max_len = max(max_len, len(s) - stack[-1])\n                # If the stack is empty\n                else:\n                    # Update the maximum length\n                    max_len = max(max_len, len(s))\n        # Return the maximum length\n        return max_len", "runtimes": [0.0005896091461181641, 0.0006670951843261719, 0.0006959438323974609, 0.0007026195526123047, 0.0007154941558837891, 0.0007154941558837891, 0.0007166862487792969, 0.0007262229919433594, 0.0007357597351074219, 0.0007550716400146484, 0.0007624626159667969, 0.0008978843688964844, 0.0009431838989257812, 0.00098419189453125, 0.0010251998901367188, 0.0010497570037841797, 0.0013151168823242188], "beyond_p": 0.0}], "fraction-to-recurring-decimal": [{"slug_name": "fraction-to-recurring-decimal", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = \"-\"\n        elif numerator > 0 and denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        whole = str(numerator // denominator)\n        fraction = str(numerator % denominator)\n        \n        if fraction == \"0\":\n            return sign + whole\n        \n        fraction_dict = {}\n        fraction_list = []\n        while fraction not in fraction_dict:\n            fraction_dict[fraction] = len(fraction_list)\n            fraction = str(int(fraction) * 10)\n            fraction_list.append(fraction)\n        \n        fraction_string = \"\".join(fraction_list)\n        fraction_string = fraction_string[:fraction_dict[fraction]] + \"(\" + fraction_string[fraction_dict[fraction]:] + \")\"\n        \n        return sign + whole + \".\" + fraction_string", "runtimes": [0.0004551410675048828, 0.00045943260192871094, 0.0004620552062988281, 0.00046443939208984375, 0.00046706199645996094, 0.0004673004150390625, 0.0004687309265136719, 0.000469207763671875, 0.0004699230194091797, 0.0004737377166748047, 0.0004935264587402344], "beyond_p": 0.0}], "sort-list": [{"slug_name": "sort-list", "status": {"result": "passed", "runtime": 0.004724025726318359, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast is not None and fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode(0)\n        cur = dummy\n        \n        while left is not None and right is not None:\n            if left.val < right.val:\n                cur.next = left\n                left = left.next\n            else:\n                cur.next = right\n                right = right.next\n            cur = cur.next\n        \n        cur.next = left if left is not None else right\n        \n        return dummy.next", "runtimes": [0.0017094612121582031, 0.001806020736694336, 0.0018970966339111328, 0.0019562244415283203, 0.002355813980102539, 0.002585172653198242, 0.00412750244140625, 0.004471302032470703, 0.004645586013793945, 0.004762887954711914, 0.004878997802734375, 0.0048902034759521484, 0.0049288272857666016, 0.0050389766693115234, 0.005286216735839844, 0.0054056644439697266, 0.005524158477783203, 0.0056116580963134766, 0.005785942077636719, 0.005899667739868164, 0.006199836730957031, 0.0063440799713134766, 0.006569862365722656], "beyond_p": 0.37977043068772687}], "russian-doll-envelopes": [{"slug_name": "russian-doll-envelopes", "status": {"result": "passed", "runtime": 0.18546319007873535, "index": 0}, "solution": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], x[1]))\n        \n        # Initialize the dp array\n        dp = [1] * len(envelopes)\n        \n        # Initialize the maximum height\n        max_height = 0\n        \n        # Loop through the envelopes\n        for i in range(len(envelopes)):\n            \n            # Get the current width and height\n            width = envelopes[i][0]\n            height = envelopes[i][1]\n            \n            # Loop through the previous envelopes\n            for j in range(i):\n                \n                # Get the previous width and height\n                prev_width = envelopes[j][0]\n                prev_height = envelopes[j][1]\n                \n                # Check if the current envelope can fit into the previous envelope\n                if width > prev_width and height > prev_height:\n                    \n                    # Update the maximum height\n                    max_height = max(max_height, height)\n                    \n                    # Update the dp value\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        # Return the maximum number of envelopes that can be Russian doll\n        return max(dp)", "runtimes": [0.0017671585083007812, 0.0017740726470947266, 0.0017910003662109375, 0.0018277168273925781, 0.0018811225891113281, 0.0019655227661132812, 0.0021364688873291016, 0.0023713111877441406, 0.002478361129760742, 0.0027811527252197266, 0.002803802490234375, 0.0028982162475585938, 0.003954410552978516, 0.0041162967681884766, 0.0041351318359375, 0.004738807678222656, 0.005312442779541016, 0.0067348480224609375, 0.017960786819458008, 0.021886587142944336], "beyond_p": 0.0}], "set-matrix-zeroes": [{"slug_name": "set-matrix-zeroes", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # Initialize two boolean variables to keep track of rows and columns\n        row = False\n        col = False\n        \n        # Traverse the matrix and if an element is 0, set the corresponding row and column to True\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] == 0:\n                    row = True\n                    col = True\n                    break\n                    \n        # If row is True, set all elements in the current row to 0\n        if row:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    matrix[i][j] = 0\n                    \n        # If col is True, set all elements in the current column to 0\n        if col:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    matrix[j][i] = 0", "runtimes": [0.0003170967102050781, 0.00031876564025878906, 0.0003228187561035156, 0.0003275871276855469, 0.00032782554626464844, 0.0003285408020019531, 0.00033164024353027344, 0.0003337860107421875, 0.0003368854522705078, 0.0003371238708496094, 0.00034117698669433594, 0.0003504753112792969, 0.0003540515899658203, 0.0003552436828613281, 0.0003552436828613281, 0.00035572052001953125, 0.0003566741943359375, 0.0003581047058105469, 0.0003693103790283203, 0.00037550926208496094, 0.0003769397735595703, 0.00038623809814453125, 0.0004241466522216797, 0.00045108795166015625, 0.0006585121154785156, 0.0006678104400634766, 0.0007300376892089844], "beyond_p": 0.0}], "remove-nth-node-from-end-of-list": [{"slug_name": "remove-nth-node-from-end-of-list", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize two pointers\n        first = head\n        second = head\n        \n        # Move the second pointer n-1 steps ahead\n        for i in range(n-1):\n            second = second.next\n        \n        # If the second pointer is at the end, then\n        # the first pointer is at the (n-1)th node\n        if second.next == None:\n            head = head.next\n            return head\n        \n        # Move both pointers until the second pointer\n        # reaches the end\n        while second.next != None:\n            first = first.next\n            second = second.next\n        \n        # First must be pointing to the (n-1)th node\n        # So, delete the next node\n        first.next = first.next.next\n        \n        return head", "runtimes": [0.00034427642822265625, 0.0003478527069091797, 0.0003478527069091797, 0.00034880638122558594, 0.0003490447998046875, 0.00035119056701660156, 0.0003521442413330078, 0.0003521442413330078, 0.00035381317138671875, 0.0003540515899658203, 0.00035452842712402344, 0.00035452842712402344, 0.0003554821014404297, 0.00035572052001953125, 0.0003561973571777344, 0.0003571510314941406, 0.0003573894500732422, 0.00035881996154785156, 0.0003590583801269531, 0.00036072731018066406, 0.00036215782165527344, 0.00036334991455078125, 0.0003643035888671875, 0.0003650188446044922, 0.0003662109375, 0.00036787986755371094, 0.0003685951232910156, 0.00036907196044921875, 0.0003695487976074219, 0.00038051605224609375, 0.0003809928894042969, 0.0003814697265625], "beyond_p": 0.0}], "intersection-of-two-arrays": [{"slug_name": "intersection-of-two-arrays", "status": {"result": "passed", "runtime": 0.0007545948028564453, "index": 0}, "solution": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1).intersection(set(nums2)))", "runtimes": [0.0007050037384033203, 0.0007112026214599609, 0.0007195472717285156, 0.0007259845733642578, 0.0007269382476806641, 0.000736236572265625, 0.0007419586181640625, 0.0007569789886474609, 0.0007615089416503906, 0.0008509159088134766, 0.0009546279907226562, 0.0010707378387451172, 0.001689910888671875, 0.0018589496612548828, 0.0023610591888427734, 0.00739598274230957, 0.007703065872192383, 0.015407800674438477, 0.017191410064697266, 0.03646731376647949], "beyond_p": 0.9986133148441979}], "super-washing-machines": [{"slug_name": "super-washing-machines", "status": {"result": "failed@cases", "runtime": 0.00036025047302246094, "index": 0}, "solution": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Find the total number of dresses\n        total = sum(machines)\n        \n        # If total is odd, then it is not possible to make all washing machines have the same number of dresses.\n        if total % len(machines) != 0:\n            return -1\n        \n        # Find the number of dresses each washing machine should have\n        target = total // len(machines)\n        \n        # Initialize the result\n        result = 0\n        \n        # Initialize the extra dresses\n        extra = 0\n        \n        # Iterate over the washing machines\n        for machine in machines:\n            \n            # Add the extra dresses to the current washing machine\n            machine += extra\n            \n            # If the number of dresses in the current washing machine is greater than the target\n            if machine > target:\n                \n                # Add the difference to the result\n                result += machine - target\n                \n                # Add the difference to the extra dresses\n                extra += machine - target\n                \n            # If the number of dresses in the current washing machine is less than the target\n            elif machine < target:\n                \n                # Add the difference to the result\n                result += target - machine\n                \n                # Subtract the difference from the extra dresses\n                extra -= target - machine\n                \n        return result", "runtimes": [0.00033402442932128906, 0.00034427642822265625, 0.0003502368927001953, 0.0003535747528076172, 0.000354766845703125, 0.0003573894500732422, 0.00035881996154785156, 0.00036025047302246094, 0.000362396240234375, 0.00036263465881347656, 0.0003674030303955078, 0.0003674030303955078, 0.00036835670471191406, 0.00037097930908203125, 0.00037169456481933594, 0.00037217140197753906], "beyond_p": 0.0}], "kth-smallest-number-in-multiplication-table": [{"slug_name": "kth-smallest-number-in-multiplication-table", "status": {"result": "passed", "runtime": 0.3252737522125244, "index": 0}, "solution": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(mid):\n            count = 0\n            for i in range(1, m+1):\n                count += min(mid//i, n)\n            return count\n        \n        left = 1\n        right = m*n\n        while left < right:\n            mid = (left + right)//2\n            if count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "runtimes": [0.07293367385864258, 0.11299562454223633, 0.13379502296447754, 0.15007472038269043, 0.19428110122680664, 0.2872650623321533, 0.3061051368713379, 0.32951784133911133, 0.3333725929260254, 0.33473992347717285, 0.33765435218811035, 0.3572678565979004, 0.36495542526245117, 0.3710300922393799, 0.45120716094970703, 0.4813077449798584], "beyond_p": 0.382085944729383}], "convert-sorted-list-to-binary-search-tree": [{"slug_name": "convert-sorted-list-to-binary-search-tree", "status": {"result": "passed", "runtime": 0.005194425582885742, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head.next.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        \n        return root", "runtimes": [0.005338907241821289, 0.005403757095336914, 0.005501985549926758, 0.005514860153198242, 0.005537271499633789, 0.005582332611083984, 0.005656719207763672, 0.0057566165924072266, 0.00578618049621582, 0.006146430969238281, 0.00632476806640625, 0.006345272064208984, 0.007496356964111328, 0.008672237396240234], "beyond_p": 1.0433445390172378}], "merge-two-sorted-lists": [{"slug_name": "merge-two-sorted-lists", "status": {"result": "passed", "runtime": 0.0005440711975097656, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2", "runtimes": [0.00047969818115234375, 0.0004830360412597656, 0.00048470497131347656, 0.00048661231994628906, 0.0004889965057373047, 0.0004901885986328125, 0.0004935264587402344, 0.0004935264587402344, 0.0004951953887939453, 0.0004968643188476562, 0.0004968643188476562, 0.0004973411560058594, 0.0004982948303222656, 0.0004985332489013672, 0.0004987716674804688, 0.0004992485046386719, 0.0005006790161132812, 0.0005011558532714844, 0.0005013942718505859, 0.0005040168762207031, 0.0005042552947998047, 0.0005052089691162109, 0.0005054473876953125, 0.0005066394805908203, 0.0005068778991699219, 0.0005102157592773438, 0.0005183219909667969, 0.000537872314453125, 0.0005414485931396484, 0.0005598068237304688, 0.0005657672882080078, 0.0005736351013183594, 0.0006039142608642578, 0.0006105899810791016, 0.0006113052368164062, 0.0015225410461425781], "beyond_p": 0.9382716049382716}], "maximal-rectangle": [{"slug_name": "maximal-rectangle", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        heights = [0] * (cols + 1)\n        max_area = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n                    \n            # print(heights)\n            stack = []\n            heights.append(0)\n            for j in range(len(heights)):\n                while stack and heights[stack[-1]] > heights[j]:\n                    h = heights[stack.pop()]\n                    w = j - stack[-1] - 1\n                    max_area = max(max_area, h * w)\n                stack.append(j)\n                \n        return max_area", "runtimes": [0.0005884170532226562, 0.0005900859832763672, 0.0005962848663330078, 0.0006639957427978516, 0.0007884502410888672, 0.0008032321929931641, 0.001041412353515625, 0.0010554790496826172, 0.0010595321655273438, 0.001070261001586914, 0.0011439323425292969, 0.0011947154998779297, 0.0012476444244384766, 0.0012731552124023438, 0.001378774642944336, 0.0013921260833740234, 0.0014815330505371094, 0.001504659652709961, 0.0016050338745117188, 0.0016210079193115234, 0.0016474723815917969, 0.0017292499542236328, 0.0017309188842773438, 0.001733541488647461, 0.0018472671508789062, 0.0031685829162597656, 0.015569686889648438], "beyond_p": 0.0}], "subsets": [{"slug_name": "subsets", "status": {"result": "passed", "runtime": 0.0003147125244140625, "index": 0}, "solution": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Initialize the result with an empty list\n        result = [[]]\n        \n        # Iterate over the input array\n        for num in nums:\n            # Append num to each of the existing subsets\n            result += [subset + [num] for subset in result]\n        \n        # Return the result\n        return result", "runtimes": [0.0003261566162109375, 0.0003342628479003906, 0.00035643577575683594, 0.0003681182861328125, 0.0003719329833984375, 0.0003745555877685547, 0.00037741661071777344, 0.0003867149353027344, 0.00039315223693847656, 0.0003948211669921875, 0.00039958953857421875, 0.00040149688720703125, 0.00040268898010253906, 0.0004050731658935547, 0.00040841102600097656, 0.0004093647003173828], "beyond_p": 1.1375358166189111}], "find-minimum-in-rotated-sorted-array-ii": [{"slug_name": "find-minimum-in-rotated-sorted-array-ii", "status": {"result": "passed", "runtime": 0.00027632713317871094, "index": 0}, "solution": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return nums[left]", "runtimes": [0.0002732276916503906, 0.00027561187744140625, 0.00027632713317871094, 0.0002765655517578125, 0.00027680397033691406, 0.0002777576446533203, 0.0002808570861816406, 0.0002818107604980469, 0.00028252601623535156, 0.00028252601623535156, 0.00028586387634277344, 0.00028824806213378906, 0.0002903938293457031, 0.00029587745666503906, 0.00034880638122558594], "beyond_p": 0.9589905362776026}], "valid-number": [{"slug_name": "valid-number", "status": {"result": "passed", "runtime": 0.0002789497375488281, "index": 0}, "solution": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the string is empty\n        if len(s) == 0:\n            return False\n        \n        # check if the string is a valid number\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False", "runtimes": [0.00027108192443847656, 0.0002720355987548828, 0.0002741813659667969, 0.00027441978454589844, 0.00027489662170410156, 0.00027871131896972656, 0.0002853870391845703, 0.00028705596923828125, 0.0002875328063964844, 0.00028777122497558594, 0.00028896331787109375, 0.00030231475830078125, 0.0008437633514404297], "beyond_p": 0.9862614487926727}], "integer-to-roman": [{"slug_name": "integer-to-roman", "status": {"result": "passed", "runtime": 0.00028252601623535156, "index": 0}, "solution": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_numerals = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        result = ''\n        \n        for value in roman_numerals:\n            while num >= value:\n                result += roman_numerals[value]\n                num -= value\n                \n        return result", "runtimes": [0.00026798248291015625, 0.0002727508544921875, 0.00027871131896972656, 0.0002796649932861328, 0.0002799034118652344, 0.00028228759765625, 0.00028228759765625, 0.0002880096435546875, 0.0002906322479248047, 0.0002949237823486328, 0.0002951622009277344, 0.0002994537353515625, 0.00030541419982910156, 0.00031375885009765625, 0.00031876564025878906, 0.0003192424774169922, 0.00032711029052734375, 0.0004222393035888672], "beyond_p": 0.9057187017001546}], "find-the-difference": [{"slug_name": "find-the-difference", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR operation\n        # XOR of all characters in s and t\n        # will give the extra character in t\n        return chr(reduce(operator.xor, map(ord, s + t)))", "runtimes": [0.00041937828063964844, 0.00042557716369628906, 0.0004329681396484375, 0.0005168914794921875, 0.0005438327789306641, 0.0006287097930908203, 0.0006401538848876953, 0.0007848739624023438, 0.0009105205535888672, 0.0009920597076416016, 0.0025970935821533203, 0.002646923065185547, 0.002660036087036133, 0.0027832984924316406], "beyond_p": 0.0}], "sudoku-solver": [{"slug_name": "sudoku-solver", "status": {"result": "passed", "runtime": 0.04792952537536621, "index": 0}, "solution": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def is_valid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3*(row//3)+i//3][3*(col//3)+i%3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == \".\":\n                        for num in range(1, 10):\n                            if is_valid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = \".\"\n                        return False\n            return True\n        \n        solve(board)", "runtimes": [0.0009400844573974609, 0.005259990692138672, 0.006269216537475586, 0.012710332870483398, 0.01342010498046875, 0.018326282501220703, 0.020202159881591797, 0.024643659591674805, 0.024725675582885742, 0.03206515312194824, 0.032620906829833984, 0.03960776329040527, 0.040474653244018555, 0.04140210151672363, 0.042671918869018555, 0.04403233528137207, 0.04699373245239258, 0.04942822456359863, 0.04957413673400879, 0.05662250518798828, 0.06760096549987793, 0.07921242713928223, 0.0947575569152832], "beyond_p": 0.4991397690972531}], "recover-binary-search-tree": [{"slug_name": "recover-binary-search-tree", "status": {"result": "passed", "runtime": 0.00036716461181640625, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # Find the two nodes\n        first = None\n        second = None\n        prev = None\n        current = root\n        while current:\n            if current.left:\n                # Find the next node in the inorder traversal\n                next_node = current.left\n                while next_node.right and next_node.right != current:\n                    next_node = next_node.right\n                \n                # If the right child exists and it's not pointing to the current node\n                if next_node.right == None:\n                    # Make the current node the right child of the next node\n                    next_node.right = current\n                    # Move the current node to the left child of the next node\n                    current = current.left\n                    continue\n                else:\n                    # The next node already visited the current node\n                    next_node.right = None\n                \n                # Check if the current node is the first node\n                if prev and prev.val > current.val:\n                    # If the first node is not found, set it to the current node\n                    if not first:\n                        first = prev\n                    # Set the second node to the current node\n                    second = current\n                \n                # Update the previous node\n                prev = current\n                \n                # Move the current node to the right child\n                current = current.right\n            else:\n                # Check if the current node is the first node\n                if prev and prev.val > current.val:\n                    # If the first node is not found, set it to the current node\n                    if not first:\n                        first = prev\n                    # Set the second node to the current node\n                    second = current\n                \n                # Update the previous node\n                prev = current\n                \n                # Move the current node to the right child\n                current = current.right\n        \n        # Swap the values of the two nodes\n        first.val, second.val = second.val, first.val", "runtimes": [0.00036525726318359375, 0.0003657341003417969, 0.0003657341003417969, 0.0003693103790283203, 0.0003712177276611328, 0.00037598609924316406, 0.0003762245178222656, 0.000377655029296875, 0.0003781318664550781, 0.0003795623779296875, 0.0003840923309326172, 0.00038433074951171875, 0.0003886222839355469, 0.00039577484130859375, 0.000396728515625, 0.0004124641418457031, 0.0004394054412841797], "beyond_p": 0.9742765273311897}], "palindrome-linked-list": [{"slug_name": "palindrome-linked-list", "status": {"result": "passed", "runtime": 0.0018765926361083984, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # Find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half\n        node = None\n        while slow:\n            temp = slow.next\n            slow.next = node\n            node = slow\n            slow = temp\n        \n        # Check whether or not there is a palindrome\n        while node:\n            if node.val != head.val:\n                return False\n            node = node.next\n            head = head.next\n        return True", "runtimes": [0.0018000602722167969, 0.0018126964569091797, 0.0018146038055419922, 0.001825571060180664, 0.0018343925476074219, 0.0018467903137207031, 0.0018546581268310547, 0.001856088638305664, 0.0018563270568847656, 0.001863241195678711, 0.0018644332885742188, 0.0018689632415771484, 0.0018715858459472656, 0.001874685287475586, 0.0018808841705322266, 0.001920461654663086, 0.0019216537475585938, 0.001932382583618164, 0.0019414424896240234, 0.001967906951904297, 0.0021779537200927734, 0.0021898746490478516, 0.002745389938354492], "beyond_p": 0.9190416141235813}], "valid-perfect-square": [{"slug_name": "valid-perfect-square", "status": {"result": "passed", "runtime": 0.008591175079345703, "index": 0}, "solution": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        for i in range(1, num):\n            if i * i == num:\n                return True\n            elif i * i > num:\n                return False", "runtimes": [0.0002467632293701172, 0.0002512931823730469, 0.0002512931823730469, 0.00025177001953125, 0.0002551078796386719, 0.0002562999725341797, 0.0002574920654296875, 0.0002582073211669922, 0.00025963783264160156, 0.0002608299255371094, 0.0002684593200683594, 0.0003037452697753906, 0.0003180503845214844, 0.008579254150390625, 0.008612871170043945], "beyond_p": 0.0025933314334568255}], "counting-bits": [{"slug_name": "counting-bits", "status": {"result": "passed", "runtime": 0.0004112720489501953, "index": 0}, "solution": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i & i - 1] + 1\n        return ans", "runtimes": [0.000400543212890625, 0.0004239082336425781, 0.00042510032653808594, 0.00042629241943359375, 0.0004372596740722656, 0.0004677772521972656, 0.0005178451538085938, 0.0007307529449462891, 0.0007870197296142578, 0.00090789794921875, 0.0009844303131103516, 0.0010914802551269531, 0.001108407974243164, 0.0012238025665283203, 0.0013065338134765625, 0.0013194084167480469, 0.0015196800231933594, 0.0016202926635742188, 0.0016412734985351562, 0.0018460750579833984, 0.0021011829376220703, 0.0032062530517578125, 0.0038144588470458984], "beyond_p": 0.9968573224387178}], "remove-linked-list-elements": [{"slug_name": "remove-linked-list-elements", "status": {"result": "passed", "runtime": 0.000507354736328125, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return None\n        \n        while head is not None and head.val == val:\n            head = head.next\n        \n        if head is None:\n            return None\n        \n        current = head\n        \n        while current.next is not None:\n            if current.next.val == val:\n                current.next = current.next.next\n            else:\n                current = current.next\n        \n        return head", "runtimes": [0.000492095947265625, 0.0004940032958984375, 0.0004971027374267578, 0.0005016326904296875, 0.0005033016204833984, 0.0005033016204833984, 0.0005068778991699219, 0.0005106925964355469, 0.0005137920379638672, 0.0005140304565429688, 0.0005176067352294922, 0.0005204677581787109, 0.0005235671997070312, 0.0005240440368652344, 0.0005366802215576172, 0.0005700588226318359, 0.0006692409515380859, 0.0006802082061767578], "beyond_p": 0.9188846641318125}], "scramble-string": [{"slug_name": "scramble-string", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if len(s1) == 1:\n            return s1 == s2\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False", "runtimes": [0.0006241798400878906, 0.0010986328125, 0.0011751651763916016, 0.0012083053588867188, 0.006203413009643555, 0.006823062896728516, 0.007126569747924805, 0.009785175323486328, 0.013225078582763672, 0.014347314834594727, 0.01448202133178711, 0.015184402465820312, 0.017464160919189453, 0.017696142196655273, 0.017726898193359375, 0.018793821334838867, 0.024032115936279297, 0.03259539604187012, 0.03261709213256836, 0.03308677673339844, 0.03328752517700195], "beyond_p": 0.0}], "simplify-path": [{"slug_name": "simplify-path", "status": {"result": "passed", "runtime": 0.0002899169921875, "index": 0}, "solution": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # split the path into a list of directories\n        dirs = path.split('/')\n        \n        # create a stack to hold the directories\n        stack = []\n        \n        # loop through the list of directories\n        for dir in dirs:\n            \n            # if the directory is empty or a period, skip it\n            if dir == '' or dir == '.':\n                continue\n            \n            # if the directory is a double period, pop the top directory off the stack\n            elif dir == '..':\n                if len(stack) > 0:\n                    stack.pop()\n            \n            # otherwise, add the directory to the stack\n            else:\n                stack.append(dir)\n        \n        # join the directories in the stack with a slash\n        return '/' + '/'.join(stack)", "runtimes": [0.00027751922607421875, 0.00028061866760253906, 0.00028228759765625, 0.00028324127197265625, 0.0002849102020263672, 0.000286102294921875, 0.0002868175506591797, 0.00028705596923828125, 0.0002875328063964844, 0.00029349327087402344, 0.0002956390380859375, 0.0002963542938232422, 0.0002970695495605469, 0.00029754638671875, 0.00030112266540527344, 0.0003044605255126953, 0.00030541419982910156, 0.00030875205993652344, 0.0003218650817871094, 0.00044608116149902344], "beyond_p": 0.9264497878359265}], "word-search-ii": [{"slug_name": "word-search-ii", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the Trie\n        root = {}\n        for word in words:\n            current = root\n            for letter in word:\n                if letter not in current:\n                    current[letter] = {}\n                current = current[letter]\n            current['#'] = '#'\n            \n        # Initialize the answer\n        found_words = []\n        \n        # Iterate through the board\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                # Check if the current cell is the starting of any word\n                if board[i][j] in root:\n                    current = root[board[i][j]]\n                    self.dfs(i, j, board, current, found_words)\n                    \n        return found_words\n    \n    def dfs(self, i, j, board, current, found_words):\n        # If we have found the entire word, add it to the answer\n        if '#' in current:\n            found_words.append(board[i][j])\n            \n        # If the current cell is not a starting of any word, return\n        if board[i][j] not in current:\n            return\n        \n        # Temporarily mark the current cell as visited\n        board[i][j] = ' '\n        \n        # Recursively explore all the adjacent cells\n        if i > 0 and board[i - 1][j] != ' ':\n            self.dfs(i - 1, j, board, current[board[i - 1][j]], found_words)\n        if j > 0 and board[i][j - 1] != ' ':\n            self.dfs(i, j - 1, board, current[board[i][j - 1]], found_words)\n        if i < len(board) - 1 and board[i + 1][j] != ' ':\n            self.dfs(i + 1, j, board, current[board[i + 1][j]], found_words)\n        if j < len(board[0]) - 1 and board[i][j + 1] != ' ':\n            self.dfs(i, j + 1, board, current[board[i][j + 1]], found_words)\n            \n        # Backtrack\n        board[i][j] = current.keys()[0]", "runtimes": [0.0005090236663818359, 0.0005161762237548828, 0.0005228519439697266, 0.0005292892456054688, 0.0005457401275634766, 0.0005617141723632812, 0.0005681514739990234, 0.0005698204040527344, 0.0005900859832763672, 0.0006227493286132812, 0.0006303787231445312, 0.0006525516510009766, 0.0007059574127197266, 0.0007452964782714844, 0.0007593631744384766, 0.0007812976837158203, 0.0007829666137695312, 0.0007853507995605469, 0.0008056163787841797], "beyond_p": 0.0}], "valid-anagram": [{"slug_name": "valid-anagram", "status": {"result": "passed", "runtime": 0.00226593017578125, "index": 0}, "solution": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if length of s and t are not equal then return false\n        if len(s) != len(t):\n            return False\n        \n        # if length of s and t are equal then sort both the strings\n        s = sorted(s)\n        t = sorted(t)\n        \n        # if both the sorted strings are equal then return true\n        if s == t:\n            return True\n        else:\n            return False", "runtimes": [0.0005300045013427734, 0.0009217262268066406, 0.0009219646453857422, 0.0009281635284423828, 0.0009326934814453125, 0.0009427070617675781, 0.0016787052154541016, 0.001775503158569336, 0.0020856857299804688, 0.0021810531616210938, 0.002189159393310547, 0.002204418182373047, 0.0022735595703125, 0.0022788047790527344, 0.0022983551025390625, 0.002315044403076172, 0.0023810863494873047, 0.002382516860961914, 0.0028963088989257812, 0.004324197769165039, 0.005868673324584961], "beyond_p": 0.6748392282958199}], "valid-sudoku": [{"slug_name": "valid-sudoku", "status": {"result": "passed", "runtime": 0.00030994415283203125, "index": 0}, "solution": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        #check rows\n        for row in board:\n            if not self.isValidList(row):\n                return False\n        \n        #check columns\n        for col in zip(*board):\n            if not self.isValidList(col):\n                return False\n        \n        #check 3x3 sub-boxes\n        for i in (0,3,6):\n            for j in (0,3,6):\n                box = [board[x][y] for x in range(i,i+3) for y in range(j,j+3)]\n                if not self.isValidList(box):\n                    return False\n        \n        return True\n    \n    def isValidList(self,myList):\n        mySet = set()\n        for i in myList:\n            if i != '.':\n                if i in mySet:\n                    return False\n                else:\n                    mySet.add(i)\n        return True", "runtimes": [0.0003018379211425781, 0.0003020763397216797, 0.00031256675720214844, 0.00031280517578125, 0.00031876564025878906, 0.00032019615173339844, 0.0003204345703125, 0.0003337860107421875, 0.0003361701965332031, 0.0003364086151123047, 0.00033783912658691406, 0.0003619194030761719, 0.0003807544708251953, 0.00043582916259765625, 0.0005934238433837891, 0.0006105899810791016, 0.0006847381591796875], "beyond_p": 0.9788293897882939}], "fizz-buzz": [{"slug_name": "fizz-buzz", "status": {"result": "passed", "runtime": 0.00037026405334472656, "index": 0}, "solution": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        result = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result", "runtimes": [0.0003504753112792969, 0.0003523826599121094, 0.0003573894500732422, 0.000362396240234375, 0.0003638267517089844, 0.00036525726318359375, 0.0003714561462402344, 0.00037217140197753906, 0.00037360191345214844, 0.00037360191345214844, 0.0003757476806640625, 0.00037598609924316406, 0.0003829002380371094, 0.00038886070251464844, 0.00038933753967285156, 0.0008356571197509766], "beyond_p": 0.9592137592137592}], "reverse-words-in-a-string": [{"slug_name": "reverse-words-in-a-string", "status": {"result": "passed", "runtime": 0.00032973289489746094, "index": 0}, "solution": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # reverse the list of words\n        words.reverse()\n        \n        # join the list of words into a string\n        return \" \".join(words)", "runtimes": [0.0003199577331542969, 0.0003249645233154297, 0.00033164024353027344, 0.00033283233642578125, 0.0003333091735839844, 0.0003371238708496094, 0.0003383159637451172, 0.00034356117248535156, 0.00035762786865234375, 0.00041961669921875, 0.0005156993865966797, 0.0005328655242919922, 0.0005581378936767578, 0.0006318092346191406, 0.0007543563842773438, 0.0010020732879638672, 0.001325845718383789, 0.001583099365234375], "beyond_p": 0.9922612306530766}], "excel-sheet-column-number": [{"slug_name": "excel-sheet-column-number", "status": {"result": "passed", "runtime": 0.0002970695495605469, "index": 0}, "solution": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize result\n        result = 0\n        \n        # Iterate through all characters\n        for i in range(len(columnTitle)):\n            \n            # Find numerical value\n            # of current character\n            val = ord(columnTitle[i]) - 64\n            \n            # Multiply with\n            # appropriate power\n            # of 26\n            result += val * pow(26, len(columnTitle) - i - 1)\n            \n        return result", "runtimes": [0.00027561187744140625, 0.00028228759765625, 0.00028252601623535156, 0.0002837181091308594, 0.0002849102020263672, 0.0002872943878173828, 0.0002884864807128906, 0.00029158592224121094, 0.0002918243408203125, 0.0002949237823486328, 0.00029659271240234375, 0.00029850006103515625, 0.0003044605255126953], "beyond_p": 0.256198347107438}], "candy": [{"slug_name": "candy", "status": {"result": "passed", "runtime": 0.0018467903137207031, "index": 0}, "solution": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n == 1:\n            return 1\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        return sum(candies)", "runtimes": [0.0010051727294921875, 0.0015175342559814453, 0.0017743110656738281, 0.0018062591552734375, 0.0018129348754882812, 0.0018379688262939453, 0.0018854141235351562, 0.0018894672393798828, 0.0018951892852783203, 0.002136707305908203, 0.002170085906982422, 0.0024547576904296875, 0.002459287643432617, 0.0024640560150146484, 0.002488374710083008, 0.002519845962524414, 0.002531290054321289, 0.0026154518127441406, 0.002639293670654297, 0.002826213836669922, 0.003174304962158203, 0.0033936500549316406, 0.0034253597259521484, 0.0063762664794921875], "beyond_p": 0.8433061079545454}], "same-tree": [{"slug_name": "same-tree", "status": {"result": "passed", "runtime": 0.0005834102630615234, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        else:\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)", "runtimes": [0.0005521774291992188, 0.00055694580078125, 0.0005598068237304688, 0.0005612373352050781, 0.0005614757537841797, 0.0005633831024169922, 0.0005648136138916016, 0.0005700588226318359, 0.0005710124969482422, 0.0005714893341064453, 0.0005731582641601562, 0.0005817413330078125, 0.0006861686706542969, 0.0007779598236083984], "beyond_p": 0.8616684266103485}], "reorder-list": [{"slug_name": "reorder-list", "status": {"result": "passed", "runtime": 0.0010123252868652344, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if head is None:\n            return\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # merge the first and second half of the list\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        # handle the case when the length of the list is odd\n        if second != first:\n            first.next = second", "runtimes": [0.001016378402709961, 0.0010190010070800781, 0.0010232925415039062, 0.0010273456573486328, 0.001046895980834961, 0.001047372817993164, 0.0010557174682617188, 0.0010676383972167969, 0.0010743141174316406, 0.0010755062103271484, 0.001089334487915039, 0.0010919570922851562, 0.0011057853698730469, 0.0011124610900878906, 0.0011169910430908203, 0.0011250972747802734, 0.0011782646179199219, 0.0011823177337646484, 0.0011882781982421875, 0.0011947154998779297, 0.0012328624725341797, 0.0013911724090576172, 0.001422882080078125], "beyond_p": 1.0099706744868036}], "word-pattern": [{"slug_name": "word-pattern", "status": {"result": "passed", "runtime": 0.0002853870391845703, "index": 0}, "solution": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal return false\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to map the pattern and words\n        d = {}\n        \n        # loop through the pattern and words\n        for i in range(len(pattern)):\n            \n            # if the pattern is not in the dictionary add it\n            if pattern[i] not in d:\n                d[pattern[i]] = words[i]\n            \n            # if the pattern is in the dictionary and the word is not equal to the value return false\n            elif words[i] != d[pattern[i]]:\n                return False\n        \n        # return true\n        return True", "runtimes": [0.0002758502960205078, 0.0002791881561279297, 0.0002803802490234375, 0.00028228759765625, 0.0002830028533935547, 0.00028324127197265625, 0.0002837181091308594, 0.0002865791320800781, 0.0002906322479248047, 0.0002968311309814453, 0.0002982616424560547, 0.0003120899200439453, 0.00031757354736328125], "beyond_p": 0.7714285714285715}], "permutations": [{"slug_name": "permutations", "status": {"result": "passed", "runtime": 0.0021011829376220703, "index": 0}, "solution": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        else:\n            result = []\n            for i in range(len(nums)):\n                for j in self.permute(nums[:i] + nums[i+1:]):\n                    result.append([nums[i]] + j)\n            return result", "runtimes": [0.0015730857849121094, 0.0018994808197021484, 0.002033233642578125, 0.002066373825073242, 0.002087831497192383, 0.0021047592163085938, 0.0021729469299316406, 0.0022177696228027344, 0.0022363662719726562, 0.002290487289428711, 0.0022950172424316406, 0.0023033618927001953, 0.0025157928466796875, 0.002783536911010742, 0.0030608177185058594, 0.0033829212188720703], "beyond_p": 0.7082070873402714}], "search-a-2d-matrix": [{"slug_name": "search-a-2d-matrix", "status": {"result": "passed", "runtime": 0.0002562999725341797, "index": 0}, "solution": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix:\n            return False\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[m-1][n-1]:\n            return False\n        \n        i = 0\n        j = n-1\n        \n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] > target:\n                j -= 1\n            else:\n                i += 1\n                \n        return False", "runtimes": [0.00023984909057617188, 0.00023984909057617188, 0.00024247169494628906, 0.0002429485321044922, 0.0002429485321044922, 0.00024366378784179688, 0.0002448558807373047, 0.00024700164794921875, 0.00024819374084472656, 0.0002512931823730469, 0.0002524852752685547, 0.00025463104248046875, 0.0002586841583251953, 0.00026106834411621094, 0.0002617835998535156, 0.00026988983154296875, 0.0002772808074951172, 0.0002951622009277344], "beyond_p": 0.7025862068965517}], "add-two-numbers": [{"slug_name": "add-two-numbers", "status": {"result": "failed@cases", "runtime": 0.0008244514465332031, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result node\n        result = ListNode()\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        \n        # Traverse the two linked lists\n        while l1 or l2 or carry:\n            # Calculate the sum of the two digits\n            # and add the carry\n            sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n            # Update the carry\n            carry = sum // 10\n            # Update the sum\n            sum = sum % 10\n            # Update the current node\n            current.val = sum\n            # Update the current node\n            current.next = ListNode()\n            # Update the current node\n            current = current.next\n            # Update the linked list\n            l1 = l1.next if l1 else None\n            # Update the linked list\n            l2 = l2.next if l2 else None\n            \n        # Return the result\n        return result", "runtimes": [0.0007717609405517578, 0.0007851123809814453, 0.0007855892181396484, 0.0007891654968261719, 0.0007905960083007812, 0.0007925033569335938, 0.0007939338684082031, 0.0007987022399902344, 0.0007996559143066406, 0.0008041858673095703, 0.0008056163787841797, 0.0008149147033691406, 0.0008208751678466797, 0.0008387565612792969, 0.0008425712585449219, 0.0008535385131835938, 0.0008761882781982422, 0.0009121894836425781, 0.0009667873382568359], "beyond_p": 0.0}], "number-complement": [{"slug_name": "number-complement", "status": {"result": "passed", "runtime": 0.0002396106719970703, "index": 0}, "solution": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert num to binary\n        binary = bin(num)[2:]\n        \n        # flip the binary\n        flipped = binary.replace('0', '2').replace('1', '0').replace('2', '1')\n        \n        # convert flipped binary to int\n        return int(flipped, 2)", "runtimes": [0.00023698806762695312, 0.00023865699768066406, 0.0002391338348388672, 0.00024080276489257812, 0.00024175643920898438, 0.000244140625, 0.0002446174621582031, 0.0002493858337402344, 0.0002512931823730469, 0.00025343894958496094, 0.0002665519714355469, 0.0002734661102294922, 0.0002777576446533203], "beyond_p": 0.935672514619883}], "arithmetic-slices-ii-subsequence": [{"slug_name": "arithmetic-slices-ii-subsequence", "status": {"result": "failed@cases", "runtime": 0.0008192062377929688, "index": 0}, "solution": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        n = len(nums)\n        dp = [0] * n\n        count = 0\n        \n        # Edge case\n        if n < 3:\n            return 0\n        \n        # Loop through the list\n        for i in range(2, n):\n            \n            # Check if the difference is the same\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n                count += dp[i]\n                \n        return count", "runtimes": [0.21711158752441406, 0.2274031639099121, 0.31056880950927734, 0.31279420852661133, 0.34816670417785645, 0.5232255458831787, 0.5298745632171631, 0.5930516719818115, 0.7799172401428223, 0.8574693202972412, 0.8657565116882324, 1.9399330615997314], "beyond_p": 0.0}], "text-justification": [{"slug_name": "text-justification", "status": {"result": "failed@cases", "runtime": 0.0006871223449707031, "index": 0}, "solution": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        n = len(words)\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            length = len(words[start])\n            \n            while end < n and length + len(words[end]) + end - start <= maxWidth:\n                length += len(words[end])\n                end += 1\n                \n            if end == n:\n                res.append(self.left_justify(words[start:end], maxWidth))\n                break\n                \n            if end - start == 1:\n                res.append(self.left_justify(words[start:end], maxWidth))\n            else:\n                res.append(self.full_justify(words[start:end], maxWidth, length))\n                \n            start = end\n            \n        return res\n    \n    def left_justify(self, words, maxWidth):\n        return \" \".join(words) + \" \" * (maxWidth - len(\" \".join(words)))\n    \n    def full_justify(self, words, maxWidth, length):\n        num_spaces = maxWidth - length\n        num_words = len(words) - 1\n        avg_spaces = num_spaces // num_words\n        extra_spaces = num_spaces % num_words\n        \n        res = \"\"\n        for i in range(len(words)):\n            res += words[i]\n            if i < num_words:\n                res += \" \" * (avg_spaces + 1)\n                if extra_spaces:\n                    res += \" \"\n                    extra_spaces -= 1\n        return res", "runtimes": [0.0006961822509765625, 0.0007083415985107422, 0.0007808208465576172, 0.0007872581481933594, 0.0007877349853515625, 0.0008056163787841797, 0.0008618831634521484, 0.0008711814880371094, 0.0008785724639892578, 0.0008807182312011719, 0.0009016990661621094, 0.0009925365447998047, 0.001073598861694336], "beyond_p": 0.0}], "binary-tree-postorder-traversal": [{"slug_name": "binary-tree-postorder-traversal", "status": {"result": "passed", "runtime": 0.00044226646423339844, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        stack.append(root)\n        result = []\n        \n        while stack:\n            root = stack.pop()\n            result.append(root.val)\n            if root.left:\n                stack.append(root.left)\n            if root.right:\n                stack.append(root.right)\n                \n        return result[::-1]", "runtimes": [0.0004119873046875, 0.0004210472106933594, 0.00043511390686035156, 0.0004456043243408203, 0.0004496574401855469, 0.000469207763671875, 0.0005328655242919922, 0.0005342960357666016], "beyond_p": 0.7524366471734892}], "container-with-most-water": [{"slug_name": "container-with-most-water", "status": {"result": "passed", "runtime": 0.0014157295227050781, "index": 0}, "solution": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area", "runtimes": [0.0004298686981201172, 0.00045108795166015625, 0.0004596710205078125, 0.0007884502410888672, 0.0010983943939208984, 0.0010995864868164062, 0.0011105537414550781, 0.0011131763458251953, 0.0011396408081054688, 0.0011479854583740234, 0.0013048648834228516, 0.0013327598571777344, 0.0013396739959716797, 0.0013480186462402344, 0.0013785362243652344, 0.0013790130615234375, 0.001407623291015625, 0.0014090538024902344, 0.0014357566833496094, 0.0014541149139404297, 0.0022530555725097656, 0.0022673606872558594], "beyond_p": 0.46347476320228365}], "concatenated-words": [{"slug_name": "concatenated-words", "status": {"result": "failed@cases", "runtime": 0.0026159286499023438, "index": 0}, "solution": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Sort the list of words in descending order of length\n        words.sort(key=len, reverse=True)\n        \n        # Initialize a list to store the results\n        res = []\n        \n        # Iterate over the list of words\n        for w in words:\n            \n            # Check if the current word is a concatenated word\n            if self.isConcatenatedWord(w, words):\n                res.append(w)\n                \n        return res\n    \n    def isConcatenatedWord(self, word, words):\n        \n        # If the length of the word is 0 or 1, it is not a concatenated word\n        if len(word) <= 1:\n            return False\n        \n        # Iterate from the second character of the word to the last character\n        for i in range(1, len(word)):\n            \n            # If the substring from the second character to the last character\n            # is in the list of words, it means we can form a concatenated word\n            # by combining the substring with a word that comes before it in the list\n            if word[i:] in words:\n                \n                # If the substring from the beginning to the second last character\n                # is also in the list of words, it means we can form a concatenated word\n                # by combining the substring with a word that comes after it in the list\n                if word[:i] in words:\n                    return True\n                \n        # If no concatenated word can be formed, return False\n        return False", "runtimes": [0.0010476112365722656, 0.0010826587677001953, 0.001260995864868164, 0.0012738704681396484, 0.0013206005096435547, 0.0013418197631835938, 0.0016825199127197266, 0.0023145675659179688, 0.003956794738769531, 0.0042607784271240234, 0.004601955413818359, 0.005521059036254883, 0.005785703659057617, 0.011234521865844727, 0.01693272590637207], "beyond_p": 0.0}], "base-7": [{"slug_name": "base-7", "status": {"result": "failed@cases", "runtime": 0.0002543926239013672, "index": 0}, "solution": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        else:\n            return self.convertToBase7(num // 7) + str(num % 7)", "runtimes": [0.00024437904357910156, 0.00024628639221191406, 0.000247955322265625, 0.0002493858337402344, 0.00025010108947753906, 0.0002532005310058594, 0.00025534629821777344, 0.00025773048400878906, 0.0002582073211669922, 0.0002589225769042969, 0.00025916099548339844, 0.0002636909484863281], "beyond_p": 0.0}], "nim-game": [{"slug_name": "nim-game", "status": {"result": "passed", "runtime": 0.0002524852752685547, "index": 0}, "solution": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n%4 == 0:\n            return False\n        else:\n            return True", "runtimes": [0.0002541542053222656, 0.00025582313537597656, 0.0002562999725341797, 0.0002562999725341797, 0.0002589225769042969, 0.0002608299255371094, 0.0002617835998535156, 0.0002734661102294922], "beyond_p": 1.0864197530864197}], "n-queens-ii": [{"slug_name": "n-queens-ii", "status": {"result": "failed@cases", "runtime": 0.002578258514404297, "index": 0}, "solution": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            for i, j in zip(range(row), range(col, -1, -1)):\n                if board[i][j] == 1:\n                    return False\n            for i, j in zip(range(row), range(col, n)):\n                if board[i][j] == 1:\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 1\n                    count += dfs(board, row + 1)\n                    board[row][col] = 0\n            return count\n        \n        board = [[0] * n for _ in range(n)]\n        return dfs(board, 0)", "runtimes": [0.00022840499877929688, 0.0005338191986083984, 0.0007615089416503906, 0.0008246898651123047, 0.0010318756103515625, 0.0012128353118896484, 0.0012269020080566406, 0.0012969970703125, 0.0013871192932128906, 0.0014598369598388672, 0.0014994144439697266, 0.0015108585357666016, 0.0018684864044189453, 0.002229928970336914, 0.0023343563079833984, 0.003306150436401367, 0.0033524036407470703, 0.004262447357177734, 0.008171319961547852], "beyond_p": 0.0}], "n-queens": [{"slug_name": "n-queens", "status": {"result": "failed@cases", "runtime": 0.001132965087890625, "index": 0}, "solution": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_safe(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, n)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                result.append(board)\n                return\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row][col] = 'Q'\n                    dfs(board, row + 1)\n                    board[row][col] = '.'\n        \n        result = []\n        board = [['.'] * n for _ in range(n)]\n        dfs(board, 0)\n        return result", "runtimes": [0.0005853176116943359, 0.0006225109100341797, 0.0009636878967285156, 0.000993967056274414, 0.0010144710540771484, 0.0011782646179199219, 0.0011844635009765625, 0.0014331340789794922, 0.001497507095336914, 0.002078533172607422, 0.002175569534301758, 0.002592325210571289, 0.0026633739471435547, 0.00267791748046875, 0.002771615982055664, 0.002826213836669922, 0.0028738975524902344, 0.0030298233032226562, 0.005678892135620117], "beyond_p": 0.0}], "word-search": [{"slug_name": "word-search", "status": {"result": "failed@cases", "runtime": 0.0002579689025878906, "index": 0}, "solution": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False\n        \n        # check if the word is in the board\n        # if it is, return True\n        # if it is not, return False", "runtimes": [0.0003046989440917969, 0.0003216266632080078, 0.00033593177795410156, 0.0003390312194824219, 0.0003399848937988281, 0.0003409385681152344, 0.000347137451171875, 0.000347137451171875, 0.0003478527069091797, 0.00034928321838378906, 0.0003516674041748047, 0.0003523826599121094, 0.00035452842712402344, 0.0003592967987060547, 0.0003592967987060547, 0.0003662109375, 0.0003666877746582031, 0.0003726482391357422, 0.0003731250762939453, 0.00037384033203125, 0.0003771781921386719, 0.00037860870361328125, 0.0003795623779296875, 0.00043272972106933594], "beyond_p": 0.0}], "merge-sorted-array": [{"slug_name": "merge-sorted-array", "status": {"result": "passed", "runtime": 0.00031948089599609375, "index": 0}, "solution": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # Merge the two arrays into a single array\n        nums1[m:] = nums2\n        \n        # Sort the array\n        nums1.sort()", "runtimes": [0.0003209114074707031, 0.00032401084899902344, 0.0003268718719482422, 0.00033020973205566406, 0.00035190582275390625, 0.0003581047058105469, 0.0003590583801269531, 0.0003592967987060547, 0.00036787986755371094, 0.0003707408905029297, 0.0003707408905029297, 0.0003731250762939453, 0.0003962516784667969, 0.00040030479431152344, 0.0005643367767333984, 0.00226593017578125], "beyond_p": 1.0007354743809758}], "third-maximum-number": [{"slug_name": "third-maximum-number", "status": {"result": "passed", "runtime": 0.0009927749633789062, "index": 0}, "solution": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a set to store the unique elements\n        unique_nums = set()\n        \n        # Loop through the array and add the elements to the set\n        for num in nums:\n            unique_nums.add(num)\n        \n        # If the length of the set is less than or equal to 2, return the maximum element\n        if len(unique_nums) <= 2:\n            return max(unique_nums)\n        \n        # If the length of the set is greater than 2, return the third maximum\n        else:\n            # Sort the set in descending order\n            sorted_unique_nums = sorted(unique_nums, reverse=True)\n            \n            # Return the third maximum\n            return sorted_unique_nums[2]", "runtimes": [0.0008401870727539062, 0.0008411407470703125, 0.0008480548858642578, 0.0008561611175537109, 0.0008580684661865234, 0.0008602142333984375, 0.00086212158203125, 0.0008625984191894531, 0.0009012222290039062, 0.000911712646484375, 0.0009455680847167969, 0.0009555816650390625, 0.0009560585021972656, 0.0009627342224121094, 0.000980377197265625, 0.0019037723541259766, 0.0036559104919433594], "beyond_p": 0.9458086367485182}]}