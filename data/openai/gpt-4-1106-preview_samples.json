{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        while matrix:\n            result += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    result.append(row.pop())\n            if matrix:\n                result += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    result.append(row.pop(0))\n        return result"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        ranges = []\n        if not nums:\n            return ranges\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1] + 1:\n                if start == nums[i - 1]:\n                    ranges.append(str(start))\n                else:\n                    ranges.append(str(start) + '->' + str(nums[i - 1]))\n                start = nums[i]\n        if start == nums[-1]:\n            ranges.append(str(start))\n        else:\n            ranges.append(str(start) + '->' + str(nums[-1]))\n        return ranges\n\n# Example usage:\n# sol = Solution()\n# print(sol.summaryRanges([0,1,2,4,5,7]))\n# Output: ['0->2','4->5','7']\n# print(sol.summaryRanges([0,2,3,4,6,8,9]))\n# Output: ['0','2->4','6','8->9']"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        # Create a 2D DP array with dimensions (len(t) + 1) x (len(s) + 1)\n        dp = [[0] * (len(s) + 1) for _ in range(len(t) + 1)]\n\n        # Initialize the first row to 1 because an empty t can be formed by any prefix of s\n        for j in range(len(s) + 1):\n            dp[0][j] = 1\n\n        # Fill the DP table\n        for i in range(1, len(t) + 1):\n            for j in range(1, len(s) + 1):\n                # If the characters match, add the number of ways without the current character\n                # in both s and t, to the number of ways without the current character in s\n                if t[i - 1] == s[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]\n                else:\n                    # If the characters don't match, the number of ways is the same as without\n                    # the current character in s\n                    dp[i][j] = dp[i][j - 1]\n\n        # The answer is in the bottom-right cell of the DP table\n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        size = len(nums)\n        for i in range(size):\n            while 1 <= nums[i] <= size and nums[nums[i] - 1] != nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        \n        for i in range(size):\n            if nums[i] != i + 1:\n                return i + 1\n        return size + 1\n\n# Example usage:\n# sol = Solution()\n# print(sol.firstMissingPositive([1,2,0]))  # Output: 3\n# print(sol.firstMissingPositive([3,4,-1,1]))  # Output: 2\n# print(sol.firstMissingPositive([7,8,9,11,12]))  # Output: 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        from math import factorial\n        numbers = list(range(1, n+1))\n        permutation = ''\n        k -= 1\n        while n > 0:\n            n -= 1\n            index, k = divmod(k, factorial(n))\n            permutation += str(numbers[index])\n            numbers.remove(numbers[index])\n        return permutation\n\n# Example usage:\n# sol = Solution()\n# print(sol.getPermutation(3, 3))  # Output: \"213\"\n# print(sol.getPermutation(4, 9))  # Output: \"2314\"\n# print(sol.getPermutation(3, 1))  # Output: \"123\""}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n            if current_sum == target:\n                return [left + 1, right + 1]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        return []  # This line will never be reached if there is exactly one solution"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        def backtrack(index, prev_operand, current_operand, value, string):\n            if index == len(num):\n                if value == target and current_operand == 0:\n                    results.append(\"\".join(string[1:]))\n                return\n\n            current_operand = current_operand * 10 + int(num[index])\n            str_op = str(current_operand)\n\n            if current_operand > 0:\n                backtrack(index + 1, prev_operand, current_operand, value, string)\n\n            string.append('+')\n            string.append(str_op)\n            backtrack(index + 1, current_operand, 0, value + current_operand, string)\n            string.pop()\n            string.pop()\n\n            if string:\n                string.append('-')\n                string.append(str_op)\n                backtrack(index + 1, -current_operand, 0, value - current_operand, string)\n                string.pop()\n                string.pop()\n\n                string.append('*')\n                string.append(str_op)\n                backtrack(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)\n                string.pop()\n                string.pop()\n\n        results = []\n        backtrack(0, 0, 0, 0, [])\n        return results\n\n# Example usage:\n# sol = Solution()\n# output = sol.addOperators(\"123\", 6)\n# print(output)  # Output: [\"1*2*3\",\"1+2+3\"]"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "def dfs(node, current_number):\n            if not node:\n                return 0\n            current_number = current_number * 10 + node.val\n            if not node.left and not node.right:\n                return current_number\n            return dfs(node.left, current_number) + dfs(node.right, current_number)\n\n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        # Remove all dashes and convert to uppercase\n        s = s.replace('-', '').upper()\n        # Find the length of the first group\n        first_group_length = len(s) % k or k\n        # Initialize the reformatted license key with the first group\n        reformatted = s[:first_group_length]\n        # Process the remaining characters in groups of size k\n        for i in range(first_group_length, len(s), k):\n            reformatted += '-' + s[i:i+k]\n        return reformatted"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        total_tank, curr_tank = 0, 0\n        starting_station = 0\n        for i in range(len(gas)):\n            total_tank += gas[i] - cost[i]\n            curr_tank += gas[i] - cost[i]\n            if curr_tank < 0:\n                starting_station = i + 1\n                curr_tank = 0\n        return starting_station if total_tank >= 0 else -1\n\n# Example usage:\n# sol = Solution()\n# print(sol.canCompleteCircuit([1,2,3,4,5], [3,4,5,1,2]))  # Output: 3\n# print(sol.canCompleteCircuit([2,3,4], [3,4,3]))        # Output: -1"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        nums = [1] + nums + [1]  # Add 1 before and after the original nums\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n        # Build up from shorter subarrays to the whole array\n        for length in range(1, n + 1):\n            for left in range(1, n - length + 2):\n                right = left + length - 1\n                # Find the best last balloon to burst\n                for i in range(left, right + 1):\n                    dp[left][right] = max(dp[left][right],\n                                         dp[left][i - 1] + nums[left - 1] * nums[i] * nums[right + 1] + dp[i + 1][right])\n\n        return dp[1][n]\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxCoins([3,1,5,8]))  # Output: 167\n# print(sol.maxCoins([1,5]))      # Output: 10"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        carry = 1\n        for i in range(len(digits) - 1, -1, -1):\n            digits[i] += carry\n            if digits[i] == 10:\n                digits[i] = 0\n                carry = 1\n            else:\n                carry = 0\n                break\n        if carry:\n            digits.insert(0, 1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        # Base case: if the pattern is empty, return True if the string is also empty\n        if not p:\n            return not s\n\n        # Check if the first character of the string matches the first character of the pattern\n        first_match = bool(s) and p[0] in {s[0], '.'}\n\n        # If the pattern has a '*', it can either match zero characters or at least one character\n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])\n\n# Example usage:\n# sol = Solution()\n# print(sol.isMatch(\"aa\", \"a\"))  # Output: false\n# print(sol.isMatch(\"aa\", \"a*\")) # Output: true\n# print(sol.isMatch(\"ab\", \".*\")) # Output: true"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        def pick_max(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n\n        def merge(nums1, nums2):\n            return [max(nums1, nums2).pop(0) for _ in range(len(nums1) + len(nums2))]\n\n        max_combo = []\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n            temp = merge(pick_max(nums1, i), pick_max(nums2, k - i))\n            max_combo = max(max_combo, temp)\n        return max_combo\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxNumber([3,4,6,5], [9,1,2,5,8,3], 5))\n# Output: [9,8,6,5,3]"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num <= 1:\n            return False\n        \n        divisors_sum = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors_sum += i\n                if i != num // i:\n                    divisors_sum += num // i\n        \n        return divisors_sum == num\n\n# Example usage:\n# sol = Solution()\n# print(sol.checkPerfectNumber(28))  # Output: true\n# print(sol.checkPerfectNumber(7))   # Output: false"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            a, b = 0, 1\n            for _ in range(2, n + 1):\n                a, b = b, a + b\n            return b\n\n# Example usage:\n# sol = Solution()\n# print(sol.fib(2))  # Output: 1\n# print(sol.fib(3))  # Output: 2\n# print(sol.fib(4))  # Output: 3"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n        dp[m][n-1] = dp[m-1][n] = 1\n\n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                min_health = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]\n                dp[i][j] = max(min_health, 1)\n\n        return dp[0][0]\n\n# Example usage:\n# dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n# sol = Solution()\n# print(sol.calculateMinimumHP(dungeon))  # Output: 7\n\n# dungeon = [[0]]\n# sol = Solution()\n# print(sol.calculateMinimumHP(dungeon))  # Output: 1"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        nums.sort()\n\n        def count_pairs(mid):\n            count = left = 0\n            for right in range(len(nums)):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            return count\n\n        low, high = 0, nums[-1] - nums[0]\n        while low < high:\n            mid = (low + high) // 2\n            if count_pairs(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n\n# Example usage:\n# sol = Solution()\n# print(sol.smallestDistancePair([1,3,1], 1))  # Output: 0\n# print(sol.smallestDistancePair([1,1,1], 2))  # Output: 0\n# print(sol.smallestDistancePair([1,6,1], 3))  # Output: 5"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.split())\n\n# Example usage:\n# s = \"Hello, my name is John\"\n# sol = Solution()\n# print(sol.countSegments(s))  # Output: 5"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels = 'aeiouAEIOU'\n        s_list = list(s)\n        left, right = 0, len(s) - 1\n\n        while left < right:\n            while left < right and s_list[left] not in vowels:\n                left += 1\n            while left < right and s_list[right] not in vowels:\n                right -= 1\n\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left, right = left + 1, right - 1\n\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        num_set = set(nums)\n        longest_streak = 0\n\n        for num in num_set:\n            if num - 1 not in num_set:\n                current_num = num\n                current_streak = 1\n\n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_streak += 1\n\n                longest_streak = max(longest_streak, current_streak)\n\n        return longest_streak"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        expected_sum = len(nums) * (len(nums) + 1) // 2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        from collections import deque\n        wordSet = set(wordList)  # Convert list to set for O(1) look-ups\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # Queue for BFS\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordSet:\n                        wordSet.remove(next_word)\n                        queue.append((next_word, length + 1))\n\n        return 0\n\n# Example usage:\n# sol = Solution()\n# print(sol.ladderLength(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]))  # Output: 5\n# print(sol.ladderLength(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]))  # Output: 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        # Convert binary strings to integers, add them, and convert back to binary string\n        sum = bin(int(a, 2) + int(b, 2))[2:]\n        return sum\n\n# Example usage:\n# sol = Solution()\n# print(sol.addBinary(\"11\", \"1\"))  # Output: \"100\"\n# print(sol.addBinary(\"1010\", \"1011\"))  # Output: \"10101\""}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        def binarySearchLeft(nums, target):\n            left, right = 0, len(nums)\n            while left < right:\n                mid = (left + right) // 2\n                if nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        def binarySearchRight(nums, target):\n            left, right = 0, len(nums)\n            while left < right:\n                mid = (left + right) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        left_idx = binarySearchLeft(nums, target)\n        right_idx = binarySearchRight(nums, target) - 1\n\n        if left_idx <= right_idx and right_idx < len(nums) and nums[left_idx] == target and nums[right_idx] == target:\n            return [left_idx, right_idx]\n        return [-1, -1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n\n        k = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[k - 1]:\n                nums[k] = nums[i]\n                k += 1\n        return k"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        jumps = 0\n        current_end = 0\n        current_farthest = 0\n\n        for i in range(n - 1):\n            current_farthest = max(current_farthest, i + nums[i])\n            if i == current_end:\n                jumps += 1\n                current_end = current_farthest\n                if current_end >= n - 1:\n                    break\n\n        return jumps\n\n# Example usage:\n# sol = Solution()\n# print(sol.jump([2,3,1,1,4]))  # Output: 2\n# print(sol.jump([2,3,0,1,4]))  # Output: 2"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        if not prices or k == 0:\n            return 0\n\n        n = len(prices)\n        if k >= n // 2:\n            return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1))\n\n        profits = [[0] * n for _ in range(k + 1)]\n\n        for i in range(1, k + 1):\n            max_so_far = -prices[0]\n            for j in range(1, n):\n                profits[i][j] = max(profits[i][j - 1], prices[j] + max_so_far)\n                max_so_far = max(max_so_far, profits[i - 1][j] - prices[j])\n\n        return profits[k][-1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxProfit(2, [2,4,1]))  # Output: 2\n# print(sol.maxProfit(2, [3,2,6,5,0,3]))  # Output: 7"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return '0'\n        if num < 0:\n            num += 2**32\n        hex_chars = '0123456789abcdef'\n        hex_str = ''\n        while num > 0:\n            hex_str = hex_chars[num % 16] + hex_str\n            num //= 16\n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # Create a dictionary to store the frequency of each character\n        frequency = {}\n        for char in s:\n            frequency[char] = frequency.get(char, 0) + 1\n\n        # Iterate through the string to find the first unique character\n        for index, char in enumerate(s):\n            if frequency[char] == 1:\n                return index\n\n        # If no unique character is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        from sortedcontainers import SortedList\n        sorted_list = SortedList()\n        for i, num in enumerate(nums):\n            if i > indexDiff:\n                sorted_list.remove(nums[i - indexDiff - 1])\n            pos1 = sorted_list.bisect_left(num - valueDiff)\n            pos2 = sorted_list.bisect_right(num + valueDiff)\n            if pos1 != pos2:\n                return True\n            sorted_list.add(num)\n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        red, white, blue = 0, 0, len(nums) - 1\n\n        while white <= blue:\n            if nums[white] == 0:\n                nums[red], nums[white] = nums[white], nums[red]\n                red += 1\n                white += 1\n            elif nums[white] == 1:\n                white += 1\n            else:\n                nums[white], nums[blue] = nums[blue], nums[white]\n                blue -= 1\n\n# Example usage:\n# nums = [2,0,2,1,1,0]\n# Solution().sortColors(nums)\n# print(nums)  # Output: [0,0,1,1,2,2]\n\n# nums = [2,0,1]\n# Solution().sortColors(nums)\n# print(nums)  # Output: [0,1,2]"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_count = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "import math\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def get_tree_depth(node):\n            depth = 0\n            while node:\n                node = node.left\n                depth += 1\n            return depth\n        \n        if not root:\n            return 0\n        \n        left_depth = get_tree_depth(root.left)\n        right_depth = get_tree_depth(root.right)\n        \n        if left_depth == right_depth:\n            return (1 << left_depth) + self.countNodes(root.right)\n        else:\n            return (1 << right_depth) + self.countNodes(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = ''\n        carry = 0\n        p1 = len(num1) - 1\n        p2 = len(num2) - 1\n\n        while p1 >= 0 or p2 >= 0 or carry:\n            x1 = ord(num1[p1]) - ord('0') if p1 >= 0 else 0\n            x2 = ord(num2[p2]) - ord('0') if p2 >= 0 else 0\n            value = (x1 + x2 + carry) % 10\n            carry = (x1 + x2 + carry) // 10\n            result = str(value) + result\n            p1 -= 1\n            p2 -= 1\n\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.addStrings('11', '123'))  # Output: '134'\n# print(sol.addStrings('456', '77'))  # Output: '533'\n# print(sol.addStrings('0', '0'))    # Output: '0'"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        def update(op, num):\n            if op == '+': stack.append(num)\n            if op == '-': stack.append(-num)\n\n        it, num, stack, sign = 0, 0, [], '+'\n        while it < len(s):\n            if s[it].isdigit():\n                num = num * 10 + int(s[it])\n            elif s[it] in '+-':\n                update(sign, num)\n                num, sign = 0, s[it]\n            elif s[it] == '(': \n                num, j = self.calculate(s[it + 1:])\n                it += j\n            elif s[it] == ')':\n                update(sign, num)\n                return sum(stack), it + 1\n            it += 1\n        update(sign, num)\n        return sum(stack)\n\n# Example usage:\n# sol = Solution()\n# print(sol.calculate(\"1 + 1\"))  # Output: 2\n# print(sol.calculate(\" 2-1 + 2 \"))  # Output: 3\n# print(sol.calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # Output: 23"}], "ipo": [{"task_id": "ipo", "completion": "import heapq\n\nclass Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        if w >= max(capital):\n            return w + sum(sorted(profits, reverse=True)[:k])\n\n        projects = sorted(zip(capital, profits), key=lambda x: x[0])\n        available_projects = []\n        current_capital = w\n\n        for _ in range(k):\n            while projects and projects[0][0] <= current_capital:\n                _, profit = heapq.heappop(projects)\n                heapq.heappush(available_projects, -profit)\n\n            if available_projects:\n                current_capital += -heapq.heappop(available_projects)\n            else:\n                break\n\n        return current_capital"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # Find the first decreasing element from the right\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # If the entire array is non-increasing, reverse it\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # Find the element just larger than nums[i]\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        \n        # Swap the two elements\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the elements from i+1 to the end\n        nums[i+1:] = reversed(nums[i+1:])\n\n# Example usage:\n# sol = Solution()\n# arr = [1,2,3]\n# sol.nextPermutation(arr)\n# print(arr)  # Output: [1,3,2]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        # Create a dictionary to store the last index of each number\n        index_map = {}\n        # Iterate through the list\n        for i, num in enumerate(nums):\n            # If the number is in the dictionary and the difference\n            # between the current index and the last index is less than or equal to k\n            if num in index_map and i - index_map[num] <= k:\n                # Return true as we found a nearby duplicate\n                return True\n            # Update the last index of the number\n            index_map[num] = i\n        # If no nearby duplicates found, return false\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.containsNearbyDuplicate([1,2,3,1], 3))  # Output: true\n# print(sol.containsNearbyDuplicate([1,0,1,1], 1))  # Output: true\n# print(sol.containsNearbyDuplicate([1,2,3,1,2,3], 2))  # Output: false"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) < 2:\n            return 0\n\n        # Find the minimum and maximum values\n        min_val, max_val = min(nums), max(nums)\n\n        # Calculate the minimum possible gap (bucket size)\n        bucket_size = max(1, (max_val - min_val) // (len(nums) - 1))\n\n        # Initialize buckets\n        buckets = [[None, None] for _ in range((max_val - min_val) // bucket_size + 1)]\n\n        # Place each number in a bucket\n        for num in nums:\n            bucket_idx = (num - min_val) // bucket_size\n            bucket = buckets[bucket_idx]\n            bucket[0] = min(bucket[0], num) if bucket[0] is not None else num\n            bucket[1] = max(bucket[1], num) if bucket[1] is not None else num\n\n        # Calculate the maximum gap\n        max_gap, prev_max = 0, min_val\n        for bucket in buckets:\n            if bucket[0] is None:\n                continue\n            max_gap = max(max_gap, bucket[0] - prev_max)\n            prev_max = bucket[1]\n\n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "import collections\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n\n        result = []\n        queue = collections.deque([root])\n\n        while queue:\n            level_size = len(queue)\n            current_level = []\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            result.append(current_level)\n\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        def find_partner(x):\n            return x ^ 1\n\n        def find_position(x):\n            return pos[x]\n\n        pos = {person: i for i, person in enumerate(row)}\n        swaps = 0\n\n        for i in range(0, len(row), 2):\n            first_person = row[i]\n            second_person = find_partner(first_person)\n            if row[i + 1] != second_person:\n                partner_pos = find_position(second_person)\n                row[i + 1], row[partner_pos] = row[partner_pos], row[i + 1]\n                pos[row[i + 1]], pos[row[partner_pos]] = i + 1, partner_pos\n                swaps += 1\n\n        return swaps\n\n# Example usage:\n# sol = Solution()\n# print(sol.minSwapsCouples([0, 2, 1, 3]))  # Output: 1\n# print(sol.minSwapsCouples([3, 2, 0, 1]))  # Output: 0"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [False] * (len(s2) + 1)\n        dp[0] = True\n\n        for i in range(1, len(s2) + 1):\n            dp[i] = dp[i - 1] and s2[i - 1] == s3[i - 1]\n\n        for i in range(1, len(s1) + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n            for j in range(1, len(s2) + 1):\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n\n        return dp[-1]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        # Sort the greed factors of the children and the sizes of the cookies\n        g.sort()\n        s.sort()\n\n        # Initialize the count of content children\n        content_children = 0\n\n        # Initialize the index for cookies\n        cookie_index = 0\n\n        # Iterate through each child's greed factor\n        for greed in g:\n            # While there are cookies left and the current cookie is too small,\n            # move to the next cookie\n            while cookie_index < len(s) and s[cookie_index] < greed:\n                cookie_index += 1\n\n            # If there are no more cookies, break out of the loop\n            if cookie_index == len(s):\n                break\n\n            # The current cookie satisfies the child's greed, give it to the child\n            content_children += 1\n            # Move to the next cookie\n            cookie_index += 1\n\n        # Return the count of content children\n        return content_children\n\n# Example usage:\n# sol = Solution()\n# print(sol.findContentChildren([1,2,3], [1,1]))  # Output: 1\n# print(sol.findContentChildren([1,2], [1,2,3]))  # Output: 2"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        # Define the rows of the American keyboard\n        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n\n        # Function to check if a word can be typed using one row\n        def can_be_typed_with_one_row(word):\n            word_set = set(word.lower())\n            return word_set.issubset(row1) or word_set.issubset(row2) or word_set.issubset(row3)\n\n        # Filter the words that can be typed with one row\n        return [word for word in words if can_be_typed_with_one_row(word)]\n\n# Example usage:\n# sol = Solution()\n# print(sol.findWords([\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]))  # Output: [\"Alaska\",\"Dad\"]\n# print(sol.findWords([\"omk\"]))  # Output: []\n# print(sol.findWords([\"adsdf\",\"sfd\"]))  # Output: [\"adsdf\",\"sfd\"]"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Edge case: if left equals right, no need to reverse anything\n        if left == right:\n            return head\n\n        # Initialize dummy node and set it to point to the head\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        # Move prev to the node just before the left position\n        for _ in range(left - 1):\n            prev = prev.next\n\n        # Start reversing from the left position\n        reverse = None\n        current = prev.next\n        for _ in range(right - left + 1):\n            next_temp = current.next\n            current.next = reverse\n            reverse = current\n            current = next_temp\n\n        # Connect the reversed part with the rest of the list\n        prev.next.next = current\n        prev.next = reverse\n\n        # Return the new head\n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # Find the longest palindromic prefix\n        j = 0\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == s[j]:\n                j += 1\n        if j == len(s):\n            return s\n        # Add the reverse of the suffix to the front of the original string\n        suffix = s[j:]\n        return suffix[::-1] + self.shortestPalindrome(s[:j]) + s[j:]\n\n# Example usage\n# sol = Solution()\n# print(sol.shortestPalindrome('aacecaaa'))  # Output: 'aaacecaaa'\n# print(sol.shortestPalindrome('abcd'))     # Output: 'dcbabcd'"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        from collections import Counter\n        t_counter = Counter(t)\n        required = len(t_counter)\n        left, right = 0, 0\n        formed = 0\n        window_counts = {}\n        ans = float('inf'), None, None\n\n        while right < len(s):\n            character = s[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            if character in t_counter and window_counts[character] == t_counter[character]:\n                formed += 1\n\n            while left <= right and formed == required:\n                character = s[left]\n\n                if right - left + 1 < ans[0]:\n                    ans = (right - left + 1, left, right)\n\n                window_counts[character] -= 1\n                if character in t_counter and window_counts[character] < t_counter[character]:\n                    formed -= 1\n\n                left += 1\n\n            right += 1\n\n        return '' if ans[0] == float('inf') else s[ans[1]:(ans[2] + 1)]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        x = y = 0\n        directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n        visited = set([(x, y)])\n\n        for i, dist in enumerate(distance):\n            dx, dy = directions[i % 4]\n            for _ in range(dist):\n                x += dx\n                y += dy\n                if (x, y) in visited:\n                    return True\n                visited.add((x, y))\n\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.isSelfCrossing([2,1,1,2]))  # Output: true\n# print(sol.isSelfCrossing([1,2,3,4]))  # Output: false\n# print(sol.isSelfCrossing([1,1,1,2,1]))  # Output: true"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "if not head or not head.next:\n            return head\n\n        current = head\n        while current.next:\n            if current.val == current.next.val:\n                current.next = current.next.next\n            else:\n                current = current.next\n\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        from collections import Counter\n        char_count = Counter(s)\n        length = 0\n        odd_found = False\n        for count in char_count.values():\n            if count % 2 == 0:\n                length += count\n            else:\n                length += count - 1\n                odd_found = True\n        if odd_found:\n            length += 1\n        return length\n\n# Example usage:\n# sol = Solution()\n# print(sol.longestPalindrome('abccccdd'))  # Output: 7\n# print(sol.longestPalindrome('a'))        # Output: 1"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "import json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        if not inorder or not postorder:\n            return None\n\n        # The last element in postorder is the root of the tree\n        root_val = postorder.pop()\n        root = TreeNode(root_val)\n\n        # Find the index of the root in inorder to split left and right subtrees\n        inorder_index = inorder.index(root_val)\n\n        # Recursively build the right and then left subtree\n        root.right = self.buildTree(inorder[inorder_index+1:], postorder)\n        root.left = self.buildTree(inorder[:inorder_index], postorder)\n\n        return root\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\"\"\"\n        if not root:\n            return 'null'\n\n        serialized_tree = []\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node:\n                serialized_tree.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                serialized_tree.append('null')\n\n        # Remove trailing 'null' values\n        while serialized_tree[-1] == 'null':\n            serialized_tree.pop()\n\n        return json.dumps(serialized_tree)\n\n# Example usage:\n# inorder = [9,3,15,20,7]\n# postorder = [9,15,7,20,3]\n# sol = Solution()\n# root = sol.buildTree(inorder, postorder)\n# serialized_tree = sol.serialize(root)\n# print(serialized_tree)"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "import heapq\n\n\nclass Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def bfs(start, target):\n            visited, queue = set([start]), collections.deque([start + (0,)])\n            while queue:\n                x, y, steps = queue.popleft()\n                if (x, y) == target:\n                    return steps\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < len(forest) and 0 <= ny < len(forest[0]) and (nx, ny) not in visited and forest[nx][ny] > 0:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, steps + 1))\n            return -1\n\n        trees = [(height, x, y) for x, row in enumerate(forest) for y, height in enumerate(row) if height > 1]\n        heapq.heapify(trees)\n\n        steps = 0\n        start = (0, 0)\n        while trees:\n            height, tx, ty = heapq.heappop(trees)\n            step = bfs(start, (tx, ty))\n            if step == -1:\n                return -1\n            steps += step\n            start = (tx, ty)\n            forest[tx][ty] = 1\n        return steps\n\n\n# Example usage:\n# sol = Solution()\n# print(sol.cutOffTree([[1,2,3],[0,0,4],[7,6,5]]))  # Output: 6\n# print(sol.cutOffTree([[1,2,3],[0,0,0],[7,6,5]]))  # Output: -1\n# print(sol.cutOffTree([[2,3,4],[0,0,5],[8,7,6]]))  # Output: 6"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "import collections\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        \n        queue = collections.deque([(root, 1)])\n        while queue:\n            node, depth = queue.popleft()\n            if not node.left and not node.right:\n                return depth\n            if node.left:\n                queue.append((node.left, depth + 1))\n            if node.right:\n                queue.append((node.right, depth + 1))\n        \n        return 0"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        # Initialize count of range sums\n        count = 0\n        # Initialize prefix sums array\n        prefix_sums = [0]\n        for num in nums:\n            prefix_sums.append(prefix_sums[-1] + num)\n\n        # Iterate over all possible ranges\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                # Calculate the range sum\n                range_sum = prefix_sums[j + 1] - prefix_sums[i]\n                # Check if the range sum is within the bounds\n                if lower <= range_sum <= upper:\n                    count += 1\n        return count"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        left, right = 0, n\n        while left <= right:\n            mid = (left + right) // 2\n            current = mid * (mid + 1) // 2\n            if current == n:\n                return mid\n            if n < current:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return right\n\n# Example usage:\n# sol = Solution()\n# print(sol.arrangeCoins(5))  # Output: 2\n# print(sol.arrangeCoins(8))  # Output: 3"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        # If the strings are equal, there is no uncommon subsequence\n        if a == b:\n            return -1\n        # If the strings are not equal, the longest uncommon subsequence\n        # is the longer of the two strings\n        else:\n            return max(len(a), len(b))\n\n# Example usage:\n# sol = Solution()\n# print(sol.findLUSlength(\"aba\", \"cdc\"))  # Output: 3\n# print(sol.findLUSlength(\"aaa\", \"bbb\"))  # Output: 3\n# print(sol.findLUSlength(\"aaa\", \"aaa\"))  # Output: -1"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "import collections\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n\n        queue = collections.deque([root])\n        result = collections.deque()\n\n        while queue:\n            level_size = len(queue)\n            level_nodes = []\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                level_nodes.append(node.val)\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            result.appendleft(level_nodes)\n\n        return list(result)"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        # Negative numbers are not palindromes\n        if x < 0:\n            return False\n        \n        # Follow up: Solve without converting to a string\n        original = x\n        reversed_x = 0\n        while x > 0:\n            reversed_x = reversed_x * 10 + x % 10\n            x //= 10\n        \n        return original == reversed_x"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        if not s or s[0] == '0':\n            return 0\n\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n\n        for i in range(2, len(s) + 1):\n            if s[i-1] != '0':\n                dp[i] += dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n\n        return dp[len(s)]\n\n# Example usage:\n# sol = Solution()\n# print(sol.numDecodings('12'))  # Output: 2\n# print(sol.numDecodings('226')) # Output: 3\n# print(sol.numDecodings('06'))  # Output: 0"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        s_index, t_index = 0, 0\n        while s_index < len(s) and t_index < len(t):\n            if s[s_index] == t[t_index]:\n                s_index += 1\n            t_index += 1\n        return s_index == len(s)\n\n# For the follow-up, we can preprocess 't' to create a dictionary that maps each character to its indices in ascending order.\n# Then, for each 's', we can use binary search to find the next character of 's' in 't'.\n\n# Follow-up implementation\nfrom collections import defaultdict\nfrom bisect import bisect_left\n\nclass SolutionFollowUp(object):\n    def __init__(self, t):\n        self.char_indices = defaultdict(list)\n        for index, char in enumerate(t):\n            self.char_indices[char].append(index)\n\n    def isSubsequence(self, s):\n        current_index = -1\n        for char in s:\n            if char not in self.char_indices:\n                return False\n            indices_list = self.char_indices[char]\n            i = bisect_left(indices_list, current_index + 1)\n            if i == len(indices_list):\n                return False\n            current_index = indices_list[i]\n        return True"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        result = [0]\n        for i in range(n):\n            add_val = 1 << i\n            for j in range(len(result) - 1, -1, -1):\n                result.append(result[j] + add_val)\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.grayCode(2))  # Output: [0,1,3,2]\n# print(sol.grayCode(1))  # Output: [0,1]"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # Base cases\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n\n        # Initialize the first two steps\n        first, second = 1, 2\n\n        # Calculate the number of ways for each step\n        for i in range(3, n + 1):\n            third = first + second\n            first = second\n            second = third\n\n        # The 'second' variable holds the number of ways to reach the nth step\n        return second"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n\n        return dp[len(s)]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "import sys\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        return self._isValidBST(root, -sys.maxsize, sys.maxsize)\n    \n    def _isValidBST(self, node, lower, upper):\n        if not node:\n            return True\n        val = node.val\n        if val <= lower or val >= upper:\n            return False\n        if not self._isValidBST(node.right, val, upper):\n            return False\n        if not self._isValidBST(node.left, lower, val):\n            return False\n        return True"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        merged = []\n        i, n = 0, len(intervals)\n        while i < n and intervals[i][1] < newInterval[0]:\n            merged.append(intervals[i])\n            i += 1\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        merged.append(newInterval)\n        while i < n:\n            merged.append(intervals[i])\n            i += 1\n        return merged"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        def is_palindrome(sub):\n            return sub == sub[::-1]\n\n        def backtrack(start, path):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    path.append(s[start:end])\n                    backtrack(end, path)\n                    path.pop()\n\n        result = []\n        backtrack(0, [])\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.partition('aab'))\n# print(sol.partition('a'))"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "import heapq\n\nclass Solution(object):\n    def smallestRange(self, nums):\n        min_heap = []\n        current_max = float('-inf')\n        for i, row in enumerate(nums):\n            heapq.heappush(min_heap, (row[0], i, 0))\n            current_max = max(current_max, row[0])\n        \n        smallest_range = [float('-inf'), float('inf')]\n        \n        while min_heap:\n            current_min, row_index, element_index = heapq.heappop(min_heap)\n            if current_max - current_min < smallest_range[1] - smallest_range[0]:\n                smallest_range = [current_min, current_max]\n            \n            if element_index + 1 < len(nums[row_index]):\n                next_element = nums[row_index][element_index + 1]\n                heapq.heappush(min_heap, (next_element, row_index, element_index + 1))\n                current_max = max(current_max, next_element)\n            else:\n                break\n        \n        return smallest_range\n\n# Example usage:\n# sol = Solution()\n# print(sol.smallestRange([[4,10,15,24,26],[0,9,12,20],[5,18,22,30]])) # Output: [20,24]\n# print(sol.smallestRange([[1,2,3],[1,2,3],[1,2,3]])) # Output: [1,1]"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "import math\n\nclass Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        states = minutesToTest // minutesToDie + 1\n        return math.ceil(math.log(buckets) / math.log(states))\n\n# Example usage:\n# sol = Solution()\n# print(sol.poorPigs(4, 15, 15))  # Output: 2\n# print(sol.poorPigs(4, 15, 30))  # Output: 2"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "import heapq\n\nclass Solution(object):\n    def swimInWater(self, grid):\n        n = len(grid)\n        visited = set()\n        min_heap = [(grid[0][0], 0, 0)]  # (elevation, x, y)\n        visited.add((0, 0))\n        time = 0\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        while min_heap:\n            elevation, x, y = heapq.heappop(min_heap)\n            time = max(time, elevation)\n            if x == n - 1 and y == n - 1:\n                return time\n\n            for dx, dy in directions:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < n and 0 <= new_y < n and (new_x, new_y) not in visited:\n                    visited.add((new_x, new_y))\n                    heapq.heappush(min_heap, (grid[new_x][new_y], new_x, new_y))\n\n        return time"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        # Create a 2D array to store the number of ways to reach each cell\n        dp = [[0] * n for _ in range(m)]\n\n        # Initialize the first row and first column to 1\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n\n        # Fill in the rest of the dp array\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        # The bottom-right corner will have the number of unique paths\n        return dp[m - 1][n - 1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.uniquePaths(3, 7))  # Output: 28\n# print(sol.uniquePaths(3, 2))  # Output: 3"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        len1, len2 = len(num1), len(num2)\n        result = [0] * (len1 + len2)\n\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                p1, p2 = i + j, i + j + 1\n                sum = mul + result[p2]\n\n                result[p1] += sum // 10\n                result[p2] = sum % 10\n\n        result_str = ''.join(map(str, result))\n        return result_str.lstrip('0')"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n\n        # Initialize the profits to zero for the first two transactions\n        first_buy, second_buy = float('inf'), float('inf')\n        first_profit, second_profit = 0, 0\n\n        for price in prices:\n            # Update the first_buy to be the minimum price so far\n            first_buy = min(first_buy, price)\n            # Update the first_profit to be the maximum of previous first_profit or\n            # the profit from selling at current price minus first_buy\n            first_profit = max(first_profit, price - first_buy)\n            # Update the second_buy to be the minimum of previous second_buy or\n            # the current price minus the first_profit\n            second_buy = min(second_buy, price - first_profit)\n            # Update the second_profit to be the maximum of previous second_profit or\n            # the profit from selling at current price minus second_buy\n            second_profit = max(second_profit, price - second_buy)\n\n        return second_profit\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxProfit([3,3,5,0,0,3,1,4]))  # Output: 6\n# print(sol.maxProfit([1,2,3,4,5]))        # Output: 4\n# print(sol.maxProfit([7,6,4,3,1]))        # Output: 0"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "def backtrack(start, end, temp, target_remaining):\n            if target_remaining == 0:\n                result.append(list(temp))\n                return\n            if target_remaining < 0:\n                return\n            for i in range(start, end):\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue\n                temp.append(candidates[i])\n                backtrack(i + 1, end, temp, target_remaining - candidates[i])\n                temp.pop()\n\n        candidates.sort()\n        result = []\n        backtrack(0, len(candidates), [], target)\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.combinationSum2([10,1,2,7,6,1,5], 8))\n# print(sol.combinationSum2([2,5,2,1,2], 5))"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        return word.isupper() or word.islower() or word.istitle()\n\n# Example usage:\n# sol = Solution()\n# print(sol.detectCapitalUse(\"USA\"))  # Output: true\n# print(sol.detectCapitalUse(\"FlaG\"))  # Output: false"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxProfit([7,1,5,3,6,4]))  # Output: 5\n# print(sol.maxProfit([7,6,4,3,1]))    # Output: 0"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Initialize the stack and the result list\n        stack = []\n        result = []\n        current = root\n        \n        # Iterate until the stack is empty or the current node is None\n        while current is not None or len(stack) > 0:\n            # Reach the left most Node of the current Node\n            while current is not None:\n                # Place pointer to a tree node on the stack before traversing the node's left subtree\n                stack.append(current)\n                current = current.left\n            \n            # Current must be None at this point\n            current = stack.pop()\n            result.append(current.val)  # Add the node's value\n            \n            # We have visited the node and its left subtree. Now, it's right subtree's turn\n            current = current.right\n        \n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n        # class TreeNode(object):\n        #     def __init__(self, val=0, left=None, right=None):\n        #         self.val = val\n        #         self.left = left\n        #         self.right = right\n        class Solution(object):\n            def buildTree(self, preorder, inorder):\n                if not preorder or not inorder:\n                    return None\n\n                # The first element of preorder list is the root.\n                root_val = preorder[0]\n                root = TreeNode(root_val)\n\n                # Find the index of the root in inorder list.\n                mid = inorder.index(root_val)\n\n                # Recursively construct the left and right subtree.\n                root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n                root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n\n                return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        def is_valid(string):\n            count = 0\n            for char in string:\n                if char == '(': count += 1\n                elif char == ')': count -= 1\n                if count < 0: return False\n            return count == 0\n\n        def dfs(s, start, l, r):\n            if l == r == 0:\n                if is_valid(s):\n                    ans.add(s)\n                return\n            for i in range(start, len(s)):\n                if i != start and s[i] == s[i-1]:\n                    continue\n                if s[i] in ('(', ')'):\n                    curr = s[:i] + s[i+1:]\n                    if r > 0 and s[i] == ')':\n                        dfs(curr, i, l, r-1)\n                    elif l > 0 and s[i] == '(': \n                        dfs(curr, i, l-1, r)\n\n        ans = set()\n        left = right = 0\n        for char in s:\n            if char == '(': left += 1\n            elif char == ')':\n                if left == 0: right += 1\n                else: left -= 1\n        dfs(s, 0, left, right)\n        return list(ans)\n\n# Example usage:\n# sol = Solution()\n# print(sol.removeInvalidParentheses('()())()'))\n# print(sol.removeInvalidParentheses('(a)())()'))\n# print(sol.removeInvalidParentheses(')('))"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "import heapq\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        # Initialize a priority queue\n        min_heap = []\n        # Fill the priority queue with the first node of each list\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(min_heap, (node.val, i, node))\n        \n        # Dummy node to start the merged list\n        dummy = ListNode(0)\n        current = dummy\n        \n        # Extract the smallest element from the heap and add it to the merged list\n        while min_heap:\n            val, i, node = heapq.heappop(min_heap)\n            current.next = ListNode(val)\n            current = current.next\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, i, node.next))\n        \n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        cut = [x for x in range(-1, n)]\n        pal = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            for j in range(i + 1):\n                if s[i] == s[j] and (i - j < 2 or pal[j + 1][i - 1]):\n                    pal[j][i] = True\n                    cut[i + 1] = min(cut[i + 1], cut[j] + 1)\n\n        return cut[-1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.minCut('aab'))  # Output: 1\n# print(sol.minCut('a'))    # Output: 0\n# print(sol.minCut('ab'))   # Output: 1"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        def zeta(n):\n            count = 0\n            while n > 0:\n                n //= 5\n                count += n\n            return count\n        \n        def binary_search(k):\n            left, right = 0, 5 * (k + 1)\n            while left <= right:\n                mid = (left + right) // 2\n                z = zeta(mid)\n                if z < k:\n                    left = mid + 1\n                elif z > k:\n                    right = mid - 1\n                else:\n                    return 5\n            return 0\n        \n        return binary_search(k)\n\n# Example usage:\n# sol = Solution()\n# print(sol.preimageSizeFZF(0))  # Output: 5\n# print(sol.preimageSizeFZF(5))  # Output: 0\n# print(sol.preimageSizeFZF(3))  # Output: 5"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        def is_palindrome(check):\n            return check == check[::-1]\n\n        word_dict = {word: i for i, word in enumerate(words)}\n        result = []\n\n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix, suffix = word[:j], word[j:]\n                reverse_prefix, reverse_suffix = prefix[::-1], suffix[::-1]\n\n                if is_palindrome(suffix) and reverse_prefix in word_dict and word_dict[reverse_prefix] != i:\n                    result.append([i, word_dict[reverse_prefix]])\n\n                if j > 0 and is_palindrome(prefix) and reverse_suffix in word_dict and word_dict[reverse_suffix] != i:\n                    result.append([word_dict[reverse_suffix], i])\n\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.palindromePairs([\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]))\n# Output: [[0,1],[1,0],[3,2],[2,4]]\n# print(sol.palindromePairs([\"bat\",\"tab\",\"cat\"]))\n# Output: [[0,1],[1,0]]\n# print(sol.palindromePairs([\"a\",\"\"]))\n# Output: [[0,1],[1,0]]"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "import json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        def convertListToBST(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            node = TreeNode(nums[mid])\n            node.left = convertListToBST(left, mid - 1)\n            node.right = convertListToBST(mid + 1, right)\n            return node\n        return convertListToBST(0, len(nums) - 1)\n\n# Helper function to serialize TreeNode to list\ndef serialize(root):\n    \"\"\"Encodes a tree to a single string.\n    \n    :type root: TreeNode\n    :rtype: str\n    \"\"\"\n    if not root:\n        return 'null'\n    queue = [root]\n    res = []\n    while queue:\n        node = queue.pop(0)\n        if node:\n            res.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            res.append('null')\n    # Remove trailing 'null' values\n    while res and res[-1] == 'null':\n        res.pop()\n    return res\n\n# Example usage:\nsol = Solution()\nnums = [-10,-3,0,5,9]\nroot = sol.sortedArrayToBST(nums)\noutput = serialize(root)\nprint(json.dumps({'Output': output}))\n\nnums = [1,3]\nroot = sol.sortedArrayToBST(nums)\noutput = serialize(root)\nprint(json.dumps({'Output': output}))"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        from collections import defaultdict\n\n        def dfs(i, j, index, walls, visited):\n            if (i, j) in visited:\n                return 0\n            visited.add((i, j))\n            wall_count = 0\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < m and 0 <= y < n:\n                    if isInfected[x][y] == 1 and (x, y) not in visited:\n                        wall_count += dfs(x, y, index, walls, visited)\n                    elif isInfected[x][y] == 0:\n                        walls[index].add((min(i, x), min(j, y), max(i, x), max(j, y)))\n                        wall_count += 1\n            return wall_count\n\n        m, n = len(isInfected), len(isInfected[0])\n        total_walls = 0\n        while True:\n            regions = defaultdict(set)\n            walls = defaultdict(set)\n            region_index = 0\n            visited = set()\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1 and (i, j) not in visited:\n                        region_walls = dfs(i, j, region_index, walls, visited)\n                        if region_walls > 0:\n                            regions[region_index] = region_walls\n                            region_index += 1\n\n            if not regions:\n                break\n\n            target_region = max(regions, key=regions.get)\n            total_walls += len(walls[target_region])\n\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                            if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 0:\n                                isInfected[x][y] = 1\n\n            for wall in walls[target_region]:\n                i1, j1, i2, j2 = wall\n                if i1 == i2:\n                    isInfected[i1][j1] = -1\n                    isInfected[i2][j2] = -1\n                else:\n                    isInfected[i1][j1] = -1\n                    isInfected[i2][j2] = -1\n\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == -1:\n                        isInfected[i][j] = 1\n\n        return total_walls"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        def dfs(i, j):\n            if not dp[i][j]:\n                val = matrix[i][j]\n                dp[i][j] = 1 + max(\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\n                    dfs(i + 1, j) if i < m - 1 and val > matrix[i + 1][j] else 0,\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\n                    dfs(i, j + 1) if j < n - 1 and val > matrix[i][j + 1] else 0\n                )\n            return dp[i][j]\n\n        if not matrix or not matrix[0]:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        return max(dfs(x, y) for x in range(m) for y in range(n))\n\n# Example usage:\nsol = Solution()\nexample_matrix = [[9,9,4],[6,6,8],[2,1,1]]\nprint(sol.longestIncreasingPath(example_matrix))  # Output: 4"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ones_count = 0\n        m = 1\n        while m <= n:\n            a = n // m\n            b = n % m\n            ones_count += (a + 8) // 10 * m + (a % 10 == 1) * (b + 1)\n            m *= 10\n        return ones_count\n\n# Example usage:\n# sol = Solution()\n# print(sol.countDigitOne(13))  # Output: 6\n# print(sol.countDigitOne(0))   # Output: 0"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        def canBreak(start, end, wordSet):\n            if start == end:\n                return True\n            return s[start:end] in wordSet\n\n        def backtrack(start, path):\n            if start == len(s):\n                results.append(' '.join(path))\n                return\n            for end in range(start + 1, len(s) + 1):\n                if canBreak(start, end, wordSet):\n                    backtrack(end, path + [s[start:end]])\n\n        wordSet = set(wordDict)\n        results = []\n        backtrack(0, [])\n        return results\n\n# Example usage:\n# sol = Solution()\n# print(sol.wordBreak(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]))\n# Output: [\"cats and dog\",\"cat sand dog\"]"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "if not root:\n            return []\n\n        result, level, direction = [], [root], 1\n\n        while level:\n            current_level_values = [node.val for node in level]\n            result.append(current_level_values[::direction])\n            direction *= -1\n            next_level = []\n            for node in level:\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            level = next_level\n\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "import itertools\n\nclass Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        if turnedOn < 0 or turnedOn > 8:\n            return []\n\n        def bit_count(n):\n            count = 0\n            while n:\n                n &= n - 1\n                count += 1\n            return count\n\n        times = []\n        for h in range(12):\n            for m in range(60):\n                if bit_count(h) + bit_count(m) == turnedOn:\n                    times.append(f'{h}:{m:02d}')\n        return times\n\n# Example usage:\n# sol = Solution()\n# print(sol.readBinaryWatch(1))\n# Output: ['0:01', '0:02', '0:04', '0:08', '0:16', '0:32', '1:00', '2:00', '4:00', '8:00']"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        pascal_triangle = []\n        for i in range(numRows):\n            row = [1] * (i + 1)\n            for j in range(1, i):\n                row[j] = pascal_triangle[i-1][j-1] + pascal_triangle[i-1][j]\n            pascal_triangle.append(row)\n        return pascal_triangle"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        # The maximum power of 3 value that\n        # integer can hold is 3^19 = 1162261467\n        # since 3^20 is bigger than int\n        return n > 0 and 1162261467 % n == 0\n\n# Example usage:\n# sol = Solution()\n# print(sol.isPowerOfThree(27))  # Output: true\n# print(sol.isPowerOfThree(0))   # Output: false\n# print(sol.isPowerOfThree(-1))  # Output: false"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "def max_gain(node):\n            nonlocal max_sum\n            if not node:\n                return 0\n\n            # Recursively call max_gain on node's left and right children\n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n\n            # Price to start a new path where 'node' is the highest node\n            price_newpath = node.val + left_gain + right_gain\n\n            # Update max_sum if it's better to start a new path\n            max_sum = max(max_sum, price_newpath)\n\n            # For recursion :\n            # Return the max gain if continue the same path\n            return node.val + max(left_gain, right_gain)\n\n        max_sum = float('-inf')\n        max_gain(root)\n        return max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        import heapq\n\n        if not heightMap or not heightMap[0]:\n            return 0\n\n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        heap = []\n\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        water = 0\n\n        while heap:\n            height, x, y = heapq.heappop(heap)\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    water += max(0, height - heightMap[nx][ny])\n                    visited[nx][ny] = True\n                    heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny))\n\n        return water\n\n# Example usage:\n# sol = Solution()\n# print(sol.trapRainWater([[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]))  # Output: 4\n# print(sol.trapRainWater([[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]))  # Output: 10"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # Convert to lowercase and remove non-alphanumeric characters\n        filtered_chars = [c.lower() for c in s if c.isalnum()]\n        # Check if the filtered string is a palindrome\n        return filtered_chars == filtered_chars[::-1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.isPalindrome(\"A man, a plan, a canal: Panama\"))  # Output: true\n# print(sol.isPalindrome(\"race a car\"))  # Output: false\n# print(sol.isPalindrome(\" \"))  # Output: true"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        from sortedcontainers import SortedList\n        window = SortedList()\n        result = []\n        for i in range(len(nums)):\n            if i >= k:\n                window.remove(nums[i-k])\n            window.add(nums[i])\n            if i >= k - 1:\n                if k % 2 == 0:\n                    median = (window[k//2 - 1] + window[k//2]) / 2.0\n                else:\n                    median = window[k//2]\n                result.append(float(median))\n        return result"}], "rotate-list": [{"task_id": "rotate-list", "completion": "if not head or not head.next or k == 0:\n            return head\n\n        # Find the length of the linked list\n        length = 1\n        current = head\n        while current.next:\n            current = current.next\n            length += 1\n\n        # Make the linked list circular\n        current.next = head\n\n        # Find the new head after rotation\n        k = k % length\n        steps_to_new_head = length - k\n        new_tail = head\n        for _ in range(steps_to_new_head - 1):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n\n        # Break the circle\n        new_tail.next = None\n\n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        for p in [2, 3, 5]:\n            while n % p == 0:\n                n //= p\n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        # Initialize the list to store the height after each drop\n        heights = []\n        # Initialize the list to store the current state of the squares\n        squares = []\n\n        # Iterate through each position\n        for left, size in positions:\n            right = left + size\n            current_height = 0\n\n            # Check each previously placed square\n            for prev_left, prev_right, prev_height in squares:\n                # If the current square intersects with a previous square\n                if left < prev_right and right > prev_left:\n                    # Update the current height if necessary\n                    current_height = max(current_height, prev_height)\n\n            # The new height is the current height plus the size of the new square\n            new_height = current_height + size\n            # Add the new square to the list of squares\n            squares.append((left, right, new_height))\n            # Add the new height to the list of heights\n            heights.append(max(heights[-1], new_height) if heights else new_height)\n\n        # Return the list of heights after each drop\n        return heights"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Helper function to check if a node is a leaf node\n        def is_leaf(node):\n            return node is not None and node.left is None and node.right is None\n\n        # Recursive function to find sum of left leaves\n        def find_sum_of_left_leaves(node, is_left):\n            if node is None:\n                return 0\n            if is_leaf(node) and is_left:\n                return node.val\n            return find_sum_of_left_leaves(node.left, True) + find_sum_of_left_leaves(node.right, False)\n\n        # Call the recursive function starting with the root node\n        return find_sum_of_left_leaves(root, False)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "import bisect\n\nclass Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        def maxSumSublist(vals):\n            max_sum = float('-inf')\n            prefix_sum = 0\n            prefix_sums = [float('inf')]\n            for val in vals:\n                bisect.insort(prefix_sums, prefix_sum)\n                prefix_sum += val\n                i = bisect.bisect_left(prefix_sums, prefix_sum - k)\n                max_sum = max(max_sum, prefix_sum - prefix_sums[i])\n            return max_sum\n\n        rows, cols = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        for left in range(cols):\n            row_sums = [0] * rows\n            for right in range(left, cols):\n                for i in range(rows):\n                    row_sums[i] += matrix[i][right]\n                max_sum = max(max_sum, maxSumSublist(row_sums))\n                if max_sum == k:\n                    return k\n        return max_sum\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxSumSubmatrix([[1,0,1],[0,-2,3]], 2))  # Output: 2\n# print(sol.maxSumSubmatrix([[2,2,-1]], 3))  # Output: 3"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        # Constants for the 32-bit signed integer range\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        # Handling overflow and underflow\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n\n        # Determine the sign of the result\n        negative = (dividend < 0) != (divisor < 0)\n\n        # Work with positive values to avoid overflow issues\n        dividend, divisor = abs(dividend), abs(divisor)\n\n        # Initialize the quotient\n        quotient = 0\n\n        # Subtract the divisor from the dividend until dividend is less than divisor\n        while dividend >= divisor:\n            # Initialize power of two and value\n            power_of_two = 1\n            value = divisor\n            while value <= dividend >> 1:\n                value <<= 1\n                power_of_two <<= 1\n            # Subtract the value from the dividend\n            dividend -= value\n            # Add the power of two to the quotient\n            quotient += power_of_two\n\n        # Adjust the sign of the quotient\n        return -quotient if negative else quotient\n\n# Example usage:\n# sol = Solution()\n# print(sol.divide(10, 3))  # Output: 3\n# print(sol.divide(7, -3)) # Output: -2"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'E'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        if not board or not board[0]:\n            return\n\n        m, n = len(board), len(board[0])\n\n        for i in range(m):\n            if board[i][0] == 'O':\n                dfs(i, 0)\n            if board[i][n - 1] == 'O':\n                dfs(i, n - 1)\n\n        for j in range(n):\n            if board[0][j] == 'O':\n                dfs(0, j)\n            if board[m - 1][j] == 'O':\n                dfs(m - 1, j)\n\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'E':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'\n\n# Example usage:\n# board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n# Solution().solve(board)\n# print(board)  # Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        num_to_index = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_to_index:\n                return [num_to_index[complement], i]\n            num_to_index[num] = i\n        return []"}], "24-game": [{"task_id": "24-game", "completion": "import itertools\n\nclass Solution(object):\n    def judgePoint24(self, cards):\n        def calculate(a, b, op):\n            if op == '+': return a + b\n            if op == '-': return a - b\n            if op == '*': return a * b\n            if op == '/':\n                if b == 0: return float('inf')\n                return a / b\n\n        def search(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n\n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        for op in '+-*/':\n                            if (op != '/' or nums[j] != 0):\n                                next_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                                next_nums.append(calculate(nums[i], nums[j], op))\n                                if search(next_nums):\n                                    return True\n            return False\n\n        for nums in itertools.permutations(cards):\n            if search(list(nums)):\n                return True\n        return False\n\n# Example usage:\nsol = Solution()\nprint(sol.judgePoint24([4, 1, 8, 7]))  # Output: true\nprint(sol.judgePoint24([1, 2, 1, 2]))  # Output: false"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n\n        return dp[len(s)][len(p)]\n\n# Example usage:\n# sol = Solution()\n# print(sol.isMatch(\"aa\", \"a\"))  # Output: false\n# print(sol.isMatch(\"aa\", \"*\"))  # Output: true\n# print(sol.isMatch(\"cb\", \"?a\"))  # Output: false"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        candidate = None\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n\n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        from collections import defaultdict\n        import heapq\n\n        def visit(airport):\n            while graph[airport]:\n                next_airport = heapq.heappop(graph[airport])\n                visit(next_airport)\n            itinerary.append(airport)\n\n        graph = defaultdict(list)\n        for depart, arrive in sorted(tickets)[::-1]:\n            graph[depart].append(arrive)\n\n        for key in graph.keys():\n            heapq.heapify(graph[key])\n\n        itinerary = []\n        visit('JFK')\n        return itinerary[::-1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.findItinerary([['MUC','LHR'],['JFK','MUC'],['SFO','SJC'],['LHR','SFO']]))\n# Output: ['JFK', 'MUC', 'LHR', 'SFO', 'SJC']\n# print(sol.findItinerary([['JFK','SFO'],['JFK','ATL'],['SFO','ATL'],['ATL','JFK'],['ATL','SFO']]))\n# Output: ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        nums.sort()\n        result = []\n        length = len(nums)\n        for i in range(length - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, length - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, length - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total < target:\n                        left += 1\n                    elif total > target:\n                        right -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.fourSum([1,0,-1,0,-2,2], 0))\n# print(sol.fourSum([2,2,2,2,2], 8))"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        # Define the events\n        events = []\n        for l, r, h in buildings:\n            events.append((l, -h, r))\n            events.append((r, 0, 0))\n        events.sort()\n\n        # Use a heap to maintain the max height\n        import heapq\n        heap = [(0, float('inf'))] # (height, right)\n        result = [[0, 0]]\n\n        for x, negH, R in events:\n            while heap[0][1] <= x:\n                heapq.heappop(heap)\n            if negH:\n                heapq.heappush(heap, (negH, R))\n            if result[-1][1] != -heap[0][0]:\n                result.append([x, -heap[0][0]])\n\n        # Remove the initial dummy result\n        return result[1:]"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n\n# Example usage:\n# s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n# Solution().reverseString(s)\n# print(s)  # Output: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\n# s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n# Solution().reverseString(s)\n# print(s)  # Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Iterative approach\n        prev = None\n        current = head\n        while current:\n            next_temp = current.next\n            current.next = prev\n            prev = current\n            current = next_temp\n        return prev\n\n    # Recursive approach\n    def reverseListRecursive(self, head):\n        if head is None or head.next is None:\n            return head\n        p = self.reverseListRecursive(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Start from the second last row and move upwards\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(len(triangle[row])):\n                # Update the current value to the minimum path sum of the two adjacent numbers in the row below\n                triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n        # The top element will have the minimum path sum\n        return triangle[0][0]\n\n# Example usage:\n# sol = Solution()\n# print(sol.minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]]))  # Output: 11\n# print(sol.minimumTotal([[-10]]))  # Output: -10"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        if num == 0: return 'Zero'\n\n        def one(num):\n            switcher = {\n                1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five',\n                6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'\n            }\n            return switcher.get(num)\n\n        def two_less_20(num):\n            switcher = {\n                10: 'Ten', 11: 'Eleven', 12: 'Twelve', 13: 'Thirteen', 14: 'Fourteen',\n                15: 'Fifteen', 16: 'Sixteen', 17: 'Seventeen', 18: 'Eighteen', 19: 'Nineteen'\n            }\n            return switcher.get(num)\n\n        def ten(num):\n            switcher = {\n                2: 'Twenty', 3: 'Thirty', 4: 'Forty', 5: 'Fifty',\n                6: 'Sixty', 7: 'Seventy', 8: 'Eighty', 9: 'Ninety'\n            }\n            return switcher.get(num)\n\n        def two(num):\n            if not num:\n                return ''\n            elif num < 10:\n                return one(num)\n            elif num < 20:\n                return two_less_20(num)\n            else:\n                tenner = num // 10\n                rest = num - tenner * 10\n                return ten(tenner) + ' ' + one(rest) if rest else ten(tenner)\n\n        def three(num):\n            hundred = num // 100\n            rest = num - hundred * 100\n            if hundred and rest:\n                return one(hundred) + ' Hundred ' + two(rest)\n            elif not hundred and rest:\n                return two(rest)\n            elif hundred and not rest:\n                return one(hundred) + ' Hundred'\n\n        billion = num // 1000000000\n        million = (num - billion * 1000000000) // 1000000\n        thousand = (num - billion * 1000000000 - million * 1000000) // 1000\n        remainder = num - billion * 1000000000 - million * 1000000 - thousand * 1000\n\n        result = ''\n        if billion:\n            result = three(billion) + ' Billion'\n        if million:\n            result += ' ' if result else ''\n            result += three(million) + ' Million'\n        if thousand:\n            result += ' ' if result else ''\n            result += three(thousand) + ' Thousand'\n        if remainder:\n            result += ' ' if result else ''\n            result += three(remainder)\n        return result.strip()\n\n# Example usage:\n# sol = Solution()\n# print(sol.numberToWords(123))\n# print(sol.numberToWords(12345))\n# print(sol.numberToWords(1234567))"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        dp[0][0] = 1\n\n        for i in range(1, n+1):\n            for j in range(k+1):\n                dp[i][j] = dp[i-1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j-1]\n                if j >= i:\n                    dp[i][j] -= dp[i-1][j-i]\n                dp[i][j] %= MOD\n\n        return dp[n][k]\n\n# Example usage:\n# sol = Solution()\n# print(sol.kInversePairs(3, 0))  # Output: 1\n# print(sol.kInversePairs(3, 1))  # Output: 2"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Initialize a dummy node to point to the head of the list\n        dummy = ListNode(0)\n        dummy.next = head\n        # Initialize current to the dummy node\n        current = dummy\n        \n        # Loop through the list while there are at least two more nodes to swap\n        while current.next and current.next.next:\n            # Identify the nodes to swap\n            first = current.next\n            second = current.next.next\n            \n            # Swap the nodes\n            first.next = second.next\n            second.next = first\n            current.next = second\n            \n            # Move current two nodes ahead\n            current = first\n        \n        # Return the new head of the list\n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "import json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        # Base case: if the tree is empty\n        if not root:\n            return False\n\n        # Check if we've reached a leaf node and the path sum equals targetSum\n        if not root.left and not root.right:\n            return root.val == targetSum\n\n        # Recursively check the left and right subtrees with the updated targetSum\n        return (self.hasPathSum(root.left, targetSum - root.val) or\n                self.hasPathSum(root.right, targetSum - root.val))\n\n# Example usage:\n# root = TreeNode(5)\n# root.left = TreeNode(4)\n# root.right = TreeNode(8)\n# root.left.left = TreeNode(11)\n# root.left.left.left = TreeNode(7)\n# root.left.left.right = TreeNode(2)\n# root.right.left = TreeNode(13)\n# root.right.right = TreeNode(4)\n# root.right.right.right = TreeNode(1)\n# targetSum = 22\n# solution = Solution()\n# result = solution.hasPathSum(root, targetSum)\n# print(json.dumps({'result': result}))"}], "partition-list": [{"task_id": "partition-list", "completion": "before_head = ListNode(0)  # Dummy node for the 'before' list\n        before = before_head  # Pointer for the 'before' list\n        after_head = ListNode(0)  # Dummy node for the 'after' list\n        after = after_head  # Pointer for the 'after' list\n\n        while head:\n            if head.val < x:\n                before.next = head\n                before = before.next\n            else:\n                after.next = head\n                after = after.next\n            head = head.next\n\n        after.next = None  # Important to avoid circular references in the final list\n        before.next = after_head.next  # Connect the 'before' list with the 'after' list\n\n        return before_head.next  # The first node of the 'before' list is the new head"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        parent = {}\n        candidates = []\n        for u, v in edges:\n            if v in parent:\n                candidates.append((parent[v], v))\n                candidates.append((u, v))\n            else:\n                parent[v] = u\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX == rootY:\n                return False\n            parent[rootY] = rootX\n            return True\n\n        parent = {i: i for i in range(1, len(edges) + 1)}\n        for u, v in edges:\n            if candidates and (u, v) == candidates[1]:\n                continue\n            if not union(u, v):\n                if candidates:\n                    return candidates[0]\n                return [u, v]\n\n        return candidates[1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.findRedundantDirectedConnection([[1,2],[1,3],[2,3]]))  # Output: [2,3]\n# print(sol.findRedundantDirectedConnection([[1,2],[2,3],[3,4],[4,1],[1,5]]))  # Output: [4,1]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        def backtrack(first=0):\n            if first == n:\n                out = list(nums)\n                if out not in result:\n                    result.append(out)\n                return\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        nums.sort()\n        n = len(nums)\n        result = []\n        backtrack()\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.permuteUnique([1,1,2]))\n# print(sol.permuteUnique([1,2,3]))"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        # Follow-up: O(1) runtime solution using Digital Root concept\n        if num == 0:\n            return 0\n        elif num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for num in nums:\n            result ^= num\n        return result"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # Split the string into words\n        words = s.strip().split(' ')\n        # Return the length of the last word\n        return len(words[-1])\n\n# Example usage:\n# sol = Solution()\n# print(sol.lengthOfLastWord(\"Hello World\"))  # Output: 5\n# print(sol.lengthOfLastWord(\"   fly me   to   the moon  \"))  # Output: 4\n# print(sol.lengthOfLastWord(\"luffy is still joyboy\"))  # Output: 6"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        n = len(grid)\n        dp = [[float('-inf')] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n\n        for t in range(1, 2 * n - 1):\n            new_dp = [[float('-inf')] * n for _ in range(n)]\n            for i in range(max(0, t - n + 1), min(n, t + 1)):\n                for j in range(max(0, t - n + 1), min(n, t + 1)):\n                    if grid[i][t - i] == -1 or grid[j][t - j] == -1:\n                        continue\n                    val = grid[i][t - i]\n                    if i != j:\n                        val += grid[j][t - j]\n                    for pi in [i - 1, i]:\n                        for pj in [j - 1, j]:\n                            if pi >= 0 and pj >= 0:\n                                new_dp[i][j] = max(new_dp[i][j], dp[pi][pj] + val)\n            dp = new_dp\n\n        return max(0, dp[n - 1][n - 1])\n\n# Example usage:\n# sol = Solution()\n# print(sol.cherryPickup([[0,1,-1],[1,0,-1],[1,1,1]]))  # Output: 5\n# print(sol.cherryPickup([[1,1,-1],[1,-1,1],[-1,1,1]]))  # Output: 0"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        MOD = 10**9 + 7\n\n        # dp[i][j][k] will be the count of valid sequences of length i\n        # where there are j A's and the last k characters are L\n        dp = [[[0] * 3 for _ in range(2)] for _ in range(n+1)]\n\n        # Base case: empty string is a valid sequence\n        dp[0][0][0] = 1\n\n        for i in range(1, n+1):\n            for j in range(2):\n                for k in range(3):\n                    # Case 1: Add a 'P' to the sequence\n                    dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][k]) % MOD\n\n                    # Case 2: Add an 'L' to the sequence\n                    if k < 2:\n                        dp[i][j][k+1] = (dp[i][j][k+1] + dp[i-1][j][k]) % MOD\n\n                    # Case 3: Add an 'A' to the sequence\n                    if j == 0:\n                        dp[i][1][0] = (dp[i][1][0] + dp[i-1][j][k]) % MOD\n\n        # Sum all valid sequences\n        result = 0\n        for j in range(2):\n            for k in range(3):\n                result = (result + dp[n][j][k]) % MOD\n\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.checkRecord(2))  # Output: 8\n# print(sol.checkRecord(1))  # Output: 3\n# print(sol.checkRecord(10101))  # Output: 183236316"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        def get_next(number):\n            total_sum = 0\n            while number > 0:\n                number, digit = divmod(number, 10)\n                total_sum += digit ** 2\n            return total_sum\n\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n\n        return n == 1\n\n# Example usage:\n# sol = Solution()\n# print(sol.isHappy(19))  # Output: true\n# print(sol.isHappy(2))   # Output: false"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n# Example usage:\n# sol = Solution()\n# print(sol.searchInsert([1,3,5,6], 5))  # Output: 2\n# print(sol.searchInsert([1,3,5,6], 2))  # Output: 1\n# print(sol.searchInsert([1,3,5,6], 7))  # Output: 4"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        max_reach = 0\n        for i, jump in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + jump)\n            if max_reach >= len(nums) - 1:\n                return True\n        return max_reach >= len(nums) - 1\n\n# Example usage:\n# sol = Solution()\n# print(sol.canJump([2,3,1,1,4]))  # Output: true\n# print(sol.canJump([3,2,1,0,4]))  # Output: false"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        for i in range(1, n):\n            grid[0][i] += grid[0][i-1]\n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        return grid[-1][-1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.minPathSum([[1,3,1],[1,5,1],[4,2,1]]))  # Output: 7\n# print(sol.minPathSum([[1,2,3],[4,5,6]]))  # Output: 12"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        prev = self.countAndSay(n - 1)\n        result = ''\n        count = 1\n        for i in range(1, len(prev)):\n            if prev[i] == prev[i - 1]:\n                count += 1\n            else:\n                result += str(count) + prev[i - 1]\n                count = 1\n        result += str(count) + prev[-1]\n        return result"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def is_valid(mid):\n            count, current_sum = 1, 0\n            for num in nums:\n                current_sum += num\n                if current_sum > mid:\n                    count += 1\n                    current_sum = num\n                if count > k:\n                    return False\n            return True\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n# Example usage:\n# sol = Solution()\n# print(sol.splitArray([7,2,5,10,8], 2))  # Output: 18\n# print(sol.splitArray([1,2,3,4,5], 2))  # Output: 9"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n\n        phone_map = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n\n        def backtrack(index, path):\n            if index == len(digits):\n                combinations.append(''.join(path))\n                return\n            possible_letters = phone_map[digits[index]]\n            for letter in possible_letters:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n\n        combinations = []\n        backtrack(0, [])\n        return combinations\n\n# Example usage:\n# sol = Solution()\n# print(sol.letterCombinations(\"23\"))\n# Output: ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        def backtrack(remaining, combo, start):\n            if remaining == 0:\n                result.append(list(combo))\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > remaining:\n                    break\n                combo.append(candidates[i])\n                backtrack(remaining - candidates[i], combo, i)\n                combo.pop()\n        \n        candidates.sort()\n        result = []\n        backtrack(target, [], 0)\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.combinationSum([2,3,6,7], 7))\n# Output: [[2,2,3],[7]]\n# print(sol.combinationSum([2,3,5], 8))\n# Output: [[2,2,2,2],[2,3,3],[3,5]]\n# print(sol.combinationSum([2], 1))\n# Output: []"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        def create_palindrome(mid):\n            return int(mid + mid[-2::-1]) if len(n) % 2 else int(mid + mid[::-1])\n\n        length = len(n)\n        original_num = int(n)\n        candidates = set()\n\n        middle = int(n[:(length + 1) // 2])\n        for diff in (-1, 0, 1):\n            candidates.add(create_palindrome(str(middle + diff)))\n\n        candidates.discard(original_num)\n\n        return str(min(candidates, key=lambda x: (abs(x - original_num), x)))\n\n# Example usage:\n# sol = Solution()\n# print(sol.nearestPalindromic(\"123\"))  # Output: \"121\"\n# print(sol.nearestPalindromic(\"1\"))    # Output: \"0\""}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        matrix = [[0] * n for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n\n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n\n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        sign = -1 if x < 0 else 1\n        x_abs = abs(x)\n        reversed_x = 0\n\n        while x_abs != 0:\n            pop = x_abs % 10\n            x_abs //= 10\n\n            if reversed_x > INT_MAX // 10 or (reversed_x == INT_MAX // 10 and pop > 7):\n                return 0\n            if reversed_x < INT_MIN // 10 or (reversed_x == INT_MIN // 10 and pop < -8):\n                return 0\n\n            reversed_x = reversed_x * 10 + pop\n\n        return sign * reversed_x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n - j - 1][i]\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n                matrix[j][n - i - 1] = temp\n\n# Example usage:\n# matrix = [[1,2,3],[4,5,6],[7,8,9]]\n# Solution().rotate(matrix)\n# print(matrix)  # Output: [[7,4,1],[8,5,2],[9,6,3]]\n\n# matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n# Solution().rotate(matrix)\n# print(matrix)  # Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        max_prod = min_prod = result = nums[0]\n        \n        for i in range(1, len(nums)):\n            num = nums[i]\n            if num < 0:\n                max_prod, min_prod = min_prod, max_prod\n            \n            max_prod = max(num, max_prod * num)\n            min_prod = min(num, min_prod * num)\n            \n            result = max(result, max_prod)\n        \n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        stone_positions = set(stones)\n        last_stone = stones[-1]\n        stack = [(0, 0)]\n        visited = set()\n\n        while stack:\n            stone, jump = stack.pop()\n            if stone == last_stone:\n                return True\n            for next_jump in (jump - 1, jump, jump + 1):\n                if next_jump > 0 and stone + next_jump in stone_positions and (stone + next_jump, next_jump) not in visited:\n                    visited.add((stone + next_jump, next_jump))\n                    stack.append((stone + next_jump, next_jump))\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.canCross([0,1,3,5,6,8,12,17]))  # Output: true\n# print(sol.canCross([0,1,2,3,4,8,9,11]))    # Output: false"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        # Create a dictionary to hold the score and its index\n        score_index_dict = {s: i for i, s in enumerate(score)}\n        # Sort the scores in descending order\n        sorted_scores = sorted(score, reverse=True)\n        # Initialize the answer list with the same size as the score list\n        answer = [''] * len(score)\n\n        # Assign the medals or the placement numbers\n        for rank, s in enumerate(sorted_scores):\n            if rank == 0:\n                answer[score_index_dict[s]] = 'Gold Medal'\n            elif rank == 1:\n                answer[score_index_dict[s]] = 'Silver Medal'\n            elif rank == 2:\n                answer[score_index_dict[s]] = 'Bronze Medal'\n            else:\n                answer[score_index_dict[s]] = str(rank + 1)\n\n        return answer"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        char_map = {}\n        left = 0\n        max_length = 0\n        for right in range(len(s)):\n            if s[right] in char_map and char_map[s[right]] >= left:\n                left = char_map[s[right]] + 1\n            char_map[s[right]] = right\n            max_length = max(max_length, right - left + 1)\n        return max_length\n\n# Example usage:\n# sol = Solution()\n# print(sol.lengthOfLongestSubstring('abcabcbb'))  # Output: 3\n# print(sol.lengthOfLongestSubstring('bbbbb'))     # Output: 1\n# print(sol.lengthOfLongestSubstring('pwwkew'))    # Output: 3"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "import collections\n\nclass Solution(object):\n    def findSubstring(self, s, words):\n        word_length = len(words[0])\n        word_count = len(words)\n        total_length = word_length * word_count\n        word_freq = collections.Counter(words)\n        result = []\n\n        for i in range(word_length):\n            left = i\n            right = i\n            current_freq = collections.Counter()\n\n            while right + word_length <= len(s):\n                word = s[right:right + word_length]\n                right += word_length\n\n                if word in word_freq:\n                    current_freq[word] += 1\n                    while current_freq[word] > word_freq[word]:\n                        current_freq[s[left:left + word_length]] -= 1\n                        left += word_length\n\n                    if right - left == total_length:\n                        result.append(left)\n                else:\n                    current_freq.clear()\n                    left = right\n\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.findSubstring(\"barfoothefoobarman\", [\"foo\",\"bar\"]))\n# Output: [0,9]"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        max_so_far = 0\n        chunk_count = 0\n        for i, num in enumerate(arr):\n            max_so_far = max(max_so_far, num)\n            if max_so_far == i:\n                chunk_count += 1\n        return chunk_count\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxChunksToSorted([5,4,3,2,1]))  # Output: 1\n# print(sol.maxChunksToSorted([2,1,3,4,4]))  # Output: 4"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Initialize a dummy node to act as the head of the sorted list\n        dummy = ListNode(0)\n\n        # Iterate through each element in the original list\n        current = head\n        while current:\n            # At each iteration, we will insert the current node into the sorted list\n            prev_node = dummy\n            next_node = dummy.next\n            # Find the correct position to insert the current node\n            while next_node and next_node.val < current.val:\n                prev_node = next_node\n                next_node = next_node.next\n            \n            # Insert the current node between prev_node and next_node\n            next_current = current.next\n            current.next = next_node\n            prev_node.next = current\n\n            # Move to the next element in the original list\n            current = next_current\n\n        # Return the sorted list, which starts at dummy.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Initialize a dummy node with value 0 and point its next to head\n        dummy = ListNode(0, head)\n        # Initialize prev to dummy\n        prev = dummy\n        \n        # Iterate through the linked list\n        while head:\n            # If we find a node with a duplicate value\n            if head.next and head.val == head.next.val:\n                # Skip all nodes with the same value\n                while head.next and head.val == head.next.val:\n                    head = head.next\n                # Link prev to the node after the last duplicate\n                prev.next = head.next\n            else:\n                # If current node is unique, move prev to this node\n                prev = prev.next\n            # Move to the next node\n            head = head.next\n        \n        # Return the modified list\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        nums.sort()\n        result = []\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total < 0:\n                    left += 1\n                elif total > 0:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.threeSum([-1,0,1,2,-1,-4])) # Output: [[-1,-1,2],[-1,0,1]]\n# print(sol.threeSum([0,1,1])) # Output: []\n# print(sol.threeSum([0,0,0])) # Output: [[0,0,0]]"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        # XOR x and y to find the bits that are different\n        xor = x ^ y\n        # Count the number of set bits (1s) in the XOR result\n        distance = 0\n        while xor:\n            distance += xor & 1\n            xor >>= 1\n        return distance\n\n# Example usage:\n# sol = Solution()\n# print(sol.hammingDistance(1, 4))  # Output: 2\n# print(sol.hammingDistance(3, 1))  # Output: 1"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "def dfs(node, path, paths):\n            if not node:\n                return\n            path += str(node.val)\n            if not node.left and not node.right:\n                paths.append(path)\n            else:\n                path += '->'\n                dfs(node.left, path, paths)\n                dfs(node.right, path, paths)\n\n        paths = []\n        dfs(root, '', paths)\n        return paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        def merge_sort(arr, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = merge_sort(arr, left, mid) + merge_sort(arr, mid + 1, right)\n            j = mid + 1\n            for i in range(left, mid + 1):\n                while j <= right and arr[i] > 2 * arr[j]:\n                    j += 1\n                count += j - (mid + 1)\n            arr[left:right+1] = sorted(arr[left:right+1])\n            return count\n        return merge_sort(nums, 0, len(nums) - 1)\n\n# Example usage:\n# sol = Solution()\n# print(sol.reversePairs([1,3,2,3,1]))  # Output: 2\n# print(sol.reversePairs([2,4,3,5,1]))  # Output: 3"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        while tx >= sx and ty >= sy:\n            if tx == ty: break\n            if tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    return (tx - sx) % ty == 0\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    return (ty - sy) % tx == 0\n        return tx == sx and ty == sy\n\n# Example usage:\n# sol = Solution()\n# print(sol.reachingPoints(1, 1, 3, 5))  # Output: true\n# print(sol.reachingPoints(1, 1, 2, 2))  # Output: false\n# print(sol.reachingPoints(1, 1, 1, 1))  # Output: true"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        # Split the version numbers into lists of revisions\n        revisions1 = version1.split('.')\n        revisions2 = version2.split('.')\n\n        # Compare each revision\n        for i in range(max(len(revisions1), len(revisions2))):\n            # Convert revision to integer, if revision does not exist, use 0\n            rev1 = int(revisions1[i]) if i < len(revisions1) else 0\n            rev2 = int(revisions2[i]) if i < len(revisions2) else 0\n\n            # Compare the integer values of revisions\n            if rev1 < rev2:\n                return -1\n            elif rev1 > rev2:\n                return 1\n\n        # If all revisions are equal\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        max_profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                max_profit += prices[i] - prices[i - 1]\n        return max_profit\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxProfit([7,1,5,3,6,4]))  # Output: 7\n# print(sol.maxProfit([1,2,3,4,5]))    # Output: 4\n# print(sol.maxProfit([7,6,4,3,1]))    # Output: 0"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "import heapq\n\nclass Solution(object):\n    def scheduleCourse(self, courses):\n        # Sort the courses by their ending day\n        courses.sort(key=lambda x: x[1])\n        total_time = 0\n        max_heap = []\n        for duration, last_day in courses:\n            if total_time + duration <= last_day:\n                # If the course can be finished before the last day\n                heapq.heappush(max_heap, -duration)\n                total_time += duration\n            elif max_heap and -max_heap[0] > duration:\n                # If the current course duration is less than the longest duration course taken\n                total_time += duration + heapq.heappop(max_heap)\n                heapq.heappush(max_heap, -duration)\n        return len(max_heap)\n\n# Example usage:\n# sol = Solution()\n# print(sol.scheduleCourse([[100,200],[200,1300],[1000,1250],[2000,3200]])) # Output: 3\n# print(sol.scheduleCourse([[1,2]])) # Output: 1\n# print(sol.scheduleCourse([[3,2],[4,3]])) # Output: 0"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Helper function to reverse a linked list segment\n        def reverse_segment(start, end):\n            prev, curr = None, start\n            while curr != end:\n                next_temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = next_temp\n            return prev\n\n        # Dummy node initialization\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        # Main loop to process the list in k-group segments\n        while True:\n            # Check if there are at least k nodes left to reverse\n            kth = prev\n            for i in range(k):\n                kth = kth.next\n                if not kth:\n                    return dummy.next\n\n            # Reverse k nodes\n            next_group = kth.next\n            kth.next = None\n            start = prev.next\n            prev.next = reverse_segment(start, kth.next)\n            start.next = next_group\n            prev = start\n\n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # The idea is to check for all possible substring lengths\n        for i in range(1, len(s) // 2 + 1):\n            # If the current length can divide the string into equal parts\n            if len(s) % i == 0:\n                # Get the substring\n                substring = s[:i]\n                # Multiply the substring and compare with the original string\n                if substring * (len(s) // i) == s:\n                    return True\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.repeatedSubstringPattern('abab'))  # Output: true\n# print(sol.repeatedSubstringPattern('aba'))   # Output: false\n# print(sol.repeatedSubstringPattern('abcabcabcabc'))  # Output: true"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # Catalan number Cn formula\n        # Cn = (2n)! / ((n+1)! * n!)\n        # We can compute it using dynamic programming\n\n        # Initialize the list to store the number of unique BSTs\n        G = [0] * (n + 1)\n        G[0], G[1] = 1, 1\n\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                # G[i] accumulates number of unique BSTs with i nodes\n                G[i] += G[j - 1] * G[i - j]\n\n        return G[n]\n\n# Example usage:\n# sol = Solution()\n# print(sol.numTrees(3))  # Output: 5\n# print(sol.numTrees(1))  # Output: 1"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ones, twos = 0, 0\n        for num in nums:\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n        return ones"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        from collections import Counter\n\n        def dfs(rem):\n            if not rem:\n                return 0\n            if rem in memo:\n                return memo[rem]\n            rem_count = Counter(rem)\n            ans = float('inf')\n            for sticker in stickers:\n                if sticker_counts[sticker][rem[0]] == 0:\n                    continue\n                used = max((rem_count[char] // sticker_counts[sticker][char]) for char in rem_count if sticker_counts[sticker][char] > 0)\n                if used > 0:\n                    new_rem = rem\n                    for char in sticker_counts[sticker]:\n                        if char in rem_count:\n                            new_rem = new_rem.replace(char, '', used * sticker_counts[sticker][char])\n                    ans = min(ans, used + dfs(new_rem))\n            memo[rem] = -1 if ans == float('inf') else ans\n            return memo[rem]\n\n        sticker_counts = {sticker: Counter(sticker) for sticker in stickers}\n        memo = {}\n        result = dfs(target)\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.minStickers(['with','example','science'], 'thehat'))  # Output: 3\n# print(sol.minStickers(['notice','possible'], 'basicbasic'))  # Output: -1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n\n        # dp[i][j] will be the minimum number of turns to print s[i:j+1]\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][k] + dp[k + 1][j] for k in range(i, j))\n\n        return dp[0][n - 1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.strangePrinter(\"aaabbb\"))  # Output: 2\n# print(sol.strangePrinter(\"aba\"))    # Output: 2"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 2:\n            return x\n\n        left, right = 1, x // 2\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        # Define the mapping of Roman numerals to integers\n        roman_to_int = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n\n        # Initialize the result variable\n        result = 0\n\n        # Iterate through the characters of the string\n        for i in range(len(s)):\n            # If the current character is less than the next one, subtract it\n            if i + 1 < len(s) and roman_to_int[s[i]] < roman_to_int[s[i + 1]]:\n                result -= roman_to_int[s[i]]\n            else:\n                # Otherwise, add it\n                result += roman_to_int[s[i]]\n\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "import collections\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        deque = collections.deque()\n        for i, num in enumerate(nums):\n            while deque and deque[0] < i - k + 1:\n                deque.popleft()\n            while deque and nums[deque[-1]] < num:\n                deque.pop()\n            deque.append(i)\n            if i >= k - 1:\n                result.append(nums[deque[0]])\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3))\n# Output: [3,3,5,5,6,7]\n# print(sol.maxSlidingWindow([1], 1))\n# Output: [1]"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        # This function finds the median of two sorted arrays\n        def findMedian(A, B):\n            m, n = len(A), len(B)\n            if m > n:\n                A, B, m, n = B, A, n, m\n            if n == 0:\n                raise ValueError\n\n            imin, imax, half_len = 0, m, (m + n + 1) // 2\n            while imin <= imax:\n                i = (imin + imax) // 2\n                j = half_len - i\n                if i < m and B[j-1] > A[i]:\n                    imin = i + 1\n                elif i > 0 and A[i-1] > B[j]:\n                    imax = i - 1\n                else:\n                    if i == 0: min_of_right = B[j]\n                    elif j == 0: min_of_right = A[i]\n                    else: min_of_right = min(A[i], B[j])\n\n                    if (m + n) % 2 == 1:\n                        return min_of_right\n\n                    if i == m: max_of_left = B[j-1]\n                    elif j == n: max_of_left = A[i-1]\n                    else: max_of_left = max(A[i-1], B[j-1])\n\n                    return (max_of_left + min_of_right) / 2.0\n\n        return findMedian(nums1, nums2)"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        row = [1]\n        for _ in range(rowIndex):\n            row = [x + y for x, y in zip([0]+row, row+[0])]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "def dfs(node, current_path, current_sum):\n            if not node:\n                return []\n            current_path.append(node.val)\n            current_sum += node.val\n            if not node.left and not node.right and current_sum == targetSum:\n                paths.append(list(current_path))\n            else:\n                dfs(node.left, current_path, current_sum)\n                dfs(node.right, current_path, current_sum)\n            current_path.pop()\n\n        paths = []\n        dfs(root, [], 0)\n        return paths"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        # Start with the largest possible square smaller than or equal to the area\n        width = int(area**0.5)\n        # Decrease width until we find the one that divides the area exactly\n        while area % width != 0:\n            width -= 1\n        # Calculate the length by dividing the area by the width\n        length = area // width\n        # Return the dimensions with length being greater than or equal to width\n        return [length, width]\n\n# Example usage:\n# sol = Solution()\n# print(sol.constructRectangle(4))  # Output: [2, 2]\n# print(sol.constructRectangle(37)) # Output: [37, 1]\n# print(sol.constructRectangle(122122)) # Output: [427, 286]"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        from collections import defaultdict, deque\n\n        def add_word(word, dict):\n            for i in range(len(word)):\n                pattern = word[:i] + '_' + word[i+1:]\n                dict[pattern].append(word)\n\n        def bfs(front_level, end_level, is_forward, word_set, parent_map):\n            if len(front_level) == 0:\n                return False\n            if len(front_level) > len(end_level):\n                return bfs(end_level, front_level, not is_forward, word_set, parent_map)\n\n            for word in (front_level | end_level):\n                word_set.discard(word)\n\n            next_level = set()\n            done = False\n            while front_level:\n                word = front_level.pop()\n                for i in range(len(word)):\n                    pattern = word[:i] + '_' + word[i+1:]\n                    for next_word in pattern_dict[pattern]:\n                        if next_word in end_level:\n                            done = True\n                            add_parent(parent_map, word, next_word, is_forward)\n                        if not done and next_word in word_set:\n                            next_level.add(next_word)\n                            add_parent(parent_map, word, next_word, is_forward)\n            return done or bfs(next_level, end_level, is_forward, word_set, parent_map)\n\n        def add_parent(parent_map, word, next_word, is_forward):\n            if not is_forward:\n                word, next_word = next_word, word\n            if next_word not in parent_map:\n                parent_map[next_word] = [word]\n            else:\n                parent_map[next_word].append(word)\n\n        def construct_paths(beginWord, endWord, parent_map):\n            if beginWord == endWord:\n                return [[beginWord]]\n            if endWord not in parent_map:\n                return []\n            paths = []\n            for parent in parent_map[endWord]:\n                for path in construct_paths(beginWord, parent, parent_map):\n                    paths.append(path + [endWord])\n            return paths\n\n        if endWord not in wordList:\n            return []\n\n        wordList = set(wordList)\n        pattern_dict = defaultdict(list)\n        for word in wordList:\n            add_word(word, pattern_dict)\n\n        front_level = {beginWord}\n        end_level = {endWord}\n        is_forward = True\n        parent_map = {}\n        word_set = set(wordList)\n\n        if not bfs(front_level, end_level, is_forward, word_set, parent_map):\n            return []\n\n        return construct_paths(beginWord, endWord, parent_map)\n\n# Example usage:\n# sol = Solution()\n# print(sol.findLadders(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]))\n# Output: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "def getHeight(self, node):\n            if not node:\n                return 0\n            left_height = self.getHeight(node.left)\n            if left_height == -1:\n                return -1\n            right_height = self.getHeight(node.right)\n            if right_height == -1:\n                return -1\n            if abs(left_height - right_height) > 1:\n                return -1\n            return max(left_height, right_height) + 1\n\n        def isBalanced(self, root):\n            return self.getHeight(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        # Follow up: Solve without loops/recursion\n        # A number is a power of two if it is greater than 0 and\n        # its binary representation contains only one '1'.\n        return n > 0 and (n & (n - 1)) == 0\n\n# Example usage:\n# sol = Solution()\n# print(sol.isPowerOfTwo(1))  # Output: true\n# print(sol.isPowerOfTwo(16)) # Output: true\n# print(sol.isPowerOfTwo(3))  # Output: false"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                backtrack(i + 1, path + [nums[i]])\n        \n        nums.sort()\n        res = []\n        backtrack(0, [])\n        return res\n\n# Example usage:\n# sol = Solution()\n# print(sol.subsetsWithDup([1,2,2]))\n# print(sol.subsetsWithDup([0]))"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        stack = []\n        max_area = 0\n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                max_area = max(max_area, height * (i - index))\n                start = index\n            stack.append((start, h))\n        \n        for i, h in stack:\n            max_area = max(max_area, h * (len(heights) - i))\n        return max_area\n\n# Example usage:\n# heights = [2,1,5,6,2,3]\n# print(Solution().largestRectangleArea(heights))\n# Output: 10"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "stack = []\n        for token in tokens:\n            if token not in '+-*/':\n                stack.append(int(token))\n            else:\n                right_operand = stack.pop()\n                left_operand = stack.pop()\n                if token == '+':\n                    stack.append(left_operand + right_operand)\n                elif token == '-':\n                    stack.append(left_operand - right_operand)\n                elif token == '*':\n                    stack.append(left_operand * right_operand)\n                elif token == '/':\n                    stack.append(int(float(left_operand) / right_operand))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        # Calculate the area of the big rectangle\n        X1, Y1 = min(x for x, _, _, _ in rectangles), min(y for _, y, _, _ in rectangles)\n        X2, Y2 = max(a for _, _, a, _ in rectangles), max(b for _, _, _, b in rectangles)\n        expected_area = (X2 - X1) * (Y2 - Y1)\n\n        # Calculate the sum of areas of all small rectangles\n        actual_area = sum((x2 - x1) * (y2 - y1) for x1, y1, x2, y2 in rectangles)\n\n        # Check if the total area of small rectangles equals the area of the big rectangle\n        if expected_area != actual_area:\n            return False\n\n        # Check for overlap and count corners\n        corners = set()\n        for x1, y1, x2, y2 in rectangles:\n            p1, p2, p3, p4 = (x1, y1), (x2, y2), (x1, y2), (x2, y1)\n            for p in [p1, p2, p3, p4]:\n                if p in corners:\n                    corners.remove(p)\n                else:\n                    corners.add(p)\n\n        # There should be exactly 4 corners for the big rectangle\n        if len(corners) != 4 or (X1, Y1) not in corners or (X2, Y2) not in corners or (X1, Y2) not in corners or (X2, Y1) not in corners:\n            return False\n\n        return True\n\n# Example usage:\n# sol = Solution()\n# print(sol.isRectangleCover([[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]])) # Output: true\n# print(sol.isRectangleCover([[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]])) # Output: false\n# print(sol.isRectangleCover([[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]])) # Output: false"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        result = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            result = chr(65 + (columnNumber % 26)) + result\n            columnNumber //= 26\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.convertToTitle(1))  # Output: \"A\"\n# print(sol.convertToTitle(28)) # Output: \"AB\"\n# print(sol.convertToTitle(701)) # Output: \"ZY\""}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_sum = nums[0]\n        current_sum = nums[0]\n\n        for num in nums[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n\n        return max_sum\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxSubArray([-2,1,-3,4,-1,2,1,-5,4]))  # Output: 6\n# print(sol.maxSubArray([1]))                       # Output: 1\n# print(sol.maxSubArray([5,4,-1,7,8]))              # Output: 23"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "import collections\n\nclass Solution(object):\n    def slidingPuzzle(self, board):\n        # Convert the board into a string representation\n        start = ''.join(str(num) for row in board for num in row)\n        target = '123450'\n        # Use a BFS approach\n        queue = collections.deque([(start, start.index('0'))])\n        visited = set()\n        visited.add(start)\n        moves = 0\n        # Define the neighbors based on the index of '0'\n        neighbors = [\n            [1, 3], [0, 2, 4], [1, 5],\n            [0, 4], [1, 3, 5], [2, 4]\n        ]\n        \n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                state, zero = queue.popleft()\n                if state == target:\n                    return moves\n                for neighbor in neighbors[zero]:\n                    new_state = list(state)\n                    new_state[zero], new_state[neighbor] = new_state[neighbor], new_state[zero]\n                    new_state = ''.join(new_state)\n                    if new_state not in visited:\n                        visited.add(new_state)\n                        queue.append((new_state, neighbor))\n            moves += 1\n        \n        return -1\n\n# Example usage:\n# sol = Solution()\n# print(sol.slidingPuzzle([[1,2,3],[4,0,5]]))  # Output: 1\n# print(sol.slidingPuzzle([[1,2,3],[5,4,0]]))  # Output: -1\n# print(sol.slidingPuzzle([[4,1,2],[5,0,3]]))  # Output: 5"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n\n        char_map_s_to_t = {}\n        char_map_t_to_s = {}\n\n        for char_s, char_t in zip(s, t):\n            if char_s not in char_map_s_to_t and char_t not in char_map_t_to_s:\n                char_map_s_to_t[char_s] = char_t\n                char_map_t_to_s[char_t] = char_s\n            elif char_map_s_to_t.get(char_s) != char_t or char_map_t_to_s.get(char_t) != char_s:\n                return False\n\n        return True\n\n# Example usage:\n# sol = Solution()\n# print(sol.isIsomorphic('egg', 'add'))  # Output: true\n# print(sol.isIsomorphic('foo', 'bar'))  # Output: false\n# print(sol.isIsomorphic('paper', 'title'))  # Output: true"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.search([2,5,6,0,0,1,2], 0))  # Output: true\n# print(sol.search([2,5,6,0,0,1,2], 3))  # Output: false"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                else:\n                    if i > 0:\n                        dp[i][j] += dp[i - 1][j]\n                    if j > 0:\n                        dp[i][j] += dp[i][j - 1]\n\n        return dp[m - 1][n - 1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        MOD = 10**9 + 7\n\n        # A helper function to calculate the number of ways to decode a single character.\n        def ways(ch):\n            if ch == '*':\n                return 9\n            if ch == '0':\n                return 0\n            return 1\n\n        # A helper function to calculate the number of ways to decode a two-character string.\n        def ways2(ch1, ch2):\n            if ch1 == '*' and ch2 == '*':\n                return 15\n            if ch1 == '*':\n                return 2 if ch2 <= '6' else 1\n            if ch2 == '*':\n                if ch1 == '1':\n                    return 9\n                if ch1 == '2':\n                    return 6\n                return 0\n            return int(ch1 == '1' or (ch1 == '2' and ch2 <= '6'))\n\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = ways(s[0])\n\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] * ways(s[i - 1])\n            dp[i] += dp[i - 2] * ways2(s[i - 2], s[i - 1])\n            dp[i] %= MOD\n\n        return dp[n]\n\n# Example usage:\n# sol = Solution()\n# print(sol.numDecodings('*'))  # Output: 9\n# print(sol.numDecodings('1*')) # Output: 18\n# print(sol.numDecodings('2*')) # Output: 15"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        closest_sum = float('inf')\n        for i in range(len(nums) - 2):\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                if abs(target - current_sum) < abs(target - closest_sum):\n                    closest_sum = current_sum\n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    return target\n        return closest_sum"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "if not root:\n            return 0\n        else:\n            left_depth = self.maxDepth(root.left)\n            right_depth = self.maxDepth(root.right)\n            return max(left_depth, right_depth) + 1"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        from collections import Counter\n        counts = Counter(nums1)\n        intersection = []\n        for num in nums2:\n            if counts[num] > 0:\n                intersection.append(num)\n                counts[num] -= 1\n        return intersection"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "import sys\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        # Initialize previous node as None and min difference as max value\n        self.prev = None\n        self.min_diff = sys.maxsize\n        \n        def inorder(node):\n            # Inorder traversal of BST yields sorted values\n            if not node:\n                return\n            inorder(node.left)\n            if self.prev is not None:\n                self.min_diff = min(self.min_diff, node.val - self.prev.val)\n            self.prev = node\n            inorder(node.right)\n        \n        # Perform inorder traversal\n        inorder(root)\n        return self.min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Helper function to perform in-order traversal and track the count of elements\n        def in_order_traversal(node):\n            if not node:\n                return\n            in_order_traversal(node.left)\n            if self.prev_val == node.val:\n                self.curr_count += 1\n            else:\n                self.prev_val = node.val\n                self.curr_count = 1\n            if self.curr_count > self.max_count:\n                self.max_count = self.curr_count\n                self.modes = [node.val]\n            elif self.curr_count == self.max_count:\n                self.modes.append(node.val)\n            in_order_traversal(node.right)\n\n        self.prev_val = None\n        self.curr_count = 0\n        self.max_count = 0\n        self.modes = []\n        in_order_traversal(root)\n        return self.modes"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        # Check if needle is an empty string\n        if not needle:\n            return 0\n\n        # Iterate through the haystack to find the needle\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n\n        # If needle is not found, return -1\n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        def count_repeating_chars(s):\n            count = 0\n            i = 2\n            while i < len(s):\n                if s[i] == s[i-1] == s[i-2]:\n                    count += 1\n                    i += 2\n                else:\n                    i += 1\n            return count\n\n        length = len(password)\n        has_lower = any(c.islower() for c in password)\n        has_upper = any(c.isupper() for c in password)\n        has_digit = any(c.isdigit() for c in password)\n        repeating_chars = count_repeating_chars(password)\n\n        steps = 0\n        steps += not has_lower\n        steps += not has_upper\n        steps += not has_digit\n\n        if length < 6:\n            steps += max(6 - length, 3 - (has_lower + has_upper + has_digit))\n        elif length > 20:\n            delete_steps = length - 20\n            steps += delete_steps\n            repeating_chars = max(0, repeating_chars - delete_steps // 3)\n        steps += repeating_chars\n\n        return steps\n\n# Example usage:\n# sol = Solution()\n# print(sol.strongPasswordChecker('a'))  # Output: 5\n# print(sol.strongPasswordChecker('aA1'))  # Output: 3\n# print(sol.strongPasswordChecker('1337C0d3'))  # Output: 0"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # Initialize count of trailing zeroes\n        count = 0\n\n        # Keep dividing n by powers of 5 and update count\n        while n > 0:\n            n //= 5\n            count += n\n\n        return count\n\n# Example usage:\n# sol = Solution()\n# print(sol.trailingZeroes(3))  # Output: 0\n# print(sol.trailingZeroes(5))  # Output: 1\n# print(sol.trailingZeroes(0))  # Output: 0"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        # Initialize an array to hold the zigzag pattern\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n\n        # Iterate through each character in the string\n        for char in s:\n            rows[current_row] += char\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n            current_row += 1 if going_down else -1\n\n        # Concatenate all rows to get the final string\n        return ''.join(rows)\n\n# Example usage:\n# sol = Solution()\n# output = sol.convert(\"PAYPALISHIRING\", 3)\n# print(output)  # Output: \"PAHNAPLSIIGYIR\"\n\n# output = sol.convert(\"PAYPALISHIRING\", 4)\n# print(output)  # Output: \"PINALSIGYAHRPI\"\n\n# output = sol.convert(\"A\", 1)\n# print(output)  # Output: \"A\""}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n\n        left_max = [0] * len(height)\n        right_max = [0] * len(height)\n        water_trapped = 0\n\n        left_max[0] = height[0]\n        for i in range(1, len(height)):\n            left_max[i] = max(left_max[i - 1], height[i])\n\n        right_max[-1] = height[-1]\n        for i in range(len(height) - 2, -1, -1):\n            right_max[i] = max(right_max[i + 1], height[i])\n\n        for i in range(len(height)):\n            water_trapped += min(left_max[i], right_max[i]) - height[i]\n\n        return water_trapped\n\n# Example usage:\n# sol = Solution()\n# print(sol.trap([0,1,0,2,1,0,1,3,2,1,2,1]))  # Output: 6\n# print(sol.trap([4,2,0,3,2,5]))  # Output: 9"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for num in nums:\n            index = abs(num) - 1\n            nums[index] = -abs(nums[index])\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        def sort(enum):\n            half = len(enum) // 2\n            if half:\n                left, right = sort(enum[:half]), sort(enum[half:])\n                for i in range(len(enum))[::-1]:\n                    if not right or left and left[-1][1] > right[-1][1]:\n                        smaller[left[-1][0]] += len(right)\n                        enum[i] = left.pop()\n                    else:\n                        enum[i] = right.pop()\n            return enum\n\n        smaller = [0] * len(nums)\n        sort(list(enumerate(nums)))\n        return smaller\n\n# Example usage:\n# sol = Solution()\n# print(sol.countSmaller([5,2,6,1]))  # Output: [2,1,1,0]\n# print(sol.countSmaller([-1]))      # Output: [0]\n# print(sol.countSmaller([-1,-1]))   # Output: [0,0]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        todo = [2] * len(intervals)\n        ans = 0\n        while intervals:\n            (start, end) = intervals.pop()\n            t = todo.pop()\n            for p in range(end - t + 1, end + 1):\n                for i, (s, e) in enumerate(intervals):\n                    if todo[i] and s <= p <= e:\n                        todo[i] -= 1\n            ans += t\n        return ans\n\n# Example usage:\n# intervals = [[1,3],[3,7],[8,9]]\n# sol = Solution()\n# print(sol.intersectionSizeTwo(intervals)) # Output: 5"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Helper function to check if two trees are mirror of each other\n        def isMirror(t1, t2):\n            if t1 is None and t2 is None:\n                return True\n            if t1 is None or t2 is None:\n                return False\n            return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)\n\n        # Check if the tree is symmetric\n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "import collections\nimport re\n\nclass Solution(object):\n    def countOfAtoms(self, formula):\n        def parse():\n            N = len(formula)\n            count = collections.Counter()\n            stack = [collections.Counter()]\n            i = 0\n            while i < N:\n                if formula[i] == '(':  # Start of a group\n                    stack.append(collections.Counter())\n                    i += 1\n                elif formula[i] == ')':  # End of a group\n                    i += 1\n                    i_start = i\n                    while i < N and formula[i].isdigit():\n                        i += 1\n                    multiplier = int(formula[i_start:i] or 1)\n                    group = stack.pop()\n                    for element, cnt in group.items():\n                        stack[-1][element] += cnt * multiplier\n                else:  # Start of an element\n                    i_start = i\n                    i += 1\n                    while i < N and formula[i].islower():\n                        i += 1\n                    element = formula[i_start:i]\n                    i_start = i\n                    while i < N and formula[i].isdigit():\n                        i += 1\n                    count = int(formula[i_start:i] or 1)\n                    stack[-1][element] += count\n            return stack.pop()\n        \n        # Parse the formula and get the counts\n        counts = parse()\n        \n        # Sort the elements and format the result\n        return ''.join(element + (str(counts[element]) if counts[element] > 1 else '') for element in sorted(counts))\n\n# Example usage:\nsol = Solution()\nprint(sol.countOfAtoms(\"H2O\"))  # Output: \"H2O\"\nprint(sol.countOfAtoms(\"Mg(OH)2\"))  # Output: \"H2MgO2\"\nprint(sol.countOfAtoms(\"K4(ON(SO3)2)2\"))  # Output: \"K4N2O14S4\""}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Initialize an empty list to store the preorder traversal result\n        result = []\n\n        # Check if the root is None, return the empty result list\n        if not root:\n            return result\n\n        # Initialize a stack with the root node\n        stack = [root]\n\n        # Iterate while the stack is not empty\n        while stack:\n            # Pop the last node from the stack\n            node = stack.pop()\n            # Append the node's value to the result list\n            result.append(node.val)\n\n            # Push the right child first so that the left child is processed first\n            if node.right:\n                stack.append(node.right)\n\n            # Push the left child to the stack\n            if node.left:\n                stack.append(node.left)\n\n        # Return the result list containing the preorder traversal\n        return result"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        # Follow up: Solve without loops/recursion\n        # A power of four in binary has a '1' followed by an even number of '0's\n        # It also has to be greater than 0\n        if n <= 0:\n            return False\n        # Check if n is a power of 2 (only one '1' in binary representation)\n        if n & (n - 1) != 0:\n            return False\n        # Count the number of zeros after the '1'\n        # A power of four has an even number of zeros\n        # Use the binary representation of n to count zeros\n        # The binary mask 0b01010101010101010101010101010101 will have '1's in the places\n        # where a power of four has its single '1' bit\n        return n & 0b01010101010101010101010101010101 != 0\n\n# Example usage:\n# sol = Solution()\n# print(sol.isPowerOfFour(16))  # Output: true\n# print(sol.isPowerOfFour(5))   # Output: false\n# print(sol.isPowerOfFour(1))   # Output: true"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "if not root:\n            return None\n        # Swap the left and right children\n        root.left, root.right = root.right, root.left\n        # Recursively call invertTree on the children\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        def backtrack(s='', left=0, right=0):\n            if len(s) == 2 * n:\n                result.append(s)\n                return\n            if left < n:\n                backtrack(s+'(', left+1, right)\n            if right < left:\n                backtrack(s+')', left, right+1)\n\n        result = []\n        backtrack()\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.generateParenthesis(3))"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        patches = 0\n        current_sum = 0\n        i = 0\n\n        while current_sum < n:\n            if i < len(nums) and nums[i] <= current_sum + 1:\n                current_sum += nums[i]\n                i += 1\n            else:\n                current_sum += current_sum + 1\n                patches += 1\n\n        return patches\n\n# Example usage:\n# sol = Solution()\n# print(sol.minPatches([1,3], 6))  # Output: 1\n# print(sol.minPatches([1,5,10], 20))  # Output: 2\n# print(sol.minPatches([1,2,2], 5))  # Output: 0"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        stack = [-1]\n        max_length = 0\n\n        for i in range(len(s)):\n            if s[i] == '(':  # Push the index onto the stack\n                stack.append(i)\n            else:  # ')' encountered\n                stack.pop()  # Pop the last '(' index\n                if not stack:\n                    stack.append(i)  # No matching '(', so push current index\n                else:\n                    # Compute the length of the current valid substring\n                    max_length = max(max_length, i - stack[-1])\n\n        return max_length\n\n# Example usage:\n# sol = Solution()\n# print(sol.longestValidParentheses(\"(()\"))  # Output: 2\n# print(sol.longestValidParentheses(\")()())\"))  # Output: 4\n# print(sol.longestValidParentheses(\"\"))  # Output: 0"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n\n        sign = '-' if numerator * denominator < 0 else ''\n        numerator, denominator = abs(numerator), abs(denominator)\n\n        integer_part = numerator // denominator\n        fractional_part = numerator % denominator\n\n        result = [sign + str(integer_part), '.']\n        seen = {}\n\n        while fractional_part not in seen:\n            seen[fractional_part] = len(result)\n            numerator = fractional_part * 10\n            result.append(str(numerator // denominator))\n            fractional_part = numerator % denominator\n            if fractional_part == 0:\n                return ''.join(result)\n\n        result.insert(seen[fractional_part], '(')\n        result.append(')')\n        return ''.join(result)\n\n# Example usage:\n# sol = Solution()\n# print(sol.fractionToDecimal(1, 2))  # Output: '0.5'\n# print(sol.fractionToDecimal(2, 1))  # Output: '2'\n# print(sol.fractionToDecimal(4, 333))  # Output: '0.(012)'"}], "sort-list": [{"task_id": "sort-list", "completion": "# Merge two sorted lists and return the head of the sorted list\n        def merge(l1, l2):\n            dummy = ListNode(0)\n            tail = dummy\n            while l1 and l2:\n                if l1.val < l2.val:\n                    tail.next = l1\n                    l1 = l1.next\n                else:\n                    tail.next = l2\n                    l2 = l2.next\n                tail = tail.next\n            tail.next = l1 or l2\n            return dummy.next\n\n        # Split the list into two halves and return the heads of the two halves\n        def split(head):\n            slow, fast = head, head.next\n            while fast and fast.next:\n                slow = slow.next\n                fast = fast.next.next\n            mid = slow.next\n            slow.next = None\n            return head, mid\n\n        # Main function to sort the linked list\n        if not head or not head.next:\n            return head\n        left, right = split(head)\n        left = self.sortList(left)\n        right = self.sortList(right)\n        return merge(left, right)"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "import bisect\n\nclass Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Sort the envelopes by width and then by height in descending order\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n\n        def lis(sequence):\n            tails = []\n            for s in sequence:\n                # Find the index of the smallest tail that is greater than or equal to s\n                index = bisect.bisect_left(tails, s)\n                if index == len(tails):\n                    # If s is larger than any tail, append it to the tails list\n                    tails.append(s)\n                else:\n                    # Otherwise, replace the existing tail with s\n                    tails[index] = s\n            return len(tails)\n\n        # Extract the heights of the envelopes\n        heights = [h for _, h in envelopes]\n        # Find the length of the longest increasing subsequence of heights\n        return lis(heights)\n\n# Example usage:\n# envelopes = [[5,4],[6,4],[6,7],[2,3]]\n# sol = Solution()\n# print(sol.maxEnvelopes(envelopes))  # Output: 3"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # First, determine if the first row and first column need to be zeroed\n        first_row_has_zero = any(matrix[0][j] == 0 for j in range(len(matrix[0])))\n        first_col_has_zero = any(matrix[i][0] == 0 for i in range(len(matrix)))\n\n        # Use the first row and first column to mark zero rows and columns\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n\n        # Zero out cells based on marks in the first row and first column\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        # Zero out the first column if needed\n        if first_col_has_zero:\n            for i in range(len(matrix)):\n                matrix[i][0] = 0\n\n        # Zero out the first row if needed\n        if first_row_has_zero:\n            for j in range(len(matrix[0])):\n                matrix[0][j] = 0\n\n# Example usage:\n# matrix = [[1,1,1],[1,0,1],[1,1,1]]\n# Solution().setZeroes(matrix)\n# print(matrix)  # Output: [[1,0,1],[0,0,0],[1,0,1]]\n\n# matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n# Solution().setZeroes(matrix)\n# print(matrix)  # Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Initialize two pointers, both starting at the head of the list\n        first = second = head\n        \n        # Move the first pointer n steps ahead\n        for _ in range(n):\n            first = first.next\n        \n        # If first is None, we need to remove the head of the list\n        if not first:\n            return head.next\n        \n        # Move both pointers until the first one reaches the end\n        # Second pointer will then point to the node before the one we want to remove\n        while first.next:\n            first = first.next\n            second = second.next\n        \n        # Remove the nth node from the end\n        # by skipping it in the list\n        second.next = second.next.next\n        \n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        # Convert both lists to sets to remove duplicates\n        set_nums1 = set(nums1)\n        set_nums2 = set(nums2)\n\n        # Find the intersection of the two sets\n        result_set = set_nums1.intersection(set_nums2)\n\n        # Convert the set back to a list\n        result = list(result_set)\n\n        return result"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        total_dresses = sum(machines)\n        n = len(machines)\n\n        if total_dresses % n != 0:\n            return -1\n\n        target = total_dresses // n\n        max_moves = 0\n        current_balance = 0\n\n        for dresses in machines:\n            current_balance += dresses - target\n            max_moves = max(max_moves, abs(current_balance), dresses - target)\n\n        return max_moves\n\n# Example usage:\n# sol = Solution()\n# print(sol.findMinMoves([1,0,5]))  # Output: 3\n# print(sol.findMinMoves([0,3,0]))  # Output: 2\n# print(sol.findMinMoves([0,2,0]))  # Output: -1"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        def count_less_equal(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(x // i, n)\n            return count\n\n        left, right = 1, m * n\n        while left < right:\n            mid = (left + right) // 2\n            if count_less_equal(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n# Example usage:\n# sol = Solution()\n# print(sol.findKthNumber(3, 3, 5))  # Output: 3\n# print(sol.findKthNumber(2, 3, 6))  # Output: 6"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "import json\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def findMiddle(self, head):\n        prev_ptr = None\n        slow_ptr = head\n        fast_ptr = head\n\n        while fast_ptr and fast_ptr.next:\n            prev_ptr = slow_ptr\n            slow_ptr = slow_ptr.next\n            fast_ptr = fast_ptr.next.next\n\n        if prev_ptr:\n            prev_ptr.next = None\n\n        return slow_ptr\n\n    def sortedListToBST(self, head):\n        if not head:\n            return None\n\n        mid = self.findMiddle(head)\n\n        node = TreeNode(mid.val)\n\n        if head == mid:\n            return node\n\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(mid.next)\n\n        return node\n\n# Example usage:\n# Convert the given sorted linked list to a list for easier processing\nlinked_list_values = [-10, -3, 0, 5, 9]\nhead = ListNode(0)\ncurrent = head\nfor value in linked_list_values:\n    current.next = ListNode(value)\n    current = current.next\nhead = head.next\n\n# Create a Solution object and use the method to convert\nsol = Solution()\nbst_root = sol.sortedListToBST(head)\n\n# Function to serialize the tree into a list\ndef serialize(root):\n    if not root:\n        return []\n    result = []\n    nodes = [root]\n    while any(nodes):\n        node = nodes.pop(0)\n        if node:\n            result.append(node.val)\n            nodes.append(node.left)\n            nodes.append(node.right)\n        else:\n            result.append(None)\n    # Remove trailing None values\n    while result and result[-1] is None:\n        result.pop()\n    return result\n\n# Serialize the BST to a list\nbst_list = serialize(bst_root)\n\n# Output the result in JSON format\nprint(json.dumps({'output': bst_list}))"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Initialize a dummy node to act as the start of the merged list\n        dummy = ListNode(-1)\n        current = dummy\n\n        # Traverse both lists and append the smaller value to the merged list\n        while list1 and list2:\n            if list1.val < list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        # If one of the lists reaches the end, append the other list\n        if list1:\n            current.next = list1\n        elif list2:\n            current.next = list2\n\n        # Return the head of the merged list\n        return dummy.next"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def largestRectangleArea(heights):\n            stack = [-1]\n            max_area = 0\n            for i, h in enumerate(heights):\n                while stack[-1] != -1 and heights[stack[-1]] > h:\n                    height = heights[stack.pop()]\n                    width = i - stack[-1] - 1\n                    max_area = max(max_area, height * width)\n                stack.append(i)\n            while stack[-1] != -1:\n                height = heights[stack.pop()]\n                width = len(heights) - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            return max_area\n\n        if not matrix:\n            return 0\n\n        max_rectangle = 0\n        dp = [0] * len(matrix[0])\n        for row in matrix:\n            for i in range(len(row)):\n                dp[i] = dp[i] + 1 if row[i] == '1' else 0\n            max_rectangle = max(max_rectangle, largestRectangleArea(dp))\n        return max_rectangle\n\n# Example usage:\n# sol = Solution()\n# print(sol.maximalRectangle([['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']]))\n# Output: 6"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(start, end, path):\n            result.append(path)\n            for i in range(start, end):\n                backtrack(i + 1, end, path + [nums[i]])\n        \n        result = []\n        backtrack(0, len(nums), [])\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.subsets([1,2,3]))\n# print(sol.subsets([0]))"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:  # nums[mid] == nums[right]\n                right -= 1\n        return nums[left]\n\n# Example usage:\n# sol = Solution()\n# print(sol.findMin([2,2,2,0,1]))  # Output: 0"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        # Helper function to check if a substring is a valid integer\n        def isInteger(s):\n            if not s:\n                return False\n            if s[0] in ['+', '-']:\n                s = s[1:]\n            return s.isdigit()\n\n        # Helper function to check if a substring is a valid decimal\n        def isDecimal(s):\n            if not s:\n                return False\n            if s[0] in ['+', '-']:\n                s = s[1:]\n            if '.' not in s:\n                return s.isdigit()\n            integerPart, _, decimalPart = s.partition('.')\n            if integerPart and not integerPart.isdigit():\n                return False\n            if decimalPart and not decimalPart.isdigit():\n                return False\n            return integerPart.isdigit() or decimalPart.isdigit()\n\n        # Check for scientific notation\n        if 'e' in s or 'E' in s:\n            base, _, exponent = s.partition('e' if 'e' in s else 'E')\n            return (isInteger(exponent) and (isInteger(base) or isDecimal(base)))\n        else:\n            return isInteger(s) or isDecimal(s)\n\n# Example usage:\n# sol = Solution()\n# print(sol.isNumber(\"0\"))  # Output: true\n# print(sol.isNumber(\"e\"))  # Output: false\n# print(sol.isNumber(\".\"))  # Output: false"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        # Define the mapping of Roman numerals to their integer values\n        val_map = [\n            (1000, 'M'),\n            (900, 'CM'),\n            (500, 'D'),\n            (400, 'CD'),\n            (100, 'C'),\n            (90, 'XC'),\n            (50, 'L'),\n            (40, 'XL'),\n            (10, 'X'),\n            (9, 'IX'),\n            (5, 'V'),\n            (4, 'IV'),\n            (1, 'I')\n        ]\n\n        # Initialize the result string\n        roman_numeral = ''\n\n        # Convert the integer to Roman numeral\n        for value, symbol in val_map:\n            while num >= value:\n                roman_numeral += symbol\n                num -= value\n\n        return roman_numeral\n\n# Example usage:\n# sol = Solution()\n# print(sol.intToRoman(3))  # Output: 'III'\n# print(sol.intToRoman(58)) # Output: 'LVIII'\n# print(sol.intToRoman(1994)) # Output: 'MCMXCIV'"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        # Initialize a variable to store the sum of ASCII values\n        sum_s, sum_t = 0, 0\n\n        # Sum the ASCII values of all characters in s\n        for char in s:\n            sum_s += ord(char)\n\n        # Sum the ASCII values of all characters in t\n        for char in t:\n            sum_t += ord(char)\n\n        # The difference in sums is the ASCII value of the added character\n        return chr(sum_t - sum_s)"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        def is_valid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num or board[i][col] == num:\n                    return False\n            startRow, startCol = 3 * (row // 3), 3 * (col // 3)\n            for i in range(3):\n                for j in range(3):\n                    if board[startRow + i][startCol + j] == num:\n                        return False\n            return True\n\n        def solve(board):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        for num in '123456789':\n                            if is_valid(board, row, col, num):\n                                board[row][col] = num\n                                if solve(board):\n                                    return True\n                                board[row][col] = '.'\n                        return False\n            return True\n\n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "import sys\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        # Initialize variables to keep track of the nodes to be swapped\n        first_element = None\n        second_element = None\n        prev_element = TreeNode(-sys.maxsize)\n\n        # Helper function to perform in-order traversal\n        def in_order_traversal(node):\n            nonlocal first_element, second_element, prev_element\n            if not node:\n                return\n\n            # Traverse the left subtree\n            in_order_traversal(node.left)\n\n            # Start of the main logic to find the two nodes\n            if first_element is None and prev_element.val >= node.val:\n                first_element = prev_element\n            if first_element is not None and prev_element.val >= node.val:\n                second_element = node\n            prev_element = node\n\n            # Traverse the right subtree\n            in_order_traversal(node.right)\n\n        # Call the in-order traversal helper function\n        in_order_traversal(root)\n\n        # Swap the values of the two nodes\n        first_element.val, second_element.val = second_element.val, first_element.val\n\n# Example usage:\n# sol = Solution()\n# root = TreeNode(1, TreeNode(3, None, TreeNode(2)), None)\n# sol.recoverTree(root)\n# The tree is now recovered to a valid BST."}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Helper function to reverse the linked list\n        def reverseList(head):\n            prev = None\n            current = head\n            while current:\n                next_temp = current.next\n                current.next = prev\n                prev = current\n                current = next_temp\n            return prev\n\n        # Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Reverse the second half of the linked list\n        slow = reverseList(slow)\n        fast = head\n\n        # Compare the first and second half nodes\n        while slow:\n            if slow.val != fast.val:\n                return False\n            slow = slow.next\n            fast = fast.next\n\n        # If we reach here, then the linked list is a palindrome\n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        left, right = 1, num\n        while left \\<= right:\n            mid = left + (right - left) // 2\n            square = mid * mid\n            if square == num:\n                return True\n            elif square \\< num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.isPerfectSquare(16))  # Output: true\n# print(sol.isPerfectSquare(14))  # Output: false"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Initialize a dummy node which will help us easily handle edge cases such as when we need to delete the head node\n        dummy = ListNode(-1)\n        dummy.next = head\n        \n        # Initialize current pointer to start from the dummy node\n        current = dummy\n        \n        # Iterate through the list\n        while current.next:\n            # If the next node's value is the one we need to remove\n            if current.next.val == val:\n                # Skip the node to remove it\n                current.next = current.next.next\n            else:\n                # Move to the next node\n                current = current.next\n        \n        # Return the new head of the list, which is the next node of dummy\n        return dummy.next"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \n        # Base case: If both strings are equal, return True\n        if s1 == s2:\n            return True\n        \n        # If the sorted characters of both strings are not the same, they can't be scrambled\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        for i in range(1, n):\n            # Check if the current split leads to a scrambled string\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\n               (self.isScramble(s1[:i], s2[n-i:]) and self.isScramble(s1[i:], s2[:n-i])):\n                return True\n        \n        # If no split leads to a scrambled string, return False\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.isScramble('great', 'rgeat'))  # Output: true\n# print(sol.isScramble('abcde', 'caebd'))  # Output: false\n# print(sol.isScramble('a', 'a'))          # Output: true"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        # Split the path by '/' and initialize a stack\n        parts = path.split('/')\n        stack = []\n\n        # Process each part of the path\n        for part in parts:\n            if part == '..':\n                if stack:\n                    stack.pop()\n            elif part and part != '.':\n                stack.append(part)\n\n        # Join the stack to form the simplified path\n        return '/' + '/'.join(stack)\n\n# Example usage:\n# sol = Solution()\n# print(sol.simplifyPath('/home/'))  # Output: '/home'\n# print(sol.simplifyPath('/../'))    # Output: '/'\n# print(sol.simplifyPath('/home//foo/'))  # Output: '/home/foo'"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        def backtrack(i, j, node, path):\n            if '#' in node:\n                result.add(node['#'])\n            letter = board[i][j]\n            board[i][j] = '@'\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= x < m and 0 <= y < n and board[x][y] in node:\n                    backtrack(x, y, node[board[x][y]], path + board[x][y])\n            board[i][j] = letter\n        \n        def buildTrie():\n            root = {}\n            for word in words:\n                node = root\n                for letter in word:\n                    if letter not in node:\n                        node[letter] = {}\n                    node = node[letter]\n                node['#'] = word\n            return root\n        \n        result = set()\n        trie = buildTrie()\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie:\n                    backtrack(i, j, trie[board[i][j]], board[i][j])\n        return list(result)"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        # If the lengths of the strings are not equal, they cannot be anagrams\n        if len(s) != len(t):\n            return False\n\n        # Create a dictionary to count the frequency of each letter in s\n        count = {}\n        for char in s:\n            count[char] = count.get(char, 0) + 1\n\n        # Decrease the count for each letter in t\n        for char in t:\n            if char not in count or count[char] == 0:\n                return False\n            count[char] -= 1\n\n        # If all counts are zero, then t is an anagram of s\n        return all(value == 0 for value in count.values())\n\n# Example usage:\n# sol = Solution()\n# print(sol.isAnagram(\"anagram\", \"nagaram\"))  # Output: true\n# print(sol.isAnagram(\"rat\", \"car\"))        # Output: false"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "# Initialize data structures to hold the state of rows, columns, and boxes\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        # Iterate over each cell in the board\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != '.':\n                    # Calculate box index\n                    box_index = (i // 3) * 3 + j // 3\n\n                    # Check if the number is already in the current row, column, or box\n                    if num in rows[i] or num in cols[j] or num in boxes[box_index]:\n                        return False\n\n                    # Add the number to the current row, column, and box\n                    rows[i].add(num)\n                    cols[j].add(num)\n                    boxes[box_index].add(num)\n\n        # If no duplicates are found, the board is valid\n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        answer = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                answer.append('FizzBuzz')\n            elif i % 3 == 0:\n                answer.append('Fizz')\n            elif i % 5 == 0:\n                answer.append('Buzz')\n            else:\n                answer.append(str(i))\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # Split the string into words\n        words = s.split()\n        # Reverse the list of words\n        words.reverse()\n        # Join the words using a single space\n        reversed_s = ' '.join(words)\n        return reversed_s\n\n# Example usage:\n# sol = Solution()\n# print(sol.reverseWords(\"the sky is blue\"))  # Output: \"blue is sky the\"\n# print(sol.reverseWords(\"  hello world  \"))  # Output: \"world hello\"\n# print(sol.reverseWords(\"a good   example\"))  # Output: \"example good a\""}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        result = 0\n        for char in columnTitle:\n            result = result * 26 + (ord(char) - ord('A') + 1)\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.titleToNumber('A'))  # Output: 1\n# print(sol.titleToNumber('AB')) # Output: 28\n# print(sol.titleToNumber('ZY')) # Output: 701"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(ratings)\n        if n == 0:\n            return 0\n\n        candies = [1] * n\n\n        # Left to right pass\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Right to left pass\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        # Sum up the candies\n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# If both nodes are None, trees are structurally identical here\n        if not p and not q:\n            return True\n\n        # If one of the nodes is None, trees are not identical\n        if not p or not q:\n            return False\n\n        # If the value of nodes are different, trees are not identical\n        if p.val != q.val:\n            return False\n\n        # Recursively check the left subtree and the right subtree\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Helper function to reverse a linked list\n        def reverseList(head):\n            prev = None\n            current = head\n            while current:\n                next_temp = current.next\n                current.next = prev\n                prev = current\n                current = next_temp\n            return prev\n\n        # Helper function to merge two lists\n        def mergeLists(l1, l2):\n            while l1 and l2:\n                l1_next = l1.next\n                l2_next = l2.next\n\n                l1.next = l2\n                if l1_next is None:\n                    break\n                l2.next = l1_next\n\n                l1 = l1_next\n                l2 = l2_next\n\n        # Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Reverse the second half of the list\n        second_half = reverseList(slow.next)\n        slow.next = None\n\n        # Merge the two halves\n        mergeLists(head, second_half)"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        char_to_word = {}\n        word_to_char = {}\n        for c, w in zip(pattern, words):\n            if c not in char_to_word and w not in word_to_char:\n                char_to_word[c] = w\n                word_to_char[w] = c\n            elif char_to_word.get(c) != w or word_to_char.get(w) != c:\n                return False\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        def backtrack(first=0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output\n\n# Example usage:\n# sol = Solution()\n# print(sol.permute([1,2,3]))"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        if not matrix or not matrix[0]:\n            return False\n\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n            mid_value = matrix[mid // n][mid % n]\n\n            if mid_value == target:\n                return True\n            elif mid_value < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Initialize current node to dummy head of the returning list.\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        # Loop through lists l1 and l2 until you reach both ends.\n        while l1 is not None or l2 is not None:\n            # At the start of each iteration, we should add carry from last iteration.\n            x = l1.val if l1 is not None else 0\n            y = l2.val if l2 is not None else 0\n            sum = carry + x + y\n\n            # Update carry for next iteration.\n            carry = sum // 10\n\n            # Create a new node with the digit value of (sum mod 10) and set it to current node's next,\n            # then advance current node to next.\n            current.next = ListNode(sum % 10)\n            current = current.next\n\n            # Advance both l1 and l2.\n            if l1 is not None:\n                l1 = l1.next\n            if l2 is not None:\n                l2 = l2.next\n\n        # After the final iteration, we should check if there is a remaining carry and add it if so.\n        if carry > 0:\n            current.next = ListNode(carry)\n\n        # The dummy head's next node is the beginning of the reversed result list.\n        return dummy_head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        # Convert the number to binary and remove the '0b' prefix\n        binary_num = bin(num)[2:]\n\n        # Flip the bits in the binary representation\n        complement_bits = ''.join('1' if x == '0' else '0' for x in binary_num)\n\n        # Convert the binary string back to an integer\n        complement = int(complement_bits, 2)\n\n        return complement"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        from collections import defaultdict\n        n = len(nums)\n        if n < 3:\n            return 0\n\n        dp = [defaultdict(int) for _ in range(n)]\n        count = 0\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                dp[i][diff] += 1\n                if diff in dp[j]:\n                    dp[i][diff] += dp[j][diff]\n                    count += dp[j][diff]\n        return count\n\n# Example usage:\n# sol = Solution()\n# print(sol.numberOfArithmeticSlices([2,4,6,8,10]))  # Output: 7\n# print(sol.numberOfArithmeticSlices([7,7,7,7,7]))  # Output: 16"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        def justify_line(line, width, is_last=False):\n            if is_last or len(line) == 1:\n                return ' '.join(line).ljust(width)\n            total_spaces = width - sum(len(word) for word in line)\n            space_slots = len(line) - 1\n            even_space = total_spaces // space_slots\n            extra_space = total_spaces % space_slots\n            for i in range(extra_space):\n                line[i] += ' '\n            return (' ' * even_space).join(line)\n\n        result, current_line, current_length = [], [], 0\n        for word in words:\n            if current_length + len(word) + len(current_line) > maxWidth:\n                result.append(justify_line(current_line, maxWidth))\n                current_line, current_length = [], 0\n            current_line.append(word)\n            current_length += len(word)\n        result.append(justify_line(current_line, maxWidth, is_last=True))\n        return result\n\n# Example usage:\n# sol = Solution()\n# output = sol.fullJustify([\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], 16)\n# print(output)"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Initialize an empty list to store the postorder traversal\n        postorder = []\n\n        # Check if the tree is empty\n        if not root:\n            return postorder\n\n        # Initialize a stack to store the nodes\n        stack = []\n        current = root\n\n        # Iterate until the stack is empty\n        while stack or current:\n            # Reach the leftmost node of the current node\n            while current:\n                stack.append(current)\n                current = current.left if current.left else current.right\n\n            # Process the nodes from the stack\n            node = stack.pop()\n            postorder.append(node.val)\n\n            # If the stack is not empty and the current node is the left child of the top node in the stack\n            if stack and stack[-1].left == node:\n                current = stack[-1].right\n            else:\n                current = None\n\n        return postorder"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        left = 0\n        right = len(height) - 1\n        max_area = 0\n\n        while left < right:\n            width = right - left\n            current_area = min(height[left], height[right]) * width\n            max_area = max(max_area, current_area)\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxArea([1,8,6,2,5,4,8,3,7]))  # Output: 49\n# print(sol.maxArea([1,1]))  # Output: 1"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        def canForm(word, wordSet):\n            if word in wordSet:\n                return True\n            for i in range(1, len(word)):\n                prefix, suffix = word[:i], word[i:]\n                if prefix in wordSet and canForm(suffix, wordSet):\n                    return True\n            return False\n\n        words.sort(key=len)\n        wordSet = set()\n        result = []\n        for word in words:\n            if canForm(word, wordSet):\n                result.append(word)\n            wordSet.add(word)\n        return result\n\n# Example usage:\nsol = Solution()\nexample1 = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\nexample2 = [\"cat\",\"dog\",\"catdog\"]\nprint(sol.findAllConcatenatedWordsInADict(example1))\nprint(sol.findAllConcatenatedWordsInADict(example2))"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return '0'\n        negative = num < 0\n        num = abs(num)\n        base7 = ''\n        while num > 0:\n            base7 = str(num % 7) + base7\n            num //= 7\n        if negative:\n            base7 = '-' + base7\n        return base7"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        # The key observation is that if the number of stones is a multiple of 4,\n        # the player who starts will always lose if the opponent plays optimally.\n        # This is because no matter how many stones the first player takes (1, 2, or 3),\n        # the second player can always take enough stones to make the total number\n        # of stones taken by both players a multiple of 4.\n        # Therefore, the strategy for the second player is to always take\n        # (4 - x) stones where x is the number of stones the first player took.\n        # When the number of stones left is 4, the first player will have no choice\n        # but to take the last stone on their turn.\n        \n        # If the initial number of stones is not a multiple of 4,\n        # the first player can always ensure that the number of stones left\n        # after their first turn is a multiple of 4, putting the second player\n        # in the losing position.\n        \n        # Therefore, the first player wins if and only if n % 4 != 0.\n        return n % 4 != 0\n\n# Example usage:\n# sol = Solution()\n# print(sol.canWinNim(4))  # Output: false\n# print(sol.canWinNim(1))  # Output: true\n# print(sol.canWinNim(2))  # Output: true"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        def is_not_under_attack(row, col):\n            for prev_row in range(row):\n                if board[prev_row] == col or \n                   board[prev_row] - prev_row == col - row or \n                   board[prev_row] + prev_row == col + row:\n                    return False\n            return True\n\n        def place_queen(row):\n            if row == n:\n                nonlocal count\n                count += 1\n                return\n            for col in range(n):\n                if is_not_under_attack(row, col):\n                    board[row] = col\n                    place_queen(row + 1)\n                    board[row] = -1\n\n        count = 0\n        board = [-1] * n\n        place_queen(0)\n        return count\n\n# Example usage:\n# sol = Solution()\n# print(sol.totalNQueens(4))  # Output: 2\n# print(sol.totalNQueens(1))  # Output: 1"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        def is_not_under_attack(row, col):\n            for prev_row in range(row):\n                if board[prev_row] == col or \n                   board[prev_row] - prev_row == col - row or \n                   board[prev_row] + prev_row == col + row:\n                    return False\n            return True\n\n        def place_queen(row, col):\n            board[row] = col\n\n        def remove_queen(row, col):\n            board[row] = -1\n\n        def add_solution():\n            solution = []\n            for i in range(n):\n                row = ['.'] * n\n                row[board[i]] = 'Q'\n                solution.append(''.join(row))\n            result.append(solution)\n\n        def backtrack(row = 0):\n            for col in range(n):\n                if is_not_under_attack(row, col):\n                    place_queen(row, col)\n                    if row + 1 == n:\n                        add_solution()\n                    else:\n                        backtrack(row + 1)\n                    remove_queen(row, col)\n\n        result = []\n        board = [-1] * n\n        backtrack()\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.solveNQueens(4))"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        def dfs(i, j, k):\n            if not (0 <= i < len(board)) or not (0 <= j < len(board[0])) or board[i][j] != word[k]:\n                return False\n            if k == len(word) - 1:\n                return True\n            tmp, board[i][j] = board[i][j], '/'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = tmp\n            return res\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCCED'))  # Output: true\n# print(sol.exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'SEE'))  # Output: true\n# print(sol.exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCB'))  # Output: false"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        # Initialize two pointers for nums1 and nums2 respectively\n        p1, p2 = m - 1, n - 1\n        # Pointer for the last element in the merged array\n        p = m + n - 1\n\n        # Merge in reverse order\n        while p1 >= 0 and p2 >= 0:\n            if nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n\n        # If there are remaining elements in nums2, add them\n        nums1[:p2 + 1] = nums2[:p2 + 1]\n\n# Example usage:\n# sol = Solution()\n# nums1 = [1,2,3,0,0,0]\n# m = 3\n# nums2 = [2,5,6]\n# n = 3\n# sol.merge(nums1, m, nums2, n)\n# print(nums1)  # Output: [1,2,2,3,5,6]"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # Initialize three variables to store the maximums\n        first_max = second_max = third_max = float('-inf')\n        for num in nums:\n            if num > first_max:\n                third_max = second_max\n                second_max = first_max\n                first_max = num\n            elif first_max > num > second_max:\n                third_max = second_max\n                second_max = num\n            elif second_max > num > third_max:\n                third_max = num\n        # If the third maximum does not exist, return the maximum number\n        return first_max if third_max == float('-inf') else third_max\n\n# Example usage:\n# sol = Solution()\n# print(sol.thirdMax([3,2,1]))  # Output: 1\n# print(sol.thirdMax([1,2]))    # Output: 2\n# print(sol.thirdMax([2,2,3,1])) # Output: 1"}]}