{
    "spiral-matrix": [
        {
            "slug_name": "spiral-matrix",
            "result": {
                "result": "passed",
                "runtime": 0.0003330707550048828,
                "index": 0
            },
            "solution": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        while matrix:\n            result += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    result.append(row.pop())\n            if matrix:\n                result += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    result.append(row.pop(0))\n        return result",
            "runtimes": [
                0.0002751350402832031,
                0.00027871131896972656,
                0.0002849102020263672,
                0.00031375885009765625,
                0.000316619873046875,
                0.00032067298889160156,
                0.00032210350036621094,
                0.0003237724304199219,
                0.0003566741943359375,
                0.00035953521728515625,
                0.0003809928894042969,
                0.0003914833068847656,
                0.00040793418884277344,
                0.0004515647888183594
            ],
            "beyond_p": 0.6716216216216216
        }
    ],
    "summary-ranges": [
        {
            "slug_name": "summary-ranges",
            "result": {
                "result": "passed",
                "runtime": 0.0004017353057861328,
                "index": 0
            },
            "solution": "class Solution(object):\n    def summaryRanges(self, nums):\n        ranges = []\n        if not nums:\n            return ranges\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1] + 1:\n                if start == nums[i - 1]:\n                    ranges.append(str(start))\n                else:\n                    ranges.append(str(start) + '->' + str(nums[i - 1]))\n                start = nums[i]\n        if start == nums[-1]:\n            ranges.append(str(start))\n        else:\n            ranges.append(str(start) + '->' + str(nums[-1]))\n        return ranges\n\n# Example usage:\n# sol = Solution()\n# print(sol.summaryRanges([0,1,2,4,5,7]))\n# Output: ['0->2','4->5','7']\n# print(sol.summaryRanges([0,2,3,4,6,8,9]))\n# Output: ['0','2->4','6','8->9']",
            "runtimes": [
                0.0002803802490234375,
                0.00029778480529785156,
                0.00030612945556640625,
                0.0003211498260498047,
                0.0003216266632080078,
                0.0003235340118408203,
                0.00033020973205566406,
                0.00033020973205566406,
                0.0003325939178466797,
                0.0003407001495361328,
                0.0003476142883300781,
                0.0004200935363769531,
                0.0004253387451171875,
                0.0005059242248535156,
                0.012386322021484375
            ],
            "beyond_p": 0.9899755790137073
        }
    ],
    "distinct-subsequences": [
        {
            "slug_name": "distinct-subsequences",
            "result": {
                "result": "passed",
                "runtime": 0.11252808570861816,
                "index": 0
            },
            "solution": "class Solution(object):\n    def numDistinct(self, s, t):\n        # Create a 2D DP array with dimensions (len(t) + 1) x (len(s) + 1)\n        dp = [[0] * (len(s) + 1) for _ in range(len(t) + 1)]\n\n        # Initialize the first row to 1 because an empty t can be formed by any prefix of s\n        for j in range(len(s) + 1):\n            dp[0][j] = 1\n\n        # Fill the DP table\n        for i in range(1, len(t) + 1):\n            for j in range(1, len(s) + 1):\n                # If the characters match, add the number of ways without the current character\n                # in both s and t, to the number of ways without the current character in s\n                if t[i - 1] == s[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]\n                else:\n                    # If the characters don't match, the number of ways is the same as without\n                    # the current character in s\n                    dp[i][j] = dp[i][j - 1]\n\n        # The answer is in the bottom-right cell of the DP table\n        return dp[-1][-1]",
            "runtimes": [
                0.005184173583984375,
                0.006737709045410156,
                0.009837150573730469,
                0.009960651397705078,
                0.012686967849731445,
                0.013928413391113281,
                0.014031648635864258,
                0.016263723373413086,
                0.019391536712646484,
                0.022980213165283203,
                0.031140565872192383,
                0.032312870025634766,
                0.047193288803100586,
                0.04967904090881348,
                0.06819295883178711,
                0.0694272518157959,
                0.08350014686584473,
                0.08539795875549316,
                0.09250497817993164,
                0.09348034858703613,
                0.10883522033691406,
                0.11040711402893066,
                0.1284956932067871,
                0.1551682949066162,
                0.19527983665466309,
                0.23031949996948242,
                0.3938279151916504
            ],
            "beyond_p": 0.7237986859621248
        }
    ],
    "first-missing-positive": [
        {
            "slug_name": "first-missing-positive",
            "result": {
                "result": "passed",
                "runtime": 0.0009543895721435547,
                "index": 0
            },
            "solution": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        size = len(nums)\n        for i in range(size):\n            while 1 <= nums[i] <= size and nums[nums[i] - 1] != nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        \n        for i in range(size):\n            if nums[i] != i + 1:\n                return i + 1\n        return size + 1\n\n# Example usage:\n# sol = Solution()\n# print(sol.firstMissingPositive([1,2,0]))  # Output: 3\n# print(sol.firstMissingPositive([3,4,-1,1]))  # Output: 2\n# print(sol.firstMissingPositive([7,8,9,11,12]))  # Output: 1",
            "runtimes": [
                0.0007658004760742188,
                0.0009305477142333984,
                0.0009412765502929688,
                0.0009486675262451172,
                0.0009493827819824219,
                0.0010409355163574219,
                0.0010411739349365234,
                0.001081705093383789,
                0.0010983943939208984,
                0.0010991096496582031,
                0.0014233589172363281,
                0.0014367103576660156,
                0.0014727115631103516,
                0.0016493797302246094,
                0.0017249584197998047,
                0.0017943382263183594,
                0.0023279190063476562,
                0.002818584442138672,
                0.006886005401611328,
                0.017302513122558594
            ],
            "beyond_p": 0.9885957324106113
        }
    ],
    "permutation-sequence": [
        {
            "slug_name": "permutation-sequence",
            "result": {
                "result": "passed",
                "runtime": 0.00034332275390625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def getPermutation(self, n, k):\n        from math import factorial\n        numbers = list(range(1, n+1))\n        permutation = ''\n        k -= 1\n        while n > 0:\n            n -= 1\n            index, k = divmod(k, factorial(n))\n            permutation += str(numbers[index])\n            numbers.remove(numbers[index])\n        return permutation\n\n# Example usage:\n# sol = Solution()\n# print(sol.getPermutation(3, 3))  # Output: \"213\"\n# print(sol.getPermutation(4, 9))  # Output: \"2314\"\n# print(sol.getPermutation(3, 1))  # Output: \"123\"",
            "runtimes": [
                0.00041484832763671875,
                0.02144002914428711,
                0.026653528213500977,
                0.052785396575927734,
                0.05947756767272949,
                0.06846499443054199,
                0.08644866943359375,
                0.12376070022583008,
                0.19761967658996582,
                0.21409153938293457,
                0.3085188865661621,
                0.30959177017211914,
                0.4468419551849365,
                0.4593510627746582,
                0.4960620403289795,
                0.6057794094085693,
                0.6706676483154297,
                0.8836908340454102,
                0.889549732208252,
                1.9145543575286865
            ],
            "beyond_p": 1.0000373669596112
        }
    ],
    "two-sum-ii-input-array-is-sorted": [
        {
            "slug_name": "two-sum-ii-input-array-is-sorted",
            "result": {
                "result": "passed",
                "runtime": 0.00029015541076660156,
                "index": 0
            },
            "solution": "class Solution(object):\n    def twoSum(self, numbers, target):\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n            if current_sum == target:\n                return [left + 1, right + 1]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        return []  # This line will never be reached if there is exactly one solution",
            "runtimes": [
                0.0002865791320800781,
                0.0002868175506591797,
                0.00029659271240234375,
                0.0002970695495605469,
                0.0003008842468261719,
                0.0003082752227783203,
                0.00031638145446777344,
                0.0003216266632080078,
                0.0003268718719482422,
                0.00032806396484375,
                0.0003287792205810547,
                0.00032901763916015625,
                0.0003306865692138672,
                0.0003314018249511719,
                0.0003421306610107422,
                0.0003447532653808594,
                0.0004985332489013672,
                0.000499725341796875,
                0.000537872314453125,
                0.00193023681640625
            ],
            "beyond_p": 0.9978241949521323
        }
    ],
    "expression-add-operators": [
        {
            "slug_name": "expression-add-operators",
            "result": {
                "result": "failed@cases",
                "runtime": 1.1090891361236572,
                "index": 0
            },
            "solution": "class Solution(object):\n    def addOperators(self, num, target):\n        def backtrack(index, prev_operand, current_operand, value, string):\n            if index == len(num):\n                if value == target and current_operand == 0:\n                    results.append(\"\".join(string[1:]))\n                return\n\n            current_operand = current_operand * 10 + int(num[index])\n            str_op = str(current_operand)\n\n            if current_operand > 0:\n                backtrack(index + 1, prev_operand, current_operand, value, string)\n\n            string.append('+')\n            string.append(str_op)\n            backtrack(index + 1, current_operand, 0, value + current_operand, string)\n            string.pop()\n            string.pop()\n\n            if string:\n                string.append('-')\n                string.append(str_op)\n                backtrack(index + 1, -current_operand, 0, value - current_operand, string)\n                string.pop()\n                string.pop()\n\n                string.append('*')\n                string.append(str_op)\n                backtrack(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)\n                string.pop()\n                string.pop()\n\n        results = []\n        backtrack(0, 0, 0, 0, [])\n        return results\n\n# Example usage:\n# sol = Solution()\n# output = sol.addOperators(\"123\", 6)\n# print(output)  # Output: [\"1*2*3\",\"1+2+3\"]",
            "runtimes": [
                3.119155168533325,
                5.0105507373809814
            ],
            "beyond_p": 0.0
        }
    ],
    "sum-root-to-leaf-numbers": [
        {
            "slug_name": "sum-root-to-leaf-numbers",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "def dfs(node, current_number):\n            if not node:\n                return 0\n            current_number = current_number * 10 + node.val\n            if not node.left and not node.right:\n                return current_number\n            return dfs(node.left, current_number) + dfs(node.right, current_number)\n\n        return dfs(root, 0)",
            "runtimes": [
                0.0002980232238769531,
                0.00029921531677246094,
                0.0002994537353515625,
                0.0003039836883544922,
                0.0003097057342529297,
                0.00031113624572753906,
                0.00035119056701660156,
                0.0003592967987060547,
                0.00035953521728515625,
                0.00037217140197753906,
                0.0003826618194580078,
                0.00040459632873535156,
                0.0005011558532714844,
                0.0005288124084472656,
                0.001003265380859375,
                0.015451908111572266
            ],
            "beyond_p": 0.0
        }
    ],
    "license-key-formatting": [
        {
            "slug_name": "license-key-formatting",
            "result": {
                "result": "passed",
                "runtime": 0.0003342628479003906,
                "index": 0
            },
            "solution": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        # Remove all dashes and convert to uppercase\n        s = s.replace('-', '').upper()\n        # Find the length of the first group\n        first_group_length = len(s) % k or k\n        # Initialize the reformatted license key with the first group\n        reformatted = s[:first_group_length]\n        # Process the remaining characters in groups of size k\n        for i in range(first_group_length, len(s), k):\n            reformatted += '-' + s[i:i+k]\n        return reformatted",
            "runtimes": [
                0.0002994537353515625,
                0.00032329559326171875,
                0.00033020973205566406,
                0.0003752708435058594,
                0.0006580352783203125,
                0.0006973743438720703,
                0.0007090568542480469,
                0.0007970333099365234,
                0.00080108642578125,
                0.00080108642578125,
                0.0008242130279541016,
                0.0008358955383300781,
                0.0008897781372070312,
                0.0009088516235351562,
                0.0009565353393554688,
                0.0009686946868896484,
                0.0010578632354736328,
                0.0011060237884521484,
                0.001360177993774414,
                0.001554250717163086,
                0.001691579818725586
            ],
            "beyond_p": 0.9749957184449392
        }
    ],
    "gas-station": [
        {
            "slug_name": "gas-station",
            "result": {
                "result": "passed",
                "runtime": 0.0006482601165771484,
                "index": 0
            },
            "solution": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        total_tank, curr_tank = 0, 0\n        starting_station = 0\n        for i in range(len(gas)):\n            total_tank += gas[i] - cost[i]\n            curr_tank += gas[i] - cost[i]\n            if curr_tank < 0:\n                starting_station = i + 1\n                curr_tank = 0\n        return starting_station if total_tank >= 0 else -1\n\n# Example usage:\n# sol = Solution()\n# print(sol.canCompleteCircuit([1,2,3,4,5], [3,4,5,1,2]))  # Output: 3\n# print(sol.canCompleteCircuit([2,3,4], [3,4,3]))        # Output: -1",
            "runtimes": [
                0.0002982616424560547,
                0.0003094673156738281,
                0.0003218650817871094,
                0.0003495216369628906,
                0.00034999847412109375,
                0.0003561973571777344,
                0.00035858154296875,
                0.00036215782165527344,
                0.0003631114959716797,
                0.0004019737243652344,
                0.0005228519439697266,
                0.0005309581756591797,
                0.0005769729614257812,
                0.0005903244018554688,
                0.0006258487701416016,
                0.000637054443359375,
                0.0006458759307861328,
                0.0006475448608398438,
                0.0008387565612792969,
                0.0009181499481201172,
                0.0009350776672363281,
                0.0009663105010986328,
                0.0010395050048828125,
                0.0014688968658447266,
                0.0022499561309814453
            ],
            "beyond_p": 0.8206694356217933
        }
    ],
    "burst-balloons": [
        {
            "slug_name": "burst-balloons",
            "result": {
                "result": "passed",
                "runtime": 3.420703887939453,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        nums = [1] + nums + [1]  # Add 1 before and after the original nums\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n        # Build up from shorter subarrays to the whole array\n        for length in range(1, n + 1):\n            for left in range(1, n - length + 2):\n                right = left + length - 1\n                # Find the best last balloon to burst\n                for i in range(left, right + 1):\n                    dp[left][right] = max(dp[left][right],\n                                         dp[left][i - 1] + nums[left - 1] * nums[i] * nums[right + 1] + dp[i + 1][right])\n\n        return dp[1][n]\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxCoins([3,1,5,8]))  # Output: 167\n# print(sol.maxCoins([1,5]))      # Output: 10",
            "runtimes": [
                0.8701143264770508,
                1.112614393234253,
                1.1296072006225586,
                1.6741242408752441,
                1.8297431468963623,
                2.4092302322387695,
                2.526853322982788,
                2.595304250717163,
                2.8477625846862793,
                3.8008103370666504,
                3.862647771835327,
                4.103488922119141,
                4.424175977706909,
                4.448257684707642,
                4.761566877365112,
                4.763156890869141,
                5.121384620666504,
                5.132631540298462,
                5.14789080619812,
                5.23296046257019,
                5.450868606567383,
                5.657240867614746,
                5.846303462982178,
                6.071931838989258,
                6.197021961212158,
                6.452938795089722
            ],
            "beyond_p": 0.5431363504616468
        }
    ],
    "plus-one": [
        {
            "slug_name": "plus-one",
            "result": {
                "result": "passed",
                "runtime": 0.0003077983856201172,
                "index": 0
            },
            "solution": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        carry = 1\n        for i in range(len(digits) - 1, -1, -1):\n            digits[i] += carry\n            if digits[i] == 10:\n                digits[i] = 0\n                carry = 1\n            else:\n                carry = 0\n                break\n        if carry:\n            digits.insert(0, 1)\n        return digits",
            "runtimes": [
                0.0002665519714355469,
                0.0002944469451904297,
                0.00030231475830078125,
                0.00030541419982910156,
                0.00031113624572753906,
                0.00031280517578125,
                0.0003917217254638672,
                0.0003921985626220703,
                0.0004239082336425781,
                0.00042438507080078125,
                0.0004296302795410156,
                0.000431060791015625,
                0.0004379749298095703,
                0.0005292892456054688
            ],
            "beyond_p": 0.8430127041742287
        }
    ],
    "regular-expression-matching": [
        {
            "slug_name": "regular-expression-matching",
            "result": {
                "result": "passed",
                "runtime": 0.00031828880310058594,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isMatch(self, s, p):\n        # Base case: if the pattern is empty, return True if the string is also empty\n        if not p:\n            return not s\n\n        # Check if the first character of the string matches the first character of the pattern\n        first_match = bool(s) and p[0] in {s[0], '.'}\n\n        # If the pattern has a '*', it can either match zero characters or at least one character\n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])\n\n# Example usage:\n# sol = Solution()\n# print(sol.isMatch(\"aa\", \"a\"))  # Output: false\n# print(sol.isMatch(\"aa\", \"a*\")) # Output: true\n# print(sol.isMatch(\"ab\", \".*\")) # Output: true",
            "runtimes": [
                0.0003192424774169922,
                0.0003216266632080078,
                0.0003237724304199219,
                0.0003249645233154297,
                0.00032901763916015625,
                0.0003345012664794922,
                0.00039005279541015625,
                0.0004143714904785156,
                0.0004532337188720703,
                0.0008630752563476562,
                0.0008630752563476562,
                0.0009086132049560547,
                0.0010046958923339844,
                0.001302957534790039,
                0.005100727081298828,
                0.019942760467529297
            ],
            "beyond_p": 1.000048598539614
        }
    ],
    "create-maximum-number": [
        {
            "slug_name": "create-maximum-number",
            "result": {
                "result": "passed",
                "runtime": 0.0005009174346923828,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        def pick_max(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n\n        def merge(nums1, nums2):\n            return [max(nums1, nums2).pop(0) for _ in range(len(nums1) + len(nums2))]\n\n        max_combo = []\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n            temp = merge(pick_max(nums1, i), pick_max(nums2, k - i))\n            max_combo = max(max_combo, temp)\n        return max_combo\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxNumber([3,4,6,5], [9,1,2,5,8,3], 5))\n# Output: [9,8,6,5,3]",
            "runtimes": [
                0.0004372596740722656,
                0.0004611015319824219,
                0.0004680156707763672,
                0.00048804283142089844,
                0.0004978179931640625,
                0.0005028247833251953,
                0.0005040168762207031,
                0.0005276203155517578,
                0.0005540847778320312,
                0.0007507801055908203,
                0.0007770061492919922,
                0.0007920265197753906,
                0.012731313705444336,
                0.02464461326599121
            ],
            "beyond_p": 0.9973703131001743
        }
    ],
    "perfect-number": [
        {
            "slug_name": "perfect-number",
            "result": {
                "result": "passed",
                "runtime": 0.008249044418334961,
                "index": 0
            },
            "solution": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num <= 1:\n            return False\n        \n        divisors_sum = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors_sum += i\n                if i != num // i:\n                    divisors_sum += num // i\n        \n        return divisors_sum == num\n\n# Example usage:\n# sol = Solution()\n# print(sol.checkPerfectNumber(28))  # Output: true\n# print(sol.checkPerfectNumber(7))   # Output: false",
            "runtimes": [
                0.002112865447998047,
                0.013462066650390625,
                2.0539562702178955,
                2.1471426486968994,
                2.182313919067383,
                2.536064863204956,
                3.226625442504883,
                6.405961275100708,
                7.2773919105529785,
                8.041385412216187,
                8.052072286605835,
                9.29275918006897,
                9.32087755203247,
                10.741214275360107,
                11.95233678817749
            ],
            "beyond_p": 0.9994865218417651
        }
    ],
    "fibonacci-number": [
        {
            "slug_name": "fibonacci-number",
            "result": {
                "result": "passed",
                "runtime": 0.0002639293670654297,
                "index": 0
            },
            "solution": "class Solution(object):\n    def fib(self, n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            a, b = 0, 1\n            for _ in range(2, n + 1):\n                a, b = b, a + b\n            return b\n\n# Example usage:\n# sol = Solution()\n# print(sol.fib(2))  # Output: 1\n# print(sol.fib(3))  # Output: 2\n# print(sol.fib(4))  # Output: 3",
            "runtimes": [
                0.0002677440643310547,
                0.00026798248291015625,
                0.00031638145446777344,
                0.0003364086151123047,
                0.0004379749298095703,
                0.0005137920379638672,
                0.0006127357482910156,
                0.10355544090270996,
                0.11753177642822266,
                0.16178441047668457,
                0.1740720272064209,
                0.1850271224975586,
                0.19730067253112793,
                0.2079019546508789,
                0.230790376663208,
                0.23895955085754395,
                0.24243736267089844,
                0.2518787384033203,
                0.27799105644226074,
                0.27872228622436523,
                0.2790358066558838,
                0.2793745994567871,
                0.28805088996887207,
                0.28966426849365234,
                0.2898061275482178
            ],
            "beyond_p": 1.0000131751003778
        }
    ],
    "dungeon-game": [
        {
            "slug_name": "dungeon-game",
            "result": {
                "result": "passed",
                "runtime": 0.0004687309265136719,
                "index": 0
            },
            "solution": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n        dp[m][n-1] = dp[m-1][n] = 1\n\n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                min_health = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]\n                dp[i][j] = max(min_health, 1)\n\n        return dp[0][0]\n\n# Example usage:\n# dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n# sol = Solution()\n# print(sol.calculateMinimumHP(dungeon))  # Output: 7\n\n# dungeon = [[0]]\n# sol = Solution()\n# print(sol.calculateMinimumHP(dungeon))  # Output: 1",
            "runtimes": [
                0.00041484832763671875,
                0.00042939186096191406,
                0.0004992485046386719,
                0.0005719661712646484,
                0.0006463527679443359,
                0.0007107257843017578,
                0.0007107257843017578,
                0.0007307529449462891,
                0.0007612705230712891,
                0.0007889270782470703,
                0.0007979869842529297,
                0.0008637905120849609,
                0.0010249614715576172,
                0.002443075180053711,
                0.0024847984313964844,
                0.0032379627227783203,
                0.0032880306243896484,
                0.0038056373596191406,
                0.00390625,
                0.03304934501647949
            ],
            "beyond_p": 0.998348906698617
        }
    ],
    "find-k-th-smallest-pair-distance": [
        {
            "slug_name": "find-k-th-smallest-pair-distance",
            "result": {
                "result": "passed",
                "runtime": 0.0013413429260253906,
                "index": 0
            },
            "solution": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        nums.sort()\n\n        def count_pairs(mid):\n            count = left = 0\n            for right in range(len(nums)):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            return count\n\n        low, high = 0, nums[-1] - nums[0]\n        while low < high:\n            mid = (low + high) // 2\n            if count_pairs(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n\n# Example usage:\n# sol = Solution()\n# print(sol.smallestDistancePair([1,3,1], 1))  # Output: 0\n# print(sol.smallestDistancePair([1,1,1], 2))  # Output: 0\n# print(sol.smallestDistancePair([1,6,1], 3))  # Output: 5",
            "runtimes": [
                0.0013251304626464844,
                0.001483917236328125,
                0.0015082359313964844,
                0.0015425682067871094,
                0.001646280288696289,
                0.0016469955444335938,
                0.0018525123596191406,
                0.0018830299377441406,
                0.0018858909606933594,
                0.0020792484283447266,
                0.002438783645629883,
                0.0024793148040771484,
                0.002721548080444336,
                0.002747774124145508,
                0.002942323684692383,
                0.0030188560485839844,
                0.003179788589477539,
                0.00586390495300293,
                0.007115364074707031
            ],
            "beyond_p": 0.997200032940789
        }
    ],
    "number-of-segments-in-a-string": [
        {
            "slug_name": "number-of-segments-in-a-string",
            "result": {
                "result": "passed",
                "runtime": 0.0002765655517578125,
                "index": 0
            },
            "solution": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.split())\n\n# Example usage:\n# s = \"Hello, my name is John\"\n# sol = Solution()\n# print(sol.countSegments(s))  # Output: 5",
            "runtimes": [
                0.00023293495178222656,
                0.0002460479736328125,
                0.0002560615539550781,
                0.0002720355987548828,
                0.00027370452880859375,
                0.00027823448181152344,
                0.0003306865692138672,
                0.000335693359375,
                0.0003490447998046875
            ],
            "beyond_p": 0.6242299794661191
        }
    ],
    "reverse-vowels-of-a-string": [
        {
            "slug_name": "reverse-vowels-of-a-string",
            "result": {
                "result": "passed",
                "runtime": 0.0007615089416503906,
                "index": 0
            },
            "solution": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels = 'aeiouAEIOU'\n        s_list = list(s)\n        left, right = 0, len(s) - 1\n\n        while left < right:\n            while left < right and s_list[left] not in vowels:\n                left += 1\n            while left < right and s_list[right] not in vowels:\n                right -= 1\n\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left, right = left + 1, right - 1\n\n        return ''.join(s_list)",
            "runtimes": [
                0.0008330345153808594,
                0.0008451938629150391,
                0.0008971691131591797,
                0.0008978843688964844,
                0.0009989738464355469,
                0.001049041748046875,
                0.0010635852813720703,
                0.001142740249633789,
                0.0011777877807617188,
                0.0012750625610351562,
                0.0012993812561035156,
                0.0013871192932128906,
                0.001886129379272461,
                0.0018875598907470703,
                0.0020368099212646484,
                0.0021796226501464844,
                0.0022754669189453125,
                0.002312183380126953,
                0.003266572952270508,
                0.003372669219970703,
                0.0039539337158203125,
                0.004009246826171875,
                0.005468606948852539,
                0.018893718719482422
            ],
            "beyond_p": 1.0039602914774528
        }
    ],
    "longest-consecutive-sequence": [
        {
            "slug_name": "longest-consecutive-sequence",
            "result": {
                "result": "passed",
                "runtime": 0.0258636474609375,
                "index": 0
            },
            "solution": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        num_set = set(nums)\n        longest_streak = 0\n\n        for num in num_set:\n            if num - 1 not in num_set:\n                current_num = num\n                current_streak = 1\n\n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_streak += 1\n\n                longest_streak = max(longest_streak, current_streak)\n\n        return longest_streak",
            "runtimes": [
                0.0007510185241699219,
                0.0007636547088623047,
                0.0007662773132324219,
                0.000782012939453125,
                0.0008220672607421875,
                0.0008540153503417969,
                0.0008602142333984375,
                0.0008633136749267578,
                0.0008933544158935547,
                0.0009179115295410156,
                0.0009577274322509766,
                0.0010037422180175781,
                0.0010066032409667969,
                0.001028299331665039,
                0.0011456012725830078,
                0.0011510848999023438,
                0.0015010833740234375,
                0.0015959739685058594,
                0.0016031265258789062,
                0.0016126632690429688,
                0.0041811466217041016,
                0.007177591323852539,
                0.03021836280822754
            ],
            "beyond_p": 0.1477810591043327
        }
    ],
    "missing-number": [
        {
            "slug_name": "missing-number",
            "result": {
                "result": "passed",
                "runtime": 0.00026488304138183594,
                "index": 0
            },
            "solution": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        expected_sum = len(nums) * (len(nums) + 1) // 2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum",
            "runtimes": [
                0.00026106834411621094,
                0.00029158592224121094,
                0.0002961158752441406,
                0.0002968311309814453,
                0.0002989768981933594,
                0.00031304359436035156,
                0.0003147125244140625,
                0.0003151893615722656,
                0.00031685829162597656,
                0.00031948089599609375,
                0.0003209114074707031,
                0.00032329559326171875,
                0.00032329559326171875,
                0.00032329559326171875,
                0.0003275871276855469,
                0.0003292560577392578,
                0.0003466606140136719,
                0.00037479400634765625,
                0.00039124488830566406,
                0.0005869865417480469
            ],
            "beyond_p": 0.9882955376737381
        }
    ],
    "word-ladder": [
        {
            "slug_name": "word-ladder",
            "result": {
                "result": "passed",
                "runtime": 0.0003948211669921875,
                "index": 0
            },
            "solution": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        from collections import deque\n        wordSet = set(wordList)  # Convert list to set for O(1) look-ups\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # Queue for BFS\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordSet:\n                        wordSet.remove(next_word)\n                        queue.append((next_word, length + 1))\n\n        return 0\n\n# Example usage:\n# sol = Solution()\n# print(sol.ladderLength(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]))  # Output: 5\n# print(sol.ladderLength(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]))  # Output: 0",
            "runtimes": [
                0.0002841949462890625,
                0.0003132820129394531,
                0.0003197193145751953,
                0.00032329559326171875,
                0.00032591819763183594,
                0.00033783912658691406,
                0.0003380775451660156,
                0.0003490447998046875,
                0.0003590583801269531,
                0.0004968643188476562,
                0.0005314350128173828,
                0.0005860328674316406,
                0.0006849765777587891,
                0.0013949871063232422,
                0.0014357566833496094,
                0.0014765262603759766,
                0.0016427040100097656,
                0.00176239013671875,
                0.0021021366119384766,
                0.0022919178009033203,
                0.0025587081909179688,
                0.004452705383300781,
                0.024402379989624023
            ],
            "beyond_p": 0.9954131614586937
        }
    ],
    "add-binary": [
        {
            "slug_name": "add-binary",
            "result": {
                "result": "passed",
                "runtime": 0.0002570152282714844,
                "index": 0
            },
            "solution": "class Solution(object):\n    def addBinary(self, a, b):\n        # Convert binary strings to integers, add them, and convert back to binary string\n        sum = bin(int(a, 2) + int(b, 2))[2:]\n        return sum\n\n# Example usage:\n# sol = Solution()\n# print(sol.addBinary(\"11\", \"1\"))  # Output: \"100\"\n# print(sol.addBinary(\"1010\", \"1011\"))  # Output: \"10101\"",
            "runtimes": [
                0.0002529621124267578,
                0.0002536773681640625,
                0.0002665519714355469,
                0.0003523826599121094,
                0.0011615753173828125,
                0.0015218257904052734,
                0.002129793167114258,
                0.0021677017211914062,
                0.0034906864166259766,
                0.006668806076049805
            ],
            "beyond_p": 0.9993682645856559
        }
    ],
    "find-first-and-last-position-of-element-in-sorted-array": [
        {
            "slug_name": "find-first-and-last-position-of-element-in-sorted-array",
            "result": {
                "result": "passed",
                "runtime": 0.00032329559326171875,
                "index": 0
            },
            "solution": "class Solution(object):\n    def searchRange(self, nums, target):\n        def binarySearchLeft(nums, target):\n            left, right = 0, len(nums)\n            while left < right:\n                mid = (left + right) // 2\n                if nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        def binarySearchRight(nums, target):\n            left, right = 0, len(nums)\n            while left < right:\n                mid = (left + right) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        left_idx = binarySearchLeft(nums, target)\n        right_idx = binarySearchRight(nums, target) - 1\n\n        if left_idx <= right_idx and right_idx < len(nums) and nums[left_idx] == target and nums[right_idx] == target:\n            return [left_idx, right_idx]\n        return [-1, -1]",
            "runtimes": [
                0.0002884864807128906,
                0.00028967857360839844,
                0.0002923011779785156,
                0.0002982616424560547,
                0.00030350685119628906,
                0.00031876564025878906,
                0.0003211498260498047,
                0.0003261566162109375,
                0.0003266334533691406,
                0.0003268718719482422,
                0.0003273487091064453,
                0.00032806396484375,
                0.0003292560577392578,
                0.0003414154052734375,
                0.0003445148468017578,
                0.0003552436828613281,
                0.0003647804260253906,
                0.00041604042053222656,
                0.0005960464477539062,
                0.0063991546630859375,
                0.02982163429260254
            ],
            "beyond_p": 0.9988213544736056
        }
    ],
    "remove-duplicates-from-sorted-array": [
        {
            "slug_name": "remove-duplicates-from-sorted-array",
            "result": {
                "result": "failed@cases",
                "runtime": 0.0004372596740722656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n\n        k = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[k - 1]:\n                nums[k] = nums[i]\n                k += 1\n        return k",
            "runtimes": [
                0.00034999847412109375,
                0.0005419254302978516,
                0.0005667209625244141,
                0.0006129741668701172,
                0.0006794929504394531,
                0.0007977485656738281,
                0.0008058547973632812,
                0.0008318424224853516,
                0.0008866786956787109,
                0.0010380744934082031,
                0.001318216323852539,
                0.009423494338989258,
                0.01425480842590332
            ],
            "beyond_p": 0.0
        }
    ],
    "jump-game-ii": [
        {
            "slug_name": "jump-game-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0002834796905517578,
                "index": 0
            },
            "solution": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        jumps = 0\n        current_end = 0\n        current_farthest = 0\n\n        for i in range(n - 1):\n            current_farthest = max(current_farthest, i + nums[i])\n            if i == current_end:\n                jumps += 1\n                current_end = current_farthest\n                if current_end >= n - 1:\n                    break\n\n        return jumps\n\n# Example usage:\n# sol = Solution()\n# print(sol.jump([2,3,1,1,4]))  # Output: 2\n# print(sol.jump([2,3,0,1,4]))  # Output: 2",
            "runtimes": [
                0.00023984909057617188,
                0.0003185272216796875,
                0.00034427642822265625,
                0.0003573894500732422,
                0.00035762786865234375,
                0.00035881996154785156,
                0.0004172325134277344,
                0.0006432533264160156,
                0.0008571147918701172,
                0.0027246475219726562,
                0.002906322479248047,
                0.003242969512939453,
                0.003278493881225586,
                0.004562854766845703,
                0.006823539733886719,
                0.00797581672668457,
                0.009198665618896484,
                0.014303207397460938,
                0.04315614700317383,
                0.0436244010925293,
                0.053344011306762695,
                0.05550980567932129,
                0.06297898292541504,
                0.08842611312866211
            ],
            "beyond_p": 0.9995052449443063
        }
    ],
    "best-time-to-buy-and-sell-stock-iv": [
        {
            "slug_name": "best-time-to-buy-and-sell-stock-iv",
            "result": {
                "result": "passed",
                "runtime": 0.11544966697692871,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maxProfit(self, k, prices):\n        if not prices or k == 0:\n            return 0\n\n        n = len(prices)\n        if k >= n // 2:\n            return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1))\n\n        profits = [[0] * n for _ in range(k + 1)]\n\n        for i in range(1, k + 1):\n            max_so_far = -prices[0]\n            for j in range(1, n):\n                profits[i][j] = max(profits[i][j - 1], prices[j] + max_so_far)\n                max_so_far = max(max_so_far, profits[i - 1][j] - prices[j])\n\n        return profits[k][-1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxProfit(2, [2,4,1]))  # Output: 2\n# print(sol.maxProfit(2, [3,2,6,5,0,3]))  # Output: 7",
            "runtimes": [
                0.001203775405883789,
                0.023825883865356445,
                0.07357501983642578,
                0.0777442455291748,
                0.09744691848754883,
                0.11364150047302246,
                0.11823344230651855,
                0.13075017929077148,
                0.13960886001586914,
                0.1780250072479248,
                0.2204113006591797,
                0.31632208824157715,
                0.3699479103088379,
                0.3804645538330078,
                0.5016052722930908,
                0.5056684017181396,
                0.5299463272094727,
                0.5308568477630615,
                0.5868945121765137
            ],
            "beyond_p": 0.8049381962211462
        }
    ],
    "convert-a-number-to-hexadecimal": [
        {
            "slug_name": "convert-a-number-to-hexadecimal",
            "result": {
                "result": "passed",
                "runtime": 0.0002510547637939453,
                "index": 0
            },
            "solution": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return '0'\n        if num < 0:\n            num += 2**32\n        hex_chars = '0123456789abcdef'\n        hex_str = ''\n        while num > 0:\n            hex_str = hex_chars[num % 16] + hex_str\n            num //= 16\n        return hex_str",
            "runtimes": [
                0.0002307891845703125,
                0.00024509429931640625,
                0.0002460479736328125,
                0.0002522468566894531,
                0.00025391578674316406,
                0.00025773048400878906,
                0.0002646446228027344,
                0.0002703666687011719,
                0.0002713203430175781,
                0.0002734661102294922,
                0.0002758502960205078,
                0.00027823448181152344,
                0.00027942657470703125,
                0.00028133392333984375,
                0.0002868175506591797,
                0.0002918243408203125,
                0.0003097057342529297,
                0.0003783702850341797,
                0.0004258155822753906,
                0.004511594772338867
            ],
            "beyond_p": 0.9952659426343636
        }
    ],
    "first-unique-character-in-a-string": [
        {
            "slug_name": "first-unique-character-in-a-string",
            "result": {
                "result": "passed",
                "runtime": 0.0007729530334472656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # Create a dictionary to store the frequency of each character\n        frequency = {}\n        for char in s:\n            frequency[char] = frequency.get(char, 0) + 1\n\n        # Iterate through the string to find the first unique character\n        for index, char in enumerate(s):\n            if frequency[char] == 1:\n                return index\n\n        # If no unique character is found, return -1\n        return -1",
            "runtimes": [
                0.0003676414489746094,
                0.0012562274932861328,
                0.0016932487487792969,
                0.0020148754119873047,
                0.0020780563354492188,
                0.0020956993103027344,
                0.0021109580993652344,
                0.002205371856689453,
                0.0022695064544677734,
                0.002293825149536133,
                0.002384185791015625,
                0.0025222301483154297,
                0.002591371536254883,
                0.004700422286987305,
                0.006262063980102539,
                0.00684809684753418,
                0.008717775344848633,
                0.011649608612060547,
                0.012795209884643555,
                0.0529170036315918,
                0.06339073181152344
            ],
            "beyond_p": 0.9935688398943776
        }
    ],
    "contains-duplicate-iii": [
        {
            "slug_name": "contains-duplicate-iii",
            "result": {
                "result": "passed",
                "runtime": 0.0022649765014648438,
                "index": 0
            },
            "solution": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        from sortedcontainers import SortedList\n        sorted_list = SortedList()\n        for i, num in enumerate(nums):\n            if i > indexDiff:\n                sorted_list.remove(nums[i - indexDiff - 1])\n            pos1 = sorted_list.bisect_left(num - valueDiff)\n            pos2 = sorted_list.bisect_right(num + valueDiff)\n            if pos1 != pos2:\n                return True\n            sorted_list.add(num)\n        return False",
            "runtimes": [
                0.00026798248291015625,
                0.0002942085266113281,
                0.00029587745666503906,
                0.0003027915954589844,
                0.00039124488830566406,
                0.0004851818084716797,
                0.0005121231079101562,
                0.0006072521209716797,
                0.0008797645568847656,
                0.0011360645294189453,
                0.0016491413116455078
            ],
            "beyond_p": 0.0
        }
    ],
    "sort-colors": [
        {
            "slug_name": "sort-colors",
            "result": {
                "result": "passed",
                "runtime": 0.0003085136413574219,
                "index": 0
            },
            "solution": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        red, white, blue = 0, 0, len(nums) - 1\n\n        while white <= blue:\n            if nums[white] == 0:\n                nums[red], nums[white] = nums[white], nums[red]\n                red += 1\n                white += 1\n            elif nums[white] == 1:\n                white += 1\n            else:\n                nums[white], nums[blue] = nums[blue], nums[white]\n                blue -= 1\n\n# Example usage:\n# nums = [2,0,2,1,1,0]\n# Solution().sortColors(nums)\n# print(nums)  # Output: [0,0,1,1,2,2]\n\n# nums = [2,0,1]\n# Solution().sortColors(nums)\n# print(nums)  # Output: [0,1,2]",
            "runtimes": [
                0.00029969215393066406,
                0.00030350685119628906,
                0.00030422210693359375,
                0.00030684471130371094,
                0.00030803680419921875,
                0.0003235340118408203,
                0.0003409385681152344,
                0.0003426074981689453,
                0.0003445148468017578,
                0.0003495216369628906,
                0.0003552436828613281,
                0.0003952980041503906,
                0.00043201446533203125,
                0.0019237995147705078,
                0.001941680908203125,
                0.0024230480194091797,
                0.0768435001373291
            ],
            "beyond_p": 0.9998847524357728
        }
    ],
    "max-consecutive-ones": [
        {
            "slug_name": "max-consecutive-ones",
            "result": {
                "result": "passed",
                "runtime": 0.0005140304565429688,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_count = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n        return max_count",
            "runtimes": [
                0.0003440380096435547,
                0.0003447532653808594,
                0.00039076805114746094,
                0.0004012584686279297,
                0.00041413307189941406,
                0.0004172325134277344,
                0.0005071163177490234,
                0.0005524158477783203,
                0.0005686283111572266,
                0.0005786418914794922,
                0.0007288455963134766,
                0.0007488727569580078,
                0.0007679462432861328,
                0.0008144378662109375,
                0.0008251667022705078,
                0.0008306503295898438,
                0.0008988380432128906,
                0.0009000301361083984,
                0.0010135173797607422
            ],
            "beyond_p": 0.7460826210826211
        }
    ],
    "count-complete-tree-nodes": [
        {
            "slug_name": "count-complete-tree-nodes",
            "result": {
                "result": "passed",
                "runtime": 0.0003314018249511719,
                "index": 0
            },
            "solution": "import math\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def get_tree_depth(node):\n            depth = 0\n            while node:\n                node = node.left\n                depth += 1\n            return depth\n        \n        if not root:\n            return 0\n        \n        left_depth = get_tree_depth(root.left)\n        right_depth = get_tree_depth(root.right)\n        \n        if left_depth == right_depth:\n            return (1 << left_depth) + self.countNodes(root.right)\n        else:\n            return (1 << right_depth) + self.countNodes(root.left)",
            "runtimes": [
                0.00032329559326171875,
                0.00032591819763183594,
                0.0003261566162109375,
                0.00032711029052734375,
                0.00033736228942871094,
                0.0003426074981689453,
                0.0003542900085449219,
                0.0003674030303955078,
                0.0003705024719238281,
                0.00037670135498046875,
                0.00037932395935058594,
                0.00038170814514160156,
                0.0003821849822998047,
                0.0003867149353027344,
                0.0003876686096191406,
                0.00038814544677734375,
                0.0003902912139892578,
                0.00040030479431152344,
                0.0005898475646972656,
                0.004334688186645508
            ],
            "beyond_p": 0.9979791976225855
        }
    ],
    "add-strings": [
        {
            "slug_name": "add-strings",
            "result": {
                "result": "passed",
                "runtime": 0.0021665096282958984,
                "index": 0
            },
            "solution": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = ''\n        carry = 0\n        p1 = len(num1) - 1\n        p2 = len(num2) - 1\n\n        while p1 >= 0 or p2 >= 0 or carry:\n            x1 = ord(num1[p1]) - ord('0') if p1 >= 0 else 0\n            x2 = ord(num2[p2]) - ord('0') if p2 >= 0 else 0\n            value = (x1 + x2 + carry) % 10\n            carry = (x1 + x2 + carry) // 10\n            result = str(value) + result\n            p1 -= 1\n            p2 -= 1\n\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.addStrings('11', '123'))  # Output: '134'\n# print(sol.addStrings('456', '77'))  # Output: '533'\n# print(sol.addStrings('0', '0'))    # Output: '0'",
            "runtimes": [
                0.0003819465637207031,
                0.0003991127014160156,
                0.0004703998565673828,
                0.001600027084350586,
                0.0016067028045654297,
                0.0018739700317382812,
                0.0019905567169189453,
                0.002003908157348633,
                0.002007007598876953,
                0.0021522045135498047,
                0.0022461414337158203,
                0.002306222915649414,
                0.0024662017822265625,
                0.0024793148040771484,
                0.0029065608978271484,
                0.003989458084106445,
                0.004832267761230469,
                0.018367767333984375
            ],
            "beyond_p": 0.9007794480235425
        }
    ],
    "basic-calculator": [
        {
            "slug_name": "basic-calculator",
            "result": {
                "result": "passed",
                "runtime": 0.00035500526428222656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def calculate(self, s):\n        def update(op, num):\n            if op == '+': stack.append(num)\n            if op == '-': stack.append(-num)\n\n        it, num, stack, sign = 0, 0, [], '+'\n        while it < len(s):\n            if s[it].isdigit():\n                num = num * 10 + int(s[it])\n            elif s[it] in '+-':\n                update(sign, num)\n                num, sign = 0, s[it]\n            elif s[it] == '(': \n                num, j = self.calculate(s[it + 1:])\n                it += j\n            elif s[it] == ')':\n                update(sign, num)\n                return sum(stack), it + 1\n            it += 1\n        update(sign, num)\n        return sum(stack)\n\n# Example usage:\n# sol = Solution()\n# print(sol.calculate(\"1 + 1\"))  # Output: 2\n# print(sol.calculate(\" 2-1 + 2 \"))  # Output: 3\n# print(sol.calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # Output: 23",
            "runtimes": [
                0.0003509521484375,
                0.00037169456481933594,
                0.0003771781921386719,
                0.0003781318664550781,
                0.0003781318664550781,
                0.00038814544677734375,
                0.00038909912109375,
                0.00042629241943359375,
                0.00044083595275878906,
                0.0004451274871826172,
                0.000457763671875,
                0.00047850608825683594,
                0.0004916191101074219,
                0.0005018711090087891,
                0.0005583763122558594,
                0.0006253719329833984,
                0.0006451606750488281,
                0.0006773471832275391,
                0.0010461807250976562,
                0.012623786926269531,
                0.019671201705932617
            ],
            "beyond_p": 0.9997902141050163
        }
    ],
    "ipo": [
        {
            "slug_name": "ipo",
            "result": {
                "result": "passed",
                "runtime": 0.0021359920501708984,
                "index": 0
            },
            "solution": "import heapq\n\nclass Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        if w >= max(capital):\n            return w + sum(sorted(profits, reverse=True)[:k])\n\n        projects = sorted(zip(capital, profits), key=lambda x: x[0])\n        available_projects = []\n        current_capital = w\n\n        for _ in range(k):\n            while projects and projects[0][0] <= current_capital:\n                _, profit = heapq.heappop(projects)\n                heapq.heappush(available_projects, -profit)\n\n            if available_projects:\n                current_capital += -heapq.heappop(available_projects)\n            else:\n                break\n\n        return current_capital",
            "runtimes": [
                0.001577615737915039,
                0.0016362667083740234,
                0.001710653305053711,
                0.0017986297607421875,
                0.0018613338470458984,
                0.0018835067749023438,
                0.0020017623901367188,
                0.002032041549682617,
                0.002080678939819336,
                0.002165079116821289,
                0.0023746490478515625,
                0.0030100345611572266,
                0.0030384063720703125,
                0.003221273422241211,
                0.006258487701416016,
                0.007696390151977539,
                0.007720947265625,
                0.008501052856445312,
                0.009716272354125977,
                0.011916875839233398,
                0.01460576057434082,
                0.03197050094604492
            ],
            "beyond_p": 0.9816280583948477
        }
    ],
    "valid-parentheses": [
        {
            "slug_name": "valid-parentheses",
            "result": {
                "result": "passed",
                "runtime": 0.00027060508728027344,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack",
            "runtimes": [
                0.00026702880859375,
                0.00026869773864746094,
                0.000270843505859375,
                0.0002722740173339844,
                0.0002727508544921875,
                0.0002741813659667969,
                0.00027561187744140625,
                0.00028514862060546875,
                0.0003008842468261719,
                0.00030517578125,
                0.00030684471130371094,
                0.0003077983856201172,
                0.0003101825714111328,
                0.00031065940856933594,
                0.00031113624572753906,
                0.0003120899200439453,
                0.0003120899200439453,
                0.0003132820129394531,
                0.00031495094299316406,
                0.0003190040588378906,
                0.00033593177795410156,
                0.00035190582275390625,
                0.0003726482391357422,
                0.0004153251647949219,
                0.0004169940948486328,
                0.0004267692565917969,
                0.0005774497985839844,
                0.0006427764892578125,
                0.0006983280181884766,
                0.0007233619689941406,
                0.0007381439208984375,
                0.001957416534423828,
                0.002063274383544922
            ],
            "beyond_p": 0.9980090257499337
        }
    ],
    "next-permutation": [
        {
            "slug_name": "next-permutation",
            "result": {
                "result": "passed",
                "runtime": 0.0003185272216796875,
                "index": 0
            },
            "solution": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # Find the first decreasing element from the right\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # If the entire array is non-increasing, reverse it\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # Find the element just larger than nums[i]\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        \n        # Swap the two elements\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the elements from i+1 to the end\n        nums[i+1:] = reversed(nums[i+1:])\n\n# Example usage:\n# sol = Solution()\n# arr = [1,2,3]\n# sol.nextPermutation(arr)\n# print(arr)  # Output: [1,3,2]",
            "runtimes": [
                0.00026535987854003906,
                0.0002703666687011719,
                0.000270843505859375,
                0.0002758502960205078,
                0.00030040740966796875,
                0.0003020763397216797,
                0.0003025531768798828,
                0.000308990478515625,
                0.00030994415283203125,
                0.00031685829162597656,
                0.00031757354736328125,
                0.0003178119659423828,
                0.0003180503845214844,
                0.000324249267578125,
                0.00038313865661621094,
                0.0004367828369140625,
                0.006193637847900391
            ],
            "beyond_p": 0.9910315704805952
        }
    ],
    "contains-duplicate-ii": [
        {
            "slug_name": "contains-duplicate-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0005266666412353516,
                "index": 0
            },
            "solution": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        # Create a dictionary to store the last index of each number\n        index_map = {}\n        # Iterate through the list\n        for i, num in enumerate(nums):\n            # If the number is in the dictionary and the difference\n            # between the current index and the last index is less than or equal to k\n            if num in index_map and i - index_map[num] <= k:\n                # Return true as we found a nearby duplicate\n                return True\n            # Update the last index of the number\n            index_map[num] = i\n        # If no nearby duplicates found, return false\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.containsNearbyDuplicate([1,2,3,1], 3))  # Output: true\n# print(sol.containsNearbyDuplicate([1,0,1,1], 1))  # Output: true\n# print(sol.containsNearbyDuplicate([1,2,3,1,2,3], 2))  # Output: false",
            "runtimes": [
                0.0003857612609863281,
                0.00043082237243652344,
                0.0004684925079345703,
                0.00047206878662109375,
                0.0004956722259521484,
                0.0005013942718505859,
                0.0005085468292236328,
                0.0005116462707519531,
                0.0005168914794921875,
                0.0005197525024414062,
                0.0005233287811279297,
                0.0005252361297607422,
                0.0005466938018798828,
                0.0005636215209960938,
                0.0005755424499511719,
                0.0006422996520996094,
                0.0006482601165771484,
                0.0008218288421630859,
                0.00093841552734375,
                0.0009887218475341797,
                0.004514932632446289,
                0.03095722198486328
            ],
            "beyond_p": 0.9953909503532825
        }
    ],
    "maximum-gap": [
        {
            "slug_name": "maximum-gap",
            "result": {
                "result": "passed",
                "runtime": 0.0019757747650146484,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) < 2:\n            return 0\n\n        # Find the minimum and maximum values\n        min_val, max_val = min(nums), max(nums)\n\n        # Calculate the minimum possible gap (bucket size)\n        bucket_size = max(1, (max_val - min_val) // (len(nums) - 1))\n\n        # Initialize buckets\n        buckets = [[None, None] for _ in range((max_val - min_val) // bucket_size + 1)]\n\n        # Place each number in a bucket\n        for num in nums:\n            bucket_idx = (num - min_val) // bucket_size\n            bucket = buckets[bucket_idx]\n            bucket[0] = min(bucket[0], num) if bucket[0] is not None else num\n            bucket[1] = max(bucket[1], num) if bucket[1] is not None else num\n\n        # Calculate the maximum gap\n        max_gap, prev_max = 0, min_val\n        for bucket in buckets:\n            if bucket[0] is None:\n                continue\n            max_gap = max(max_gap, bucket[0] - prev_max)\n            prev_max = bucket[1]\n\n        return max_gap",
            "runtimes": [
                0.0007240772247314453,
                0.000850677490234375,
                0.0010962486267089844,
                0.0010972023010253906,
                0.0012238025665283203,
                0.002038717269897461,
                0.0021314620971679688,
                0.002176523208618164,
                0.002972841262817383,
                0.0033533573150634766,
                0.003590106964111328,
                0.0037474632263183594,
                0.0038225650787353516,
                0.0038366317749023438,
                0.003932476043701172,
                0.006672859191894531,
                0.007442951202392578,
                0.0077571868896484375,
                0.009023427963256836,
                0.011013269424438477,
                0.013753652572631836,
                0.015039205551147461,
                0.017621278762817383,
                0.01946544647216797,
                0.021099567413330078
            ],
            "beyond_p": 0.9385684698283427
        }
    ],
    "binary-tree-level-order-traversal": [
        {
            "slug_name": "binary-tree-level-order-traversal",
            "result": {
                "result": "passed",
                "runtime": 0.003042936325073242,
                "index": 0
            },
            "solution": "import collections\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n\n        result = []\n        queue = collections.deque([root])\n\n        while queue:\n            level_size = len(queue)\n            current_level = []\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            result.append(current_level)\n\n        return result",
            "runtimes": [
                0.0009202957153320312,
                0.0009524822235107422,
                0.001004934310913086,
                0.0010075569152832031,
                0.0010097026824951172,
                0.0010132789611816406,
                0.0010137557983398438,
                0.0010237693786621094,
                0.0010366439819335938,
                0.0011072158813476562,
                0.004059791564941406,
                0.012840509414672852,
                0.023263216018676758
            ],
            "beyond_p": 0.9049971722173018
        }
    ],
    "couples-holding-hands": [
        {
            "slug_name": "couples-holding-hands",
            "result": {
                "result": "passed",
                "runtime": 0.0003161430358886719,
                "index": 0
            },
            "solution": "class Solution(object):\n    def minSwapsCouples(self, row):\n        def find_partner(x):\n            return x ^ 1\n\n        def find_position(x):\n            return pos[x]\n\n        pos = {person: i for i, person in enumerate(row)}\n        swaps = 0\n\n        for i in range(0, len(row), 2):\n            first_person = row[i]\n            second_person = find_partner(first_person)\n            if row[i + 1] != second_person:\n                partner_pos = find_position(second_person)\n                row[i + 1], row[partner_pos] = row[partner_pos], row[i + 1]\n                pos[row[i + 1]], pos[row[partner_pos]] = i + 1, partner_pos\n                swaps += 1\n\n        return swaps\n\n# Example usage:\n# sol = Solution()\n# print(sol.minSwapsCouples([0, 2, 1, 3]))  # Output: 1\n# print(sol.minSwapsCouples([3, 2, 0, 1]))  # Output: 0",
            "runtimes": [
                0.00026702880859375,
                0.00029087066650390625,
                0.00030112266540527344,
                0.0003058910369873047,
                0.00030612945556640625,
                0.0003077983856201172,
                0.0003116130828857422,
                0.0003287792205810547,
                0.00033020973205566406,
                0.0003497600555419922,
                0.0003657341003417969,
                0.0003707408905029297,
                0.00039577484130859375,
                0.00041174888610839844,
                0.0005047321319580078,
                0.0005228519439697266,
                0.0006756782531738281,
                0.005166769027709961
            ],
            "beyond_p": 0.9899761568780108
        }
    ],
    "interleaving-string": [
        {
            "slug_name": "interleaving-string",
            "result": {
                "result": "passed",
                "runtime": 0.0002837181091308594,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [False] * (len(s2) + 1)\n        dp[0] = True\n\n        for i in range(1, len(s2) + 1):\n            dp[i] = dp[i - 1] and s2[i - 1] == s3[i - 1]\n\n        for i in range(1, len(s1) + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n            for j in range(1, len(s2) + 1):\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n\n        return dp[-1]",
            "runtimes": [
                0.0002818107604980469,
                0.0002925395965576172,
                0.00030350685119628906,
                0.00032591819763183594,
                0.0003261566162109375,
                0.00032639503479003906,
                0.0003294944763183594,
                0.0003299713134765625,
                0.0003402233123779297,
                0.00034236907958984375,
                0.0003445148468017578,
                0.00035452842712402344,
                0.0003662109375,
                0.0003714561462402344,
                0.0003745555877685547,
                0.00037479400634765625,
                0.0003764629364013672,
                0.0003771781921386719,
                0.0004296302795410156,
                0.00043320655822753906,
                0.00043392181396484375,
                0.00043487548828125
            ],
            "beyond_p": 0.9875389408099688
        }
    ],
    "assign-cookies": [
        {
            "slug_name": "assign-cookies",
            "result": {
                "result": "passed",
                "runtime": 0.0005052089691162109,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findContentChildren(self, g, s):\n        # Sort the greed factors of the children and the sizes of the cookies\n        g.sort()\n        s.sort()\n\n        # Initialize the count of content children\n        content_children = 0\n\n        # Initialize the index for cookies\n        cookie_index = 0\n\n        # Iterate through each child's greed factor\n        for greed in g:\n            # While there are cookies left and the current cookie is too small,\n            # move to the next cookie\n            while cookie_index < len(s) and s[cookie_index] < greed:\n                cookie_index += 1\n\n            # If there are no more cookies, break out of the loop\n            if cookie_index == len(s):\n                break\n\n            # The current cookie satisfies the child's greed, give it to the child\n            content_children += 1\n            # Move to the next cookie\n            cookie_index += 1\n\n        # Return the count of content children\n        return content_children\n\n# Example usage:\n# sol = Solution()\n# print(sol.findContentChildren([1,2,3], [1,1]))  # Output: 1\n# print(sol.findContentChildren([1,2], [1,2,3]))  # Output: 2",
            "runtimes": [
                0.0005197525024414062,
                0.0005273818969726562,
                0.0005435943603515625,
                0.0005505084991455078,
                0.0005695819854736328,
                0.0005812644958496094,
                0.0005888938903808594,
                0.0005953311920166016,
                0.0006515979766845703,
                0.0006577968597412109,
                0.0007233619689941406,
                0.0007417201995849609,
                0.0008308887481689453,
                0.0008380413055419922,
                0.0008382797241210938,
                0.0008616447448730469,
                0.000988006591796875,
                0.0010416507720947266,
                0.0010426044464111328,
                0.0010881423950195312,
                0.0020651817321777344,
                0.009946823120117188
            ],
            "beyond_p": 1.001542741527567
        }
    ],
    "keyboard-row": [
        {
            "slug_name": "keyboard-row",
            "result": {
                "result": "passed",
                "runtime": 0.0005202293395996094,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        # Define the rows of the American keyboard\n        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n\n        # Function to check if a word can be typed using one row\n        def can_be_typed_with_one_row(word):\n            word_set = set(word.lower())\n            return word_set.issubset(row1) or word_set.issubset(row2) or word_set.issubset(row3)\n\n        # Filter the words that can be typed with one row\n        return [word for word in words if can_be_typed_with_one_row(word)]\n\n# Example usage:\n# sol = Solution()\n# print(sol.findWords([\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]))  # Output: [\"Alaska\",\"Dad\"]\n# print(sol.findWords([\"omk\"]))  # Output: []\n# print(sol.findWords([\"adsdf\",\"sfd\"]))  # Output: [\"adsdf\",\"sfd\"]",
            "runtimes": [
                0.00031685829162597656,
                0.00036025047302246094,
                0.0003662109375,
                0.00037479400634765625,
                0.0004334449768066406,
                0.0004696846008300781,
                0.0004932880401611328,
                0.0005826950073242188,
                0.0005946159362792969,
                0.0006420612335205078,
                0.0009541511535644531,
                0.0009639263153076172,
                0.0009903907775878906
            ],
            "beyond_p": 0.6980530973451328
        }
    ],
    "reverse-linked-list-ii": [
        {
            "slug_name": "reverse-linked-list-ii",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Edge case: if left equals right, no need to reverse anything\n        if left == right:\n            return head\n\n        # Initialize dummy node and set it to point to the head\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        # Move prev to the node just before the left position\n        for _ in range(left - 1):\n            prev = prev.next\n\n        # Start reversing from the left position\n        reverse = None\n        current = prev.next\n        for _ in range(right - left + 1):\n            next_temp = current.next\n            current.next = reverse\n            reverse = current\n            current = next_temp\n\n        # Connect the reversed part with the rest of the list\n        prev.next.next = current\n        prev.next = reverse\n\n        # Return the new head\n        return dummy.next",
            "runtimes": [
                0.0013668537139892578,
                0.0014071464538574219,
                0.00148773193359375,
                0.0015118122100830078,
                0.0015292167663574219,
                0.0015370845794677734,
                0.0015807151794433594,
                0.0015871524810791016,
                0.0017380714416503906,
                0.0018031597137451172,
                0.0018680095672607422,
                0.0019009113311767578,
                0.0021369457244873047,
                0.009073734283447266,
                0.009401798248291016,
                0.013513565063476562
            ],
            "beyond_p": 0.0
        }
    ],
    "shortest-palindrome": [
        {
            "slug_name": "shortest-palindrome",
            "result": {
                "result": "passed",
                "runtime": 0.00038552284240722656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # Find the longest palindromic prefix\n        j = 0\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == s[j]:\n                j += 1\n        if j == len(s):\n            return s\n        # Add the reverse of the suffix to the front of the original string\n        suffix = s[j:]\n        return suffix[::-1] + self.shortestPalindrome(s[:j]) + s[j:]\n\n# Example usage\n# sol = Solution()\n# print(sol.shortestPalindrome('aacecaaa'))  # Output: 'aaacecaaa'\n# print(sol.shortestPalindrome('abcd'))     # Output: 'dcbabcd'",
            "runtimes": [
                0.0004010200500488281,
                0.0005059242248535156,
                0.0006363391876220703,
                0.000682830810546875,
                0.0007188320159912109,
                0.0007848739624023438,
                0.0007944107055664062,
                0.0008411407470703125,
                0.0008614063262939453,
                0.0009057521820068359,
                0.0009512901306152344,
                0.0010390281677246094,
                0.0015215873718261719,
                0.0021047592163085938,
                0.002132415771484375,
                0.0021889209747314453,
                0.002824068069458008,
                0.004018545150756836,
                0.007664203643798828
            ],
            "beyond_p": 1.0021336659663866
        }
    ],
    "minimum-window-substring": [
        {
            "slug_name": "minimum-window-substring",
            "result": {
                "result": "passed",
                "runtime": 0.0013425350189208984,
                "index": 0
            },
            "solution": "class Solution(object):\n    def minWindow(self, s, t):\n        from collections import Counter\n        t_counter = Counter(t)\n        required = len(t_counter)\n        left, right = 0, 0\n        formed = 0\n        window_counts = {}\n        ans = float('inf'), None, None\n\n        while right < len(s):\n            character = s[right]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            if character in t_counter and window_counts[character] == t_counter[character]:\n                formed += 1\n\n            while left <= right and formed == required:\n                character = s[left]\n\n                if right - left + 1 < ans[0]:\n                    ans = (right - left + 1, left, right)\n\n                window_counts[character] -= 1\n                if character in t_counter and window_counts[character] < t_counter[character]:\n                    formed -= 1\n\n                left += 1\n\n            right += 1\n\n        return '' if ans[0] == float('inf') else s[ans[1]:(ans[2] + 1)]",
            "runtimes": [
                0.0005652904510498047,
                0.0006194114685058594,
                0.0006232261657714844,
                0.0006525516510009766,
                0.0007150173187255859,
                0.001077890396118164,
                0.0011353492736816406,
                0.0012035369873046875,
                0.0012960433959960938,
                0.001455545425415039,
                0.0015366077423095703,
                0.002823352813720703,
                0.021343231201171875
            ],
            "beyond_p": 0.9625928008353509
        }
    ],
    "self-crossing": [
        {
            "slug_name": "self-crossing",
            "result": {
                "result": "passed",
                "runtime": 0.0031473636627197266,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        x = y = 0\n        directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n        visited = set([(x, y)])\n\n        for i, dist in enumerate(distance):\n            dx, dy = directions[i % 4]\n            for _ in range(dist):\n                x += dx\n                y += dy\n                if (x, y) in visited:\n                    return True\n                visited.add((x, y))\n\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.isSelfCrossing([2,1,1,2]))  # Output: true\n# print(sol.isSelfCrossing([1,2,3,4]))  # Output: false\n# print(sol.isSelfCrossing([1,1,1,2,1]))  # Output: true",
            "runtimes": [
                0.0002853870391845703,
                0.00031876564025878906,
                0.00031948089599609375,
                0.0003261566162109375,
                0.0003445148468017578,
                0.00034928321838378906,
                0.00037026405334472656,
                0.000392913818359375,
                0.0003955364227294922,
                0.00040340423583984375,
                0.0004057884216308594,
                0.0004162788391113281,
                0.0004208087921142578,
                0.0004756450653076172,
                0.00047898292541503906,
                0.0005056858062744141
            ],
            "beyond_p": 0.0
        }
    ],
    "remove-duplicates-from-sorted-list": [
        {
            "slug_name": "remove-duplicates-from-sorted-list",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "if not head or not head.next:\n            return head\n\n        current = head\n        while current.next:\n            if current.val == current.next.val:\n                current.next = current.next.next\n            else:\n                current = current.next\n\n        return head",
            "runtimes": [
                0.0006000995635986328,
                0.0006291866302490234,
                0.0006315708160400391,
                0.0006315708160400391,
                0.0006339550018310547,
                0.0006356239318847656,
                0.0006375312805175781,
                0.0006856918334960938,
                0.0006949901580810547,
                0.000701904296875,
                0.0007109642028808594,
                0.0007288455963134766,
                0.0007288455963134766,
                0.0007350444793701172,
                0.0007419586181640625,
                0.0007445812225341797,
                0.0008416175842285156,
                0.0010726451873779297,
                0.0010883808135986328
            ],
            "beyond_p": 0.0
        }
    ],
    "longest-palindrome": [
        {
            "slug_name": "longest-palindrome",
            "result": {
                "result": "passed",
                "runtime": 0.0009403228759765625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        from collections import Counter\n        char_count = Counter(s)\n        length = 0\n        odd_found = False\n        for count in char_count.values():\n            if count % 2 == 0:\n                length += count\n            else:\n                length += count - 1\n                odd_found = True\n        if odd_found:\n            length += 1\n        return length\n\n# Example usage:\n# sol = Solution()\n# print(sol.longestPalindrome('abccccdd'))  # Output: 7\n# print(sol.longestPalindrome('a'))        # Output: 1",
            "runtimes": [
                0.0004887580871582031,
                0.0005028247833251953,
                0.0005128383636474609,
                0.0005931854248046875,
                0.0006167888641357422,
                0.0006504058837890625,
                0.0010533332824707031,
                0.0012240409851074219,
                0.0023484230041503906,
                0.015184879302978516
            ],
            "beyond_p": 0.9692731992212849
        }
    ],
    "construct-binary-tree-from-inorder-and-postorder-traversal": [
        {
            "slug_name": "construct-binary-tree-from-inorder-and-postorder-traversal",
            "result": {
                "result": "passed",
                "runtime": 0.0433812141418457,
                "index": 0
            },
            "solution": "import json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        if not inorder or not postorder:\n            return None\n\n        # The last element in postorder is the root of the tree\n        root_val = postorder.pop()\n        root = TreeNode(root_val)\n\n        # Find the index of the root in inorder to split left and right subtrees\n        inorder_index = inorder.index(root_val)\n\n        # Recursively build the right and then left subtree\n        root.right = self.buildTree(inorder[inorder_index+1:], postorder)\n        root.left = self.buildTree(inorder[:inorder_index], postorder)\n\n        return root\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\"\"\"\n        if not root:\n            return 'null'\n\n        serialized_tree = []\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node:\n                serialized_tree.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                serialized_tree.append('null')\n\n        # Remove trailing 'null' values\n        while serialized_tree[-1] == 'null':\n            serialized_tree.pop()\n\n        return json.dumps(serialized_tree)\n\n# Example usage:\n# inorder = [9,3,15,20,7]\n# postorder = [9,15,7,20,3]\n# sol = Solution()\n# root = sol.buildTree(inorder, postorder)\n# serialized_tree = sol.serialize(root)\n# print(serialized_tree)",
            "runtimes": [
                0.0032312870025634766,
                0.003617525100708008,
                0.0037386417388916016,
                0.0037789344787597656,
                0.0038449764251708984,
                0.003959178924560547,
                0.0039861202239990234,
                0.0040547847747802734,
                0.004096031188964844,
                0.004181623458862305,
                0.0042455196380615234,
                0.004290580749511719,
                0.004619598388671875,
                0.0053441524505615234,
                0.007765531539916992,
                0.007834911346435547,
                0.008195877075195312,
                0.016715049743652344,
                0.01973557472229004,
                0.019974470138549805,
                0.020409584045410156,
                0.02057480812072754,
                0.022525787353515625,
                0.028046131134033203,
                0.028219938278198242
            ],
            "beyond_p": 0.0
        }
    ],
    "cut-off-trees-for-golf-event": [
        {
            "slug_name": "cut-off-trees-for-golf-event",
            "result": {
                "result": "passed",
                "runtime": 8.302628993988037,
                "index": 0
            },
            "solution": "import heapq\n\n\nclass Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def bfs(start, target):\n            visited, queue = set([start]), collections.deque([start + (0,)])\n            while queue:\n                x, y, steps = queue.popleft()\n                if (x, y) == target:\n                    return steps\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < len(forest) and 0 <= ny < len(forest[0]) and (nx, ny) not in visited and forest[nx][ny] > 0:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, steps + 1))\n            return -1\n\n        trees = [(height, x, y) for x, row in enumerate(forest) for y, height in enumerate(row) if height > 1]\n        heapq.heapify(trees)\n\n        steps = 0\n        start = (0, 0)\n        while trees:\n            height, tx, ty = heapq.heappop(trees)\n            step = bfs(start, (tx, ty))\n            if step == -1:\n                return -1\n            steps += step\n            start = (tx, ty)\n            forest[tx][ty] = 1\n        return steps\n\n\n# Example usage:\n# sol = Solution()\n# print(sol.cutOffTree([[1,2,3],[0,0,4],[7,6,5]]))  # Output: 6\n# print(sol.cutOffTree([[1,2,3],[0,0,0],[7,6,5]]))  # Output: -1\n# print(sol.cutOffTree([[2,3,4],[0,0,5],[8,7,6]]))  # Output: 6",
            "runtimes": [
                0.1591792106628418,
                0.18805575370788574,
                0.24989962577819824,
                1.3670105934143066,
                4.785325765609741,
                5.27714729309082,
                6.968709945678711,
                7.294732093811035,
                8.50535249710083,
                8.785672903060913,
                8.971121788024902,
                9.317182302474976,
                10.14094066619873,
                10.546763896942139,
                11.865632057189941
            ],
            "beyond_p": 0.3043623128127086
        }
    ],
    "minimum-depth-of-binary-tree": [
        {
            "slug_name": "minimum-depth-of-binary-tree",
            "result": {
                "result": "passed",
                "runtime": 0.00048351287841796875,
                "index": 0
            },
            "solution": "import collections\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        \n        queue = collections.deque([(root, 1)])\n        while queue:\n            node, depth = queue.popleft()\n            if not node.left and not node.right:\n                return depth\n            if node.left:\n                queue.append((node.left, depth + 1))\n            if node.right:\n                queue.append((node.right, depth + 1))\n        \n        return 0",
            "runtimes": [
                0.0004172325134277344,
                0.0004291534423828125,
                0.00043320655822753906,
                0.0004379749298095703,
                0.0004420280456542969,
                0.0004436969757080078,
                0.0004470348358154297,
                0.00046181678771972656,
                0.0004699230194091797,
                0.00047397613525390625,
                0.00047850608825683594,
                0.00048542022705078125,
                0.0004870891571044922,
                0.0004875659942626953,
                0.0004878044128417969,
                0.0004916191101074219,
                0.0004961490631103516,
                0.0004978179931640625,
                0.0005080699920654297,
                0.0005083084106445312,
                0.0005359649658203125,
                0.0005364418029785156,
                0.0005364418029785156,
                0.0005488395690917969,
                0.0006196498870849609,
                0.0008122920989990234,
                0.0038111209869384766,
                0.012605428695678711
            ],
            "beyond_p": 0.9945619217151465
        }
    ],
    "count-of-range-sum": [
        {
            "slug_name": "count-of-range-sum",
            "result": {
                "result": "passed",
                "runtime": 0.14488911628723145,
                "index": 0
            },
            "solution": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        # Initialize count of range sums\n        count = 0\n        # Initialize prefix sums array\n        prefix_sums = [0]\n        for num in nums:\n            prefix_sums.append(prefix_sums[-1] + num)\n\n        # Iterate over all possible ranges\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                # Calculate the range sum\n                range_sum = prefix_sums[j + 1] - prefix_sums[i]\n                # Check if the range sum is within the bounds\n                if lower <= range_sum <= upper:\n                    count += 1\n        return count",
            "runtimes": [
                0.0019390583038330078,
                0.0033652782440185547,
                0.004736185073852539,
                0.005376100540161133,
                0.006383419036865234,
                0.007495880126953125,
                0.009904146194458008,
                0.013035297393798828,
                0.014774799346923828,
                0.017013072967529297,
                0.018378496170043945,
                0.029416561126708984,
                0.03272438049316406,
                0.03349471092224121,
                0.04806017875671387,
                0.05550026893615723,
                0.058887481689453125,
                0.06805753707885742
            ],
            "beyond_p": 0.0
        }
    ],
    "arranging-coins": [
        {
            "slug_name": "arranging-coins",
            "result": {
                "result": "passed",
                "runtime": 0.00030040740966796875,
                "index": 0
            },
            "solution": "class Solution(object):\n    def arrangeCoins(self, n):\n        left, right = 0, n\n        while left <= right:\n            mid = (left + right) // 2\n            current = mid * (mid + 1) // 2\n            if current == n:\n                return mid\n            if n < current:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return right\n\n# Example usage:\n# sol = Solution()\n# print(sol.arrangeCoins(5))  # Output: 2\n# print(sol.arrangeCoins(8))  # Output: 3",
            "runtimes": [
                0.00028061866760253906,
                0.00028967857360839844,
                0.009571552276611328,
                0.013314962387084961,
                0.016333580017089844,
                0.01724696159362793,
                0.021893978118896484,
                0.024790048599243164,
                0.03202366828918457,
                0.03273439407348633,
                0.03395652770996094,
                0.040673017501831055,
                0.0423579216003418,
                0.04470324516296387,
                0.046961307525634766,
                0.048886775970458984,
                0.05566740036010742,
                0.05996060371398926,
                0.06605815887451172,
                0.08220243453979492,
                0.08966374397277832,
                0.10889792442321777
            ],
            "beyond_p": 0.9998178122544307
        }
    ],
    "longest-uncommon-subsequence-i": [
        {
            "slug_name": "longest-uncommon-subsequence-i",
            "result": {
                "result": "passed",
                "runtime": 0.00030493736267089844,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        # If the strings are equal, there is no uncommon subsequence\n        if a == b:\n            return -1\n        # If the strings are not equal, the longest uncommon subsequence\n        # is the longer of the two strings\n        else:\n            return max(len(a), len(b))\n\n# Example usage:\n# sol = Solution()\n# print(sol.findLUSlength(\"aba\", \"cdc\"))  # Output: 3\n# print(sol.findLUSlength(\"aaa\", \"bbb\"))  # Output: 3\n# print(sol.findLUSlength(\"aaa\", \"aaa\"))  # Output: -1",
            "runtimes": [
                0.0002727508544921875,
                0.00029778480529785156,
                0.0003075599670410156,
                0.000308990478515625,
                0.00037360191345214844,
                0.0003838539123535156,
                0.0004057884216308594,
                0.00044798851013183594,
                0.014441490173339844,
                0.018396377563476562
            ],
            "beyond_p": 0.998224058093033
        }
    ],
    "binary-tree-level-order-traversal-ii": [
        {
            "slug_name": "binary-tree-level-order-traversal-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0005121231079101562,
                "index": 0
            },
            "solution": "import collections\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n\n        queue = collections.deque([root])\n        result = collections.deque()\n\n        while queue:\n            level_size = len(queue)\n            level_nodes = []\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                level_nodes.append(node.val)\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            result.appendleft(level_nodes)\n\n        return list(result)",
            "runtimes": [
                0.00047969818115234375,
                0.0005042552947998047,
                0.0005691051483154297,
                0.00067138671875,
                0.0007190704345703125,
                0.0007717609405517578,
                0.0007891654968261719,
                0.0008280277252197266,
                0.0008935928344726562,
                0.0010266304016113281,
                0.001573801040649414
            ],
            "beyond_p": 0.97036391370669
        }
    ],
    "palindrome-number": [
        {
            "slug_name": "palindrome-number",
            "result": {
                "result": "passed",
                "runtime": 0.0002646446228027344,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        # Negative numbers are not palindromes\n        if x < 0:\n            return False\n        \n        # Follow up: Solve without converting to a string\n        original = x\n        reversed_x = 0\n        while x > 0:\n            reversed_x = reversed_x * 10 + x % 10\n            x //= 10\n        \n        return original == reversed_x",
            "runtimes": [
                0.0002605915069580078,
                0.0002639293670654297,
                0.00026488304138183594,
                0.00026988983154296875,
                0.0003039836883544922,
                0.00030422210693359375,
                0.0003044605255126953,
                0.0003066062927246094,
                0.0003077983856201172,
                0.0003077983856201172,
                0.0003273487091064453,
                0.0003368854522705078,
                0.00034427642822265625,
                0.000354766845703125,
                0.0003571510314941406,
                0.0003681182861328125,
                0.00037288665771484375,
                0.0003764629364013672,
                0.00038313865661621094,
                0.00039005279541015625
            ],
            "beyond_p": 0.9686924493554327
        }
    ],
    "decode-ways": [
        {
            "slug_name": "decode-ways",
            "result": {
                "result": "passed",
                "runtime": 0.0004487037658691406,
                "index": 0
            },
            "solution": "class Solution(object):\n    def numDecodings(self, s):\n        if not s or s[0] == '0':\n            return 0\n\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n\n        for i in range(2, len(s) + 1):\n            if s[i-1] != '0':\n                dp[i] += dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n\n        return dp[len(s)]\n\n# Example usage:\n# sol = Solution()\n# print(sol.numDecodings('12'))  # Output: 2\n# print(sol.numDecodings('226')) # Output: 3\n# print(sol.numDecodings('06'))  # Output: 0",
            "runtimes": [
                0.00032782554626464844,
                0.00035572052001953125,
                0.00035643577575683594,
                0.0003788471221923828,
                0.0003886222839355469,
                0.00040435791015625,
                0.0004336833953857422,
                0.0004379749298095703,
                0.00045561790466308594,
                0.00046253204345703125,
                0.00046896934509277344,
                0.0004696846008300781,
                0.0005428791046142578,
                0.0005538463592529297,
                0.0006241798400878906
            ],
            "beyond_p": 0.5921158487530169
        }
    ],
    "is-subsequence": [
        {
            "slug_name": "is-subsequence",
            "result": {
                "result": "passed",
                "runtime": 0.001447439193725586,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isSubsequence(self, s, t):\n        s_index, t_index = 0, 0\n        while s_index < len(s) and t_index < len(t):\n            if s[s_index] == t[t_index]:\n                s_index += 1\n            t_index += 1\n        return s_index == len(s)\n\n# For the follow-up, we can preprocess 't' to create a dictionary that maps each character to its indices in ascending order.\n# Then, for each 's', we can use binary search to find the next character of 's' in 't'.\n\n# Follow-up implementation\nfrom collections import defaultdict\nfrom bisect import bisect_left\n\nclass SolutionFollowUp(object):\n    def __init__(self, t):\n        self.char_indices = defaultdict(list)\n        for index, char in enumerate(t):\n            self.char_indices[char].append(index)\n\n    def isSubsequence(self, s):\n        current_index = -1\n        for char in s:\n            if char not in self.char_indices:\n                return False\n            indices_list = self.char_indices[char]\n            i = bisect_left(indices_list, current_index + 1)\n            if i == len(indices_list):\n                return False\n            current_index = indices_list[i]\n        return True",
            "runtimes": [
                0.0006802082061767578,
                0.0011453628540039062,
                0.0013129711151123047,
                0.001371622085571289,
                0.001378774642944336,
                0.001432180404663086,
                0.0014531612396240234,
                0.0014698505401611328,
                0.0014941692352294922,
                0.0015876293182373047,
                0.0018858909606933594,
                0.0023450851440429688,
                0.0035943984985351562,
                0.00427699089050293,
                0.007192373275756836,
                0.42447423934936523,
                1.6136603355407715
            ],
            "beyond_p": 0.9995243394667133
        }
    ],
    "gray-code": [
        {
            "slug_name": "gray-code",
            "result": {
                "result": "passed",
                "runtime": 0.0003566741943359375,
                "index": 0
            },
            "solution": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        result = [0]\n        for i in range(n):\n            add_val = 1 << i\n            for j in range(len(result) - 1, -1, -1):\n                result.append(result[j] + add_val)\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.grayCode(2))  # Output: [0,1,3,2]\n# print(sol.grayCode(1))  # Output: [0,1]",
            "runtimes": [
                0.0003254413604736328,
                0.00033473968505859375,
                0.0003616809844970703,
                0.00039696693420410156,
                0.0005104541778564453,
                0.0005147457122802734,
                0.0005397796630859375,
                0.0005955696105957031,
                0.0011355876922607422,
                0.0012733936309814453,
                0.0013260841369628906,
                0.0014755725860595703,
                0.0016851425170898438,
                0.002099752426147461,
                0.00275421142578125,
                0.01620340347290039,
                0.016930103302001953
            ],
            "beyond_p": 0.9981190322349056
        }
    ],
    "climbing-stairs": [
        {
            "slug_name": "climbing-stairs",
            "result": {
                "result": "passed",
                "runtime": 0.0003657341003417969,
                "index": 0
            },
            "solution": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # Base cases\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n\n        # Initialize the first two steps\n        first, second = 1, 2\n\n        # Calculate the number of ways for each step\n        for i in range(3, n + 1):\n            third = first + second\n            first = second\n            second = third\n\n        # The 'second' variable holds the number of ways to reach the nth step\n        return second",
            "runtimes": [
                0.00025773048400878906,
                0.0002713203430175781,
                0.0002720355987548828,
                0.00027561187744140625,
                0.0002849102020263672,
                0.00029778480529785156,
                0.0003371238708496094,
                0.0003523826599121094,
                0.0003619194030761719,
                0.0004067420959472656,
                0.0004773139953613281,
                0.0006110668182373047
            ],
            "beyond_p": 0.694331983805668
        }
    ],
    "word-break": [
        {
            "slug_name": "word-break",
            "result": {
                "result": "passed",
                "runtime": 0.01574397087097168,
                "index": 0
            },
            "solution": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n\n        return dp[len(s)]",
            "runtimes": [
                0.0010013580322265625,
                0.0013670921325683594,
                0.001377105712890625,
                0.0013980865478515625,
                0.001430511474609375,
                0.0025453567504882812,
                0.0025615692138671875,
                0.0030531883239746094,
                0.0033795833587646484,
                0.004448652267456055,
                0.013444662094116211,
                0.013458490371704102,
                0.04834794998168945,
                0.049368858337402344,
                0.17382144927978516,
                0.17432141304016113,
                0.20310378074645996
            ],
            "beyond_p": 0.9270537550181142
        }
    ],
    "validate-binary-search-tree": [
        {
            "slug_name": "validate-binary-search-tree",
            "result": {
                "result": "passed",
                "runtime": 0.0004734992980957031,
                "index": 0
            },
            "solution": "import sys\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        return self._isValidBST(root, -sys.maxsize, sys.maxsize)\n    \n    def _isValidBST(self, node, lower, upper):\n        if not node:\n            return True\n        val = node.val\n        if val <= lower or val >= upper:\n            return False\n        if not self._isValidBST(node.right, val, upper):\n            return False\n        if not self._isValidBST(node.left, lower, val):\n            return False\n        return True",
            "runtimes": [
                0.00042057037353515625,
                0.0004398822784423828,
                0.0004487037658691406,
                0.00046181678771972656,
                0.0004870891571044922,
                0.0004885196685791016,
                0.0005054473876953125,
                0.0005064010620117188,
                0.0005598068237304688,
                0.0005602836608886719,
                0.000576019287109375,
                0.0005900859832763672,
                0.0006625652313232422,
                0.0006756782531738281,
                0.0007488727569580078,
                0.0007894039154052734,
                0.007778167724609375
            ],
            "beyond_p": 0.9928062216461438
        }
    ],
    "insert-interval": [
        {
            "slug_name": "insert-interval",
            "result": {
                "result": "passed",
                "runtime": 0.012103557586669922,
                "index": 0
            },
            "solution": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        merged = []\n        i, n = 0, len(intervals)\n        while i < n and intervals[i][1] < newInterval[0]:\n            merged.append(intervals[i])\n            i += 1\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        merged.append(newInterval)\n        while i < n:\n            merged.append(intervals[i])\n            i += 1\n        return merged",
            "runtimes": [
                0.00025463104248046875,
                0.0002639293670654297,
                0.0002646446228027344,
                0.0002765655517578125,
                0.00028324127197265625,
                0.0002887248992919922,
                0.0002892017364501953,
                0.00029206275939941406,
                0.00029397010803222656,
                0.0002944469451904297,
                0.00029540061950683594,
                0.0002956390380859375,
                0.00029587745666503906,
                0.00029587745666503906,
                0.0002961158752441406,
                0.0002989768981933594,
                0.0002999305725097656,
                0.0003135204315185547,
                0.00031757354736328125,
                0.0003254413604736328,
                0.0003314018249511719,
                0.00033593177795410156,
                0.0003762245178222656,
                0.0003840923309326172
            ],
            "beyond_p": 0.0
        }
    ],
    "palindrome-partitioning": [
        {
            "slug_name": "palindrome-partitioning",
            "result": {
                "result": "passed",
                "runtime": 0.0004000663757324219,
                "index": 0
            },
            "solution": "class Solution(object):\n    def partition(self, s):\n        def is_palindrome(sub):\n            return sub == sub[::-1]\n\n        def backtrack(start, path):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    path.append(s[start:end])\n                    backtrack(end, path)\n                    path.pop()\n\n        result = []\n        backtrack(0, [])\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.partition('aab'))\n# print(sol.partition('a'))",
            "runtimes": [
                0.00033164024353027344,
                0.0003495216369628906,
                0.0003604888916015625,
                0.00036144256591796875,
                0.00036215782165527344,
                0.00037360191345214844,
                0.00037741661071777344,
                0.00038695335388183594,
                0.00038909912109375,
                0.00039696693420410156,
                0.0003998279571533203,
                0.0004029273986816406,
                0.0004038810729980469,
                0.00041413307189941406,
                0.0004246234893798828,
                0.0004317760467529297,
                0.0004355907440185547,
                0.0004646778106689453,
                0.0004901885986328125,
                0.0005390644073486328,
                0.0006158351898193359,
                0.0006258487701416016,
                0.0006899833679199219,
                0.0016868114471435547,
                0.012373924255371094,
                0.07243847846984863,
                0.10533738136291504,
                0.11649179458618164,
                0.3912842273712158
            ],
            "beyond_p": 0.9998249758808226
        }
    ],
    "smallest-range-covering-elements-from-k-lists": [
        {
            "slug_name": "smallest-range-covering-elements-from-k-lists",
            "result": {
                "result": "passed",
                "runtime": 0.0011532306671142578,
                "index": 0
            },
            "solution": "import heapq\n\nclass Solution(object):\n    def smallestRange(self, nums):\n        min_heap = []\n        current_max = float('-inf')\n        for i, row in enumerate(nums):\n            heapq.heappush(min_heap, (row[0], i, 0))\n            current_max = max(current_max, row[0])\n        \n        smallest_range = [float('-inf'), float('inf')]\n        \n        while min_heap:\n            current_min, row_index, element_index = heapq.heappop(min_heap)\n            if current_max - current_min < smallest_range[1] - smallest_range[0]:\n                smallest_range = [current_min, current_max]\n            \n            if element_index + 1 < len(nums[row_index]):\n                next_element = nums[row_index][element_index + 1]\n                heapq.heappush(min_heap, (next_element, row_index, element_index + 1))\n                current_max = max(current_max, next_element)\n            else:\n                break\n        \n        return smallest_range\n\n# Example usage:\n# sol = Solution()\n# print(sol.smallestRange([[4,10,15,24,26],[0,9,12,20],[5,18,22,30]])) # Output: [20,24]\n# print(sol.smallestRange([[1,2,3],[1,2,3],[1,2,3]])) # Output: [1,1]",
            "runtimes": [
                0.0010251998901367188,
                0.0011458396911621094,
                0.0011584758758544922,
                0.0011746883392333984,
                0.001188516616821289,
                0.0012536048889160156,
                0.0014157295227050781,
                0.002238750457763672,
                0.003008604049682617,
                0.0030977725982666016,
                0.003306150436401367,
                0.0055391788482666016,
                0.007261037826538086,
                0.00756525993347168,
                0.013741493225097656,
                0.018029212951660156,
                0.023630380630493164,
                0.02394556999206543
            ],
            "beyond_p": 0.9944141051646123
        }
    ],
    "poor-pigs": [
        {
            "slug_name": "poor-pigs",
            "result": {
                "result": "passed",
                "runtime": 0.0002987384796142578,
                "index": 0
            },
            "solution": "import math\n\nclass Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        states = minutesToTest // minutesToDie + 1\n        return math.ceil(math.log(buckets) / math.log(states))\n\n# Example usage:\n# sol = Solution()\n# print(sol.poorPigs(4, 15, 15))  # Output: 2\n# print(sol.poorPigs(4, 15, 30))  # Output: 2",
            "runtimes": [
                0.0002651214599609375,
                0.0002684593200683594,
                0.00026988983154296875,
                0.0002779960632324219,
                0.00027823448181152344,
                0.00028252601623535156,
                0.0002827644348144531,
                0.0002868175506591797,
                0.0002980232238769531,
                0.00031065940856933594,
                0.0003762245178222656,
                0.00043272972106933594,
                0.00045013427734375
            ],
            "beyond_p": 0.8182989690721649
        }
    ],
    "swim-in-rising-water": [
        {
            "slug_name": "swim-in-rising-water",
            "result": {
                "result": "passed",
                "runtime": 0.002278566360473633,
                "index": 0
            },
            "solution": "import heapq\n\nclass Solution(object):\n    def swimInWater(self, grid):\n        n = len(grid)\n        visited = set()\n        min_heap = [(grid[0][0], 0, 0)]  # (elevation, x, y)\n        visited.add((0, 0))\n        time = 0\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        while min_heap:\n            elevation, x, y = heapq.heappop(min_heap)\n            time = max(time, elevation)\n            if x == n - 1 and y == n - 1:\n                return time\n\n            for dx, dy in directions:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < n and 0 <= new_y < n and (new_x, new_y) not in visited:\n                    visited.add((new_x, new_y))\n                    heapq.heappush(min_heap, (grid[new_x][new_y], new_x, new_y))\n\n        return time",
            "runtimes": [
                0.002308368682861328,
                0.0024759769439697266,
                0.0030448436737060547,
                0.003974437713623047,
                0.0041332244873046875,
                0.004277467727661133,
                0.004611492156982422,
                0.005943775177001953,
                0.006211757659912109,
                0.0063877105712890625,
                0.008006572723388672,
                0.008394241333007812,
                0.00898289680480957,
                0.009021520614624023,
                0.009331703186035156,
                0.01167607307434082,
                0.011917829513549805,
                0.016039371490478516,
                0.01733231544494629,
                0.021570205688476562
            ],
            "beyond_p": 1.0015472211907415
        }
    ],
    "unique-paths": [
        {
            "slug_name": "unique-paths",
            "result": {
                "result": "passed",
                "runtime": 0.0003101825714111328,
                "index": 0
            },
            "solution": "class Solution(object):\n    def uniquePaths(self, m, n):\n        # Create a 2D array to store the number of ways to reach each cell\n        dp = [[0] * n for _ in range(m)]\n\n        # Initialize the first row and first column to 1\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n\n        # Fill in the rest of the dp array\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        # The bottom-right corner will have the number of unique paths\n        return dp[m - 1][n - 1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.uniquePaths(3, 7))  # Output: 28\n# print(sol.uniquePaths(3, 2))  # Output: 3",
            "runtimes": [
                0.0002796649932861328,
                0.0003457069396972656,
                0.0003762245178222656,
                0.0003795623779296875,
                0.0003795623779296875,
                0.0003981590270996094,
                0.000431060791015625,
                0.0005064010620117188,
                0.0005083084106445312,
                0.0005176067352294922,
                0.0005338191986083984,
                0.00054931640625,
                0.0005555152893066406,
                0.0007507801055908203,
                0.0007762908935546875,
                0.0037093162536621094,
                0.012419700622558594
            ],
            "beyond_p": 0.9974862035782321
        }
    ],
    "multiply-strings": [
        {
            "slug_name": "multiply-strings",
            "result": {
                "result": "passed",
                "runtime": 0.022362947463989258,
                "index": 0
            },
            "solution": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        len1, len2 = len(num1), len(num2)\n        result = [0] * (len1 + len2)\n\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                p1, p2 = i + j, i + j + 1\n                sum = mul + result[p2]\n\n                result[p1] += sum // 10\n                result[p2] = sum % 10\n\n        result_str = ''.join(map(str, result))\n        return result_str.lstrip('0')",
            "runtimes": [
                0.00024437904357910156,
                0.00025653839111328125,
                0.00028133392333984375,
                0.00030112266540527344,
                0.00038814544677734375,
                0.0007228851318359375,
                0.009010076522827148,
                0.009864091873168945,
                0.011549949645996094,
                0.013443708419799805,
                0.013579368591308594,
                0.013671159744262695,
                0.014108657836914062,
                0.016199111938476562,
                0.019374608993530273,
                0.022962570190429688,
                0.023366212844848633,
                0.02572917938232422,
                0.025884628295898438,
                0.029261112213134766,
                0.0330812931060791,
                0.034207820892333984,
                0.047095537185668945,
                0.047200918197631836
            ],
            "beyond_p": 0.5289565879664889
        }
    ],
    "best-time-to-buy-and-sell-stock-iii": [
        {
            "slug_name": "best-time-to-buy-and-sell-stock-iii",
            "result": {
                "result": "passed",
                "runtime": 0.002058744430541992,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n\n        # Initialize the profits to zero for the first two transactions\n        first_buy, second_buy = float('inf'), float('inf')\n        first_profit, second_profit = 0, 0\n\n        for price in prices:\n            # Update the first_buy to be the minimum price so far\n            first_buy = min(first_buy, price)\n            # Update the first_profit to be the maximum of previous first_profit or\n            # the profit from selling at current price minus first_buy\n            first_profit = max(first_profit, price - first_buy)\n            # Update the second_buy to be the minimum of previous second_buy or\n            # the current price minus the first_profit\n            second_buy = min(second_buy, price - first_profit)\n            # Update the second_profit to be the maximum of previous second_profit or\n            # the profit from selling at current price minus second_buy\n            second_profit = max(second_profit, price - second_buy)\n\n        return second_profit\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxProfit([3,3,5,0,0,3,1,4]))  # Output: 6\n# print(sol.maxProfit([1,2,3,4,5]))        # Output: 4\n# print(sol.maxProfit([7,6,4,3,1]))        # Output: 0",
            "runtimes": [
                0.0007855892181396484,
                0.0021238327026367188,
                0.0022919178009033203,
                0.002595186233520508,
                0.0026602745056152344,
                0.0028896331787109375,
                0.0033538341522216797,
                0.0033795833587646484,
                0.003692626953125,
                0.004126548767089844,
                0.004551887512207031,
                0.004740476608276367,
                0.0055389404296875,
                0.0072596073150634766,
                0.008003711700439453,
                0.009145021438598633,
                0.01029515266418457,
                0.011693954467773438,
                0.01626110076904297,
                0.02126789093017578,
                0.03414106369018555,
                0.03709053993225098
            ],
            "beyond_p": 0.9649316363922928
        }
    ],
    "combination-sum-ii": [
        {
            "slug_name": "combination-sum-ii",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "def backtrack(start, end, temp, target_remaining):\n            if target_remaining == 0:\n                result.append(list(temp))\n                return\n            if target_remaining < 0:\n                return\n            for i in range(start, end):\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue\n                temp.append(candidates[i])\n                backtrack(i + 1, end, temp, target_remaining - candidates[i])\n                temp.pop()\n\n        candidates.sort()\n        result = []\n        backtrack(0, len(candidates), [], target)\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.combinationSum2([10,1,2,7,6,1,5], 8))\n# print(sol.combinationSum2([2,5,2,1,2], 5))",
            "runtimes": [
                0.00048661231994628906,
                0.0004992485046386719,
                0.0005068778991699219,
                0.0013134479522705078,
                0.0017480850219726562,
                0.001956939697265625,
                0.002056598663330078,
                0.002300262451171875,
                0.002359628677368164,
                0.0024423599243164062,
                0.0041697025299072266,
                0.0045549869537353516,
                0.006454944610595703,
                0.008414983749389648,
                0.011193513870239258,
                0.016088247299194336,
                0.017813682556152344
            ],
            "beyond_p": 0.0
        }
    ],
    "detect-capital": [
        {
            "slug_name": "detect-capital",
            "result": {
                "result": "passed",
                "runtime": 0.0002732276916503906,
                "index": 0
            },
            "solution": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        return word.isupper() or word.islower() or word.istitle()\n\n# Example usage:\n# sol = Solution()\n# print(sol.detectCapitalUse(\"USA\"))  # Output: true\n# print(sol.detectCapitalUse(\"FlaG\"))  # Output: false",
            "runtimes": [
                0.00023889541625976562,
                0.00023937225341796875,
                0.0002429485321044922,
                0.0002651214599609375,
                0.00027251243591308594,
                0.0002765655517578125,
                0.0002779960632324219,
                0.0002796649932861328,
                0.00028395652770996094,
                0.0003001689910888672,
                0.0003845691680908203
            ],
            "beyond_p": 0.7643207855973814
        }
    ],
    "best-time-to-buy-and-sell-stock": [
        {
            "slug_name": "best-time-to-buy-and-sell-stock",
            "result": {
                "result": "passed",
                "runtime": 0.0012600421905517578,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxProfit([7,1,5,3,6,4]))  # Output: 5\n# print(sol.maxProfit([7,6,4,3,1]))    # Output: 0",
            "runtimes": [
                0.0005121231079101562,
                0.0005145072937011719,
                0.0005252361297607422,
                0.0005447864532470703,
                0.0005652904510498047,
                0.0005686283111572266,
                0.0005846023559570312,
                0.0009469985961914062,
                0.0012230873107910156,
                0.0012423992156982422,
                0.0012841224670410156,
                0.0013599395751953125,
                0.0014107227325439453,
                0.0015397071838378906,
                0.0017786026000976562,
                0.005152225494384766,
                0.01931595802307129,
                0.020490169525146484
            ],
            "beyond_p": 0.9625629520013366
        }
    ],
    "binary-tree-inorder-traversal": [
        {
            "slug_name": "binary-tree-inorder-traversal",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize the stack and the result list\n        stack = []\n        result = []\n        current = root\n        \n        # Iterate until the stack is empty or the current node is None\n        while current is not None or len(stack) > 0:\n            # Reach the left most Node of the current Node\n            while current is not None:\n                # Place pointer to a tree node on the stack before traversing the node's left subtree\n                stack.append(current)\n                current = current.left\n            \n            # Current must be None at this point\n            current = stack.pop()\n            result.append(current.val)  # Add the node's value\n            \n            # We have visited the node and its left subtree. Now, it's right subtree's turn\n            current = current.right\n        \n        return result",
            "runtimes": [
                0.00044798851013183594,
                0.0004603862762451172,
                0.00046563148498535156,
                0.0004761219024658203,
                0.0004837512969970703,
                0.0004940032958984375,
                0.0005023479461669922,
                0.0005095005035400391,
                0.0005142688751220703,
                0.000514984130859375,
                0.0005230903625488281,
                0.0005276203155517578,
                0.0005288124084472656,
                0.0005321502685546875,
                0.000537872314453125,
                0.0005426406860351562,
                0.0006399154663085938,
                0.0006949901580810547,
                0.004659891128540039,
                0.007197380065917969,
                0.01848292350769043
            ],
            "beyond_p": 0.0
        }
    ],
    "construct-binary-tree-from-preorder-and-inorder-traversal": [
        {
            "slug_name": "construct-binary-tree-from-preorder-and-inorder-traversal",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Definition for a binary tree node.\n        # class TreeNode(object):\n        #     def __init__(self, val=0, left=None, right=None):\n        #         self.val = val\n        #         self.left = left\n        #         self.right = right\n        class Solution(object):\n            def buildTree(self, preorder, inorder):\n                if not preorder or not inorder:\n                    return None\n\n                # The first element of preorder list is the root.\n                root_val = preorder[0]\n                root = TreeNode(root_val)\n\n                # Find the index of the root in inorder list.\n                mid = inorder.index(root_val)\n\n                # Recursively construct the left and right subtree.\n                root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n                root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n\n                return root",
            "runtimes": [
                0.003693819046020508,
                0.004355192184448242,
                0.00439143180847168,
                0.0045757293701171875,
                0.004604816436767578,
                0.004757404327392578,
                0.004822492599487305,
                0.00485539436340332,
                0.0050237178802490234,
                0.005027294158935547,
                0.005236387252807617,
                0.0057675838470458984,
                0.005865812301635742,
                0.006121158599853516,
                0.006579399108886719,
                0.00876164436340332,
                0.010344982147216797,
                0.011077642440795898,
                0.013987064361572266,
                0.019535541534423828,
                0.01971578598022461,
                0.023035049438476562,
                0.02581501007080078,
                0.032581329345703125,
                0.03415250778198242
            ],
            "beyond_p": 0.0
        }
    ],
    "remove-invalid-parentheses": [
        {
            "slug_name": "remove-invalid-parentheses",
            "result": {
                "result": "failed@cases",
                "runtime": 0.0003669261932373047,
                "index": 0
            },
            "solution": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        def is_valid(string):\n            count = 0\n            for char in string:\n                if char == '(': count += 1\n                elif char == ')': count -= 1\n                if count < 0: return False\n            return count == 0\n\n        def dfs(s, start, l, r):\n            if l == r == 0:\n                if is_valid(s):\n                    ans.add(s)\n                return\n            for i in range(start, len(s)):\n                if i != start and s[i] == s[i-1]:\n                    continue\n                if s[i] in ('(', ')'):\n                    curr = s[:i] + s[i+1:]\n                    if r > 0 and s[i] == ')':\n                        dfs(curr, i, l, r-1)\n                    elif l > 0 and s[i] == '(': \n                        dfs(curr, i, l-1, r)\n\n        ans = set()\n        left = right = 0\n        for char in s:\n            if char == '(': left += 1\n            elif char == ')':\n                if left == 0: right += 1\n                else: left -= 1\n        dfs(s, 0, left, right)\n        return list(ans)\n\n# Example usage:\n# sol = Solution()\n# print(sol.removeInvalidParentheses('()())()'))\n# print(sol.removeInvalidParentheses('(a)())()'))\n# print(sol.removeInvalidParentheses(')('))",
            "runtimes": [
                0.0003521442413330078,
                0.00038743019104003906
            ],
            "beyond_p": 0.0
        }
    ],
    "merge-k-sorted-lists": [
        {
            "slug_name": "merge-k-sorted-lists",
            "result": {
                "result": "passed",
                "runtime": 0.003238677978515625,
                "index": 0
            },
            "solution": "import heapq\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        # Initialize a priority queue\n        min_heap = []\n        # Fill the priority queue with the first node of each list\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(min_heap, (node.val, i, node))\n        \n        # Dummy node to start the merged list\n        dummy = ListNode(0)\n        current = dummy\n        \n        # Extract the smallest element from the heap and add it to the merged list\n        while min_heap:\n            val, i, node = heapq.heappop(min_heap)\n            current.next = ListNode(val)\n            current = current.next\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, i, node.next))\n        \n        return dummy.next",
            "runtimes": [
                0.0017783641815185547,
                0.0019676685333251953,
                0.0020780563354492188,
                0.002078533172607422,
                0.0021033287048339844,
                0.002151012420654297,
                0.002164602279663086,
                0.0024678707122802734,
                0.002817869186401367,
                0.003000020980834961,
                0.0030465126037597656,
                0.0031681060791015625,
                0.004328012466430664,
                0.005755186080932617,
                0.008270025253295898,
                0.009285688400268555,
                0.010073423385620117,
                0.012012720108032227,
                0.02245616912841797,
                0.023196697235107422,
                0.03078174591064453,
                0.03633236885070801,
                0.42730212211608887
            ],
            "beyond_p": 0.9965681967933231
        }
    ],
    "palindrome-partitioning-ii": [
        {
            "slug_name": "palindrome-partitioning-ii",
            "result": {
                "result": "passed",
                "runtime": 0.06181740760803223,
                "index": 0
            },
            "solution": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        cut = [x for x in range(-1, n)]\n        pal = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            for j in range(i + 1):\n                if s[i] == s[j] and (i - j < 2 or pal[j + 1][i - 1]):\n                    pal[j][i] = True\n                    cut[i + 1] = min(cut[i + 1], cut[j] + 1)\n\n        return cut[-1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.minCut('aab'))  # Output: 1\n# print(sol.minCut('a'))    # Output: 0\n# print(sol.minCut('ab'))   # Output: 1",
            "runtimes": [
                0.0017955303192138672,
                0.0048258304595947266,
                0.016385316848754883,
                0.06681275367736816,
                0.08563709259033203,
                0.12221789360046387,
                0.19887948036193848,
                0.24419188499450684,
                0.2885925769805908,
                0.3297550678253174,
                0.33945488929748535,
                0.3732273578643799,
                0.404834508895874,
                0.4162468910217285,
                0.45115184783935547,
                0.4878814220428467,
                0.49474287033081055,
                0.597064733505249,
                0.5987370014190674
            ],
            "beyond_p": 0.8994509844018223
        }
    ],
    "preimage-size-of-factorial-zeroes-function": [
        {
            "slug_name": "preimage-size-of-factorial-zeroes-function",
            "result": {
                "result": "passed",
                "runtime": 0.0004665851593017578,
                "index": 0
            },
            "solution": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        def zeta(n):\n            count = 0\n            while n > 0:\n                n //= 5\n                count += n\n            return count\n        \n        def binary_search(k):\n            left, right = 0, 5 * (k + 1)\n            while left <= right:\n                mid = (left + right) // 2\n                z = zeta(mid)\n                if z < k:\n                    left = mid + 1\n                elif z > k:\n                    right = mid - 1\n                else:\n                    return 5\n            return 0\n        \n        return binary_search(k)\n\n# Example usage:\n# sol = Solution()\n# print(sol.preimageSizeFZF(0))  # Output: 5\n# print(sol.preimageSizeFZF(5))  # Output: 0\n# print(sol.preimageSizeFZF(3))  # Output: 5",
            "runtimes": [
                0.0003132820129394531,
                0.0003154277801513672,
                0.0003368854522705078,
                0.00037980079650878906,
                0.0004935264587402344,
                0.0005247592926025391,
                0.0005817413330078125,
                0.0007159709930419922,
                0.0008816719055175781,
                0.0008962154388427734,
                0.002431631088256836,
                0.0028994083404541016
            ],
            "beyond_p": 0.9407209366645155
        }
    ],
    "palindrome-pairs": [
        {
            "slug_name": "palindrome-pairs",
            "result": {
                "result": "passed",
                "runtime": 0.0029413700103759766,
                "index": 0
            },
            "solution": "class Solution(object):\n    def palindromePairs(self, words):\n        def is_palindrome(check):\n            return check == check[::-1]\n\n        word_dict = {word: i for i, word in enumerate(words)}\n        result = []\n\n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix, suffix = word[:j], word[j:]\n                reverse_prefix, reverse_suffix = prefix[::-1], suffix[::-1]\n\n                if is_palindrome(suffix) and reverse_prefix in word_dict and word_dict[reverse_prefix] != i:\n                    result.append([i, word_dict[reverse_prefix]])\n\n                if j > 0 and is_palindrome(prefix) and reverse_suffix in word_dict and word_dict[reverse_suffix] != i:\n                    result.append([word_dict[reverse_suffix], i])\n\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.palindromePairs([\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]))\n# Output: [[0,1],[1,0],[3,2],[2,4]]\n# print(sol.palindromePairs([\"bat\",\"tab\",\"cat\"]))\n# Output: [[0,1],[1,0]]\n# print(sol.palindromePairs([\"a\",\"\"]))\n# Output: [[0,1],[1,0]]",
            "runtimes": [
                0.001422882080078125,
                0.0014634132385253906,
                0.0014674663543701172,
                0.0017430782318115234,
                0.0017936229705810547,
                0.00183868408203125,
                0.002974987030029297,
                0.003929615020751953,
                0.004513740539550781,
                0.0048007965087890625,
                0.005082607269287109,
                0.005095243453979492,
                0.0064907073974609375,
                0.00708317756652832,
                0.008428335189819336,
                0.00851750373840332,
                0.008540868759155273,
                0.008794069290161133,
                0.009115219116210938,
                0.009194374084472656,
                0.010352849960327148,
                0.012337923049926758,
                0.023237943649291992,
                0.03961658477783203
            ],
            "beyond_p": 0.960242452995081
        }
    ],
    "convert-sorted-array-to-binary-search-tree": [
        {
            "slug_name": "convert-sorted-array-to-binary-search-tree",
            "result": {
                "result": "failed@cases",
                "runtime": 0.0045566558837890625,
                "index": 0
            },
            "solution": "import json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        def convertListToBST(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            node = TreeNode(nums[mid])\n            node.left = convertListToBST(left, mid - 1)\n            node.right = convertListToBST(mid + 1, right)\n            return node\n        return convertListToBST(0, len(nums) - 1)\n\n# Helper function to serialize TreeNode to list\ndef serialize(root):\n    \"\"\"Encodes a tree to a single string.\n    \n    :type root: TreeNode\n    :rtype: str\n    \"\"\"\n    if not root:\n        return 'null'\n    queue = [root]\n    res = []\n    while queue:\n        node = queue.pop(0)\n        if node:\n            res.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            res.append('null')\n    # Remove trailing 'null' values\n    while res and res[-1] == 'null':\n        res.pop()\n    return res\n\n# Example usage:\nsol = Solution()\nnums = [-10,-3,0,5,9]\nroot = sol.sortedArrayToBST(nums)\noutput = serialize(root)\nprint(json.dumps({'Output': output}))\n\nnums = [1,3]\nroot = sol.sortedArrayToBST(nums)\noutput = serialize(root)\nprint(json.dumps({'Output': output}))",
            "runtimes": [
                0.002363920211791992,
                0.002443075180053711,
                0.0025360584259033203,
                0.0025420188903808594,
                0.0025832653045654297,
                0.0026450157165527344,
                0.0026848316192626953,
                0.0026865005493164062,
                0.0027091503143310547,
                0.008463621139526367
            ],
            "beyond_p": 0.0
        }
    ],
    "contain-virus": [
        {
            "slug_name": "contain-virus",
            "result": {
                "result": "failed@eval",
                "runtime": 0,
                "index": 0
            },
            "solution": "class Solution(object):\n    def containVirus(self, isInfected):\n        from collections import defaultdict\n\n        def dfs(i, j, index, walls, visited):\n            if (i, j) in visited:\n                return 0\n            visited.add((i, j))\n            wall_count = 0\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < m and 0 <= y < n:\n                    if isInfected[x][y] == 1 and (x, y) not in visited:\n                        wall_count += dfs(x, y, index, walls, visited)\n                    elif isInfected[x][y] == 0:\n                        walls[index].add((min(i, x), min(j, y), max(i, x), max(j, y)))\n                        wall_count += 1\n            return wall_count\n\n        m, n = len(isInfected), len(isInfected[0])\n        total_walls = 0\n        while True:\n            regions = defaultdict(set)\n            walls = defaultdict(set)\n            region_index = 0\n            visited = set()\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1 and (i, j) not in visited:\n                        region_walls = dfs(i, j, region_index, walls, visited)\n                        if region_walls > 0:\n                            regions[region_index] = region_walls\n                            region_index += 1\n\n            if not regions:\n                break\n\n            target_region = max(regions, key=regions.get)\n            total_walls += len(walls[target_region])\n\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                            if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 0:\n                                isInfected[x][y] = 1\n\n            for wall in walls[target_region]:\n                i1, j1, i2, j2 = wall\n                if i1 == i2:\n                    isInfected[i1][j1] = -1\n                    isInfected[i2][j2] = -1\n                else:\n                    isInfected[i1][j1] = -1\n                    isInfected[i2][j2] = -1\n\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == -1:\n                        isInfected[i][j] = 1\n\n        return total_walls",
            "runtimes": [
                0.013116836547851562,
                0.014129877090454102,
                0.02417135238647461,
                0.031553030014038086,
                0.05537056922912598,
                0.21697640419006348
            ],
            "beyond_p": 0.0
        }
    ],
    "longest-increasing-path-in-a-matrix": [
        {
            "slug_name": "longest-increasing-path-in-a-matrix",
            "result": {
                "result": "passed",
                "runtime": 0.0011169910430908203,
                "index": 0
            },
            "solution": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        def dfs(i, j):\n            if not dp[i][j]:\n                val = matrix[i][j]\n                dp[i][j] = 1 + max(\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\n                    dfs(i + 1, j) if i < m - 1 and val > matrix[i + 1][j] else 0,\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\n                    dfs(i, j + 1) if j < n - 1 and val > matrix[i][j + 1] else 0\n                )\n            return dp[i][j]\n\n        if not matrix or not matrix[0]:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        return max(dfs(x, y) for x in range(m) for y in range(n))\n\n# Example usage:\nsol = Solution()\nexample_matrix = [[9,9,4],[6,6,8],[2,1,1]]\nprint(sol.longestIncreasingPath(example_matrix))  # Output: 4",
            "runtimes": [
                0.0010676383972167969,
                0.0011353492736816406,
                0.0011467933654785156,
                0.0012142658233642578,
                0.0012292861938476562,
                0.0012557506561279297,
                0.0012900829315185547,
                0.0013549327850341797,
                0.0013625621795654297,
                0.001377105712890625,
                0.001434326171875,
                0.0014851093292236328,
                0.0015287399291992188,
                0.0015621185302734375,
                0.0017189979553222656,
                0.0017459392547607422,
                0.0019936561584472656,
                0.0019991397857666016,
                0.0021805763244628906,
                0.002274036407470703,
                0.002330303192138672,
                0.0024111270904541016,
                0.0030374526977539062,
                0.0032253265380859375,
                0.0033080577850341797,
                0.003929853439331055,
                0.0045588016510009766,
                0.005865335464477539,
                0.008450508117675781,
                0.014436483383178711,
                0.02266860008239746
            ],
            "beyond_p": 0.9977152570059933
        }
    ],
    "number-of-digit-one": [
        {
            "slug_name": "number-of-digit-one",
            "result": {
                "result": "passed",
                "runtime": 0.0002853870391845703,
                "index": 0
            },
            "solution": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ones_count = 0\n        m = 1\n        while m <= n:\n            a = n // m\n            b = n % m\n            ones_count += (a + 8) // 10 * m + (a % 10 == 1) * (b + 1)\n            m *= 10\n        return ones_count\n\n# Example usage:\n# sol = Solution()\n# print(sol.countDigitOne(13))  # Output: 6\n# print(sol.countDigitOne(0))   # Output: 0",
            "runtimes": [
                0.00027370452880859375,
                0.0003135204315185547,
                0.0003185272216796875,
                0.0003211498260498047,
                0.0003247261047363281,
                0.00033092498779296875,
                0.0003876686096191406,
                0.0003910064697265625,
                0.0004115104675292969,
                0.0010297298431396484,
                0.0010800361633300781
            ],
            "beyond_p": 0.985511531638084
        }
    ],
    "word-break-ii": [
        {
            "slug_name": "word-break-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0006279945373535156,
                "index": 0
            },
            "solution": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        def canBreak(start, end, wordSet):\n            if start == end:\n                return True\n            return s[start:end] in wordSet\n\n        def backtrack(start, path):\n            if start == len(s):\n                results.append(' '.join(path))\n                return\n            for end in range(start + 1, len(s) + 1):\n                if canBreak(start, end, wordSet):\n                    backtrack(end, path + [s[start:end]])\n\n        wordSet = set(wordDict)\n        results = []\n        backtrack(0, [])\n        return results\n\n# Example usage:\n# sol = Solution()\n# print(sol.wordBreak(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]))\n# Output: [\"cats and dog\",\"cat sand dog\"]",
            "runtimes": [
                0.0006136894226074219,
                0.0006864070892333984,
                0.0007050037384033203,
                0.0007543563842773438,
                0.0017774105072021484,
                0.001926422119140625,
                0.0020699501037597656,
                0.002379894256591797,
                0.0023813247680664062,
                0.0024361610412597656,
                0.002759695053100586,
                0.004151821136474609,
                0.006429433822631836,
                0.021004438400268555
            ],
            "beyond_p": 0.9992984507453961
        }
    ],
    "binary-tree-zigzag-level-order-traversal": [
        {
            "slug_name": "binary-tree-zigzag-level-order-traversal",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "if not root:\n            return []\n\n        result, level, direction = [], [root], 1\n\n        while level:\n            current_level_values = [node.val for node in level]\n            result.append(current_level_values[::direction])\n            direction *= -1\n            next_level = []\n            for node in level:\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            level = next_level\n\n        return result",
            "runtimes": [
                0.0060939788818359375,
                0.0070688724517822266,
                0.007366657257080078,
                0.007780551910400391,
                0.008209228515625,
                0.010788917541503906,
                0.013276815414428711,
                0.018543243408203125,
                0.025017976760864258,
                0.03270888328552246
            ],
            "beyond_p": 0.0
        }
    ],
    "binary-watch": [
        {
            "slug_name": "binary-watch",
            "result": {
                "result": "passed",
                "runtime": 0.0018661022186279297,
                "index": 0
            },
            "solution": "import itertools\n\nclass Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        if turnedOn < 0 or turnedOn > 8:\n            return []\n\n        def bit_count(n):\n            count = 0\n            while n:\n                n &= n - 1\n                count += 1\n            return count\n\n        times = []\n        for h in range(12):\n            for m in range(60):\n                if bit_count(h) + bit_count(m) == turnedOn:\n                    times.append(f'{h}:{m:02d}')\n        return times\n\n# Example usage:\n# sol = Solution()\n# print(sol.readBinaryWatch(1))\n# Output: ['0:01', '0:02', '0:04', '0:08', '0:16', '0:32', '1:00', '2:00', '4:00', '8:00']",
            "runtimes": [
                0.002008676528930664,
                0.0023772716522216797,
                0.002412080764770508,
                0.0024263858795166016,
                0.003459453582763672,
                0.003641366958618164,
                0.004479646682739258,
                0.004759550094604492
            ],
            "beyond_p": 1.0518287398162594
        }
    ],
    "pascals-triangle": [
        {
            "slug_name": "pascals-triangle",
            "result": {
                "result": "passed",
                "runtime": 0.0003139972686767578,
                "index": 0
            },
            "solution": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        pascal_triangle = []\n        for i in range(numRows):\n            row = [1] * (i + 1)\n            for j in range(1, i):\n                row[j] = pascal_triangle[i-1][j-1] + pascal_triangle[i-1][j]\n            pascal_triangle.append(row)\n        return pascal_triangle",
            "runtimes": [
                0.0003199577331542969,
                0.0003261566162109375,
                0.0003504753112792969,
                0.00035500526428222656,
                0.0003566741943359375,
                0.0003619194030761719,
                0.00036644935607910156,
                0.00036907196044921875,
                0.0003693103790283203,
                0.0004024505615234375,
                0.0004317760467529297,
                0.00043511390686035156,
                0.00043582916259765625,
                0.00048470497131347656,
                0.0005133152008056641
            ],
            "beyond_p": 1.030826140567201
        }
    ],
    "power-of-three": [
        {
            "slug_name": "power-of-three",
            "result": {
                "result": "passed",
                "runtime": 0.000263214111328125,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        # The maximum power of 3 value that\n        # integer can hold is 3^19 = 1162261467\n        # since 3^20 is bigger than int\n        return n > 0 and 1162261467 % n == 0\n\n# Example usage:\n# sol = Solution()\n# print(sol.isPowerOfThree(27))  # Output: true\n# print(sol.isPowerOfThree(0))   # Output: false\n# print(sol.isPowerOfThree(-1))  # Output: false",
            "runtimes": [
                0.0002608299255371094,
                0.00026488304138183594,
                0.00027060508728027344,
                0.00027942657470703125,
                0.0002899169921875,
                0.0002982616424560547,
                0.0002987384796142578,
                0.00030493736267089844,
                0.000308990478515625,
                0.0003094673156738281,
                0.00031566619873046875,
                0.0003170967102050781,
                0.0003230571746826172,
                0.0003268718719482422,
                0.0003285408020019531,
                0.00041675567626953125,
                0.0004227161407470703,
                0.0004601478576660156,
                0.006712198257446289,
                0.04853510856628418
            ],
            "beyond_p": 0.9999506116744123
        }
    ],
    "binary-tree-maximum-path-sum": [
        {
            "slug_name": "binary-tree-maximum-path-sum",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "def max_gain(node):\n            nonlocal max_sum\n            if not node:\n                return 0\n\n            # Recursively call max_gain on node's left and right children\n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n\n            # Price to start a new path where 'node' is the highest node\n            price_newpath = node.val + left_gain + right_gain\n\n            # Update max_sum if it's better to start a new path\n            max_sum = max(max_sum, price_newpath)\n\n            # For recursion :\n            # Return the max gain if continue the same path\n            return node.val + max(left_gain, right_gain)\n\n        max_sum = float('-inf')\n        max_gain(root)\n        return max_sum",
            "runtimes": [
                0.0017552375793457031,
                0.001886129379272461,
                0.0018939971923828125,
                0.0019023418426513672,
                0.0019366741180419922,
                0.0019922256469726562,
                0.0020058155059814453,
                0.0020599365234375,
                0.0021126270294189453,
                0.0021429061889648438,
                0.0021514892578125,
                0.0022497177124023438,
                0.004145622253417969,
                0.004219770431518555,
                0.0058863162994384766,
                0.0069081783294677734,
                0.007811546325683594,
                0.014956951141357422,
                0.020267724990844727,
                0.021864652633666992,
                0.025827407836914062
            ],
            "beyond_p": 0.0
        }
    ],
    "trapping-rain-water-ii": [
        {
            "slug_name": "trapping-rain-water-ii",
            "result": {
                "result": "passed",
                "runtime": 0.00577545166015625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        import heapq\n\n        if not heightMap or not heightMap[0]:\n            return 0\n\n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        heap = []\n\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        water = 0\n\n        while heap:\n            height, x, y = heapq.heappop(heap)\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    water += max(0, height - heightMap[nx][ny])\n                    visited[nx][ny] = True\n                    heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny))\n\n        return water\n\n# Example usage:\n# sol = Solution()\n# print(sol.trapRainWater([[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]))  # Output: 4\n# print(sol.trapRainWater([[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]))  # Output: 10",
            "runtimes": [
                0.005023479461669922,
                0.005322933197021484,
                0.006644725799560547,
                0.008264541625976562,
                0.008470773696899414,
                0.009891033172607422,
                0.01196742057800293,
                0.013256549835205078,
                0.013418197631835938,
                0.013926267623901367,
                0.015212297439575195,
                0.02031087875366211,
                0.03597545623779297,
                0.03951120376586914,
                0.039949655532836914,
                0.06111502647399902,
                0.07931876182556152
            ],
            "beyond_p": 0.9898786009749148
        }
    ],
    "valid-palindrome": [
        {
            "slug_name": "valid-palindrome",
            "result": {
                "result": "passed",
                "runtime": 0.0005161762237548828,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # Convert to lowercase and remove non-alphanumeric characters\n        filtered_chars = [c.lower() for c in s if c.isalnum()]\n        # Check if the filtered string is a palindrome\n        return filtered_chars == filtered_chars[::-1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.isPalindrome(\"A man, a plan, a canal: Panama\"))  # Output: true\n# print(sol.isPalindrome(\"race a car\"))  # Output: false\n# print(sol.isPalindrome(\" \"))  # Output: true",
            "runtimes": [
                0.0004353523254394531,
                0.0004677772521972656,
                0.00046896934509277344,
                0.000484466552734375,
                0.0004901885986328125,
                0.0004942417144775391,
                0.0004961490631103516,
                0.0004994869232177734,
                0.000499725341796875,
                0.0005002021789550781,
                0.0005011558532714844,
                0.0005016326904296875,
                0.0005021095275878906,
                0.0005104541778564453,
                0.0005176067352294922,
                0.0005292892456054688,
                0.0005435943603515625,
                0.000568389892578125,
                0.0005781650543212891,
                0.0006496906280517578,
                0.0007123947143554688,
                0.00680994987487793,
                0.007104396820068359,
                0.023021221160888672
            ],
            "beyond_p": 0.9964214837647257
        }
    ],
    "sliding-window-median": [
        {
            "slug_name": "sliding-window-median",
            "result": {
                "result": "passed",
                "runtime": 0.007897615432739258,
                "index": 0
            },
            "solution": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        from sortedcontainers import SortedList\n        window = SortedList()\n        result = []\n        for i in range(len(nums)):\n            if i >= k:\n                window.remove(nums[i-k])\n            window.add(nums[i])\n            if i >= k - 1:\n                if k % 2 == 0:\n                    median = (window[k//2 - 1] + window[k//2]) / 2.0\n                else:\n                    median = window[k//2]\n                result.append(float(median))\n        return result",
            "runtimes": [
                0.0013074874877929688,
                0.0014622211456298828,
                0.0021131038665771484,
                0.0023124217987060547,
                0.0025026798248291016,
                0.0026865005493164062,
                0.002734661102294922,
                0.0028121471405029297,
                0.003813505172729492,
                0.004326581954956055,
                0.0046863555908203125,
                0.006307125091552734,
                0.008610010147094727,
                0.008728981018066406,
                0.011841773986816406,
                0.02918386459350586,
                0.03610706329345703,
                0.062288522720336914,
                0.21880507469177246
            ],
            "beyond_p": 0.9697002250477117
        }
    ],
    "rotate-list": [
        {
            "slug_name": "rotate-list",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "if not head or not head.next or k == 0:\n            return head\n\n        # Find the length of the linked list\n        length = 1\n        current = head\n        while current.next:\n            current = current.next\n            length += 1\n\n        # Make the linked list circular\n        current.next = head\n\n        # Find the new head after rotation\n        k = k % length\n        steps_to_new_head = length - k\n        new_tail = head\n        for _ in range(steps_to_new_head - 1):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n\n        # Break the circle\n        new_tail.next = None\n\n        return new_head",
            "runtimes": [
                0.0004603862762451172,
                0.0004680156707763672,
                0.00047016143798828125,
                0.0004742145538330078,
                0.0004761219024658203,
                0.0004858970642089844,
                0.0005803108215332031,
                0.0006005764007568359,
                0.0006182193756103516,
                0.0006759166717529297,
                0.0007162094116210938,
                0.0007483959197998047,
                0.003167867660522461,
                0.015458345413208008
            ],
            "beyond_p": 0.0
        }
    ],
    "ugly-number": [
        {
            "slug_name": "ugly-number",
            "result": {
                "result": "passed",
                "runtime": 0.00026035308837890625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        for p in [2, 3, 5]:\n            while n % p == 0:\n                n //= p\n        return n == 1",
            "runtimes": [
                0.00026679039001464844,
                0.000278472900390625,
                0.00028014183044433594,
                0.00029540061950683594,
                0.00029778480529785156,
                0.0003046989440917969,
                0.00031447410583496094,
                0.0003161430358886719,
                0.0003161430358886719,
                0.0003197193145751953,
                0.0003254413604736328,
                0.00033664703369140625,
                0.0003647804260253906,
                0.0004093647003173828,
                0.03311967849731445
            ],
            "beyond_p": 1.0001959432490293
        }
    ],
    "falling-squares": [
        {
            "slug_name": "falling-squares",
            "result": {
                "result": "passed",
                "runtime": 0.0007979869842529297,
                "index": 0
            },
            "solution": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        # Initialize the list to store the height after each drop\n        heights = []\n        # Initialize the list to store the current state of the squares\n        squares = []\n\n        # Iterate through each position\n        for left, size in positions:\n            right = left + size\n            current_height = 0\n\n            # Check each previously placed square\n            for prev_left, prev_right, prev_height in squares:\n                # If the current square intersects with a previous square\n                if left < prev_right and right > prev_left:\n                    # Update the current height if necessary\n                    current_height = max(current_height, prev_height)\n\n            # The new height is the current height plus the size of the new square\n            new_height = current_height + size\n            # Add the new square to the list of squares\n            squares.append((left, right, new_height))\n            # Add the new height to the list of heights\n            heights.append(max(heights[-1], new_height) if heights else new_height)\n\n        # Return the list of heights after each drop\n        return heights",
            "runtimes": [
                0.0007112026214599609,
                0.0013740062713623047,
                0.0016667842864990234,
                0.003782987594604492,
                0.004166364669799805,
                0.004419565200805664,
                0.004912614822387695,
                0.005444049835205078,
                0.015162229537963867,
                0.04010128974914551,
                0.04245448112487793
            ],
            "beyond_p": 0.997920997920998
        }
    ],
    "sum-of-left-leaves": [
        {
            "slug_name": "sum-of-left-leaves",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Helper function to check if a node is a leaf node\n        def is_leaf(node):\n            return node is not None and node.left is None and node.right is None\n\n        # Recursive function to find sum of left leaves\n        def find_sum_of_left_leaves(node, is_left):\n            if node is None:\n                return 0\n            if is_leaf(node) and is_left:\n                return node.val\n            return find_sum_of_left_leaves(node.left, True) + find_sum_of_left_leaves(node.right, False)\n\n        # Call the recursive function starting with the root node\n        return find_sum_of_left_leaves(root, False)",
            "runtimes": [
                0.0020418167114257812,
                0.0020704269409179688,
                0.00225067138671875,
                0.0022535324096679688,
                0.0022704601287841797,
                0.002308368682861328,
                0.002330780029296875,
                0.002505779266357422,
                0.005128383636474609,
                0.009685754776000977,
                0.02059316635131836,
                0.020758867263793945
            ],
            "beyond_p": 0.0
        }
    ],
    "max-sum-of-rectangle-no-larger-than-k": [
        {
            "slug_name": "max-sum-of-rectangle-no-larger-than-k",
            "result": {
                "result": "passed",
                "runtime": 0.0012135505676269531,
                "index": 0
            },
            "solution": "import bisect\n\nclass Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        def maxSumSublist(vals):\n            max_sum = float('-inf')\n            prefix_sum = 0\n            prefix_sums = [float('inf')]\n            for val in vals:\n                bisect.insort(prefix_sums, prefix_sum)\n                prefix_sum += val\n                i = bisect.bisect_left(prefix_sums, prefix_sum - k)\n                max_sum = max(max_sum, prefix_sum - prefix_sums[i])\n            return max_sum\n\n        rows, cols = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        for left in range(cols):\n            row_sums = [0] * rows\n            for right in range(left, cols):\n                for i in range(rows):\n                    row_sums[i] += matrix[i][right]\n                max_sum = max(max_sum, maxSumSublist(row_sums))\n                if max_sum == k:\n                    return k\n        return max_sum\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxSumSubmatrix([[1,0,1],[0,-2,3]], 2))  # Output: 2\n# print(sol.maxSumSubmatrix([[2,2,-1]], 3))  # Output: 3",
            "runtimes": [
                0.0011110305786132812,
                0.0011801719665527344,
                0.0012738704681396484,
                0.0012912750244140625,
                0.001340627670288086,
                0.0016093254089355469,
                0.0016465187072753906,
                0.0017299652099609375,
                0.0021665096282958984,
                0.0032644271850585938,
                0.0037431716918945312,
                0.004067897796630859,
                0.004286527633666992,
                0.004746913909912109,
                0.007211208343505859
            ],
            "beyond_p": 0.9831939341827562
        }
    ],
    "divide-two-integers": [
        {
            "slug_name": "divide-two-integers",
            "result": {
                "result": "passed",
                "runtime": 0.00027441978454589844,
                "index": 0
            },
            "solution": "class Solution(object):\n    def divide(self, dividend, divisor):\n        # Constants for the 32-bit signed integer range\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        # Handling overflow and underflow\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n\n        # Determine the sign of the result\n        negative = (dividend < 0) != (divisor < 0)\n\n        # Work with positive values to avoid overflow issues\n        dividend, divisor = abs(dividend), abs(divisor)\n\n        # Initialize the quotient\n        quotient = 0\n\n        # Subtract the divisor from the dividend until dividend is less than divisor\n        while dividend >= divisor:\n            # Initialize power of two and value\n            power_of_two = 1\n            value = divisor\n            while value <= dividend >> 1:\n                value <<= 1\n                power_of_two <<= 1\n            # Subtract the value from the dividend\n            dividend -= value\n            # Add the power of two to the quotient\n            quotient += power_of_two\n\n        # Adjust the sign of the quotient\n        return -quotient if negative else quotient\n\n# Example usage:\n# sol = Solution()\n# print(sol.divide(10, 3))  # Output: 3\n# print(sol.divide(7, -3)) # Output: -2",
            "runtimes": [
                0.0002338886260986328,
                0.0002396106719970703,
                0.000240325927734375,
                0.00024247169494628906,
                0.00024271011352539062,
                0.0002639293670654297,
                0.00026607513427734375,
                0.00027108192443847656,
                0.0002713203430175781,
                0.0002734661102294922,
                0.00028395652770996094,
                0.00029277801513671875,
                0.00029349327087402344,
                0.0003094673156738281,
                0.0003352165222167969
            ],
            "beyond_p": 0.6
        }
    ],
    "surrounded-regions": [
        {
            "slug_name": "surrounded-regions",
            "result": {
                "result": "passed",
                "runtime": 0.0005686283111572266,
                "index": 0
            },
            "solution": "class Solution(object):\n    def solve(self, board):\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'E'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        if not board or not board[0]:\n            return\n\n        m, n = len(board), len(board[0])\n\n        for i in range(m):\n            if board[i][0] == 'O':\n                dfs(i, 0)\n            if board[i][n - 1] == 'O':\n                dfs(i, n - 1)\n\n        for j in range(n):\n            if board[0][j] == 'O':\n                dfs(0, j)\n            if board[m - 1][j] == 'O':\n                dfs(m - 1, j)\n\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'E':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'\n\n# Example usage:\n# board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n# Solution().solve(board)\n# print(board)  # Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
            "runtimes": [
                0.00047326087951660156,
                0.00047969818115234375,
                0.0005137920379638672,
                0.0005335807800292969,
                0.0005595684051513672,
                0.0005669593811035156,
                0.0005676746368408203,
                0.0005702972412109375,
                0.0005800724029541016,
                0.0006232261657714844,
                0.0006451606750488281,
                0.0006499290466308594,
                0.0006806850433349609,
                0.0007002353668212891,
                0.0007021427154541016,
                0.0007102489471435547,
                0.0007176399230957031,
                0.0008563995361328125,
                0.0009829998016357422,
                0.0018482208251953125,
                0.003092527389526367
            ],
            "beyond_p": 0.9635900236664846
        }
    ],
    "two-sum": [
        {
            "slug_name": "two-sum",
            "result": {
                "result": "passed",
                "runtime": 0.0002741813659667969,
                "index": 0
            },
            "solution": "class Solution(object):\n    def twoSum(self, nums, target):\n        num_to_index = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_to_index:\n                return [num_to_index[complement], i]\n            num_to_index[num] = i\n        return []",
            "runtimes": [
                0.00026607513427734375,
                0.00026798248291015625,
                0.0002720355987548828,
                0.0002753734588623047,
                0.00028634071350097656,
                0.0002949237823486328,
                0.0002989768981933594,
                0.00029969215393066406,
                0.0003039836883544922,
                0.00030422210693359375,
                0.0003070831298828125,
                0.00030922889709472656,
                0.00031375885009765625,
                0.00031757354736328125,
                0.00032520294189453125,
                0.0003275871276855469,
                0.00032806396484375,
                0.0003314018249511719,
                0.00037360191345214844,
                0.00038433074951171875
            ],
            "beyond_p": 0.9314516129032258
        }
    ],
    "24-game": [
        {
            "slug_name": "24-game",
            "result": {
                "result": "passed",
                "runtime": 2.042137384414673,
                "index": 0
            },
            "solution": "import itertools\n\nclass Solution(object):\n    def judgePoint24(self, cards):\n        def calculate(a, b, op):\n            if op == '+': return a + b\n            if op == '-': return a - b\n            if op == '*': return a * b\n            if op == '/':\n                if b == 0: return float('inf')\n                return a / b\n\n        def search(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n\n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        for op in '+-*/':\n                            if (op != '/' or nums[j] != 0):\n                                next_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                                next_nums.append(calculate(nums[i], nums[j], op))\n                                if search(next_nums):\n                                    return True\n            return False\n\n        for nums in itertools.permutations(cards):\n            if search(list(nums)):\n                return True\n        return False\n\n# Example usage:\nsol = Solution()\nprint(sol.judgePoint24([4, 1, 8, 7]))  # Output: true\nprint(sol.judgePoint24([1, 2, 1, 2]))  # Output: false",
            "runtimes": [
                0.006315469741821289,
                0.007641792297363281,
                0.019613265991210938,
                0.030678510665893555,
                0.0681917667388916,
                0.07040023803710938,
                0.14607930183410645,
                0.1822986602783203,
                0.18714213371276855,
                0.21024155616760254,
                0.22219514846801758
            ],
            "beyond_p": 0.0
        }
    ],
    "wildcard-matching": [
        {
            "slug_name": "wildcard-matching",
            "result": {
                "result": "passed",
                "runtime": 2.654797077178955,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n\n        return dp[len(s)][len(p)]\n\n# Example usage:\n# sol = Solution()\n# print(sol.isMatch(\"aa\", \"a\"))  # Output: false\n# print(sol.isMatch(\"aa\", \"*\"))  # Output: true\n# print(sol.isMatch(\"cb\", \"?a\"))  # Output: false",
            "runtimes": [
                0.00028014183044433594,
                0.00029206275939941406,
                0.00032591819763183594,
                0.00034308433532714844,
                0.00035452842712402344,
                0.00038886070251464844,
                0.0003910064697265625,
                0.0004248619079589844,
                0.0004968643188476562,
                0.0007326602935791016,
                0.0008206367492675781,
                0.012713432312011719,
                0.05035066604614258,
                0.09277796745300293,
                1.4826862812042236,
                2.354625701904297,
                2.718961000442505,
                2.8765149116516113,
                3.0705769062042236,
                3.4197838306427,
                3.6573522090911865,
                6.033223390579224
            ],
            "beyond_p": 0.5599963689532381
        }
    ],
    "majority-element": [
        {
            "slug_name": "majority-element",
            "result": {
                "result": "passed",
                "runtime": 0.0003590583801269531,
                "index": 0
            },
            "solution": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        candidate = None\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n\n        return candidate",
            "runtimes": [
                0.00032019615173339844,
                0.00032401084899902344,
                0.0003418922424316406,
                0.0003657341003417969,
                0.0003666877746582031,
                0.0003726482391357422,
                0.00037598609924316406,
                0.0003783702850341797,
                0.00038123130798339844,
                0.0004391670227050781,
                0.0004398822784423828,
                0.0004401206970214844,
                0.0004494190216064453,
                0.0004520416259765625,
                0.0004892349243164062,
                0.0004899501800537109,
                0.0004973411560058594,
                0.0005471706390380859,
                0.0009469985961914062,
                0.0031583309173583984,
                0.003501415252685547,
                0.01236724853515625
            ],
            "beyond_p": 0.9967741297076926
        }
    ],
    "reconstruct-itinerary": [
        {
            "slug_name": "reconstruct-itinerary",
            "result": {
                "result": "passed",
                "runtime": 0.00029587745666503906,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findItinerary(self, tickets):\n        from collections import defaultdict\n        import heapq\n\n        def visit(airport):\n            while graph[airport]:\n                next_airport = heapq.heappop(graph[airport])\n                visit(next_airport)\n            itinerary.append(airport)\n\n        graph = defaultdict(list)\n        for depart, arrive in sorted(tickets)[::-1]:\n            graph[depart].append(arrive)\n\n        for key in graph.keys():\n            heapq.heapify(graph[key])\n\n        itinerary = []\n        visit('JFK')\n        return itinerary[::-1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.findItinerary([['MUC','LHR'],['JFK','MUC'],['SFO','SJC'],['LHR','SFO']]))\n# Output: ['JFK', 'MUC', 'LHR', 'SFO', 'SJC']\n# print(sol.findItinerary([['JFK','SFO'],['JFK','ATL'],['SFO','ATL'],['ATL','JFK'],['ATL','SFO']]))\n# Output: ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']",
            "runtimes": [
                0.00028324127197265625,
                0.0002906322479248047,
                0.0003285408020019531,
                0.0003380775451660156,
                0.00039267539978027344,
                0.00039768218994140625,
                0.0004000663757324219,
                0.0004172325134277344,
                0.0004222393035888672,
                0.00044608116149902344,
                0.0004496574401855469,
                0.00045108795166015625,
                0.00048661231994628906,
                0.0005586147308349609,
                0.006811618804931641,
                0.013118982315063477,
                0.013756752014160156
            ],
            "beyond_p": 0.9990621460928653
        }
    ],
    "4sum": [
        {
            "slug_name": "4sum",
            "result": {
                "result": "passed",
                "runtime": 0.3487675189971924,
                "index": 0
            },
            "solution": "class Solution(object):\n    def fourSum(self, nums, target):\n        nums.sort()\n        result = []\n        length = len(nums)\n        for i in range(length - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, length - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, length - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total < target:\n                        left += 1\n                    elif total > target:\n                        right -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.fourSum([1,0,-1,0,-2,2], 0))\n# print(sol.fourSum([2,2,2,2,2], 8))",
            "runtimes": [
                0.08402514457702637,
                0.18034744262695312,
                0.19585585594177246,
                0.20441985130310059,
                0.21315240859985352,
                0.21821951866149902,
                0.21830153465270996,
                0.2860283851623535,
                0.3262155055999756,
                0.3413088321685791,
                0.42144155502319336,
                0.44643712043762207,
                0.5308570861816406,
                0.5626683235168457,
                0.5718767642974854
            ],
            "beyond_p": 0.45733013129716676
        }
    ],
    "the-skyline-problem": [
        {
            "slug_name": "the-skyline-problem",
            "result": {
                "result": "passed",
                "runtime": 0.0007557868957519531,
                "index": 0
            },
            "solution": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        # Define the events\n        events = []\n        for l, r, h in buildings:\n            events.append((l, -h, r))\n            events.append((r, 0, 0))\n        events.sort()\n\n        # Use a heap to maintain the max height\n        import heapq\n        heap = [(0, float('inf'))] # (height, right)\n        result = [[0, 0]]\n\n        for x, negH, R in events:\n            while heap[0][1] <= x:\n                heapq.heappop(heap)\n            if negH:\n                heapq.heappush(heap, (negH, R))\n            if result[-1][1] != -heap[0][0]:\n                result.append([x, -heap[0][0]])\n\n        # Remove the initial dummy result\n        return result[1:]",
            "runtimes": [
                0.0005965232849121094,
                0.0006158351898193359,
                0.000789642333984375,
                0.0008194446563720703,
                0.0009546279907226562,
                0.000995635986328125,
                0.0010769367218017578,
                0.0013685226440429688,
                0.0013897418975830078,
                0.002351999282836914,
                0.002530813217163086,
                0.0026161670684814453,
                0.002752542495727539,
                0.0031414031982421875,
                0.003535747528076172,
                0.003742218017578125,
                0.00408482551574707,
                0.004161357879638672
            ],
            "beyond_p": 0.9553237025147138
        }
    ],
    "reverse-string": [
        {
            "slug_name": "reverse-string",
            "result": {
                "result": "passed",
                "runtime": 0.00047016143798828125,
                "index": 0
            },
            "solution": "class Solution(object):\n    def reverseString(self, s):\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n\n# Example usage:\n# s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n# Solution().reverseString(s)\n# print(s)  # Output: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\n# s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n# Solution().reverseString(s)\n# print(s)  # Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
            "runtimes": [
                0.0002498626708984375,
                0.00030231475830078125,
                0.0003063678741455078,
                0.0003085136413574219,
                0.0003139972686767578,
                0.0003681182861328125,
                0.0004096031188964844,
                0.000446319580078125,
                0.00045752525329589844,
                0.0004603862762451172,
                0.00046253204345703125,
                0.0004634857177734375,
                0.0004673004150390625,
                0.0004813671112060547,
                0.0004994869232177734,
                0.0005006790161132812,
                0.0005125999450683594,
                0.0005729198455810547,
                0.0006635189056396484,
                0.0006792545318603516,
                0.0006892681121826172,
                0.000759124755859375,
                0.0008938312530517578
            ],
            "beyond_p": 0.6579044798222881
        }
    ],
    "reverse-linked-list": [
        {
            "slug_name": "reverse-linked-list",
            "result": {
                "result": "passed",
                "runtime": 0.00037479400634765625,
                "index": 0
            },
            "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Iterative approach\n        prev = None\n        current = head\n        while current:\n            next_temp = current.next\n            current.next = prev\n            prev = current\n            current = next_temp\n        return prev\n\n    # Recursive approach\n    def reverseListRecursive(self, head):\n        if head is None or head.next is None:\n            return head\n        p = self.reverseListRecursive(head.next)\n        head.next.next = head\n        head.next = None\n        return p",
            "runtimes": [
                0.0003104209899902344,
                0.00031280517578125,
                0.00031304359436035156,
                0.0003292560577392578,
                0.0003457069396972656,
                0.0003542900085449219,
                0.00035691261291503906,
                0.0003604888916015625,
                0.0003604888916015625,
                0.00036215782165527344,
                0.00036716461181640625,
                0.0003757476806640625,
                0.00038170814514160156,
                0.00039076805114746094,
                0.0004456043243408203
            ],
            "beyond_p": 0.5238095238095238
        }
    ],
    "triangle": [
        {
            "slug_name": "triangle",
            "result": {
                "result": "passed",
                "runtime": 0.00040531158447265625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Start from the second last row and move upwards\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(len(triangle[row])):\n                # Update the current value to the minimum path sum of the two adjacent numbers in the row below\n                triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n        # The top element will have the minimum path sum\n        return triangle[0][0]\n\n# Example usage:\n# sol = Solution()\n# print(sol.minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]]))  # Output: 11\n# print(sol.minimumTotal([[-10]]))  # Output: -10",
            "runtimes": [
                0.0003573894500732422,
                0.0003573894500732422,
                0.0003657341003417969,
                0.00036907196044921875,
                0.000385284423828125,
                0.0004010200500488281,
                0.0004096031188964844,
                0.0004153251647949219,
                0.00042366981506347656,
                0.00042891502380371094,
                0.00047898292541503906,
                0.0004856586456298828,
                0.0005130767822265625,
                0.0005445480346679688,
                0.0005533695220947266,
                0.0006275177001953125,
                0.0006453990936279297,
                0.0020034313201904297,
                0.0020723342895507812,
                0.024411916732788086
            ],
            "beyond_p": 0.9980077706854855
        }
    ],
    "integer-to-english-words": [
        {
            "slug_name": "integer-to-english-words",
            "result": {
                "result": "passed",
                "runtime": 0.00037479400634765625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def numberToWords(self, num):\n        if num == 0: return 'Zero'\n\n        def one(num):\n            switcher = {\n                1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five',\n                6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'\n            }\n            return switcher.get(num)\n\n        def two_less_20(num):\n            switcher = {\n                10: 'Ten', 11: 'Eleven', 12: 'Twelve', 13: 'Thirteen', 14: 'Fourteen',\n                15: 'Fifteen', 16: 'Sixteen', 17: 'Seventeen', 18: 'Eighteen', 19: 'Nineteen'\n            }\n            return switcher.get(num)\n\n        def ten(num):\n            switcher = {\n                2: 'Twenty', 3: 'Thirty', 4: 'Forty', 5: 'Fifty',\n                6: 'Sixty', 7: 'Seventy', 8: 'Eighty', 9: 'Ninety'\n            }\n            return switcher.get(num)\n\n        def two(num):\n            if not num:\n                return ''\n            elif num < 10:\n                return one(num)\n            elif num < 20:\n                return two_less_20(num)\n            else:\n                tenner = num // 10\n                rest = num - tenner * 10\n                return ten(tenner) + ' ' + one(rest) if rest else ten(tenner)\n\n        def three(num):\n            hundred = num // 100\n            rest = num - hundred * 100\n            if hundred and rest:\n                return one(hundred) + ' Hundred ' + two(rest)\n            elif not hundred and rest:\n                return two(rest)\n            elif hundred and not rest:\n                return one(hundred) + ' Hundred'\n\n        billion = num // 1000000000\n        million = (num - billion * 1000000000) // 1000000\n        thousand = (num - billion * 1000000000 - million * 1000000) // 1000\n        remainder = num - billion * 1000000000 - million * 1000000 - thousand * 1000\n\n        result = ''\n        if billion:\n            result = three(billion) + ' Billion'\n        if million:\n            result += ' ' if result else ''\n            result += three(million) + ' Million'\n        if thousand:\n            result += ' ' if result else ''\n            result += three(thousand) + ' Thousand'\n        if remainder:\n            result += ' ' if result else ''\n            result += three(remainder)\n        return result.strip()\n\n# Example usage:\n# sol = Solution()\n# print(sol.numberToWords(123))\n# print(sol.numberToWords(12345))\n# print(sol.numberToWords(1234567))",
            "runtimes": [
                0.000286102294921875,
                0.00029349327087402344,
                0.00030732154846191406,
                0.00032901763916015625,
                0.0003390312194824219,
                0.00034046173095703125,
                0.00034046173095703125,
                0.0003426074981689453,
                0.0003440380096435547,
                0.0003476142883300781,
                0.00041985511779785156,
                0.0004489421844482422,
                0.0004673004150390625,
                0.0005390644073486328
            ],
            "beyond_p": 0.649387370405278
        }
    ],
    "k-inverse-pairs-array": [
        {
            "slug_name": "k-inverse-pairs-array",
            "result": {
                "result": "passed",
                "runtime": 0.5691595077514648,
                "index": 0
            },
            "solution": "class Solution(object):\n    def kInversePairs(self, n, k):\n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        dp[0][0] = 1\n\n        for i in range(1, n+1):\n            for j in range(k+1):\n                dp[i][j] = dp[i-1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j-1]\n                if j >= i:\n                    dp[i][j] -= dp[i-1][j-i]\n                dp[i][j] %= MOD\n\n        return dp[n][k]\n\n# Example usage:\n# sol = Solution()\n# print(sol.kInversePairs(3, 0))  # Output: 1\n# print(sol.kInversePairs(3, 1))  # Output: 2",
            "runtimes": [
                0.2027139663696289,
                0.27808189392089844,
                0.36475110054016113,
                0.36725783348083496,
                0.3695666790008545,
                0.3699972629547119,
                0.4059422016143799,
                0.443129301071167,
                0.4944291114807129,
                0.5227310657501221,
                0.5747547149658203,
                0.7030878067016602,
                0.7353472709655762,
                0.8135690689086914
            ],
            "beyond_p": 0.4001105338096071
        }
    ],
    "swap-nodes-in-pairs": [
        {
            "slug_name": "swap-nodes-in-pairs",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize a dummy node to point to the head of the list\n        dummy = ListNode(0)\n        dummy.next = head\n        # Initialize current to the dummy node\n        current = dummy\n        \n        # Loop through the list while there are at least two more nodes to swap\n        while current.next and current.next.next:\n            # Identify the nodes to swap\n            first = current.next\n            second = current.next.next\n            \n            # Swap the nodes\n            first.next = second.next\n            second.next = first\n            current.next = second\n            \n            # Move current two nodes ahead\n            current = first\n        \n        # Return the new head of the list\n        return dummy.next",
            "runtimes": [
                0.0003666877746582031,
                0.00037097930908203125,
                0.0003814697265625,
                0.0003826618194580078,
                0.0003829002380371094,
                0.0003857612609863281,
                0.0003859996795654297,
                0.00038743019104003906,
                0.0004024505615234375,
                0.00041174888610839844,
                0.00041794776916503906,
                0.0004229545593261719,
                0.00042366981506347656,
                0.0004241466522216797,
                0.0004248619079589844,
                0.0004260540008544922,
                0.0004284381866455078,
                0.0004324913024902344,
                0.0004334449768066406,
                0.0004341602325439453,
                0.0004355907440185547,
                0.00043582916259765625,
                0.00043773651123046875,
                0.00044035911560058594,
                0.0004417896270751953,
                0.0004420280456542969,
                0.0004551410675048828,
                0.00048828125,
                0.0005223751068115234,
                0.0005359649658203125,
                0.000621795654296875
            ],
            "beyond_p": 0.0
        }
    ],
    "path-sum": [
        {
            "slug_name": "path-sum",
            "result": {
                "result": "passed",
                "runtime": 0.0006115436553955078,
                "index": 0
            },
            "solution": "import json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        # Base case: if the tree is empty\n        if not root:\n            return False\n\n        # Check if we've reached a leaf node and the path sum equals targetSum\n        if not root.left and not root.right:\n            return root.val == targetSum\n\n        # Recursively check the left and right subtrees with the updated targetSum\n        return (self.hasPathSum(root.left, targetSum - root.val) or\n                self.hasPathSum(root.right, targetSum - root.val))\n\n# Example usage:\n# root = TreeNode(5)\n# root.left = TreeNode(4)\n# root.right = TreeNode(8)\n# root.left.left = TreeNode(11)\n# root.left.left.left = TreeNode(7)\n# root.left.left.right = TreeNode(2)\n# root.right.left = TreeNode(13)\n# root.right.right = TreeNode(4)\n# root.right.right.right = TreeNode(1)\n# targetSum = 22\n# solution = Solution()\n# result = solution.hasPathSum(root, targetSum)\n# print(json.dumps({'result': result}))",
            "runtimes": [
                0.0005853176116943359,
                0.0005943775177001953,
                0.0006146430969238281,
                0.0006308555603027344,
                0.0006437301635742188,
                0.000644683837890625,
                0.0006580352783203125,
                0.0006597042083740234,
                0.0006618499755859375,
                0.0006682872772216797,
                0.0006744861602783203,
                0.0006747245788574219,
                0.0006890296936035156,
                0.0006971359252929688,
                0.0007379055023193359,
                0.0007998943328857422,
                0.0008339881896972656,
                0.0008952617645263672,
                0.0009448528289794922,
                0.0019600391387939453
            ],
            "beyond_p": 0.980922650017343
        }
    ],
    "partition-list": [
        {
            "slug_name": "partition-list",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "before_head = ListNode(0)  # Dummy node for the 'before' list\n        before = before_head  # Pointer for the 'before' list\n        after_head = ListNode(0)  # Dummy node for the 'after' list\n        after = after_head  # Pointer for the 'after' list\n\n        while head:\n            if head.val < x:\n                before.next = head\n                before = before.next\n            else:\n                after.next = head\n                after = after.next\n            head = head.next\n\n        after.next = None  # Important to avoid circular references in the final list\n        before.next = after_head.next  # Connect the 'before' list with the 'after' list\n\n        return before_head.next  # The first node of the 'before' list is the new head",
            "runtimes": [
                0.0007467269897460938,
                0.0007708072662353516,
                0.0007722377777099609,
                0.0008087158203125,
                0.0008208751678466797,
                0.0008373260498046875,
                0.0008382797241210938,
                0.0008411407470703125,
                0.0008411407470703125,
                0.0008647441864013672,
                0.00087738037109375,
                0.0009031295776367188,
                0.0009860992431640625,
                0.0010716915130615234,
                0.0014524459838867188,
                0.004217386245727539
            ],
            "beyond_p": 0.0
        }
    ],
    "redundant-connection-ii": [
        {
            "slug_name": "redundant-connection-ii",
            "result": {
                "result": "failed@cases",
                "runtime": 0.003009319305419922,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        parent = {}\n        candidates = []\n        for u, v in edges:\n            if v in parent:\n                candidates.append((parent[v], v))\n                candidates.append((u, v))\n            else:\n                parent[v] = u\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX == rootY:\n                return False\n            parent[rootY] = rootX\n            return True\n\n        parent = {i: i for i in range(1, len(edges) + 1)}\n        for u, v in edges:\n            if candidates and (u, v) == candidates[1]:\n                continue\n            if not union(u, v):\n                if candidates:\n                    return candidates[0]\n                return [u, v]\n\n        return candidates[1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.findRedundantDirectedConnection([[1,2],[1,3],[2,3]]))  # Output: [2,3]\n# print(sol.findRedundantDirectedConnection([[1,2],[2,3],[3,4],[4,1],[1,5]]))  # Output: [4,1]",
            "runtimes": [
                0.001476287841796875,
                0.0029206275939941406,
                0.0042209625244140625,
                0.005190610885620117,
                0.005300998687744141,
                0.005917072296142578,
                0.007894754409790039,
                0.009915351867675781,
                0.021834373474121094,
                0.06563043594360352,
                0.19962692260742188,
                0.2033405303955078,
                0.24780893325805664,
                0.503803014755249,
                8.004633665084839
            ],
            "beyond_p": 0.0
        }
    ],
    "permutations-ii": [
        {
            "slug_name": "permutations-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0015406608581542969,
                "index": 0
            },
            "solution": "class Solution(object):\n    def permuteUnique(self, nums):\n        def backtrack(first=0):\n            if first == n:\n                out = list(nums)\n                if out not in result:\n                    result.append(out)\n                return\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        nums.sort()\n        n = len(nums)\n        result = []\n        backtrack()\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.permuteUnique([1,1,2]))\n# print(sol.permuteUnique([1,2,3]))",
            "runtimes": [
                0.0003159046173095703,
                0.00031876564025878906,
                0.0003561973571777344,
                0.0003681182861328125,
                0.00037217140197753906,
                0.00039124488830566406,
                0.0004096031188964844,
                0.0004220008850097656,
                0.00042438507080078125,
                0.00044417381286621094,
                0.00047326087951660156,
                0.0004992485046386719,
                0.0005044937133789062,
                0.0005071163177490234,
                0.0005092620849609375,
                0.0005104541778564453,
                0.0005116462707519531,
                0.0005252361297607422,
                0.0006124973297119141,
                0.0045528411865234375,
                0.010063648223876953,
                0.016968250274658203
            ],
            "beyond_p": 0.9264514281623595
        }
    ],
    "add-digits": [
        {
            "slug_name": "add-digits",
            "result": {
                "result": "passed",
                "runtime": 0.0002644062042236328,
                "index": 0
            },
            "solution": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        # Follow-up: O(1) runtime solution using Digital Root concept\n        if num == 0:\n            return 0\n        elif num % 9 == 0:\n            return 9\n        else:\n            return num % 9",
            "runtimes": [
                0.00023221969604492188,
                0.0002593994140625,
                0.0002655982971191406,
                0.0002655982971191406,
                0.0002701282501220703,
                0.00028014183044433594,
                0.000286102294921875,
                0.0002887248992919922,
                0.00029087066650390625,
                0.000293731689453125,
                0.0003132820129394531,
                0.00032448768615722656,
                0.00035858154296875,
                0.0003592967987060547
            ],
            "beyond_p": 0.7467166979362101
        }
    ],
    "single-number": [
        {
            "slug_name": "single-number",
            "result": {
                "result": "passed",
                "runtime": 0.0003619194030761719,
                "index": 0
            },
            "solution": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for num in nums:\n            result ^= num\n        return result",
            "runtimes": [
                0.00039124488830566406,
                0.0004742145538330078,
                0.0004944801330566406,
                0.0005376338958740234,
                0.0005395412445068359,
                0.0005502700805664062,
                0.0005657672882080078,
                0.0006034374237060547,
                0.0006113052368164062,
                0.000621795654296875,
                0.0006468296051025391,
                0.0006504058837890625,
                0.0006651878356933594,
                0.0006692409515380859,
                0.0006844997406005859,
                0.0007319450378417969,
                0.0007586479187011719,
                0.0007710456848144531,
                0.0007905960083007812,
                0.0007910728454589844,
                0.0008187294006347656,
                0.0008313655853271484,
                0.0008373260498046875,
                0.00110626220703125
            ],
            "beyond_p": 1.0410136712237412
        }
    ],
    "length-of-last-word": [
        {
            "slug_name": "length-of-last-word",
            "result": {
                "result": "passed",
                "runtime": 0.0005464553833007812,
                "index": 0
            },
            "solution": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # Split the string into words\n        words = s.strip().split(' ')\n        # Return the length of the last word\n        return len(words[-1])\n\n# Example usage:\n# sol = Solution()\n# print(sol.lengthOfLastWord(\"Hello World\"))  # Output: 5\n# print(sol.lengthOfLastWord(\"   fly me   to   the moon  \"))  # Output: 4\n# print(sol.lengthOfLastWord(\"luffy is still joyboy\"))  # Output: 6",
            "runtimes": [
                0.000324249267578125,
                0.0004858970642089844,
                0.00048732757568359375,
                0.0005011558532714844,
                0.0005204677581787109,
                0.0005233287811279297,
                0.0005259513854980469,
                0.0005333423614501953,
                0.0005481243133544922,
                0.0005924701690673828,
                0.0006201267242431641,
                0.0006368160247802734,
                0.0007238388061523438,
                0.0018842220306396484
            ],
            "beyond_p": 0.8575576952468287
        }
    ],
    "cherry-pickup": [
        {
            "slug_name": "cherry-pickup",
            "result": {
                "result": "passed",
                "runtime": 0.035653114318847656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def cherryPickup(self, grid):\n        n = len(grid)\n        dp = [[float('-inf')] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n\n        for t in range(1, 2 * n - 1):\n            new_dp = [[float('-inf')] * n for _ in range(n)]\n            for i in range(max(0, t - n + 1), min(n, t + 1)):\n                for j in range(max(0, t - n + 1), min(n, t + 1)):\n                    if grid[i][t - i] == -1 or grid[j][t - j] == -1:\n                        continue\n                    val = grid[i][t - i]\n                    if i != j:\n                        val += grid[j][t - j]\n                    for pi in [i - 1, i]:\n                        for pj in [j - 1, j]:\n                            if pi >= 0 and pj >= 0:\n                                new_dp[i][j] = max(new_dp[i][j], dp[pi][pj] + val)\n            dp = new_dp\n\n        return max(0, dp[n - 1][n - 1])\n\n# Example usage:\n# sol = Solution()\n# print(sol.cherryPickup([[0,1,-1],[1,0,-1],[1,1,1]]))  # Output: 5\n# print(sol.cherryPickup([[1,1,-1],[1,-1,1],[-1,1,1]]))  # Output: 0",
            "runtimes": [
                0.0007960796356201172,
                0.0009248256683349609,
                0.0009622573852539062,
                0.0010972023010253906,
                0.0011913776397705078,
                0.0012950897216796875,
                0.0013704299926757812,
                0.0013842582702636719,
                0.001394033432006836,
                0.0014317035675048828,
                0.0014464855194091797,
                0.0018162727355957031,
                0.0018486976623535156,
                0.001863718032836914,
                0.00860285758972168,
                0.00870060920715332,
                0.02691936492919922,
                0.0368494987487793,
                0.04958939552307129,
                0.3406665325164795
            ],
            "beyond_p": 0.8974402323362702
        }
    ],
    "student-attendance-record-ii": [
        {
            "slug_name": "student-attendance-record-ii",
            "result": {
                "result": "passed",
                "runtime": 5.40946888923645,
                "index": 0
            },
            "solution": "class Solution(object):\n    def checkRecord(self, n):\n        MOD = 10**9 + 7\n\n        # dp[i][j][k] will be the count of valid sequences of length i\n        # where there are j A's and the last k characters are L\n        dp = [[[0] * 3 for _ in range(2)] for _ in range(n+1)]\n\n        # Base case: empty string is a valid sequence\n        dp[0][0][0] = 1\n\n        for i in range(1, n+1):\n            for j in range(2):\n                for k in range(3):\n                    # Case 1: Add a 'P' to the sequence\n                    dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][k]) % MOD\n\n                    # Case 2: Add an 'L' to the sequence\n                    if k < 2:\n                        dp[i][j][k+1] = (dp[i][j][k+1] + dp[i-1][j][k]) % MOD\n\n                    # Case 3: Add an 'A' to the sequence\n                    if j == 0:\n                        dp[i][1][0] = (dp[i][1][0] + dp[i-1][j][k]) % MOD\n\n        # Sum all valid sequences\n        result = 0\n        for j in range(2):\n            for k in range(3):\n                result = (result + dp[n][j][k]) % MOD\n\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.checkRecord(2))  # Output: 8\n# print(sol.checkRecord(1))  # Output: 3\n# print(sol.checkRecord(10101))  # Output: 183236316",
            "runtimes": [
                0.0075702667236328125,
                0.019122838973999023,
                0.31908607482910156,
                0.5606648921966553,
                1.0859956741333008,
                1.4694786071777344,
                1.8838889598846436,
                1.9633519649505615,
                2.174926519393921,
                2.6908860206604004,
                3.147930860519409,
                4.63042688369751,
                4.7908570766448975,
                5.64020562171936,
                6.129974365234375,
                7.429836750030518
            ],
            "beyond_p": 0.27220362746850896
        }
    ],
    "happy-number": [
        {
            "slug_name": "happy-number",
            "result": {
                "result": "passed",
                "runtime": 0.0003609657287597656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isHappy(self, n):\n        def get_next(number):\n            total_sum = 0\n            while number > 0:\n                number, digit = divmod(number, 10)\n                total_sum += digit ** 2\n            return total_sum\n\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n\n        return n == 1\n\n# Example usage:\n# sol = Solution()\n# print(sol.isHappy(19))  # Output: true\n# print(sol.isHappy(2))   # Output: false",
            "runtimes": [
                0.00029921531677246094,
                0.0003039836883544922,
                0.0003094673156738281,
                0.0003223419189453125,
                0.00032329559326171875,
                0.0003352165222167969,
                0.00034308433532714844,
                0.0003447532653808594,
                0.00034928321838378906,
                0.0003521442413330078,
                0.0003578662872314453,
                0.00038051605224609375,
                0.0003898143768310547,
                0.0004353523254394531,
                0.0004367828369140625,
                0.0004458427429199219,
                0.0004591941833496094,
                0.0007159709930419922
            ],
            "beyond_p": 0.8518306636155606
        }
    ],
    "search-insert-position": [
        {
            "slug_name": "search-insert-position",
            "result": {
                "result": "passed",
                "runtime": 0.0002777576446533203,
                "index": 0
            },
            "solution": "class Solution(object):\n    def searchInsert(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n# Example usage:\n# sol = Solution()\n# print(sol.searchInsert([1,3,5,6], 5))  # Output: 2\n# print(sol.searchInsert([1,3,5,6], 2))  # Output: 1\n# print(sol.searchInsert([1,3,5,6], 7))  # Output: 4",
            "runtimes": [
                0.00026798248291015625,
                0.00027632713317871094,
                0.00027751922607421875,
                0.00029969215393066406,
                0.00029969215393066406,
                0.00030231475830078125,
                0.00030231475830078125,
                0.00030303001403808594,
                0.0003037452697753906,
                0.0003046989440917969,
                0.0003056526184082031,
                0.0003063678741455078,
                0.00030803680419921875,
                0.0003085136413574219,
                0.0003120899200439453,
                0.00031280517578125,
                0.0003185272216796875,
                0.0003218650817871094,
                0.0003333091735839844,
                0.00035691261291503906,
                0.0003821849822998047,
                0.00041413307189941406,
                0.0004718303680419922,
                0.0005121231079101562
            ],
            "beyond_p": 0.9599609375
        }
    ],
    "jump-game": [
        {
            "slug_name": "jump-game",
            "result": {
                "result": "passed",
                "runtime": 0.0002789497375488281,
                "index": 0
            },
            "solution": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        max_reach = 0\n        for i, jump in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + jump)\n            if max_reach >= len(nums) - 1:\n                return True\n        return max_reach >= len(nums) - 1\n\n# Example usage:\n# sol = Solution()\n# print(sol.canJump([2,3,1,1,4]))  # Output: true\n# print(sol.canJump([3,2,1,0,4]))  # Output: false",
            "runtimes": [
                0.00027179718017578125,
                0.00027489662170410156,
                0.0002770423889160156,
                0.0002818107604980469,
                0.0003006458282470703,
                0.00030112266540527344,
                0.00030231475830078125,
                0.00031447410583496094,
                0.0003154277801513672,
                0.00031685829162597656,
                0.0003216266632080078,
                0.0003235340118408203,
                0.0003299713134765625,
                0.00036072731018066406,
                0.00036144256591796875,
                0.00036406517028808594,
                0.0003750324249267578,
                0.00037789344787597656,
                0.0003814697265625,
                0.0004086494445800781,
                0.0004131793975830078,
                0.0004706382751464844
            ],
            "beyond_p": 0.9640287769784173
        }
    ],
    "minimum-path-sum": [
        {
            "slug_name": "minimum-path-sum",
            "result": {
                "result": "passed",
                "runtime": 0.016252994537353516,
                "index": 0
            },
            "solution": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        for i in range(1, n):\n            grid[0][i] += grid[0][i-1]\n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        return grid[-1][-1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.minPathSum([[1,3,1],[1,5,1],[4,2,1]]))  # Output: 7\n# print(sol.minPathSum([[1,2,3],[4,5,6]]))  # Output: 12",
            "runtimes": [
                0.0031652450561523438,
                0.003289461135864258,
                0.0032973289489746094,
                0.003320932388305664,
                0.0033295154571533203,
                0.003384113311767578,
                0.0038623809814453125,
                0.003871440887451172,
                0.006354331970214844,
                0.00742030143737793,
                0.00867462158203125,
                0.008965015411376953,
                0.009358406066894531,
                0.013689756393432617,
                0.014902353286743164,
                0.016330957412719727,
                0.02764582633972168,
                0.031913042068481445,
                0.03447914123535156,
                0.03455162048339844,
                0.06189370155334473
            ],
            "beyond_p": 0.7771480767279001
        }
    ],
    "count-and-say": [
        {
            "slug_name": "count-and-say",
            "result": {
                "result": "passed",
                "runtime": 0.0017313957214355469,
                "index": 0
            },
            "solution": "class Solution(object):\n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        prev = self.countAndSay(n - 1)\n        result = ''\n        count = 1\n        for i in range(1, len(prev)):\n            if prev[i] == prev[i - 1]:\n                count += 1\n            else:\n                result += str(count) + prev[i - 1]\n                count = 1\n        result += str(count) + prev[-1]\n        return result",
            "runtimes": [
                0.0007672309875488281,
                0.0009903907775878906,
                0.0009908676147460938,
                0.0009946823120117188,
                0.00112152099609375,
                0.0012576580047607422,
                0.0013573169708251953,
                0.0014071464538574219,
                0.0014324188232421875,
                0.0015609264373779297,
                0.0016047954559326172,
                0.0017600059509277344,
                0.0017719268798828125,
                0.00208282470703125,
                0.004763364791870117,
                0.005258321762084961,
                0.006969928741455078,
                0.013871908187866211,
                0.0201871395111084
            ],
            "beyond_p": 0.9503517365842878
        }
    ],
    "split-array-largest-sum": [
        {
            "slug_name": "split-array-largest-sum",
            "result": {
                "result": "passed",
                "runtime": 0.003540515899658203,
                "index": 0
            },
            "solution": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def is_valid(mid):\n            count, current_sum = 1, 0\n            for num in nums:\n                current_sum += num\n                if current_sum > mid:\n                    count += 1\n                    current_sum = num\n                if count > k:\n                    return False\n            return True\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n# Example usage:\n# sol = Solution()\n# print(sol.splitArray([7,2,5,10,8], 2))  # Output: 18\n# print(sol.splitArray([1,2,3,4,5], 2))  # Output: 9",
            "runtimes": [
                0.003996372222900391,
                0.0799102783203125,
                0.6181504726409912,
                0.6451647281646729,
                0.7568066120147705,
                0.8680005073547363,
                0.9038159847259521,
                0.9051558971405029,
                1.0023515224456787,
                1.1123201847076416,
                1.4757275581359863,
                1.494985580444336,
                6.0230937004089355,
                7.412426948547363,
                7.965455770492554,
                8.981350421905518,
                10.665950775146484,
                12.5278902053833,
                13.31442904472351,
                13.732095003128052
            ],
            "beyond_p": 1.0000332060786783
        }
    ],
    "search-in-rotated-sorted-array": [
        {
            "slug_name": "search-in-rotated-sorted-array",
            "result": {
                "result": "passed",
                "runtime": 0.0003757476806640625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1",
            "runtimes": [
                0.0003266334533691406,
                0.00037860870361328125,
                0.0003807544708251953,
                0.00038170814514160156,
                0.0003924369812011719,
                0.0003943443298339844,
                0.0003993511199951172,
                0.00040030479431152344,
                0.0004241466522216797,
                0.00043845176696777344,
                0.0004849433898925781,
                0.0004918575286865234,
                0.0005178451538085938,
                0.0005385875701904297,
                0.0008087158203125,
                0.00099945068359375,
                0.0178983211517334
            ],
            "beyond_p": 0.9972049225926378
        }
    ],
    "letter-combinations-of-a-phone-number": [
        {
            "slug_name": "letter-combinations-of-a-phone-number",
            "result": {
                "result": "passed",
                "runtime": 0.00043964385986328125,
                "index": 0
            },
            "solution": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n\n        phone_map = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n\n        def backtrack(index, path):\n            if index == len(digits):\n                combinations.append(''.join(path))\n                return\n            possible_letters = phone_map[digits[index]]\n            for letter in possible_letters:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n\n        combinations = []\n        backtrack(0, [])\n        return combinations\n\n# Example usage:\n# sol = Solution()\n# print(sol.letterCombinations(\"23\"))\n# Output: ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']",
            "runtimes": [
                0.0003371238708496094,
                0.0003485679626464844,
                0.0003502368927001953,
                0.0003542900085449219,
                0.00036907196044921875,
                0.00037097930908203125,
                0.0003807544708251953,
                0.0003883838653564453,
                0.0003902912139892578,
                0.00039505958557128906,
                0.00040268898010253906,
                0.0004057884216308594,
                0.0004086494445800781,
                0.0004093647003173828,
                0.0004096031188964844,
                0.0004131793975830078,
                0.00041961669921875,
                0.0004286766052246094,
                0.00046443939208984375,
                0.00047016143798828125,
                0.0004992485046386719,
                0.0005669593811035156,
                0.002656221389770508,
                0.0040035247802734375,
                0.0065479278564453125,
                0.012591361999511719
            ],
            "beyond_p": 0.9916339157165649
        }
    ],
    "combination-sum": [
        {
            "slug_name": "combination-sum",
            "result": {
                "result": "failed@cases",
                "runtime": 0.0005254745483398438,
                "index": 0
            },
            "solution": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        def backtrack(remaining, combo, start):\n            if remaining == 0:\n                result.append(list(combo))\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > remaining:\n                    break\n                combo.append(candidates[i])\n                backtrack(remaining - candidates[i], combo, i)\n                combo.pop()\n        \n        candidates.sort()\n        result = []\n        backtrack(target, [], 0)\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.combinationSum([2,3,6,7], 7))\n# Output: [[2,2,3],[7]]\n# print(sol.combinationSum([2,3,5], 8))\n# Output: [[2,2,2,2],[2,3,3],[3,5]]\n# print(sol.combinationSum([2], 1))\n# Output: []",
            "runtimes": [
                0.00043892860412597656,
                0.00044798851013183594,
                0.0008997917175292969,
                0.0009603500366210938,
                0.0013632774353027344,
                0.002390623092651367,
                0.0042002201080322266,
                0.012113809585571289,
                0.01330256462097168
            ],
            "beyond_p": 0.0
        }
    ],
    "find-the-closest-palindrome": [
        {
            "slug_name": "find-the-closest-palindrome",
            "result": {
                "result": "passed",
                "runtime": 0.00027632713317871094,
                "index": 0
            },
            "solution": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        def create_palindrome(mid):\n            return int(mid + mid[-2::-1]) if len(n) % 2 else int(mid + mid[::-1])\n\n        length = len(n)\n        original_num = int(n)\n        candidates = set()\n\n        middle = int(n[:(length + 1) // 2])\n        for diff in (-1, 0, 1):\n            candidates.add(create_palindrome(str(middle + diff)))\n\n        candidates.discard(original_num)\n\n        return str(min(candidates, key=lambda x: (abs(x - original_num), x)))\n\n# Example usage:\n# sol = Solution()\n# print(sol.nearestPalindromic(\"123\"))  # Output: \"121\"\n# print(sol.nearestPalindromic(\"1\"))    # Output: \"0\"",
            "runtimes": [
                0.00028777122497558594,
                0.00029087066650390625,
                0.0003018379211425781,
                0.00030350685119628906,
                0.0003063678741455078,
                0.00032591819763183594,
                0.00033974647521972656,
                0.0003428459167480469,
                0.0003464221954345703,
                0.0003533363342285156,
                0.0003681182861328125,
                0.0003750324249267578,
                0.0003790855407714844,
                0.0003905296325683594,
                0.0004000663757324219,
                0.0004057884216308594,
                0.0004165172576904297
            ],
            "beyond_p": 1.0888888888888888
        }
    ],
    "spiral-matrix-ii": [
        {
            "slug_name": "spiral-matrix-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0002789497375488281,
                "index": 0
            },
            "solution": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        matrix = [[0] * n for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n\n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n\n        return matrix",
            "runtimes": [
                0.0002689361572265625,
                0.0002810955047607422,
                0.00028824806213378906,
                0.0002923011779785156,
                0.0002961158752441406,
                0.0003123283386230469,
                0.00031876564025878906,
                0.00033020973205566406,
                0.0003383159637451172,
                0.0003464221954345703,
                0.0003712177276611328,
                0.0006747245788574219
            ],
            "beyond_p": 0.9753231492361927
        }
    ],
    "reverse-integer": [
        {
            "slug_name": "reverse-integer",
            "result": {
                "result": "passed",
                "runtime": 0.0004112720489501953,
                "index": 0
            },
            "solution": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        sign = -1 if x < 0 else 1\n        x_abs = abs(x)\n        reversed_x = 0\n\n        while x_abs != 0:\n            pop = x_abs % 10\n            x_abs //= 10\n\n            if reversed_x > INT_MAX // 10 or (reversed_x == INT_MAX // 10 and pop > 7):\n                return 0\n            if reversed_x < INT_MIN // 10 or (reversed_x == INT_MIN // 10 and pop < -8):\n                return 0\n\n            reversed_x = reversed_x * 10 + pop\n\n        return sign * reversed_x",
            "runtimes": [
                0.0002701282501220703,
                0.00027179718017578125,
                0.0003008842468261719,
                0.0003039836883544922,
                0.0003046989440917969,
                0.0003070831298828125,
                0.00030732154846191406,
                0.00032448768615722656,
                0.0003247261047363281,
                0.0003261566162109375,
                0.0003294944763183594,
                0.0003349781036376953,
                0.0003681182861328125,
                0.0003705024719238281,
                0.00046825408935546875,
                0.0004980564117431641
            ],
            "beyond_p": 0.3807531380753138
        }
    ],
    "rotate-image": [
        {
            "slug_name": "rotate-image",
            "result": {
                "result": "passed",
                "runtime": 0.0004305839538574219,
                "index": 0
            },
            "solution": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n - j - 1][i]\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n                matrix[j][n - i - 1] = temp\n\n# Example usage:\n# matrix = [[1,2,3],[4,5,6],[7,8,9]]\n# Solution().rotate(matrix)\n# print(matrix)  # Output: [[7,4,1],[8,5,2],[9,6,3]]\n\n# matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n# Solution().rotate(matrix)\n# print(matrix)  # Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
            "runtimes": [
                0.00040411949157714844,
                0.0004260540008544922,
                0.0004544258117675781,
                0.0004551410675048828,
                0.00047016143798828125,
                0.0004987716674804688,
                0.0005331039428710938,
                0.0005383491516113281,
                0.0005433559417724609,
                0.0005934238433837891,
                0.0006031990051269531,
                0.0009124279022216797,
                0.0013394355773925781,
                0.002549886703491211,
                0.0033457279205322266,
                0.006280660629272461
            ],
            "beyond_p": 0.9954965920155794
        }
    ],
    "maximum-product-subarray": [
        {
            "slug_name": "maximum-product-subarray",
            "result": {
                "result": "passed",
                "runtime": 0.0004904270172119141,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        max_prod = min_prod = result = nums[0]\n        \n        for i in range(1, len(nums)):\n            num = nums[i]\n            if num < 0:\n                max_prod, min_prod = min_prod, max_prod\n            \n            max_prod = max(num, max_prod * num)\n            min_prod = min(num, min_prod * num)\n            \n            result = max(result, max_prod)\n        \n        return result",
            "runtimes": [
                0.0004150867462158203,
                0.0004296302795410156,
                0.0004315376281738281,
                0.00043272972106933594,
                0.00047707557678222656,
                0.0004801750183105469,
                0.00048804283142089844,
                0.0004892349243164062,
                0.0004918575286865234,
                0.0004940032958984375,
                0.0005042552947998047,
                0.0005059242248535156,
                0.0005123615264892578,
                0.0005376338958740234,
                0.0005421638488769531,
                0.0005495548248291016,
                0.0005958080291748047,
                0.0006384849548339844,
                0.0006885528564453125,
                0.0007197856903076172,
                0.002518892288208008,
                0.005190372467041016,
                0.013514041900634766
            ],
            "beyond_p": 0.9942483755301141
        }
    ],
    "frog-jump": [
        {
            "slug_name": "frog-jump",
            "result": {
                "result": "passed",
                "runtime": 0.0003676414489746094,
                "index": 0
            },
            "solution": "class Solution(object):\n    def canCross(self, stones):\n        stone_positions = set(stones)\n        last_stone = stones[-1]\n        stack = [(0, 0)]\n        visited = set()\n\n        while stack:\n            stone, jump = stack.pop()\n            if stone == last_stone:\n                return True\n            for next_jump in (jump - 1, jump, jump + 1):\n                if next_jump > 0 and stone + next_jump in stone_positions and (stone + next_jump, next_jump) not in visited:\n                    visited.add((stone + next_jump, next_jump))\n                    stack.append((stone + next_jump, next_jump))\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.canCross([0,1,3,5,6,8,12,17]))  # Output: true\n# print(sol.canCross([0,1,2,3,4,8,9,11]))    # Output: false",
            "runtimes": [
                0.0002739429473876953,
                0.00027823448181152344,
                0.0002810955047607422,
                0.00029087066650390625,
                0.00029540061950683594,
                0.0002963542938232422,
                0.0003387928009033203,
                0.00035452842712402344,
                0.0003561973571777344,
                0.00042891502380371094,
                0.0004298686981201172,
                0.0005323886871337891,
                0.0006308555603027344,
                0.0006787776947021484,
                0.0009334087371826172,
                0.0010228157043457031,
                0.06583523750305176,
                0.07030034065246582,
                0.1264495849609375,
                0.1715540885925293,
                0.18117618560791016,
                0.21138787269592285,
                0.2231454849243164
            ],
            "beyond_p": 0.9995795851693052
        }
    ],
    "relative-ranks": [
        {
            "slug_name": "relative-ranks",
            "result": {
                "result": "passed",
                "runtime": 0.00044083595275878906,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        # Create a dictionary to hold the score and its index\n        score_index_dict = {s: i for i, s in enumerate(score)}\n        # Sort the scores in descending order\n        sorted_scores = sorted(score, reverse=True)\n        # Initialize the answer list with the same size as the score list\n        answer = [''] * len(score)\n\n        # Assign the medals or the placement numbers\n        for rank, s in enumerate(sorted_scores):\n            if rank == 0:\n                answer[score_index_dict[s]] = 'Gold Medal'\n            elif rank == 1:\n                answer[score_index_dict[s]] = 'Silver Medal'\n            elif rank == 2:\n                answer[score_index_dict[s]] = 'Bronze Medal'\n            else:\n                answer[score_index_dict[s]] = str(rank + 1)\n\n        return answer",
            "runtimes": [
                0.00039887428283691406,
                0.00040221214294433594,
                0.00040841102600097656,
                0.0004470348358154297,
                0.0004494190216064453,
                0.00046443939208984375,
                0.0004684925079345703,
                0.0004839897155761719,
                0.0004899501800537109,
                0.0005269050598144531,
                0.0005328655242919922,
                0.0005803108215332031,
                0.0006182193756103516,
                0.0006430149078369141,
                0.000682830810546875,
                0.0011661052703857422,
                0.001199960708618164,
                0.0021622180938720703
            ],
            "beyond_p": 0.9762033531638724
        }
    ],
    "longest-substring-without-repeating-characters": [
        {
            "slug_name": "longest-substring-without-repeating-characters",
            "result": {
                "result": "passed",
                "runtime": 0.00033164024353027344,
                "index": 0
            },
            "solution": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        char_map = {}\n        left = 0\n        max_length = 0\n        for right in range(len(s)):\n            if s[right] in char_map and char_map[s[right]] >= left:\n                left = char_map[s[right]] + 1\n            char_map[s[right]] = right\n            max_length = max(max_length, right - left + 1)\n        return max_length\n\n# Example usage:\n# sol = Solution()\n# print(sol.lengthOfLongestSubstring('abcabcbb'))  # Output: 3\n# print(sol.lengthOfLongestSubstring('bbbbb'))     # Output: 1\n# print(sol.lengthOfLongestSubstring('pwwkew'))    # Output: 3",
            "runtimes": [
                0.0003306865692138672,
                0.00033736228942871094,
                0.0003457069396972656,
                0.00037932395935058594,
                0.00041484832763671875,
                0.00044536590576171875,
                0.0004487037658691406,
                0.0004687309265136719,
                0.0004990100860595703,
                0.0005197525024414062,
                0.0005214214324951172,
                0.0006053447723388672,
                0.0006315708160400391,
                0.0006463527679443359,
                0.0007481575012207031,
                0.0008976459503173828,
                0.0009458065032958984,
                0.0015552043914794922,
                0.0035583972930908203,
                0.006471395492553711
            ],
            "beyond_p": 0.9998446963814257
        }
    ],
    "substring-with-concatenation-of-all-words": [
        {
            "slug_name": "substring-with-concatenation-of-all-words",
            "result": {
                "result": "passed",
                "runtime": 0.0005202293395996094,
                "index": 0
            },
            "solution": "import collections\n\nclass Solution(object):\n    def findSubstring(self, s, words):\n        word_length = len(words[0])\n        word_count = len(words)\n        total_length = word_length * word_count\n        word_freq = collections.Counter(words)\n        result = []\n\n        for i in range(word_length):\n            left = i\n            right = i\n            current_freq = collections.Counter()\n\n            while right + word_length <= len(s):\n                word = s[right:right + word_length]\n                right += word_length\n\n                if word in word_freq:\n                    current_freq[word] += 1\n                    while current_freq[word] > word_freq[word]:\n                        current_freq[s[left:left + word_length]] -= 1\n                        left += word_length\n\n                    if right - left == total_length:\n                        result.append(left)\n                else:\n                    current_freq.clear()\n                    left = right\n\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.findSubstring(\"barfoothefoobarman\", [\"foo\",\"bar\"]))\n# Output: [0,9]",
            "runtimes": [
                0.000354766845703125,
                0.00035500526428222656,
                0.0004134178161621094,
                0.0004284381866455078,
                0.00046062469482421875,
                0.0004897117614746094,
                0.0004923343658447266,
                0.0005307197570800781,
                0.0005514621734619141,
                0.0005702972412109375,
                0.0005707740783691406,
                0.0006532669067382812,
                0.0006766319274902344,
                0.0007085800170898438,
                0.0007507801055908203,
                0.0007798671722412109,
                0.0008389949798583984,
                0.0011522769927978516,
                0.001377105712890625,
                0.0014200210571289062,
                0.007758378982543945
            ],
            "beyond_p": 0.9776511126139181
        }
    ],
    "max-chunks-to-make-sorted-ii": [
        {
            "slug_name": "max-chunks-to-make-sorted-ii",
            "result": {
                "result": "failed@cases",
                "runtime": 0.001009225845336914,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        max_so_far = 0\n        chunk_count = 0\n        for i, num in enumerate(arr):\n            max_so_far = max(max_so_far, num)\n            if max_so_far == i:\n                chunk_count += 1\n        return chunk_count\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxChunksToSorted([5,4,3,2,1]))  # Output: 1\n# print(sol.maxChunksToSorted([2,1,3,4,4]))  # Output: 4",
            "runtimes": [
                0.0009746551513671875,
                0.0012197494506835938,
                0.0012526512145996094,
                0.0016753673553466797,
                0.0016872882843017578,
                0.0017087459564208984,
                0.0022161006927490234,
                0.002488851547241211,
                0.002676248550415039,
                0.002725839614868164,
                0.0073397159576416016,
                0.014532089233398438,
                0.014691352844238281,
                0.018599987030029297,
                0.08580279350280762
            ],
            "beyond_p": 0.0
        }
    ],
    "insertion-sort-list": [
        {
            "slug_name": "insertion-sort-list",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize a dummy node to act as the head of the sorted list\n        dummy = ListNode(0)\n\n        # Iterate through each element in the original list\n        current = head\n        while current:\n            # At each iteration, we will insert the current node into the sorted list\n            prev_node = dummy\n            next_node = dummy.next\n            # Find the correct position to insert the current node\n            while next_node and next_node.val < current.val:\n                prev_node = next_node\n                next_node = next_node.next\n            \n            # Insert the current node between prev_node and next_node\n            next_current = current.next\n            current.next = next_node\n            prev_node.next = current\n\n            # Move to the next element in the original list\n            current = next_current\n\n        # Return the sorted list, which starts at dummy.next\n        return dummy.next",
            "runtimes": [
                0.013685226440429688,
                0.07853245735168457,
                0.08290338516235352,
                0.08420372009277344,
                0.08531355857849121,
                0.08622121810913086,
                0.0878744125366211,
                0.08967304229736328,
                0.09136295318603516,
                0.09673428535461426,
                0.09871125221252441,
                0.10462188720703125,
                0.10900998115539551,
                0.1116795539855957,
                0.11218857765197754,
                0.12071990966796875,
                0.1291818618774414,
                0.1409013271331787,
                0.14747166633605957,
                0.1547231674194336,
                0.15924715995788574,
                0.1695418357849121,
                0.34105563163757324,
                0.4263753890991211
            ],
            "beyond_p": 0.0
        }
    ],
    "remove-duplicates-from-sorted-list-ii": [
        {
            "slug_name": "remove-duplicates-from-sorted-list-ii",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize a dummy node with value 0 and point its next to head\n        dummy = ListNode(0, head)\n        # Initialize prev to dummy\n        prev = dummy\n        \n        # Iterate through the linked list\n        while head:\n            # If we find a node with a duplicate value\n            if head.next and head.val == head.next.val:\n                # Skip all nodes with the same value\n                while head.next and head.val == head.next.val:\n                    head = head.next\n                # Link prev to the node after the last duplicate\n                prev.next = head.next\n            else:\n                # If current node is unique, move prev to this node\n                prev = prev.next\n            # Move to the next node\n            head = head.next\n        \n        # Return the modified list\n        return dummy.next",
            "runtimes": [
                0.0007884502410888672,
                0.0007975101470947266,
                0.0008137226104736328,
                0.0008547306060791016,
                0.0008883476257324219,
                0.0009059906005859375,
                0.0009071826934814453,
                0.0009214878082275391,
                0.0009522438049316406,
                0.0009701251983642578,
                0.0010285377502441406,
                0.0010447502136230469,
                0.0012362003326416016,
                0.0022187232971191406,
                0.004069089889526367
            ],
            "beyond_p": 0.0
        }
    ],
    "3sum": [
        {
            "slug_name": "3sum",
            "result": {
                "result": "passed",
                "runtime": 0.0005986690521240234,
                "index": 0
            },
            "solution": "class Solution(object):\n    def threeSum(self, nums):\n        nums.sort()\n        result = []\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total < 0:\n                    left += 1\n                elif total > 0:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.threeSum([-1,0,1,2,-1,-4])) # Output: [[-1,-1,2],[-1,0,1]]\n# print(sol.threeSum([0,1,1])) # Output: []\n# print(sol.threeSum([0,0,0])) # Output: [[0,0,0]]",
            "runtimes": [
                0.000518798828125,
                0.000606536865234375,
                0.0007455348968505859,
                0.0009541511535644531,
                0.0010673999786376953,
                0.024495363235473633
            ],
            "beyond_p": 0.9966688211604435
        }
    ],
    "edit-distance": [
        {
            "slug_name": "edit-distance",
            "result": {
                "result": "passed",
                "runtime": 0.24195623397827148,
                "index": 0
            },
            "solution": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\n        return dp[m][n]",
            "runtimes": [
                0.1658480167388916,
                0.1773059368133545,
                0.1809074878692627,
                0.1985018253326416,
                0.20463871955871582,
                0.20605182647705078,
                0.23261618614196777,
                0.2396705150604248,
                0.24131536483764648,
                0.2642178535461426,
                0.2698631286621094,
                0.2791438102722168,
                0.2834033966064453,
                0.28779053688049316,
                0.3888587951660156,
                0.5120880603790283,
                0.6436450481414795,
                0.660351037979126,
                0.6675918102264404,
                0.6809780597686768,
                0.7095091342926025,
                0.8559744358062744,
                1.252800703048706,
                1.269538402557373,
                2.7012360095977783
            ],
            "beyond_p": 0.9699816290627926
        }
    ],
    "hamming-distance": [
        {
            "slug_name": "hamming-distance",
            "result": {
                "result": "passed",
                "runtime": 0.00028395652770996094,
                "index": 0
            },
            "solution": "class Solution(object):\n    def hammingDistance(self, x, y):\n        # XOR x and y to find the bits that are different\n        xor = x ^ y\n        # Count the number of set bits (1s) in the XOR result\n        distance = 0\n        while xor:\n            distance += xor & 1\n            xor >>= 1\n        return distance\n\n# Example usage:\n# sol = Solution()\n# print(sol.hammingDistance(1, 4))  # Output: 2\n# print(sol.hammingDistance(3, 1))  # Output: 1",
            "runtimes": [
                0.0002338886260986328,
                0.00023674964904785156,
                0.0002663135528564453,
                0.0002677440643310547,
                0.00026988983154296875,
                0.0002727508544921875,
                0.00028252601623535156,
                0.00028443336486816406,
                0.0002906322479248047,
                0.0002949237823486328,
                0.0002956390380859375,
                0.00029730796813964844
            ],
            "beyond_p": 0.21052631578947367
        }
    ],
    "binary-tree-paths": [
        {
            "slug_name": "binary-tree-paths",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "def dfs(node, path, paths):\n            if not node:\n                return\n            path += str(node.val)\n            if not node.left and not node.right:\n                paths.append(path)\n            else:\n                path += '->'\n                dfs(node.left, path, paths)\n                dfs(node.right, path, paths)\n\n        paths = []\n        dfs(root, '', paths)\n        return paths",
            "runtimes": [
                0.0005145072937011719,
                0.0005462169647216797,
                0.0005888938903808594,
                0.0006000995635986328,
                0.0006299018859863281,
                0.0006358623504638672,
                0.0006496906280517578,
                0.0006794929504394531,
                0.0009598731994628906,
                0.0010304450988769531
            ],
            "beyond_p": 0.0
        }
    ],
    "reverse-pairs": [
        {
            "slug_name": "reverse-pairs",
            "result": {
                "result": "passed",
                "runtime": 0.007282733917236328,
                "index": 0
            },
            "solution": "class Solution(object):\n    def reversePairs(self, nums):\n        def merge_sort(arr, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = merge_sort(arr, left, mid) + merge_sort(arr, mid + 1, right)\n            j = mid + 1\n            for i in range(left, mid + 1):\n                while j <= right and arr[i] > 2 * arr[j]:\n                    j += 1\n                count += j - (mid + 1)\n            arr[left:right+1] = sorted(arr[left:right+1])\n            return count\n        return merge_sort(nums, 0, len(nums) - 1)\n\n# Example usage:\n# sol = Solution()\n# print(sol.reversePairs([1,3,2,3,1]))  # Output: 2\n# print(sol.reversePairs([2,4,3,5,1]))  # Output: 3",
            "runtimes": [
                0.0025911331176757812,
                0.003628253936767578,
                0.006968259811401367,
                0.009132146835327148,
                0.0092926025390625,
                0.010016441345214844,
                0.012308597564697266,
                0.01257944107055664,
                0.012638092041015625,
                0.013750076293945312,
                0.013907909393310547,
                0.015215873718261719,
                0.015705585479736328,
                0.020107269287109375,
                0.02061176300048828,
                0.024678707122802734,
                0.027621746063232422,
                0.035066843032836914,
                0.03561687469482422,
                0.03896498680114746
            ],
            "beyond_p": 0.8710172191160374
        }
    ],
    "reaching-points": [
        {
            "slug_name": "reaching-points",
            "result": {
                "result": "passed",
                "runtime": 0.000339508056640625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        while tx >= sx and ty >= sy:\n            if tx == ty: break\n            if tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    return (tx - sx) % ty == 0\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    return (ty - sy) % tx == 0\n        return tx == sx and ty == sy\n\n# Example usage:\n# sol = Solution()\n# print(sol.reachingPoints(1, 1, 3, 5))  # Output: true\n# print(sol.reachingPoints(1, 1, 2, 2))  # Output: false\n# print(sol.reachingPoints(1, 1, 1, 1))  # Output: true",
            "runtimes": [
                0.0002593994140625,
                0.0002608299255371094,
                0.0002636909484863281,
                0.00029754638671875,
                0.0002994537353515625,
                0.00030159950256347656,
                0.0003046989440917969,
                0.0003952980041503906,
                0.0003981590270996094,
                0.0004096031188964844,
                0.0004296302795410156
            ],
            "beyond_p": 0.5294117647058824
        }
    ],
    "compare-version-numbers": [
        {
            "slug_name": "compare-version-numbers",
            "result": {
                "result": "passed",
                "runtime": 0.0004987716674804688,
                "index": 0
            },
            "solution": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        # Split the version numbers into lists of revisions\n        revisions1 = version1.split('.')\n        revisions2 = version2.split('.')\n\n        # Compare each revision\n        for i in range(max(len(revisions1), len(revisions2))):\n            # Convert revision to integer, if revision does not exist, use 0\n            rev1 = int(revisions1[i]) if i < len(revisions1) else 0\n            rev2 = int(revisions2[i]) if i < len(revisions2) else 0\n\n            # Compare the integer values of revisions\n            if rev1 < rev2:\n                return -1\n            elif rev1 > rev2:\n                return 1\n\n        # If all revisions are equal\n        return 0",
            "runtimes": [
                0.000293731689453125,
                0.0003097057342529297,
                0.00031447410583496094,
                0.00032019615173339844,
                0.00032973289489746094,
                0.00033354759216308594,
                0.0003440380096435547,
                0.0003466606140136719,
                0.00035190582275390625,
                0.00037550926208496094,
                0.00042724609375,
                0.00044846534729003906,
                0.0005242824554443359
            ],
            "beyond_p": 0.11065149948293691
        }
    ],
    "best-time-to-buy-and-sell-stock-ii": [
        {
            "slug_name": "best-time-to-buy-and-sell-stock-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0016965866088867188,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maxProfit(self, prices):\n        max_profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                max_profit += prices[i] - prices[i - 1]\n        return max_profit\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxProfit([7,1,5,3,6,4]))  # Output: 7\n# print(sol.maxProfit([1,2,3,4,5]))    # Output: 4\n# print(sol.maxProfit([7,6,4,3,1]))    # Output: 0",
            "runtimes": [
                0.0014507770538330078,
                0.00146484375,
                0.001622915267944336,
                0.0016407966613769531,
                0.0016796588897705078,
                0.0017185211181640625,
                0.0017955303192138672,
                0.001806497573852539,
                0.0018603801727294922,
                0.0018880367279052734,
                0.001988649368286133,
                0.0022537708282470703,
                0.002976655960083008,
                0.003094196319580078,
                0.0031387805938720703,
                0.00360107421875,
                0.003818511962890625,
                0.0057680606842041016,
                0.009675741195678711,
                0.011052608489990234,
                0.011905431747436523,
                0.012211322784423828,
                0.01608729362487793,
                1.7142083644866943
            ],
            "beyond_p": 0.9998564831609229
        }
    ],
    "course-schedule-iii": [
        {
            "slug_name": "course-schedule-iii",
            "result": {
                "result": "passed",
                "runtime": 0.0005457401275634766,
                "index": 0
            },
            "solution": "import heapq\n\nclass Solution(object):\n    def scheduleCourse(self, courses):\n        # Sort the courses by their ending day\n        courses.sort(key=lambda x: x[1])\n        total_time = 0\n        max_heap = []\n        for duration, last_day in courses:\n            if total_time + duration <= last_day:\n                # If the course can be finished before the last day\n                heapq.heappush(max_heap, -duration)\n                total_time += duration\n            elif max_heap and -max_heap[0] > duration:\n                # If the current course duration is less than the longest duration course taken\n                total_time += duration + heapq.heappop(max_heap)\n                heapq.heappush(max_heap, -duration)\n        return len(max_heap)\n\n# Example usage:\n# sol = Solution()\n# print(sol.scheduleCourse([[100,200],[200,1300],[1000,1250],[2000,3200]])) # Output: 3\n# print(sol.scheduleCourse([[1,2]])) # Output: 1\n# print(sol.scheduleCourse([[3,2],[4,3]])) # Output: 0",
            "runtimes": [
                0.0003886222839355469,
                0.00040650367736816406,
                0.0004086494445800781,
                0.0004153251647949219,
                0.00043201446533203125,
                0.00044035911560058594,
                0.00045561790466308594,
                0.0004730224609375,
                0.000476837158203125,
                0.0005156993865966797,
                0.0005695819854736328,
                0.0005817413330078125,
                0.0006754398345947266,
                0.0016870498657226562,
                0.0072171688079833984
            ],
            "beyond_p": 0.9769910268496211
        }
    ],
    "reverse-nodes-in-k-group": [
        {
            "slug_name": "reverse-nodes-in-k-group",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Helper function to reverse a linked list segment\n        def reverse_segment(start, end):\n            prev, curr = None, start\n            while curr != end:\n                next_temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = next_temp\n            return prev\n\n        # Dummy node initialization\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        # Main loop to process the list in k-group segments\n        while True:\n            # Check if there are at least k nodes left to reverse\n            kth = prev\n            for i in range(k):\n                kth = kth.next\n                if not kth:\n                    return dummy.next\n\n            # Reverse k nodes\n            next_group = kth.next\n            kth.next = None\n            start = prev.next\n            prev.next = reverse_segment(start, kth.next)\n            start.next = next_group\n            prev = start\n\n        return dummy.next",
            "runtimes": [
                0.000965118408203125,
                0.0009701251983642578,
                0.0009903907775878906,
                0.0010683536529541016,
                0.0010755062103271484,
                0.0010886192321777344,
                0.0010974407196044922,
                0.0011165142059326172,
                0.0011210441589355469,
                0.0011234283447265625,
                0.001132965087890625,
                0.0011582374572753906,
                0.0012886524200439453,
                0.0012929439544677734,
                0.001298666000366211,
                0.0013470649719238281,
                0.0016317367553710938,
                0.013057470321655273,
                0.02227640151977539
            ],
            "beyond_p": 0.0
        }
    ],
    "repeated-substring-pattern": [
        {
            "slug_name": "repeated-substring-pattern",
            "result": {
                "result": "passed",
                "runtime": 0.00026726722717285156,
                "index": 0
            },
            "solution": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # The idea is to check for all possible substring lengths\n        for i in range(1, len(s) // 2 + 1):\n            # If the current length can divide the string into equal parts\n            if len(s) % i == 0:\n                # Get the substring\n                substring = s[:i]\n                # Multiply the substring and compare with the original string\n                if substring * (len(s) // i) == s:\n                    return True\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.repeatedSubstringPattern('abab'))  # Output: true\n# print(sol.repeatedSubstringPattern('aba'))   # Output: false\n# print(sol.repeatedSubstringPattern('abcabcabcabc'))  # Output: true",
            "runtimes": [
                0.000274658203125,
                0.0002796649932861328,
                0.0002803802490234375,
                0.0002841949462890625,
                0.0002841949462890625,
                0.00028586387634277344,
                0.0002884864807128906,
                0.0002956390380859375,
                0.0003123283386230469,
                0.00031375885009765625,
                0.0003142356872558594,
                0.00031685829162597656,
                0.0003333091735839844,
                0.0003345012664794922,
                0.00034880638122558594,
                0.00038743019104003906,
                0.0004279613494873047,
                0.0004303455352783203,
                0.00043201446533203125,
                0.012447834014892578
            ],
            "beyond_p": 1.0006071526499276
        }
    ],
    "unique-binary-search-trees": [
        {
            "slug_name": "unique-binary-search-trees",
            "result": {
                "result": "passed",
                "runtime": 0.0003521442413330078,
                "index": 0
            },
            "solution": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # Catalan number Cn formula\n        # Cn = (2n)! / ((n+1)! * n!)\n        # We can compute it using dynamic programming\n\n        # Initialize the list to store the number of unique BSTs\n        G = [0] * (n + 1)\n        G[0], G[1] = 1, 1\n\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                # G[i] accumulates number of unique BSTs with i nodes\n                G[i] += G[j - 1] * G[i - j]\n\n        return G[n]\n\n# Example usage:\n# sol = Solution()\n# print(sol.numTrees(3))  # Output: 5\n# print(sol.numTrees(1))  # Output: 1",
            "runtimes": [
                0.0002620220184326172,
                0.0002789497375488281,
                0.0002930164337158203,
                0.00030541419982910156,
                0.000316619873046875,
                0.0003597736358642578,
                0.0003790855407714844,
                0.0003802776336669922,
                0.0003859996795654297,
                0.00046515464782714844,
                0.00047707557678222656,
                0.0005252361297607422,
                0.0005259513854980469,
                0.0039293766021728516
            ],
            "beyond_p": 0.9754258223898062
        }
    ],
    "single-number-ii": [
        {
            "slug_name": "single-number-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0004820823669433594,
                "index": 0
            },
            "solution": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ones, twos = 0, 0\n        for num in nums:\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n        return ones",
            "runtimes": [
                0.0004203319549560547,
                0.00046324729919433594,
                0.0005040168762207031,
                0.0005371570587158203,
                0.0005774497985839844,
                0.0006508827209472656,
                0.0007736682891845703,
                0.0007755756378173828,
                0.0008442401885986328,
                0.0009076595306396484,
                0.0009794235229492188,
                0.0010991096496582031,
                0.0011208057403564453,
                0.00128173828125,
                0.001299142837524414,
                0.0016291141510009766,
                0.0019490718841552734,
                0.003599405288696289,
                0.006995439529418945,
                0.006997585296630859,
                0.007322072982788086,
                0.028584003448486328
            ],
            "beyond_p": 0.9978074445300397
        }
    ],
    "stickers-to-spell-word": [
        {
            "slug_name": "stickers-to-spell-word",
            "result": {
                "result": "failed@cases",
                "runtime": 0.006139516830444336,
                "index": 0
            },
            "solution": "class Solution(object):\n    def minStickers(self, stickers, target):\n        from collections import Counter\n\n        def dfs(rem):\n            if not rem:\n                return 0\n            if rem in memo:\n                return memo[rem]\n            rem_count = Counter(rem)\n            ans = float('inf')\n            for sticker in stickers:\n                if sticker_counts[sticker][rem[0]] == 0:\n                    continue\n                used = max((rem_count[char] // sticker_counts[sticker][char]) for char in rem_count if sticker_counts[sticker][char] > 0)\n                if used > 0:\n                    new_rem = rem\n                    for char in sticker_counts[sticker]:\n                        if char in rem_count:\n                            new_rem = new_rem.replace(char, '', used * sticker_counts[sticker][char])\n                    ans = min(ans, used + dfs(new_rem))\n            memo[rem] = -1 if ans == float('inf') else ans\n            return memo[rem]\n\n        sticker_counts = {sticker: Counter(sticker) for sticker in stickers}\n        memo = {}\n        result = dfs(target)\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.minStickers(['with','example','science'], 'thehat'))  # Output: 3\n# print(sol.minStickers(['notice','possible'], 'basicbasic'))  # Output: -1",
            "runtimes": [
                0.0015194416046142578,
                0.012774467468261719,
                0.016942739486694336,
                0.031555891036987305,
                0.03345990180969238,
                0.11967086791992188,
                0.23039603233337402,
                0.5330679416656494,
                0.6222343444824219,
                0.7997391223907471,
                1.130920171737671,
                1.3676559925079346,
                1.5254125595092773,
                1.537306547164917,
                2.0220448970794678
            ],
            "beyond_p": 0.0
        }
    ],
    "strange-printer": [
        {
            "slug_name": "strange-printer",
            "result": {
                "result": "passed",
                "runtime": 0.07931113243103027,
                "index": 0
            },
            "solution": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n\n        # dp[i][j] will be the minimum number of turns to print s[i:j+1]\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][k] + dp[k + 1][j] for k in range(i, j))\n\n        return dp[0][n - 1]\n\n# Example usage:\n# sol = Solution()\n# print(sol.strangePrinter(\"aaabbb\"))  # Output: 2\n# print(sol.strangePrinter(\"aba\"))    # Output: 2",
            "runtimes": [
                0.0068395137786865234,
                0.008217573165893555,
                0.008598566055297852,
                0.012093782424926758,
                0.012263298034667969,
                0.0172727108001709,
                0.018945693969726562,
                0.019299030303955078,
                0.02579498291015625,
                0.03854727745056152,
                0.09052062034606934,
                0.09419608116149902,
                0.09839510917663574,
                0.10717988014221191,
                0.11335253715515137,
                0.1392195224761963,
                0.16873741149902344,
                0.17069339752197266
            ],
            "beyond_p": 0.5577058230375131
        }
    ],
    "sqrtx": [
        {
            "slug_name": "sqrtx",
            "result": {
                "result": "passed",
                "runtime": 0.0002982616424560547,
                "index": 0
            },
            "solution": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 2:\n            return x\n\n        left, right = 1, x // 2\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left",
            "runtimes": [
                0.00035500526428222656,
                0.0003554821014404297,
                0.00038814544677734375,
                0.0009784698486328125,
                0.0035474300384521484,
                0.0036630630493164062,
                0.004775524139404297,
                0.007670879364013672,
                0.008074045181274414,
                0.009255647659301758,
                0.00952768325805664,
                0.009579896926879883,
                0.009730815887451172,
                0.011311769485473633,
                0.012676477432250977,
                0.012814044952392578,
                0.013085126876831055,
                0.014174699783325195,
                0.014960289001464844,
                0.024309396743774414,
                0.026588916778564453,
                0.028439998626708984,
                0.08612799644470215,
                0.09078645706176758
            ],
            "beyond_p": 1.0006274766212229
        }
    ],
    "roman-to-integer": [
        {
            "slug_name": "roman-to-integer",
            "result": {
                "result": "passed",
                "runtime": 0.0002808570861816406,
                "index": 0
            },
            "solution": "class Solution(object):\n    def romanToInt(self, s):\n        # Define the mapping of Roman numerals to integers\n        roman_to_int = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n\n        # Initialize the result variable\n        result = 0\n\n        # Iterate through the characters of the string\n        for i in range(len(s)):\n            # If the current character is less than the next one, subtract it\n            if i + 1 < len(s) and roman_to_int[s[i]] < roman_to_int[s[i + 1]]:\n                result -= roman_to_int[s[i]]\n            else:\n                # Otherwise, add it\n                result += roman_to_int[s[i]]\n\n        return result",
            "runtimes": [
                0.0002765655517578125,
                0.0003020763397216797,
                0.0003056526184082031,
                0.0003161430358886719,
                0.0003178119659423828,
                0.00031876564025878906,
                0.00031876564025878906,
                0.0003192424774169922,
                0.0003209114074707031,
                0.0003230571746826172,
                0.0003230571746826172,
                0.00032448768615722656,
                0.0003666877746582031,
                0.00038504600524902344,
                0.00039649009704589844,
                0.0004189014434814453
            ],
            "beyond_p": 0.9698492462311558
        }
    ],
    "contains-duplicate": [
        {
            "slug_name": "contains-duplicate",
            "result": {
                "result": "passed",
                "runtime": 0.006678342819213867,
                "index": 0
            },
            "solution": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False",
            "runtimes": [
                0.0003559589385986328,
                0.0003833770751953125,
                0.00038695335388183594,
                0.00038933753967285156,
                0.00043892860412597656,
                0.0004413127899169922,
                0.0004413127899169922,
                0.00044655799865722656,
                0.00046062469482421875,
                0.0004677772521972656,
                0.0004761219024658203,
                0.0004787445068359375,
                0.0005049705505371094,
                0.0005087852478027344,
                0.0005536079406738281,
                0.0005576610565185547,
                0.0005946159362792969,
                0.0006279945373535156,
                0.0008039474487304688
            ],
            "beyond_p": 0.0
        }
    ],
    "sliding-window-maximum": [
        {
            "slug_name": "sliding-window-maximum",
            "result": {
                "result": "passed",
                "runtime": 0.0013720989227294922,
                "index": 0
            },
            "solution": "import collections\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        deque = collections.deque()\n        for i, num in enumerate(nums):\n            while deque and deque[0] < i - k + 1:\n                deque.popleft()\n            while deque and nums[deque[-1]] < num:\n                deque.pop()\n            deque.append(i)\n            if i >= k - 1:\n                result.append(nums[deque[0]])\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3))\n# Output: [3,3,5,5,6,7]\n# print(sol.maxSlidingWindow([1], 1))\n# Output: [1]",
            "runtimes": [
                0.0010614395141601562,
                0.0011196136474609375,
                0.0011296272277832031,
                0.0011980533599853516,
                0.0012047290802001953,
                0.0012056827545166016,
                0.0012273788452148438,
                0.0013384819030761719,
                0.0013513565063476562,
                0.0013763904571533203,
                0.0014154911041259766,
                0.001493215560913086,
                0.0015015602111816406,
                0.0015614032745361328,
                0.0015902519226074219,
                0.0016021728515625,
                0.0016438961029052734,
                0.0017101764678955078,
                0.0021300315856933594,
                0.0025243759155273438,
                0.0025436878204345703,
                0.0038721561431884766,
                0.006755828857421875
            ],
            "beyond_p": 0.9454446491374979
        }
    ],
    "median-of-two-sorted-arrays": [
        {
            "slug_name": "median-of-two-sorted-arrays",
            "result": {
                "result": "failed@eval",
                "runtime": 0,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        # This function finds the median of two sorted arrays\n        def findMedian(A, B):\n            m, n = len(A), len(B)\n            if m > n:\n                A, B, m, n = B, A, n, m\n            if n == 0:\n                raise ValueError\n\n            imin, imax, half_len = 0, m, (m + n + 1) // 2\n            while imin <= imax:\n                i = (imin + imax) // 2\n                j = half_len - i\n                if i < m and B[j-1] > A[i]:\n                    imin = i + 1\n                elif i > 0 and A[i-1] > B[j]:\n                    imax = i - 1\n                else:\n                    if i == 0: min_of_right = B[j]\n                    elif j == 0: min_of_right = A[i]\n                    else: min_of_right = min(A[i], B[j])\n\n                    if (m + n) % 2 == 1:\n                        return min_of_right\n\n                    if i == m: max_of_left = B[j-1]\n                    elif j == n: max_of_left = A[i-1]\n                    else: max_of_left = max(A[i-1], B[j-1])\n\n                    return (max_of_left + min_of_right) / 2.0\n\n        return findMedian(nums1, nums2)",
            "runtimes": [
                0.0003573894500732422,
                0.0003688335418701172,
                0.0003707408905029297,
                0.0004563331604003906,
                0.0004591941833496094,
                0.0004944801330566406,
                0.0005164146423339844,
                0.0005168914794921875,
                0.0005199909210205078,
                0.0005252361297607422,
                0.0005359649658203125,
                0.0006222724914550781,
                0.001155853271484375,
                0.0012059211730957031,
                0.001268148422241211,
                0.0021872520446777344,
                0.0035529136657714844,
                0.0054509639739990234,
                0.006399393081665039
            ],
            "beyond_p": 0.0
        }
    ],
    "find-minimum-in-rotated-sorted-array": [
        {
            "slug_name": "find-minimum-in-rotated-sorted-array",
            "result": {
                "result": "passed",
                "runtime": 0.00039505958557128906,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]",
            "runtimes": [
                0.0002849102020263672,
                0.00028514862060546875,
                0.00028967857360839844,
                0.0003032684326171875,
                0.0003159046173095703,
                0.00031948089599609375,
                0.0003204345703125,
                0.00032329559326171875,
                0.00032448768615722656,
                0.00032711029052734375,
                0.0003368854522705078,
                0.0003437995910644531,
                0.0003685951232910156,
                0.00037288665771484375,
                0.00037360191345214844,
                0.0004291534423828125,
                0.0006535053253173828
            ],
            "beyond_p": 0.7011642949547219
        }
    ],
    "pascals-triangle-ii": [
        {
            "slug_name": "pascals-triangle-ii",
            "result": {
                "result": "passed",
                "runtime": 0.00044345855712890625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        row = [1]\n        for _ in range(rowIndex):\n            row = [x + y for x, y in zip([0]+row, row+[0])]\n        return row",
            "runtimes": [
                0.00038051605224609375,
                0.0004010200500488281,
                0.00044655799865722656,
                0.0004622936248779297,
                0.0004904270172119141,
                0.0005075931549072266,
                0.0005095005035400391,
                0.0005555152893066406,
                0.0005652904510498047,
                0.0007011890411376953,
                0.0007112026214599609,
                0.0008666515350341797,
                0.0052394866943359375
            ],
            "beyond_p": 0.9870461236506379
        }
    ],
    "path-sum-ii": [
        {
            "slug_name": "path-sum-ii",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "def dfs(node, current_path, current_sum):\n            if not node:\n                return []\n            current_path.append(node.val)\n            current_sum += node.val\n            if not node.left and not node.right and current_sum == targetSum:\n                paths.append(list(current_path))\n            else:\n                dfs(node.left, current_path, current_sum)\n                dfs(node.right, current_path, current_sum)\n            current_path.pop()\n\n        paths = []\n        dfs(root, [], 0)\n        return paths",
            "runtimes": [
                0.0005118846893310547,
                0.0005166530609130859,
                0.0005295276641845703,
                0.000560760498046875,
                0.0005943775177001953,
                0.0006062984466552734,
                0.0006074905395507812,
                0.0006244182586669922,
                0.0006539821624755859,
                0.0006639957427978516,
                0.0006906986236572266,
                0.0008378028869628906,
                0.0008947849273681641,
                0.0065975189208984375,
                0.014901161193847656
            ],
            "beyond_p": 0.0
        }
    ],
    "construct-the-rectangle": [
        {
            "slug_name": "construct-the-rectangle",
            "result": {
                "result": "passed",
                "runtime": 0.0008087158203125,
                "index": 0
            },
            "solution": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        # Start with the largest possible square smaller than or equal to the area\n        width = int(area**0.5)\n        # Decrease width until we find the one that divides the area exactly\n        while area % width != 0:\n            width -= 1\n        # Calculate the length by dividing the area by the width\n        length = area // width\n        # Return the dimensions with length being greater than or equal to width\n        return [length, width]\n\n# Example usage:\n# sol = Solution()\n# print(sol.constructRectangle(4))  # Output: [2, 2]\n# print(sol.constructRectangle(37)) # Output: [37, 1]\n# print(sol.constructRectangle(122122)) # Output: [427, 286]",
            "runtimes": [
                0.0010573863983154297,
                0.025457382202148438,
                0.04261946678161621,
                0.04375123977661133,
                0.04582929611206055,
                0.05850958824157715,
                0.08162975311279297,
                0.16502785682678223,
                0.5949950218200684,
                0.6614911556243896,
                0.7419078350067139,
                0.9621293544769287,
                1.0686814785003662,
                1.1973049640655518,
                1.3696556091308594,
                1.4177682399749756,
                1.6171536445617676
            ],
            "beyond_p": 1.0001538711427285
        }
    ],
    "word-ladder-ii": [
        {
            "slug_name": "word-ladder-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0003628730773925781,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        from collections import defaultdict, deque\n\n        def add_word(word, dict):\n            for i in range(len(word)):\n                pattern = word[:i] + '_' + word[i+1:]\n                dict[pattern].append(word)\n\n        def bfs(front_level, end_level, is_forward, word_set, parent_map):\n            if len(front_level) == 0:\n                return False\n            if len(front_level) > len(end_level):\n                return bfs(end_level, front_level, not is_forward, word_set, parent_map)\n\n            for word in (front_level | end_level):\n                word_set.discard(word)\n\n            next_level = set()\n            done = False\n            while front_level:\n                word = front_level.pop()\n                for i in range(len(word)):\n                    pattern = word[:i] + '_' + word[i+1:]\n                    for next_word in pattern_dict[pattern]:\n                        if next_word in end_level:\n                            done = True\n                            add_parent(parent_map, word, next_word, is_forward)\n                        if not done and next_word in word_set:\n                            next_level.add(next_word)\n                            add_parent(parent_map, word, next_word, is_forward)\n            return done or bfs(next_level, end_level, is_forward, word_set, parent_map)\n\n        def add_parent(parent_map, word, next_word, is_forward):\n            if not is_forward:\n                word, next_word = next_word, word\n            if next_word not in parent_map:\n                parent_map[next_word] = [word]\n            else:\n                parent_map[next_word].append(word)\n\n        def construct_paths(beginWord, endWord, parent_map):\n            if beginWord == endWord:\n                return [[beginWord]]\n            if endWord not in parent_map:\n                return []\n            paths = []\n            for parent in parent_map[endWord]:\n                for path in construct_paths(beginWord, parent, parent_map):\n                    paths.append(path + [endWord])\n            return paths\n\n        if endWord not in wordList:\n            return []\n\n        wordList = set(wordList)\n        pattern_dict = defaultdict(list)\n        for word in wordList:\n            add_word(word, pattern_dict)\n\n        front_level = {beginWord}\n        end_level = {endWord}\n        is_forward = True\n        parent_map = {}\n        word_set = set(wordList)\n\n        if not bfs(front_level, end_level, is_forward, word_set, parent_map):\n            return []\n\n        return construct_paths(beginWord, endWord, parent_map)\n\n# Example usage:\n# sol = Solution()\n# print(sol.findLadders(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]))\n# Output: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
            "runtimes": [
                0.0002818107604980469,
                0.0002899169921875,
                0.00031065940856933594,
                0.0003113746643066406,
                0.0003364086151123047,
                0.00035262107849121094,
                0.0003533363342285156,
                0.0003669261932373047,
                0.0003814697265625,
                0.0003991127014160156,
                0.0004429817199707031,
                0.00045013427734375,
                0.0004837512969970703,
                0.0011484622955322266,
                0.0012693405151367188,
                0.006010770797729492,
                0.006836891174316406
            ],
            "beyond_p": 0.987633665527024
        }
    ],
    "balanced-binary-tree": [
        {
            "slug_name": "balanced-binary-tree",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "def getHeight(self, node):\n            if not node:\n                return 0\n            left_height = self.getHeight(node.left)\n            if left_height == -1:\n                return -1\n            right_height = self.getHeight(node.right)\n            if right_height == -1:\n                return -1\n            if abs(left_height - right_height) > 1:\n                return -1\n            return max(left_height, right_height) + 1\n\n        def isBalanced(self, root):\n            return self.getHeight(root) != -1",
            "runtimes": [
                0.0006034374237060547,
                0.0006101131439208984,
                0.0006124973297119141,
                0.0006420612335205078,
                0.0006532669067382812,
                0.0006608963012695312,
                0.0006954669952392578,
                0.0006964206695556641,
                0.0007092952728271484,
                0.0007135868072509766,
                0.0007224082946777344,
                0.0007328987121582031,
                0.0007476806640625,
                0.0007510185241699219,
                0.0007567405700683594,
                0.0007700920104980469,
                0.0007977485656738281,
                0.0008044242858886719,
                0.0008244514465332031,
                0.0008492469787597656,
                0.0009875297546386719,
                0.0011119842529296875,
                0.00112152099609375
            ],
            "beyond_p": 0.0
        }
    ],
    "power-of-two": [
        {
            "slug_name": "power-of-two",
            "result": {
                "result": "passed",
                "runtime": 0.00030493736267089844,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        # Follow up: Solve without loops/recursion\n        # A number is a power of two if it is greater than 0 and\n        # its binary representation contains only one '1'.\n        return n > 0 and (n & (n - 1)) == 0\n\n# Example usage:\n# sol = Solution()\n# print(sol.isPowerOfTwo(1))  # Output: true\n# print(sol.isPowerOfTwo(16)) # Output: true\n# print(sol.isPowerOfTwo(3))  # Output: false",
            "runtimes": [
                0.0002620220184326172,
                0.0002624988555908203,
                0.00026917457580566406,
                0.0002968311309814453,
                0.00030159950256347656,
                0.0003020763397216797,
                0.0003027915954589844,
                0.00030732154846191406,
                0.00031185150146484375,
                0.00032830238342285156,
                0.00034618377685546875,
                0.006447315216064453,
                0.012327432632446289
            ],
            "beyond_p": 0.996443109512706
        }
    ],
    "subsets-ii": [
        {
            "slug_name": "subsets-ii",
            "result": {
                "result": "passed",
                "runtime": 0.002071380615234375,
                "index": 0
            },
            "solution": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                backtrack(i + 1, path + [nums[i]])\n        \n        nums.sort()\n        res = []\n        backtrack(0, [])\n        return res\n\n# Example usage:\n# sol = Solution()\n# print(sol.subsetsWithDup([1,2,2]))\n# print(sol.subsetsWithDup([0]))",
            "runtimes": [
                0.0014865398406982422,
                0.0016632080078125,
                0.001678466796875,
                0.0016820430755615234,
                0.0017538070678710938,
                0.0017805099487304688,
                0.0018296241760253906,
                0.0019369125366210938,
                0.0021364688873291016,
                0.002150297164916992,
                0.0024039745330810547,
                0.005144596099853516,
                0.005613565444946289,
                0.005861997604370117,
                0.008132457733154297,
                0.008571624755859375,
                0.011773824691772461,
                0.020061016082763672
            ],
            "beyond_p": 0.9685137407421669
        }
    ],
    "largest-rectangle-in-histogram": [
        {
            "slug_name": "largest-rectangle-in-histogram",
            "result": {
                "result": "passed",
                "runtime": 0.002001523971557617,
                "index": 0
            },
            "solution": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        stack = []\n        max_area = 0\n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                max_area = max(max_area, height * (i - index))\n                start = index\n            stack.append((start, h))\n        \n        for i, h in stack:\n            max_area = max(max_area, h * (len(heights) - i))\n        return max_area\n\n# Example usage:\n# heights = [2,1,5,6,2,3]\n# print(Solution().largestRectangleArea(heights))\n# Output: 10",
            "runtimes": [
                0.0015137195587158203,
                0.0015940666198730469,
                0.0016841888427734375,
                0.0016922950744628906,
                0.0017709732055664062,
                0.0017926692962646484,
                0.0018818378448486328,
                0.0019042491912841797,
                0.001954317092895508,
                0.001972675323486328,
                0.0019996166229248047,
                0.0020003318786621094,
                0.002046346664428711,
                0.0021212100982666016,
                0.002174854278564453,
                0.002472400665283203,
                0.0024831295013427734,
                0.002495288848876953,
                0.002523660659790039,
                0.0026280879974365234,
                0.003206014633178711,
                0.0033190250396728516,
                0.004743099212646484,
                0.006046295166015625,
                0.006606101989746094,
                0.008637666702270508,
                0.008638620376586914,
                0.03500699996948242,
                0.04991412162780762
            ],
            "beyond_p": 0.989921480153296
        }
    ],
    "evaluate-reverse-polish-notation": [
        {
            "slug_name": "evaluate-reverse-polish-notation",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "stack = []\n        for token in tokens:\n            if token not in '+-*/':\n                stack.append(int(token))\n            else:\n                right_operand = stack.pop()\n                left_operand = stack.pop()\n                if token == '+':\n                    stack.append(left_operand + right_operand)\n                elif token == '-':\n                    stack.append(left_operand - right_operand)\n                elif token == '*':\n                    stack.append(left_operand * right_operand)\n                elif token == '/':\n                    stack.append(int(float(left_operand) / right_operand))\n        return stack[0]",
            "runtimes": [
                0.0003132820129394531,
                0.0003135204315185547,
                0.0003228187561035156,
                0.00032782554626464844,
                0.0003304481506347656,
                0.0003368854522705078,
                0.0003426074981689453,
                0.00034356117248535156,
                0.00035262107849121094,
                0.0003566741943359375,
                0.0003616809844970703,
                0.0003635883331298828,
                0.0003724098205566406,
                0.0004000663757324219,
                0.00040721893310546875,
                0.0004305839538574219,
                0.0005633831024169922,
                0.0006120204925537109,
                0.010743141174316406
            ],
            "beyond_p": 0.0
        }
    ],
    "perfect-rectangle": [
        {
            "slug_name": "perfect-rectangle",
            "result": {
                "result": "passed",
                "runtime": 0.0003311634063720703,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        # Calculate the area of the big rectangle\n        X1, Y1 = min(x for x, _, _, _ in rectangles), min(y for _, y, _, _ in rectangles)\n        X2, Y2 = max(a for _, _, a, _ in rectangles), max(b for _, _, _, b in rectangles)\n        expected_area = (X2 - X1) * (Y2 - Y1)\n\n        # Calculate the sum of areas of all small rectangles\n        actual_area = sum((x2 - x1) * (y2 - y1) for x1, y1, x2, y2 in rectangles)\n\n        # Check if the total area of small rectangles equals the area of the big rectangle\n        if expected_area != actual_area:\n            return False\n\n        # Check for overlap and count corners\n        corners = set()\n        for x1, y1, x2, y2 in rectangles:\n            p1, p2, p3, p4 = (x1, y1), (x2, y2), (x1, y2), (x2, y1)\n            for p in [p1, p2, p3, p4]:\n                if p in corners:\n                    corners.remove(p)\n                else:\n                    corners.add(p)\n\n        # There should be exactly 4 corners for the big rectangle\n        if len(corners) != 4 or (X1, Y1) not in corners or (X2, Y2) not in corners or (X1, Y2) not in corners or (X2, Y1) not in corners:\n            return False\n\n        return True\n\n# Example usage:\n# sol = Solution()\n# print(sol.isRectangleCover([[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]])) # Output: true\n# print(sol.isRectangleCover([[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]])) # Output: false\n# print(sol.isRectangleCover([[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]])) # Output: false",
            "runtimes": [
                0.0004296302795410156,
                0.0004336833953857422,
                0.00044083595275878906,
                0.0004904270172119141,
                0.0005757808685302734,
                0.0006377696990966797,
                0.0007410049438476562,
                0.0008778572082519531
            ],
            "beyond_p": 1.2196808510638297
        }
    ],
    "excel-sheet-column-title": [
        {
            "slug_name": "excel-sheet-column-title",
            "result": {
                "result": "passed",
                "runtime": 0.00028324127197265625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        result = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            result = chr(65 + (columnNumber % 26)) + result\n            columnNumber //= 26\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.convertToTitle(1))  # Output: \"A\"\n# print(sol.convertToTitle(28)) # Output: \"AB\"\n# print(sol.convertToTitle(701)) # Output: \"ZY\"",
            "runtimes": [
                0.000274658203125,
                0.00027561187744140625,
                0.00028443336486816406,
                0.0003135204315185547,
                0.0003142356872558594,
                0.00031948089599609375,
                0.0003209114074707031,
                0.0003256797790527344,
                0.00033545494079589844,
                0.0003368854522705078,
                0.00034880638122558594,
                0.0003554821014404297,
                0.00043964385986328125,
                0.0004956722259521484
            ],
            "beyond_p": 0.9611650485436893
        }
    ],
    "maximum-subarray": [
        {
            "slug_name": "maximum-subarray",
            "result": {
                "result": "passed",
                "runtime": 0.0010044574737548828,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_sum = nums[0]\n        current_sum = nums[0]\n\n        for num in nums[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n\n        return max_sum\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxSubArray([-2,1,-3,4,-1,2,1,-5,4]))  # Output: 6\n# print(sol.maxSubArray([1]))                       # Output: 1\n# print(sol.maxSubArray([5,4,-1,7,8]))              # Output: 23",
            "runtimes": [
                0.00044226646423339844,
                0.000484466552734375,
                0.0005104541778564453,
                0.0005519390106201172,
                0.0005762577056884766,
                0.00064849853515625,
                0.000667572021484375,
                0.0007283687591552734,
                0.0007493495941162109,
                0.0007503032684326172,
                0.0007617473602294922,
                0.0008332729339599609,
                0.0008394718170166016,
                0.0008871555328369141,
                0.0008904933929443359,
                0.0009822845458984375,
                0.0010180473327636719,
                0.0011677742004394531,
                0.001378774642944336,
                0.0016388893127441406
            ],
            "beyond_p": 0.5301852958756724
        }
    ],
    "sliding-puzzle": [
        {
            "slug_name": "sliding-puzzle",
            "result": {
                "result": "passed",
                "runtime": 0.0026056766510009766,
                "index": 0
            },
            "solution": "import collections\n\nclass Solution(object):\n    def slidingPuzzle(self, board):\n        # Convert the board into a string representation\n        start = ''.join(str(num) for row in board for num in row)\n        target = '123450'\n        # Use a BFS approach\n        queue = collections.deque([(start, start.index('0'))])\n        visited = set()\n        visited.add(start)\n        moves = 0\n        # Define the neighbors based on the index of '0'\n        neighbors = [\n            [1, 3], [0, 2, 4], [1, 5],\n            [0, 4], [1, 3, 5], [2, 4]\n        ]\n        \n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                state, zero = queue.popleft()\n                if state == target:\n                    return moves\n                for neighbor in neighbors[zero]:\n                    new_state = list(state)\n                    new_state[zero], new_state[neighbor] = new_state[neighbor], new_state[zero]\n                    new_state = ''.join(new_state)\n                    if new_state not in visited:\n                        visited.add(new_state)\n                        queue.append((new_state, neighbor))\n            moves += 1\n        \n        return -1\n\n# Example usage:\n# sol = Solution()\n# print(sol.slidingPuzzle([[1,2,3],[4,0,5]]))  # Output: 1\n# print(sol.slidingPuzzle([[1,2,3],[5,4,0]]))  # Output: -1\n# print(sol.slidingPuzzle([[4,1,2],[5,0,3]]))  # Output: 5",
            "runtimes": [
                0.002438068389892578,
                0.0025947093963623047,
                0.002899646759033203,
                0.003477334976196289,
                0.004315376281738281,
                0.0051267147064208984,
                0.005578041076660156,
                0.008916616439819336,
                0.009488582611083984,
                0.01090240478515625,
                0.022661447525024414,
                0.02543020248413086,
                0.02930927276611328,
                0.0404658317565918,
                0.046304941177368164,
                0.06309866905212402,
                0.13129782676696777
            ],
            "beyond_p": 0.9986992971023744
        }
    ],
    "isomorphic-strings": [
        {
            "slug_name": "isomorphic-strings",
            "result": {
                "result": "passed",
                "runtime": 0.0003285408020019531,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n\n        char_map_s_to_t = {}\n        char_map_t_to_s = {}\n\n        for char_s, char_t in zip(s, t):\n            if char_s not in char_map_s_to_t and char_t not in char_map_t_to_s:\n                char_map_s_to_t[char_s] = char_t\n                char_map_t_to_s[char_t] = char_s\n            elif char_map_s_to_t.get(char_s) != char_t or char_map_t_to_s.get(char_t) != char_s:\n                return False\n\n        return True\n\n# Example usage:\n# sol = Solution()\n# print(sol.isIsomorphic('egg', 'add'))  # Output: true\n# print(sol.isIsomorphic('foo', 'bar'))  # Output: false\n# print(sol.isIsomorphic('paper', 'title'))  # Output: true",
            "runtimes": [
                0.0002987384796142578,
                0.00030994415283203125,
                0.0003254413604736328,
                0.0003333091735839844,
                0.0003342628479003906,
                0.0003421306610107422,
                0.00036215782165527344,
                0.00040650367736816406,
                0.0004451274871826172,
                0.0004849433898925781,
                0.0005338191986083984,
                0.0005970001220703125,
                0.0013685226440429688,
                0.0014774799346923828,
                0.001611471176147461,
                0.0025141239166259766,
                0.0037713050842285156,
                0.0042264461517333984,
                0.006163835525512695,
                0.01911473274230957
            ],
            "beyond_p": 0.9984161175874303
        }
    ],
    "search-in-rotated-sorted-array-ii": [
        {
            "slug_name": "search-in-rotated-sorted-array-ii",
            "result": {
                "result": "passed",
                "runtime": 0.00037026405334472656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.search([2,5,6,0,0,1,2], 0))  # Output: true\n# print(sol.search([2,5,6,0,0,1,2], 3))  # Output: false",
            "runtimes": [
                0.00029397010803222656,
                0.00029468536376953125,
                0.00029921531677246094,
                0.00030422210693359375,
                0.0003070831298828125,
                0.0003235340118408203,
                0.0003247261047363281,
                0.0003304481506347656,
                0.000331878662109375,
                0.00033211708068847656,
                0.0003330707550048828,
                0.00033664703369140625,
                0.000347137451171875,
                0.00034928321838378906,
                0.0003752708435058594,
                0.0006480216979980469
            ],
            "beyond_p": 0.7845117845117845
        }
    ],
    "unique-paths-ii": [
        {
            "slug_name": "unique-paths-ii",
            "result": {
                "result": "passed",
                "runtime": 0.020794153213500977,
                "index": 0
            },
            "solution": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                else:\n                    if i > 0:\n                        dp[i][j] += dp[i - 1][j]\n                    if j > 0:\n                        dp[i][j] += dp[i][j - 1]\n\n        return dp[m - 1][n - 1]",
            "runtimes": [
                0.0002865791320800781,
                0.0003647804260253906,
                0.0004730224609375,
                0.001058340072631836,
                0.0011963844299316406,
                0.0012125968933105469,
                0.0012309551239013672,
                0.0012526512145996094,
                0.0013360977172851562,
                0.0016942024230957031,
                0.0019075870513916016,
                0.0020935535430908203,
                0.0021142959594726562,
                0.0022628307342529297,
                0.002279043197631836,
                0.002307415008544922,
                0.0027310848236083984,
                0.003076314926147461,
                0.009200572967529297,
                0.00980687141418457
            ],
            "beyond_p": 0.0
        }
    ],
    "decode-ways-ii": [
        {
            "slug_name": "decode-ways-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0022056102752685547,
                "index": 0
            },
            "solution": "class Solution(object):\n    def numDecodings(self, s):\n        MOD = 10**9 + 7\n\n        # A helper function to calculate the number of ways to decode a single character.\n        def ways(ch):\n            if ch == '*':\n                return 9\n            if ch == '0':\n                return 0\n            return 1\n\n        # A helper function to calculate the number of ways to decode a two-character string.\n        def ways2(ch1, ch2):\n            if ch1 == '*' and ch2 == '*':\n                return 15\n            if ch1 == '*':\n                return 2 if ch2 <= '6' else 1\n            if ch2 == '*':\n                if ch1 == '1':\n                    return 9\n                if ch1 == '2':\n                    return 6\n                return 0\n            return int(ch1 == '1' or (ch1 == '2' and ch2 <= '6'))\n\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = ways(s[0])\n\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] * ways(s[i - 1])\n            dp[i] += dp[i - 2] * ways2(s[i - 2], s[i - 1])\n            dp[i] %= MOD\n\n        return dp[n]\n\n# Example usage:\n# sol = Solution()\n# print(sol.numDecodings('*'))  # Output: 9\n# print(sol.numDecodings('1*')) # Output: 18\n# print(sol.numDecodings('2*')) # Output: 15",
            "runtimes": [
                0.0003008842468261719,
                0.0003058910369873047,
                0.0003185272216796875,
                0.0004038810729980469,
                0.0004229545593261719,
                0.0005314350128173828,
                0.0006473064422607422,
                0.001100301742553711,
                0.0019099712371826172,
                0.0020401477813720703,
                0.002229928970336914,
                0.0023446083068847656,
                0.0026264190673828125,
                0.007617473602294922,
                0.00781559944152832,
                0.0138397216796875,
                0.028776168823242188
            ],
            "beyond_p": 0.933109499807425
        }
    ],
    "3sum-closest": [
        {
            "slug_name": "3sum-closest",
            "result": {
                "result": "passed",
                "runtime": 0.23300623893737793,
                "index": 0
            },
            "solution": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        closest_sum = float('inf')\n        for i in range(len(nums) - 2):\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                if abs(target - current_sum) < abs(target - closest_sum):\n                    closest_sum = current_sum\n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    return target\n        return closest_sum",
            "runtimes": [
                0.0003991127014160156,
                0.00042128562927246094,
                0.042305707931518555,
                0.08716917037963867,
                0.08737659454345703,
                0.09429764747619629,
                0.11161613464355469,
                0.11732292175292969,
                0.12200188636779785,
                0.12861347198486328,
                0.14289522171020508,
                0.15631961822509766,
                0.1599116325378418,
                0.16130280494689941,
                0.16130995750427246,
                0.16922378540039062,
                0.1765601634979248,
                0.194993257522583,
                0.2197434902191162,
                0.23093366622924805,
                0.23354339599609375,
                0.2505638599395752,
                0.3092339038848877,
                0.350508451461792,
                0.4331676959991455,
                0.5155556201934814
            ],
            "beyond_p": 0.5484728954150995
        }
    ],
    "maximum-depth-of-binary-tree": [
        {
            "slug_name": "maximum-depth-of-binary-tree",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "if not root:\n            return 0\n        else:\n            left_depth = self.maxDepth(root.left)\n            right_depth = self.maxDepth(root.right)\n            return max(left_depth, right_depth) + 1",
            "runtimes": [
                0.0003898143768310547,
                0.00040340423583984375,
                0.0004088878631591797,
                0.00041222572326660156,
                0.0004239082336425781,
                0.0004239082336425781,
                0.0004334449768066406,
                0.00043845176696777344,
                0.00044417381286621094,
                0.00044608116149902344,
                0.00044918060302734375,
                0.0004513263702392578,
                0.0004553794860839844,
                0.00047516822814941406,
                0.00048279762268066406,
                0.0005707740783691406,
                0.0006086826324462891,
                0.006532907485961914
            ],
            "beyond_p": 0.0
        }
    ],
    "intersection-of-two-arrays-ii": [
        {
            "slug_name": "intersection-of-two-arrays-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0009620189666748047,
                "index": 0
            },
            "solution": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        from collections import Counter\n        counts = Counter(nums1)\n        intersection = []\n        for num in nums2:\n            if counts[num] > 0:\n                intersection.append(num)\n                counts[num] -= 1\n        return intersection",
            "runtimes": [
                0.0008080005645751953,
                0.0008451938629150391,
                0.0008728504180908203,
                0.0009176731109619141,
                0.0009353160858154297,
                0.0009503364562988281,
                0.0009555816650390625,
                0.0011217594146728516,
                0.0011241436004638672,
                0.0019485950469970703,
                0.003670930862426758,
                0.004293680191040039,
                0.00457763671875,
                0.01633453369140625,
                0.024512052536010742,
                0.025350332260131836,
                0.025919198989868164,
                0.05761551856994629
            ],
            "beyond_p": 0.9972887672704686
        }
    ],
    "minimum-absolute-difference-in-bst": [
        {
            "slug_name": "minimum-absolute-difference-in-bst",
            "result": {
                "result": "passed",
                "runtime": 0.000518798828125,
                "index": 0
            },
            "solution": "import sys\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        # Initialize previous node as None and min difference as max value\n        self.prev = None\n        self.min_diff = sys.maxsize\n        \n        def inorder(node):\n            # Inorder traversal of BST yields sorted values\n            if not node:\n                return\n            inorder(node.left)\n            if self.prev is not None:\n                self.min_diff = min(self.min_diff, node.val - self.prev.val)\n            self.prev = node\n            inorder(node.right)\n        \n        # Perform inorder traversal\n        inorder(root)\n        return self.min_diff",
            "runtimes": [
                0.0005102157592773438,
                0.0005104541778564453,
                0.0005245208740234375,
                0.0005271434783935547,
                0.0005383491516113281,
                0.0005464553833007812,
                0.0005514621734619141,
                0.0005908012390136719,
                0.0005962848663330078,
                0.0006055831909179688,
                0.0006091594696044922,
                0.0006105899810791016,
                0.0006117820739746094,
                0.0006124973297119141,
                0.0006387233734130859,
                0.0006418228149414062,
                0.0007712841033935547,
                0.0008461475372314453,
                0.006701231002807617,
                0.008759498596191406,
                0.013761043548583984,
                0.01845264434814453
            ],
            "beyond_p": 0.9995216328266184
        }
    ],
    "find-mode-in-binary-search-tree": [
        {
            "slug_name": "find-mode-in-binary-search-tree",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Helper function to perform in-order traversal and track the count of elements\n        def in_order_traversal(node):\n            if not node:\n                return\n            in_order_traversal(node.left)\n            if self.prev_val == node.val:\n                self.curr_count += 1\n            else:\n                self.prev_val = node.val\n                self.curr_count = 1\n            if self.curr_count > self.max_count:\n                self.max_count = self.curr_count\n                self.modes = [node.val]\n            elif self.curr_count == self.max_count:\n                self.modes.append(node.val)\n            in_order_traversal(node.right)\n\n        self.prev_val = None\n        self.curr_count = 0\n        self.max_count = 0\n        self.modes = []\n        in_order_traversal(root)\n        return self.modes",
            "runtimes": [
                0.0004887580871582031,
                0.0005052089691162109,
                0.0005176067352294922,
                0.0005359649658203125,
                0.0005476474761962891,
                0.0005662441253662109,
                0.0005886554718017578,
                0.0006129741668701172,
                0.0006597042083740234,
                0.0008916854858398438,
                0.0009183883666992188,
                0.0013360977172851562,
                0.009750843048095703
            ],
            "beyond_p": 0.0
        }
    ],
    "find-the-index-of-the-first-occurrence-in-a-string": [
        {
            "slug_name": "find-the-index-of-the-first-occurrence-in-a-string",
            "result": {
                "result": "passed",
                "runtime": 0.0007398128509521484,
                "index": 0
            },
            "solution": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        # Check if needle is an empty string\n        if not needle:\n            return 0\n\n        # Iterate through the haystack to find the needle\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n\n        # If needle is not found, return -1\n        return -1",
            "runtimes": [
                0.00023674964904785156,
                0.00024127960205078125,
                0.00027632713317871094,
                0.00028252601623535156,
                0.0003120899200439453,
                0.00033402442932128906,
                0.0003695487976074219,
                0.0006761550903320312,
                0.0006999969482421875,
                0.0007526874542236328,
                0.0008025169372558594,
                0.0008411407470703125,
                0.0011942386627197266,
                0.0017323493957519531,
                0.009473323822021484,
                0.013159751892089844,
                0.06606173515319824,
                0.33176159858703613
            ],
            "beyond_p": 0.9984825776905839
        }
    ],
    "strong-password-checker": [
        {
            "slug_name": "strong-password-checker",
            "result": {
                "result": "failed@cases",
                "runtime": 0.0003170967102050781,
                "index": 0
            },
            "solution": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        def count_repeating_chars(s):\n            count = 0\n            i = 2\n            while i < len(s):\n                if s[i] == s[i-1] == s[i-2]:\n                    count += 1\n                    i += 2\n                else:\n                    i += 1\n            return count\n\n        length = len(password)\n        has_lower = any(c.islower() for c in password)\n        has_upper = any(c.isupper() for c in password)\n        has_digit = any(c.isdigit() for c in password)\n        repeating_chars = count_repeating_chars(password)\n\n        steps = 0\n        steps += not has_lower\n        steps += not has_upper\n        steps += not has_digit\n\n        if length < 6:\n            steps += max(6 - length, 3 - (has_lower + has_upper + has_digit))\n        elif length > 20:\n            delete_steps = length - 20\n            steps += delete_steps\n            repeating_chars = max(0, repeating_chars - delete_steps // 3)\n        steps += repeating_chars\n\n        return steps\n\n# Example usage:\n# sol = Solution()\n# print(sol.strongPasswordChecker('a'))  # Output: 5\n# print(sol.strongPasswordChecker('aA1'))  # Output: 3\n# print(sol.strongPasswordChecker('1337C0d3'))  # Output: 0",
            "runtimes": [
                0.00031375885009765625,
                0.00035190582275390625,
                0.0003559589385986328,
                0.000377655029296875,
                0.00038623809814453125,
                0.00042366981506347656,
                0.0005018711090087891,
                0.0005559921264648438,
                0.001039743423461914,
                0.0010831356048583984
            ],
            "beyond_p": 0.0
        }
    ],
    "factorial-trailing-zeroes": [
        {
            "slug_name": "factorial-trailing-zeroes",
            "result": {
                "result": "passed",
                "runtime": 0.00031113624572753906,
                "index": 0
            },
            "solution": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # Initialize count of trailing zeroes\n        count = 0\n\n        # Keep dividing n by powers of 5 and update count\n        while n > 0:\n            n //= 5\n            count += n\n\n        return count\n\n# Example usage:\n# sol = Solution()\n# print(sol.trailingZeroes(3))  # Output: 0\n# print(sol.trailingZeroes(5))  # Output: 1\n# print(sol.trailingZeroes(0))  # Output: 0",
            "runtimes": [
                0.0003070831298828125,
                0.0003197193145751953,
                0.007764339447021484,
                0.01671004295349121,
                0.028330564498901367,
                0.03329920768737793,
                0.038884878158569336,
                0.049005985260009766,
                0.06417250633239746,
                0.06555461883544922,
                0.07645916938781738,
                0.09531450271606445,
                0.10853314399719238,
                0.11604762077331543,
                0.12901663780212402,
                0.14856553077697754,
                0.15306353569030762,
                0.1607513427734375,
                0.23842525482177734
            ],
            "beyond_p": 0.9999829785529768
        }
    ],
    "zigzag-conversion": [
        {
            "slug_name": "zigzag-conversion",
            "result": {
                "result": "passed",
                "runtime": 0.0007495880126953125,
                "index": 0
            },
            "solution": "class Solution(object):\n    def convert(self, s, numRows):\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        # Initialize an array to hold the zigzag pattern\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n\n        # Iterate through each character in the string\n        for char in s:\n            rows[current_row] += char\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n            current_row += 1 if going_down else -1\n\n        # Concatenate all rows to get the final string\n        return ''.join(rows)\n\n# Example usage:\n# sol = Solution()\n# output = sol.convert(\"PAYPALISHIRING\", 3)\n# print(output)  # Output: \"PAHNAPLSIIGYIR\"\n\n# output = sol.convert(\"PAYPALISHIRING\", 4)\n# print(output)  # Output: \"PINALSIGYAHRPI\"\n\n# output = sol.convert(\"A\", 1)\n# print(output)  # Output: \"A\"",
            "runtimes": [
                0.0007255077362060547,
                0.0009627342224121094,
                0.0011260509490966797,
                0.0013134479522705078,
                0.001386880874633789,
                0.004154682159423828,
                0.008605241775512695,
                0.008821964263916016,
                0.012139320373535156,
                0.014705419540405273,
                0.02817821502685547,
                0.03956890106201172,
                0.04112958908081055,
                0.04375267028808594,
                0.05668163299560547,
                0.05910754203796387,
                0.05989646911621094,
                0.06628680229187012,
                0.07432103157043457,
                0.07655644416809082,
                0.07925772666931152
            ],
            "beyond_p": 0.9996933707360317
        }
    ],
    "trapping-rain-water": [
        {
            "slug_name": "trapping-rain-water",
            "result": {
                "result": "passed",
                "runtime": 0.00046944618225097656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n\n        left_max = [0] * len(height)\n        right_max = [0] * len(height)\n        water_trapped = 0\n\n        left_max[0] = height[0]\n        for i in range(1, len(height)):\n            left_max[i] = max(left_max[i - 1], height[i])\n\n        right_max[-1] = height[-1]\n        for i in range(len(height) - 2, -1, -1):\n            right_max[i] = max(right_max[i + 1], height[i])\n\n        for i in range(len(height)):\n            water_trapped += min(left_max[i], right_max[i]) - height[i]\n\n        return water_trapped\n\n# Example usage:\n# sol = Solution()\n# print(sol.trap([0,1,0,2,1,0,1,3,2,1,2,1]))  # Output: 6\n# print(sol.trap([4,2,0,3,2,5]))  # Output: 9",
            "runtimes": [
                0.0003294944763183594,
                0.00036072731018066406,
                0.0003612041473388672,
                0.00040435791015625,
                0.0004286766052246094,
                0.0004661083221435547,
                0.0004742145538330078,
                0.0004954338073730469,
                0.0005097389221191406,
                0.0005159378051757812,
                0.0005688667297363281,
                0.0005853176116943359,
                0.0005924701690673828,
                0.0006349086761474609,
                0.0006577968597412109,
                0.0006766319274902344,
                0.0006861686706542969,
                0.0007565021514892578,
                0.0008275508880615234,
                0.0065038204193115234,
                0.024188518524169922
            ],
            "beyond_p": 0.9941342233591813
        }
    ],
    "find-all-numbers-disappeared-in-an-array": [
        {
            "slug_name": "find-all-numbers-disappeared-in-an-array",
            "result": {
                "result": "passed",
                "runtime": 0.004155397415161133,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for num in nums:\n            index = abs(num) - 1\n            nums[index] = -abs(nums[index])\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]",
            "runtimes": [
                0.0002722740173339844,
                0.0002760887145996094,
                0.00028395652770996094,
                0.0003075599670410156,
                0.00031256675720214844,
                0.00031280517578125,
                0.0003170967102050781,
                0.00032067298889160156,
                0.0003304481506347656,
                0.00033354759216308594,
                0.0003383159637451172,
                0.0003581047058105469,
                0.00036215782165527344,
                0.0003638267517089844,
                0.0003750324249267578,
                0.00037980079650878906,
                0.0003883838653564453,
                0.00039768218994140625,
                0.00040030479431152344,
                0.0004286766052246094,
                0.0004913806915283203,
                0.0005257129669189453,
                0.030835628509521484
            ],
            "beyond_p": 0.8729483899151274
        }
    ],
    "count-of-smaller-numbers-after-self": [
        {
            "slug_name": "count-of-smaller-numbers-after-self",
            "result": {
                "result": "passed",
                "runtime": 0.0010025501251220703,
                "index": 0
            },
            "solution": "class Solution(object):\n    def countSmaller(self, nums):\n        def sort(enum):\n            half = len(enum) // 2\n            if half:\n                left, right = sort(enum[:half]), sort(enum[half:])\n                for i in range(len(enum))[::-1]:\n                    if not right or left and left[-1][1] > right[-1][1]:\n                        smaller[left[-1][0]] += len(right)\n                        enum[i] = left.pop()\n                    else:\n                        enum[i] = right.pop()\n            return enum\n\n        smaller = [0] * len(nums)\n        sort(list(enumerate(nums)))\n        return smaller\n\n# Example usage:\n# sol = Solution()\n# print(sol.countSmaller([5,2,6,1]))  # Output: [2,1,1,0]\n# print(sol.countSmaller([-1]))      # Output: [0]\n# print(sol.countSmaller([-1,-1]))   # Output: [0,0]",
            "runtimes": [
                0.00039505958557128906,
                0.00041222572326660156,
                0.0004169940948486328,
                0.0006630420684814453,
                0.0008718967437744141,
                0.0008730888366699219,
                0.0009183883666992188,
                0.0010364055633544922,
                0.0010554790496826172,
                0.0011358261108398438,
                0.001329660415649414,
                0.0018494129180908203,
                0.0018830299377441406,
                0.001935720443725586,
                0.0024912357330322266,
                0.005875349044799805,
                0.007139682769775391,
                0.016030550003051758,
                0.021650075912475586,
                0.031789302825927734
            ],
            "beyond_p": 0.9806496199032481
        }
    ],
    "set-intersection-size-at-least-two": [
        {
            "slug_name": "set-intersection-size-at-least-two",
            "result": {
                "result": "failed@cases",
                "runtime": 0.34220266342163086,
                "index": 0
            },
            "solution": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        todo = [2] * len(intervals)\n        ans = 0\n        while intervals:\n            (start, end) = intervals.pop()\n            t = todo.pop()\n            for p in range(end - t + 1, end + 1):\n                for i, (s, e) in enumerate(intervals):\n                    if todo[i] and s <= p <= e:\n                        todo[i] -= 1\n            ans += t\n        return ans\n\n# Example usage:\n# intervals = [[1,3],[3,7],[8,9]]\n# sol = Solution()\n# print(sol.intersectionSizeTwo(intervals)) # Output: 5",
            "runtimes": [
                0.0013921260833740234,
                0.0014307498931884766,
                0.0017478466033935547,
                0.0020074844360351562,
                0.003605365753173828,
                0.005469560623168945,
                0.011247634887695312,
                0.011281728744506836,
                0.017327308654785156,
                0.019467830657958984,
                0.023540019989013672
            ],
            "beyond_p": 0.0
        }
    ],
    "symmetric-tree": [
        {
            "slug_name": "symmetric-tree",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Helper function to check if two trees are mirror of each other\n        def isMirror(t1, t2):\n            if t1 is None and t2 is None:\n                return True\n            if t1 is None or t2 is None:\n                return False\n            return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)\n\n        # Check if the tree is symmetric\n        return isMirror(root, root)",
            "runtimes": [
                0.0003876686096191406,
                0.00039649009704589844,
                0.00039887428283691406,
                0.0004024505615234375,
                0.0004067420959472656,
                0.0004069805145263672,
                0.0004153251647949219,
                0.0004265308380126953,
                0.0004448890686035156,
                0.0004889965057373047,
                0.0005056858062744141,
                0.0005586147308349609,
                0.0006129741668701172,
                0.0006182193756103516,
                0.0006201267242431641
            ],
            "beyond_p": 0.0
        }
    ],
    "number-of-atoms": [
        {
            "slug_name": "number-of-atoms",
            "result": {
                "result": "failed@cases",
                "runtime": 0.0019102096557617188,
                "index": 0
            },
            "solution": "import collections\nimport re\n\nclass Solution(object):\n    def countOfAtoms(self, formula):\n        def parse():\n            N = len(formula)\n            count = collections.Counter()\n            stack = [collections.Counter()]\n            i = 0\n            while i < N:\n                if formula[i] == '(':  # Start of a group\n                    stack.append(collections.Counter())\n                    i += 1\n                elif formula[i] == ')':  # End of a group\n                    i += 1\n                    i_start = i\n                    while i < N and formula[i].isdigit():\n                        i += 1\n                    multiplier = int(formula[i_start:i] or 1)\n                    group = stack.pop()\n                    for element, cnt in group.items():\n                        stack[-1][element] += cnt * multiplier\n                else:  # Start of an element\n                    i_start = i\n                    i += 1\n                    while i < N and formula[i].islower():\n                        i += 1\n                    element = formula[i_start:i]\n                    i_start = i\n                    while i < N and formula[i].isdigit():\n                        i += 1\n                    count = int(formula[i_start:i] or 1)\n                    stack[-1][element] += count\n            return stack.pop()\n        \n        # Parse the formula and get the counts\n        counts = parse()\n        \n        # Sort the elements and format the result\n        return ''.join(element + (str(counts[element]) if counts[element] > 1 else '') for element in sorted(counts))\n\n# Example usage:\nsol = Solution()\nprint(sol.countOfAtoms(\"H2O\"))  # Output: \"H2O\"\nprint(sol.countOfAtoms(\"Mg(OH)2\"))  # Output: \"H2MgO2\"\nprint(sol.countOfAtoms(\"K4(ON(SO3)2)2\"))  # Output: \"K4N2O14S4\"",
            "runtimes": [
                0.0019545555114746094,
                0.012276887893676758,
                0.03229498863220215
            ],
            "beyond_p": 0.0
        }
    ],
    "binary-tree-preorder-traversal": [
        {
            "slug_name": "binary-tree-preorder-traversal",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize an empty list to store the preorder traversal result\n        result = []\n\n        # Check if the root is None, return the empty result list\n        if not root:\n            return result\n\n        # Initialize a stack with the root node\n        stack = [root]\n\n        # Iterate while the stack is not empty\n        while stack:\n            # Pop the last node from the stack\n            node = stack.pop()\n            # Append the node's value to the result list\n            result.append(node.val)\n\n            # Push the right child first so that the left child is processed first\n            if node.right:\n                stack.append(node.right)\n\n            # Push the left child to the stack\n            if node.left:\n                stack.append(node.left)\n\n        # Return the result list containing the preorder traversal\n        return result",
            "runtimes": [
                0.00038814544677734375,
                0.0003936290740966797,
                0.0004096031188964844,
                0.0004115104675292969,
                0.0004260540008544922,
                0.00043010711669921875,
                0.0004398822784423828,
                0.0004417896270751953,
                0.0004572868347167969,
                0.0005452632904052734,
                0.0006277561187744141,
                0.0006501674652099609
            ],
            "beyond_p": 0.0
        }
    ],
    "power-of-four": [
        {
            "slug_name": "power-of-four",
            "result": {
                "result": "passed",
                "runtime": 0.00030422210693359375,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        # Follow up: Solve without loops/recursion\n        # A power of four in binary has a '1' followed by an even number of '0's\n        # It also has to be greater than 0\n        if n <= 0:\n            return False\n        # Check if n is a power of 2 (only one '1' in binary representation)\n        if n & (n - 1) != 0:\n            return False\n        # Count the number of zeros after the '1'\n        # A power of four has an even number of zeros\n        # Use the binary representation of n to count zeros\n        # The binary mask 0b01010101010101010101010101010101 will have '1's in the places\n        # where a power of four has its single '1' bit\n        return n & 0b01010101010101010101010101010101 != 0\n\n# Example usage:\n# sol = Solution()\n# print(sol.isPowerOfFour(16))  # Output: true\n# print(sol.isPowerOfFour(5))   # Output: false\n# print(sol.isPowerOfFour(1))   # Output: true",
            "runtimes": [
                0.0002675056457519531,
                0.0002856254577636719,
                0.0002911090850830078,
                0.0002963542938232422,
                0.0003018379211425781,
                0.0003070831298828125,
                0.0003139972686767578,
                0.0003159046173095703,
                0.00032806396484375,
                0.0003333091735839844,
                0.0003345012664794922,
                0.0004215240478515625
            ],
            "beyond_p": 0.7616099071207431
        }
    ],
    "invert-binary-tree": [
        {
            "slug_name": "invert-binary-tree",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "if not root:\n            return None\n        # Swap the left and right children\n        root.left, root.right = root.right, root.left\n        # Recursively call invertTree on the children\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root",
            "runtimes": [
                0.000492095947265625,
                0.0005128383636474609,
                0.0005402565002441406,
                0.0005409717559814453,
                0.0005452632904052734,
                0.00054931640625,
                0.0005543231964111328,
                0.0005600452423095703,
                0.0005748271942138672,
                0.0005822181701660156,
                0.0006539821624755859,
                0.0007512569427490234,
                0.006641864776611328,
                0.0066983699798583984
            ],
            "beyond_p": 0.0
        }
    ],
    "generate-parentheses": [
        {
            "slug_name": "generate-parentheses",
            "result": {
                "result": "passed",
                "runtime": 0.0004215240478515625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def generateParenthesis(self, n):\n        def backtrack(s='', left=0, right=0):\n            if len(s) == 2 * n:\n                result.append(s)\n                return\n            if left < n:\n                backtrack(s+'(', left+1, right)\n            if right < left:\n                backtrack(s+')', left, right+1)\n\n        result = []\n        backtrack()\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.generateParenthesis(3))",
            "runtimes": [
                0.0003662109375,
                0.0003821849822998047,
                0.0003933906555175781,
                0.00039505958557128906,
                0.00040793418884277344,
                0.0004208087921142578,
                0.0004208087921142578,
                0.00042366981506347656,
                0.0004277229309082031,
                0.0004336833953857422,
                0.00043654441833496094,
                0.0004382133483886719,
                0.00045871734619140625,
                0.00046133995056152344,
                0.0005552768707275391,
                0.0007405281066894531,
                0.0007832050323486328,
                0.0013210773468017578,
                0.0016689300537109375
            ],
            "beyond_p": 0.9575402635431918
        }
    ],
    "patching-array": [
        {
            "slug_name": "patching-array",
            "result": {
                "result": "passed",
                "runtime": 0.0008406639099121094,
                "index": 0
            },
            "solution": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        patches = 0\n        current_sum = 0\n        i = 0\n\n        while current_sum < n:\n            if i < len(nums) and nums[i] <= current_sum + 1:\n                current_sum += nums[i]\n                i += 1\n            else:\n                current_sum += current_sum + 1\n                patches += 1\n\n        return patches\n\n# Example usage:\n# sol = Solution()\n# print(sol.minPatches([1,3], 6))  # Output: 1\n# print(sol.minPatches([1,5,10], 20))  # Output: 2\n# print(sol.minPatches([1,2,2], 5))  # Output: 0",
            "runtimes": [
                0.0004928112030029297,
                0.0006773471832275391,
                0.0007100105285644531,
                0.0007257461547851562,
                0.0007367134094238281,
                0.0008246898651123047,
                0.000873565673828125,
                0.0009462833404541016,
                0.0011074542999267578,
                0.023833513259887695
            ],
            "beyond_p": 0.9850967333346953
        }
    ],
    "longest-valid-parentheses": [
        {
            "slug_name": "longest-valid-parentheses",
            "result": {
                "result": "passed",
                "runtime": 0.0007798671722412109,
                "index": 0
            },
            "solution": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        stack = [-1]\n        max_length = 0\n\n        for i in range(len(s)):\n            if s[i] == '(':  # Push the index onto the stack\n                stack.append(i)\n            else:  # ')' encountered\n                stack.pop()  # Pop the last '(' index\n                if not stack:\n                    stack.append(i)  # No matching '(', so push current index\n                else:\n                    # Compute the length of the current valid substring\n                    max_length = max(max_length, i - stack[-1])\n\n        return max_length\n\n# Example usage:\n# sol = Solution()\n# print(sol.longestValidParentheses(\"(()\"))  # Output: 2\n# print(sol.longestValidParentheses(\")()())\"))  # Output: 4\n# print(sol.longestValidParentheses(\"\"))  # Output: 0",
            "runtimes": [
                0.0006034374237060547,
                0.0007038116455078125,
                0.0007050037384033203,
                0.0007846355438232422,
                0.0008225440979003906,
                0.0008242130279541016,
                0.0008409023284912109,
                0.0008485317230224609,
                0.0008528232574462891,
                0.0008552074432373047,
                0.0008816719055175781,
                0.0009489059448242188,
                0.0010066032409667969,
                0.0013413429260253906,
                0.001474142074584961,
                0.007151126861572266,
                0.013178348541259766
            ],
            "beyond_p": 0.9859697021405684
        }
    ],
    "fraction-to-recurring-decimal": [
        {
            "slug_name": "fraction-to-recurring-decimal",
            "result": {
                "result": "passed",
                "runtime": 0.00048065185546875,
                "index": 0
            },
            "solution": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n\n        sign = '-' if numerator * denominator < 0 else ''\n        numerator, denominator = abs(numerator), abs(denominator)\n\n        integer_part = numerator // denominator\n        fractional_part = numerator % denominator\n\n        result = [sign + str(integer_part), '.']\n        seen = {}\n\n        while fractional_part not in seen:\n            seen[fractional_part] = len(result)\n            numerator = fractional_part * 10\n            result.append(str(numerator // denominator))\n            fractional_part = numerator % denominator\n            if fractional_part == 0:\n                return ''.join(result)\n\n        result.insert(seen[fractional_part], '(')\n        result.append(')')\n        return ''.join(result)\n\n# Example usage:\n# sol = Solution()\n# print(sol.fractionToDecimal(1, 2))  # Output: '0.5'\n# print(sol.fractionToDecimal(2, 1))  # Output: '2'\n# print(sol.fractionToDecimal(4, 333))  # Output: '0.(012)'",
            "runtimes": [
                0.0004696846008300781,
                0.000484466552734375,
                0.0005090236663818359,
                0.0005457401275634766,
                0.0005464553833007812,
                0.0005524158477783203,
                0.0005524158477783203,
                0.0005698204040527344,
                0.0007305145263671875,
                0.0007534027099609375,
                0.002323150634765625
            ],
            "beyond_p": 0.9940828402366864
        }
    ],
    "sort-list": [
        {
            "slug_name": "sort-list",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Merge two sorted lists and return the head of the sorted list\n        def merge(l1, l2):\n            dummy = ListNode(0)\n            tail = dummy\n            while l1 and l2:\n                if l1.val < l2.val:\n                    tail.next = l1\n                    l1 = l1.next\n                else:\n                    tail.next = l2\n                    l2 = l2.next\n                tail = tail.next\n            tail.next = l1 or l2\n            return dummy.next\n\n        # Split the list into two halves and return the heads of the two halves\n        def split(head):\n            slow, fast = head, head.next\n            while fast and fast.next:\n                slow = slow.next\n                fast = fast.next.next\n            mid = slow.next\n            slow.next = None\n            return head, mid\n\n        # Main function to sort the linked list\n        if not head or not head.next:\n            return head\n        left, right = split(head)\n        left = self.sortList(left)\n        right = self.sortList(right)\n        return merge(left, right)",
            "runtimes": [
                0.0019216537475585938,
                0.002020597457885742,
                0.002327442169189453,
                0.0025186538696289062,
                0.004242420196533203,
                0.004363298416137695,
                0.00457763671875,
                0.004683732986450195,
                0.004836320877075195,
                0.0048732757568359375,
                0.0049779415130615234,
                0.005007266998291016,
                0.005784273147583008,
                0.005811452865600586,
                0.00613093376159668,
                0.007898807525634766,
                0.00819253921508789,
                0.009084939956665039,
                0.010423660278320312,
                0.011411905288696289,
                0.012781143188476562,
                0.014844179153442383,
                0.020527362823486328
            ],
            "beyond_p": 0.0
        }
    ],
    "russian-doll-envelopes": [
        {
            "slug_name": "russian-doll-envelopes",
            "result": {
                "result": "passed",
                "runtime": 0.0019943714141845703,
                "index": 0
            },
            "solution": "import bisect\n\nclass Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Sort the envelopes by width and then by height in descending order\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n\n        def lis(sequence):\n            tails = []\n            for s in sequence:\n                # Find the index of the smallest tail that is greater than or equal to s\n                index = bisect.bisect_left(tails, s)\n                if index == len(tails):\n                    # If s is larger than any tail, append it to the tails list\n                    tails.append(s)\n                else:\n                    # Otherwise, replace the existing tail with s\n                    tails[index] = s\n            return len(tails)\n\n        # Extract the heights of the envelopes\n        heights = [h for _, h in envelopes]\n        # Find the length of the longest increasing subsequence of heights\n        return lis(heights)\n\n# Example usage:\n# envelopes = [[5,4],[6,4],[6,7],[2,3]]\n# sol = Solution()\n# print(sol.maxEnvelopes(envelopes))  # Output: 3",
            "runtimes": [
                0.0016460418701171875,
                0.001729726791381836,
                0.001786947250366211,
                0.0018155574798583984,
                0.0019288063049316406,
                0.0022859573364257812,
                0.002378702163696289,
                0.002628803253173828,
                0.0029947757720947266,
                0.003862619400024414,
                0.005795001983642578,
                0.009392738342285156,
                0.009549140930175781,
                0.009696006774902344,
                0.010032415390014648,
                0.010179996490478516,
                0.0155792236328125,
                0.0169217586517334,
                0.021713733673095703,
                0.02466416358947754
            ],
            "beyond_p": 0.9848671603915272
        }
    ],
    "set-matrix-zeroes": [
        {
            "slug_name": "set-matrix-zeroes",
            "result": {
                "result": "passed",
                "runtime": 0.0006182193756103516,
                "index": 0
            },
            "solution": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # First, determine if the first row and first column need to be zeroed\n        first_row_has_zero = any(matrix[0][j] == 0 for j in range(len(matrix[0])))\n        first_col_has_zero = any(matrix[i][0] == 0 for i in range(len(matrix)))\n\n        # Use the first row and first column to mark zero rows and columns\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n\n        # Zero out cells based on marks in the first row and first column\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        # Zero out the first column if needed\n        if first_col_has_zero:\n            for i in range(len(matrix)):\n                matrix[i][0] = 0\n\n        # Zero out the first row if needed\n        if first_row_has_zero:\n            for j in range(len(matrix[0])):\n                matrix[0][j] = 0\n\n# Example usage:\n# matrix = [[1,1,1],[1,0,1],[1,1,1]]\n# Solution().setZeroes(matrix)\n# print(matrix)  # Output: [[1,0,1],[0,0,0],[1,0,1]]\n\n# matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n# Solution().setZeroes(matrix)\n# print(matrix)  # Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
            "runtimes": [
                0.00030231475830078125,
                0.0003101825714111328,
                0.00032067298889160156,
                0.000324249267578125,
                0.000324249267578125,
                0.00032639503479003906,
                0.0003600120544433594,
                0.00036144256591796875,
                0.00037026405334472656,
                0.0003707408905029297,
                0.00037384033203125,
                0.0003783702850341797,
                0.00038170814514160156,
                0.0003952980041503906,
                0.00039768218994140625,
                0.00039958953857421875,
                0.00040435791015625,
                0.00040435791015625,
                0.00041484832763671875,
                0.0004360675811767578,
                0.0004878044128417969,
                0.0004911422729492188,
                0.0004956722259521484,
                0.0006287097930908203,
                0.0006356239318847656,
                0.0006492137908935547,
                0.0009555816650390625
            ],
            "beyond_p": 0.5164233576642335
        }
    ],
    "remove-nth-node-from-end-of-list": [
        {
            "slug_name": "remove-nth-node-from-end-of-list",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize two pointers, both starting at the head of the list\n        first = second = head\n        \n        # Move the first pointer n steps ahead\n        for _ in range(n):\n            first = first.next\n        \n        # If first is None, we need to remove the head of the list\n        if not first:\n            return head.next\n        \n        # Move both pointers until the first one reaches the end\n        # Second pointer will then point to the node before the one we want to remove\n        while first.next:\n            first = first.next\n            second = second.next\n        \n        # Remove the nth node from the end\n        # by skipping it in the list\n        second.next = second.next.next\n        \n        return head",
            "runtimes": [
                0.000339508056640625,
                0.00033974647521972656,
                0.00034165382385253906,
                0.00034308433532714844,
                0.00034546852111816406,
                0.0003497600555419922,
                0.0003559589385986328,
                0.0003848075866699219,
                0.0003859996795654297,
                0.00038814544677734375,
                0.0003902912139892578,
                0.00039315223693847656,
                0.00039386749267578125,
                0.0003943443298339844,
                0.0003974437713623047,
                0.00040411949157714844,
                0.0004069805145263672,
                0.0004074573516845703,
                0.0004086494445800781,
                0.00041174888610839844,
                0.0004124641418457031,
                0.0004162788391113281,
                0.0004191398620605469,
                0.0004208087921142578,
                0.0004303455352783203,
                0.0004343986511230469,
                0.0004546642303466797,
                0.0005040168762207031,
                0.0005068778991699219,
                0.0005080699920654297,
                0.0005612373352050781,
                0.012537717819213867
            ],
            "beyond_p": 0.0
        }
    ],
    "intersection-of-two-arrays": [
        {
            "slug_name": "intersection-of-two-arrays",
            "result": {
                "result": "passed",
                "runtime": 0.0007011890411376953,
                "index": 0
            },
            "solution": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        # Convert both lists to sets to remove duplicates\n        set_nums1 = set(nums1)\n        set_nums2 = set(nums2)\n\n        # Find the intersection of the two sets\n        result_set = set_nums1.intersection(set_nums2)\n\n        # Convert the set back to a list\n        result = list(result_set)\n\n        return result",
            "runtimes": [
                0.0007002353668212891,
                0.000751495361328125,
                0.0007519721984863281,
                0.0007560253143310547,
                0.0007688999176025391,
                0.0007798671722412109,
                0.0007929801940917969,
                0.0008122920989990234,
                0.0008530616760253906,
                0.0010139942169189453,
                0.0011417865753173828,
                0.0015957355499267578,
                0.0021758079528808594,
                0.004668235778808594,
                0.005003690719604492,
                0.008826494216918945,
                0.015684843063354492,
                0.030187368392944336,
                0.04050135612487793,
                0.054250478744506836
            ],
            "beyond_p": 0.9999821910367488
        }
    ],
    "super-washing-machines": [
        {
            "slug_name": "super-washing-machines",
            "result": {
                "result": "passed",
                "runtime": 0.00033593177795410156,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findMinMoves(self, machines):\n        total_dresses = sum(machines)\n        n = len(machines)\n\n        if total_dresses % n != 0:\n            return -1\n\n        target = total_dresses // n\n        max_moves = 0\n        current_balance = 0\n\n        for dresses in machines:\n            current_balance += dresses - target\n            max_moves = max(max_moves, abs(current_balance), dresses - target)\n\n        return max_moves\n\n# Example usage:\n# sol = Solution()\n# print(sol.findMinMoves([1,0,5]))  # Output: 3\n# print(sol.findMinMoves([0,3,0]))  # Output: 2\n# print(sol.findMinMoves([0,2,0]))  # Output: -1",
            "runtimes": [
                0.0003476142883300781,
                0.0003504753112792969,
                0.00035858154296875,
                0.0003783702850341797,
                0.0003871917724609375,
                0.00039267539978027344,
                0.0003972053527832031,
                0.0003981590270996094,
                0.0004029273986816406,
                0.0004036426544189453,
                0.0004069805145263672,
                0.0004127025604248047,
                0.0004227161407470703,
                0.0004265308380126953,
                0.0005326271057128906,
                0.0006437301635742188
            ],
            "beyond_p": 1.039452495974235
        }
    ],
    "kth-smallest-number-in-multiplication-table": [
        {
            "slug_name": "kth-smallest-number-in-multiplication-table",
            "result": {
                "result": "passed",
                "runtime": 0.6826202869415283,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        def count_less_equal(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(x // i, n)\n            return count\n\n        left, right = 1, m * n\n        while left < right:\n            mid = (left + right) // 2\n            if count_less_equal(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n# Example usage:\n# sol = Solution()\n# print(sol.findKthNumber(3, 3, 5))  # Output: 3\n# print(sol.findKthNumber(2, 3, 6))  # Output: 6",
            "runtimes": [
                0.1374835968017578,
                0.15790915489196777,
                0.255969762802124,
                0.2733922004699707,
                0.3292372226715088,
                0.36205005645751953,
                0.41639232635498047,
                0.43355607986450195,
                0.4776499271392822,
                0.48377466201782227,
                0.4910457134246826,
                0.5213520526885986,
                0.5680093765258789,
                0.583031415939331,
                0.5943927764892578,
                0.6356813907623291
            ],
            "beyond_p": 0.0
        }
    ],
    "convert-sorted-list-to-binary-search-tree": [
        {
            "slug_name": "convert-sorted-list-to-binary-search-tree",
            "result": {
                "result": "passed",
                "runtime": 0.018391847610473633,
                "index": 0
            },
            "solution": "import json\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def findMiddle(self, head):\n        prev_ptr = None\n        slow_ptr = head\n        fast_ptr = head\n\n        while fast_ptr and fast_ptr.next:\n            prev_ptr = slow_ptr\n            slow_ptr = slow_ptr.next\n            fast_ptr = fast_ptr.next.next\n\n        if prev_ptr:\n            prev_ptr.next = None\n\n        return slow_ptr\n\n    def sortedListToBST(self, head):\n        if not head:\n            return None\n\n        mid = self.findMiddle(head)\n\n        node = TreeNode(mid.val)\n\n        if head == mid:\n            return node\n\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(mid.next)\n\n        return node\n\n# Example usage:\n# Convert the given sorted linked list to a list for easier processing\nlinked_list_values = [-10, -3, 0, 5, 9]\nhead = ListNode(0)\ncurrent = head\nfor value in linked_list_values:\n    current.next = ListNode(value)\n    current = current.next\nhead = head.next\n\n# Create a Solution object and use the method to convert\nsol = Solution()\nbst_root = sol.sortedListToBST(head)\n\n# Function to serialize the tree into a list\ndef serialize(root):\n    if not root:\n        return []\n    result = []\n    nodes = [root]\n    while any(nodes):\n        node = nodes.pop(0)\n        if node:\n            result.append(node.val)\n            nodes.append(node.left)\n            nodes.append(node.right)\n        else:\n            result.append(None)\n    # Remove trailing None values\n    while result and result[-1] is None:\n        result.pop()\n    return result\n\n# Serialize the BST to a list\nbst_list = serialize(bst_root)\n\n# Output the result in JSON format\nprint(json.dumps({'output': bst_list}))",
            "runtimes": [
                0.005234479904174805,
                0.005259513854980469,
                0.005434274673461914,
                0.005499124526977539,
                0.005672454833984375,
                0.005708456039428711,
                0.00575566291809082,
                0.007154941558837891,
                0.008707284927368164,
                0.010779619216918945,
                0.012562990188598633,
                0.01305842399597168,
                0.028577566146850586,
                0.030387163162231445
            ],
            "beyond_p": 0.4769000360196402
        }
    ],
    "merge-two-sorted-lists": [
        {
            "slug_name": "merge-two-sorted-lists",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize a dummy node to act as the start of the merged list\n        dummy = ListNode(-1)\n        current = dummy\n\n        # Traverse both lists and append the smaller value to the merged list\n        while list1 and list2:\n            if list1.val < list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        # If one of the lists reaches the end, append the other list\n        if list1:\n            current.next = list1\n        elif list2:\n            current.next = list2\n\n        # Return the head of the merged list\n        return dummy.next",
            "runtimes": [
                0.00048470497131347656,
                0.0004932880401611328,
                0.0004947185516357422,
                0.000514984130859375,
                0.0005152225494384766,
                0.0005221366882324219,
                0.0005331039428710938,
                0.0005381107330322266,
                0.0005388259887695312,
                0.0005397796630859375,
                0.0005440711975097656,
                0.0005452632904052734,
                0.0005471706390380859,
                0.00054931640625,
                0.0005502700805664062,
                0.0005502700805664062,
                0.0005507469177246094,
                0.0005581378936767578,
                0.0005595684051513672,
                0.0005924701690673828,
                0.0005927085876464844,
                0.0006551742553710938,
                0.0006577968597412109,
                0.0006628036499023438,
                0.0006644725799560547,
                0.0006866455078125,
                0.0007798671722412109,
                0.0008413791656494141,
                0.0008423328399658203,
                0.0009329319000244141,
                0.0010783672332763672,
                0.0012538433074951172,
                0.0017445087432861328,
                0.0017824172973632812,
                0.0019795894622802734,
                0.007004737854003906
            ],
            "beyond_p": 0.0
        }
    ],
    "maximal-rectangle": [
        {
            "slug_name": "maximal-rectangle",
            "result": {
                "result": "passed",
                "runtime": 0.0008819103240966797,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def largestRectangleArea(heights):\n            stack = [-1]\n            max_area = 0\n            for i, h in enumerate(heights):\n                while stack[-1] != -1 and heights[stack[-1]] > h:\n                    height = heights[stack.pop()]\n                    width = i - stack[-1] - 1\n                    max_area = max(max_area, height * width)\n                stack.append(i)\n            while stack[-1] != -1:\n                height = heights[stack.pop()]\n                width = len(heights) - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            return max_area\n\n        if not matrix:\n            return 0\n\n        max_rectangle = 0\n        dp = [0] * len(matrix[0])\n        for row in matrix:\n            for i in range(len(row)):\n                dp[i] = dp[i] + 1 if row[i] == '1' else 0\n            max_rectangle = max(max_rectangle, largestRectangleArea(dp))\n        return max_rectangle\n\n# Example usage:\n# sol = Solution()\n# print(sol.maximalRectangle([['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']]))\n# Output: 6",
            "runtimes": [
                0.0008177757263183594,
                0.0008616447448730469,
                0.0009043216705322266,
                0.0009298324584960938,
                0.0009593963623046875,
                0.001077413558959961,
                0.0010962486267089844,
                0.00115966796875,
                0.0011668205261230469,
                0.0012102127075195312,
                0.0012896060943603516,
                0.0013689994812011719,
                0.0014522075653076172,
                0.0014858245849609375,
                0.0015473365783691406,
                0.001619100570678711,
                0.0017135143280029297,
                0.0017991065979003906,
                0.0018053054809570312,
                0.0018372535705566406,
                0.001926422119140625,
                0.0020148754119873047,
                0.0020189285278320312,
                0.0028946399688720703,
                0.004572391510009766,
                0.010870933532714844,
                0.027909278869628906
            ],
            "beyond_p": 0.9976326674293761
        }
    ],
    "subsets": [
        {
            "slug_name": "subsets",
            "result": {
                "result": "passed",
                "runtime": 0.00047087669372558594,
                "index": 0
            },
            "solution": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(start, end, path):\n            result.append(path)\n            for i in range(start, end):\n                backtrack(i + 1, end, path + [nums[i]])\n        \n        result = []\n        backtrack(0, len(nums), [])\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.subsets([1,2,3]))\n# print(sol.subsets([0]))",
            "runtimes": [
                0.00032067298889160156,
                0.0003578662872314453,
                0.00036263465881347656,
                0.0003731250762939453,
                0.0003762245178222656,
                0.00039887428283691406,
                0.00040078163146972656,
                0.0004057884216308594,
                0.00042366981506347656,
                0.0004317760467529297,
                0.0004405975341796875,
                0.00044417381286621094,
                0.0004990100860595703,
                0.0005404949188232422,
                0.0005741119384765625,
                0.0006473064422607422
            ],
            "beyond_p": 0.5401459854014599
        }
    ],
    "find-minimum-in-rotated-sorted-array-ii": [
        {
            "slug_name": "find-minimum-in-rotated-sorted-array-ii",
            "result": {
                "result": "passed",
                "runtime": 0.0002636909484863281,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:  # nums[mid] == nums[right]\n                right -= 1\n        return nums[left]\n\n# Example usage:\n# sol = Solution()\n# print(sol.findMin([2,2,2,0,1]))  # Output: 0",
            "runtimes": [
                0.0002722740173339844,
                0.0002741813659667969,
                0.0002760887145996094,
                0.0002849102020263672,
                0.00028896331787109375,
                0.00029969215393066406,
                0.00030303001403808594,
                0.00030350685119628906,
                0.0003044605255126953,
                0.0003070831298828125,
                0.0003097057342529297,
                0.0003101825714111328,
                0.00031185150146484375,
                0.00032830238342285156,
                0.00046825408935546875
            ],
            "beyond_p": 1.0437956204379562
        }
    ],
    "valid-number": [
        {
            "slug_name": "valid-number",
            "result": {
                "result": "passed",
                "runtime": 0.0003116130828857422,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isNumber(self, s):\n        # Helper function to check if a substring is a valid integer\n        def isInteger(s):\n            if not s:\n                return False\n            if s[0] in ['+', '-']:\n                s = s[1:]\n            return s.isdigit()\n\n        # Helper function to check if a substring is a valid decimal\n        def isDecimal(s):\n            if not s:\n                return False\n            if s[0] in ['+', '-']:\n                s = s[1:]\n            if '.' not in s:\n                return s.isdigit()\n            integerPart, _, decimalPart = s.partition('.')\n            if integerPart and not integerPart.isdigit():\n                return False\n            if decimalPart and not decimalPart.isdigit():\n                return False\n            return integerPart.isdigit() or decimalPart.isdigit()\n\n        # Check for scientific notation\n        if 'e' in s or 'E' in s:\n            base, _, exponent = s.partition('e' if 'e' in s else 'E')\n            return (isInteger(exponent) and (isInteger(base) or isDecimal(base)))\n        else:\n            return isInteger(s) or isDecimal(s)\n\n# Example usage:\n# sol = Solution()\n# print(sol.isNumber(\"0\"))  # Output: true\n# print(sol.isNumber(\"e\"))  # Output: false\n# print(sol.isNumber(\".\"))  # Output: false",
            "runtimes": [
                0.00027942657470703125,
                0.0002846717834472656,
                0.00030517578125,
                0.0003082752227783203,
                0.00031185150146484375,
                0.00031304359436035156,
                0.0003135204315185547,
                0.00031757354736328125,
                0.0003256797790527344,
                0.0004222393035888672,
                0.00044465065002441406,
                0.0004742145538330078,
                0.0008437633514404297
            ],
            "beyond_p": 0.9429657794676806
        }
    ],
    "integer-to-roman": [
        {
            "slug_name": "integer-to-roman",
            "result": {
                "result": "passed",
                "runtime": 0.0003108978271484375,
                "index": 0
            },
            "solution": "class Solution(object):\n    def intToRoman(self, num):\n        # Define the mapping of Roman numerals to their integer values\n        val_map = [\n            (1000, 'M'),\n            (900, 'CM'),\n            (500, 'D'),\n            (400, 'CD'),\n            (100, 'C'),\n            (90, 'XC'),\n            (50, 'L'),\n            (40, 'XL'),\n            (10, 'X'),\n            (9, 'IX'),\n            (5, 'V'),\n            (4, 'IV'),\n            (1, 'I')\n        ]\n\n        # Initialize the result string\n        roman_numeral = ''\n\n        # Convert the integer to Roman numeral\n        for value, symbol in val_map:\n            while num >= value:\n                roman_numeral += symbol\n                num -= value\n\n        return roman_numeral\n\n# Example usage:\n# sol = Solution()\n# print(sol.intToRoman(3))  # Output: 'III'\n# print(sol.intToRoman(58)) # Output: 'LVIII'\n# print(sol.intToRoman(1994)) # Output: 'MCMXCIV'",
            "runtimes": [
                0.0002713203430175781,
                0.00027298927307128906,
                0.0002772808074951172,
                0.000286102294921875,
                0.0003066062927246094,
                0.0003142356872558594,
                0.00031495094299316406,
                0.0003173351287841797,
                0.00032401084899902344,
                0.000324249267578125,
                0.00032782554626464844,
                0.0003337860107421875,
                0.00035381317138671875,
                0.0003578662872314453,
                0.00044608116149902344,
                0.0005123615264892578,
                0.0005447864532470703,
                0.00459742546081543
            ],
            "beyond_p": 0.9908514742353265
        }
    ],
    "find-the-difference": [
        {
            "slug_name": "find-the-difference",
            "result": {
                "result": "passed",
                "runtime": 0.0006990432739257812,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        # Initialize a variable to store the sum of ASCII values\n        sum_s, sum_t = 0, 0\n\n        # Sum the ASCII values of all characters in s\n        for char in s:\n            sum_s += ord(char)\n\n        # Sum the ASCII values of all characters in t\n        for char in t:\n            sum_t += ord(char)\n\n        # The difference in sums is the ASCII value of the added character\n        return chr(sum_t - sum_s)",
            "runtimes": [
                0.0004150867462158203,
                0.0004279613494873047,
                0.00046515464782714844,
                0.0006191730499267578,
                0.0006339550018310547,
                0.0008563995361328125,
                0.0009281635284423828,
                0.0009856224060058594,
                0.0010335445404052734,
                0.002722501754760742,
                0.002859830856323242,
                0.0032165050506591797,
                0.009726762771606445,
                0.024044036865234375
            ],
            "beyond_p": 0.9879826853804474
        }
    ],
    "sudoku-solver": [
        {
            "slug_name": "sudoku-solver",
            "result": {
                "result": "passed",
                "runtime": 0.05953073501586914,
                "index": 0
            },
            "solution": "class Solution(object):\n    def solveSudoku(self, board):\n        def is_valid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num or board[i][col] == num:\n                    return False\n            startRow, startCol = 3 * (row // 3), 3 * (col // 3)\n            for i in range(3):\n                for j in range(3):\n                    if board[startRow + i][startCol + j] == num:\n                        return False\n            return True\n\n        def solve(board):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        for num in '123456789':\n                            if is_valid(board, row, col, num):\n                                board[row][col] = num\n                                if solve(board):\n                                    return True\n                                board[row][col] = '.'\n                        return False\n            return True\n\n        solve(board)",
            "runtimes": [
                0.0010335445404052734,
                0.0015003681182861328,
                0.015329122543334961,
                0.024893522262573242,
                0.026417255401611328,
                0.028920650482177734,
                0.04461407661437988,
                0.04625082015991211,
                0.055187225341796875,
                0.05530667304992676,
                0.05842423439025879,
                0.06434178352355957,
                0.08339929580688477,
                0.08680486679077148,
                0.09556984901428223,
                0.0978233814239502,
                0.11908459663391113,
                0.12239432334899902,
                0.14700794219970703,
                0.17484712600708008,
                0.1962447166442871,
                0.20456457138061523,
                0.21611714363098145
            ],
            "beyond_p": 0.7280257968399093
        }
    ],
    "recover-binary-search-tree": [
        {
            "slug_name": "recover-binary-search-tree",
            "result": {
                "result": "passed",
                "runtime": 0.0004527568817138672,
                "index": 0
            },
            "solution": "import sys\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        # Initialize variables to keep track of the nodes to be swapped\n        first_element = None\n        second_element = None\n        prev_element = TreeNode(-sys.maxsize)\n\n        # Helper function to perform in-order traversal\n        def in_order_traversal(node):\n            nonlocal first_element, second_element, prev_element\n            if not node:\n                return\n\n            # Traverse the left subtree\n            in_order_traversal(node.left)\n\n            # Start of the main logic to find the two nodes\n            if first_element is None and prev_element.val >= node.val:\n                first_element = prev_element\n            if first_element is not None and prev_element.val >= node.val:\n                second_element = node\n            prev_element = node\n\n            # Traverse the right subtree\n            in_order_traversal(node.right)\n\n        # Call the in-order traversal helper function\n        in_order_traversal(root)\n\n        # Swap the values of the two nodes\n        first_element.val, second_element.val = second_element.val, first_element.val\n\n# Example usage:\n# sol = Solution()\n# root = TreeNode(1, TreeNode(3, None, TreeNode(2)), None)\n# sol.recoverTree(root)\n# The tree is now recovered to a valid BST.",
            "runtimes": [
                0.0003688335418701172,
                0.00037288665771484375,
                0.00038933753967285156,
                0.00039267539978027344,
                0.0004000663757324219,
                0.00040650367736816406,
                0.0004215240478515625,
                0.0004229545593261719,
                0.00042366981506347656,
                0.00043010711669921875,
                0.00045299530029296875,
                0.00048804283142089844,
                0.0005855560302734375,
                0.0013375282287597656,
                0.0017085075378417969,
                0.006035327911376953,
                0.024841785430908203
            ],
            "beyond_p": 0.9965707716737947
        }
    ],
    "palindrome-linked-list": [
        {
            "slug_name": "palindrome-linked-list",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Helper function to reverse the linked list\n        def reverseList(head):\n            prev = None\n            current = head\n            while current:\n                next_temp = current.next\n                current.next = prev\n                prev = current\n                current = next_temp\n            return prev\n\n        # Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Reverse the second half of the linked list\n        slow = reverseList(slow)\n        fast = head\n\n        # Compare the first and second half nodes\n        while slow:\n            if slow.val != fast.val:\n                return False\n            slow = slow.next\n            fast = fast.next\n\n        # If we reach here, then the linked list is a palindrome\n        return True",
            "runtimes": [
                0.0016367435455322266,
                0.0016715526580810547,
                0.0016798973083496094,
                0.0016868114471435547,
                0.0017731189727783203,
                0.0018126964569091797,
                0.00188446044921875,
                0.001886129379272461,
                0.001905679702758789,
                0.0019173622131347656,
                0.0019326210021972656,
                0.0019335746765136719,
                0.001950979232788086,
                0.0019712448120117188,
                0.0019714832305908203,
                0.0020475387573242188,
                0.002186298370361328,
                0.0022590160369873047,
                0.0024864673614501953,
                0.003920316696166992,
                0.0075337886810302734,
                0.010540008544921875,
                0.01295328140258789
            ],
            "beyond_p": 0.0
        }
    ],
    "valid-perfect-square": [
        {
            "slug_name": "valid-perfect-square",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isPerfectSquare(self, num):\n        left, right = 1, num\n        while left \\<= right:\n            mid = left + (right - left) // 2\n            square = mid * mid\n            if square == num:\n                return True\n            elif square \\< num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.isPerfectSquare(16))  # Output: true\n# print(sol.isPerfectSquare(14))  # Output: false",
            "runtimes": [
                0.0002560615539550781,
                0.0002570152282714844,
                0.0002639293670654297,
                0.0002639293670654297,
                0.0002856254577636719,
                0.0002930164337158203,
                0.0002987384796142578,
                0.0003020763397216797,
                0.0003046989440917969,
                0.00030493736267089844,
                0.0003063678741455078,
                0.00031948089599609375,
                0.0004565715789794922,
                0.017920494079589844,
                0.02281022071838379
            ],
            "beyond_p": 0.0
        }
    ],
    "counting-bits": [
        {
            "slug_name": "counting-bits",
            "result": {
                "result": "passed",
                "runtime": 0.00044727325439453125,
                "index": 0
            },
            "solution": "class Solution(object):\n    def countBits(self, n):\n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans",
            "runtimes": [
                0.0003764629364013672,
                0.00040149688720703125,
                0.0004551410675048828,
                0.00048089027404785156,
                0.0005016326904296875,
                0.0008275508880615234,
                0.0008504390716552734,
                0.0009129047393798828,
                0.0009431838989257812,
                0.0009822845458984375,
                0.0011484622955322266,
                0.0012617111206054688,
                0.0012631416320800781,
                0.0012955665588378906,
                0.0015838146209716797,
                0.0016810894012451172,
                0.0017502307891845703,
                0.0018770694732666016,
                0.0022737979888916016,
                0.003108978271484375,
                0.003663778305053711,
                0.0066699981689453125,
                0.014476299285888672
            ],
            "beyond_p": 0.994977933343479
        }
    ],
    "remove-linked-list-elements": [
        {
            "slug_name": "remove-linked-list-elements",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize a dummy node which will help us easily handle edge cases such as when we need to delete the head node\n        dummy = ListNode(-1)\n        dummy.next = head\n        \n        # Initialize current pointer to start from the dummy node\n        current = dummy\n        \n        # Iterate through the list\n        while current.next:\n            # If the next node's value is the one we need to remove\n            if current.next.val == val:\n                # Skip the node to remove it\n                current.next = current.next.next\n            else:\n                # Move to the next node\n                current = current.next\n        \n        # Return the new head of the list, which is the next node of dummy\n        return dummy.next",
            "runtimes": [
                0.0004911422729492188,
                0.0004994869232177734,
                0.0005035400390625,
                0.0005035400390625,
                0.0005064010620117188,
                0.0005125999450683594,
                0.0005240440368652344,
                0.0005602836608886719,
                0.0005700588226318359,
                0.0005772113800048828,
                0.0005781650543212891,
                0.0005850791931152344,
                0.0005905628204345703,
                0.0005924701690673828,
                0.0006558895111083984,
                0.0007219314575195312,
                0.0007231235504150391,
                0.0007622241973876953
            ],
            "beyond_p": 0.0
        }
    ],
    "scramble-string": [
        {
            "slug_name": "scramble-string",
            "result": {
                "result": "passed",
                "runtime": 0.0006327629089355469,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \n        # Base case: If both strings are equal, return True\n        if s1 == s2:\n            return True\n        \n        # If the sorted characters of both strings are not the same, they can't be scrambled\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        for i in range(1, n):\n            # Check if the current split leads to a scrambled string\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\n               (self.isScramble(s1[:i], s2[n-i:]) and self.isScramble(s1[i:], s2[:n-i])):\n                return True\n        \n        # If no split leads to a scrambled string, return False\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.isScramble('great', 'rgeat'))  # Output: true\n# print(sol.isScramble('abcde', 'caebd'))  # Output: false\n# print(sol.isScramble('a', 'a'))          # Output: true",
            "runtimes": [
                0.0006730556488037109,
                0.0017497539520263672,
                0.0021114349365234375,
                0.0023887157440185547,
                0.00667881965637207,
                0.014305353164672852,
                0.01584458351135254,
                0.017038583755493164,
                0.02013564109802246,
                0.024372577667236328,
                0.026147842407226562,
                0.027144670486450195,
                0.030242204666137695,
                0.030563831329345703,
                0.03357982635498047,
                0.0484004020690918,
                0.04923725128173828,
                0.055487871170043945,
                0.0612635612487793,
                0.07602190971374512,
                0.07855081558227539
            ],
            "beyond_p": 1.000517384422749
        }
    ],
    "simplify-path": [
        {
            "slug_name": "simplify-path",
            "result": {
                "result": "passed",
                "runtime": 0.0003898143768310547,
                "index": 0
            },
            "solution": "class Solution(object):\n    def simplifyPath(self, path):\n        # Split the path by '/' and initialize a stack\n        parts = path.split('/')\n        stack = []\n\n        # Process each part of the path\n        for part in parts:\n            if part == '..':\n                if stack:\n                    stack.pop()\n            elif part and part != '.':\n                stack.append(part)\n\n        # Join the stack to form the simplified path\n        return '/' + '/'.join(stack)\n\n# Example usage:\n# sol = Solution()\n# print(sol.simplifyPath('/home/'))  # Output: '/home'\n# print(sol.simplifyPath('/../'))    # Output: '/'\n# print(sol.simplifyPath('/home//foo/'))  # Output: '/home/foo'",
            "runtimes": [
                0.00027751922607421875,
                0.00028061866760253906,
                0.0002834796905517578,
                0.000286102294921875,
                0.0003142356872558594,
                0.0003192424774169922,
                0.0003237724304199219,
                0.0003254413604736328,
                0.00032591819763183594,
                0.0003285408020019531,
                0.0003294944763183594,
                0.0003325939178466797,
                0.0003352165222167969,
                0.0003402233123779297,
                0.00034046173095703125,
                0.00035119056701660156,
                0.00036597251892089844,
                0.0003757476806640625,
                0.0004222393035888672,
                0.0006413459777832031
            ],
            "beyond_p": 0.6913499344692006
        }
    ],
    "word-search-ii": [
        {
            "slug_name": "word-search-ii",
            "result": {
                "result": "passed",
                "runtime": 0.00044536590576171875,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findWords(self, board, words):\n        def backtrack(i, j, node, path):\n            if '#' in node:\n                result.add(node['#'])\n            letter = board[i][j]\n            board[i][j] = '@'\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= x < m and 0 <= y < n and board[x][y] in node:\n                    backtrack(x, y, node[board[x][y]], path + board[x][y])\n            board[i][j] = letter\n        \n        def buildTrie():\n            root = {}\n            for word in words:\n                node = root\n                for letter in word:\n                    if letter not in node:\n                        node[letter] = {}\n                    node = node[letter]\n                node['#'] = word\n            return root\n        \n        result = set()\n        trie = buildTrie()\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie:\n                    backtrack(i, j, trie[board[i][j]], board[i][j])\n        return list(result)",
            "runtimes": [
                0.0004429817199707031,
                0.00057220458984375,
                0.0005877017974853516,
                0.0005917549133300781,
                0.0005950927734375,
                0.0005984306335449219,
                0.0006325244903564453,
                0.0006468296051025391,
                0.0006725788116455078,
                0.0007827281951904297,
                0.0007827281951904297,
                0.000789642333984375,
                0.0008091926574707031,
                0.000850677490234375,
                0.0008754730224609375,
                0.0009031295776367188,
                0.0011398792266845703,
                0.00286102294921875,
                0.00514531135559082
            ],
            "beyond_p": 0.9994929777417229
        }
    ],
    "valid-anagram": [
        {
            "slug_name": "valid-anagram",
            "result": {
                "result": "passed",
                "runtime": 0.005618095397949219,
                "index": 0
            },
            "solution": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        # If the lengths of the strings are not equal, they cannot be anagrams\n        if len(s) != len(t):\n            return False\n\n        # Create a dictionary to count the frequency of each letter in s\n        count = {}\n        for char in s:\n            count[char] = count.get(char, 0) + 1\n\n        # Decrease the count for each letter in t\n        for char in t:\n            if char not in count or count[char] == 0:\n                return False\n            count[char] -= 1\n\n        # If all counts are zero, then t is an anagram of s\n        return all(value == 0 for value in count.values())\n\n# Example usage:\n# sol = Solution()\n# print(sol.isAnagram(\"anagram\", \"nagaram\"))  # Output: true\n# print(sol.isAnagram(\"rat\", \"car\"))        # Output: false",
            "runtimes": [
                0.0007219314575195312,
                0.0014522075653076172,
                0.0014986991882324219,
                0.001522064208984375,
                0.0015625953674316406,
                0.0017371177673339844,
                0.0018088817596435547,
                0.0020978450775146484,
                0.0021157264709472656,
                0.0022199153900146484,
                0.0022590160369873047,
                0.0023114681243896484,
                0.0023529529571533203,
                0.0025887489318847656,
                0.002689361572265625,
                0.004420280456542969,
                0.0048258304595947266,
                0.00854802131652832,
                0.009119272232055664,
                0.009493112564086914,
                0.019133567810058594
            ],
            "beyond_p": 0.7340723091266964
        }
    ],
    "valid-sudoku": [
        {
            "slug_name": "valid-sudoku",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize data structures to hold the state of rows, columns, and boxes\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        # Iterate over each cell in the board\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != '.':\n                    # Calculate box index\n                    box_index = (i // 3) * 3 + j // 3\n\n                    # Check if the number is already in the current row, column, or box\n                    if num in rows[i] or num in cols[j] or num in boxes[box_index]:\n                        return False\n\n                    # Add the number to the current row, column, and box\n                    rows[i].add(num)\n                    cols[j].add(num)\n                    boxes[box_index].add(num)\n\n        # If no duplicates are found, the board is valid\n        return True",
            "runtimes": [
                0.0003037452697753906,
                0.00032019615173339844,
                0.00032711029052734375,
                0.0003407001495361328,
                0.00035452842712402344,
                0.0003654956817626953,
                0.00036597251892089844,
                0.00036907196044921875,
                0.0003859996795654297,
                0.00038743019104003906,
                0.0005512237548828125,
                0.0006570816040039062,
                0.0006861686706542969,
                0.0007398128509521484,
                0.001855611801147461,
                0.006501674652099609,
                0.006663799285888672
            ],
            "beyond_p": 0.0
        }
    ],
    "fizz-buzz": [
        {
            "slug_name": "fizz-buzz",
            "result": {
                "result": "passed",
                "runtime": 0.0005488395690917969,
                "index": 0
            },
            "solution": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        answer = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                answer.append('FizzBuzz')\n            elif i % 3 == 0:\n                answer.append('Fizz')\n            elif i % 5 == 0:\n                answer.append('Buzz')\n            else:\n                answer.append(str(i))\n        return answer",
            "runtimes": [
                0.0003426074981689453,
                0.0003440380096435547,
                0.00034809112548828125,
                0.0003504753112792969,
                0.0003631114959716797,
                0.0003910064697265625,
                0.000392913818359375,
                0.0003948211669921875,
                0.0003986358642578125,
                0.0004010200500488281,
                0.0004086494445800781,
                0.0004143714904785156,
                0.00043392181396484375,
                0.0004439353942871094,
                0.000560760498046875,
                0.0007762908935546875
            ],
            "beyond_p": 0.5244639912039583
        }
    ],
    "reverse-words-in-a-string": [
        {
            "slug_name": "reverse-words-in-a-string",
            "result": {
                "result": "passed",
                "runtime": 0.00034689903259277344,
                "index": 0
            },
            "solution": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # Split the string into words\n        words = s.split()\n        # Reverse the list of words\n        words.reverse()\n        # Join the words using a single space\n        reversed_s = ' '.join(words)\n        return reversed_s\n\n# Example usage:\n# sol = Solution()\n# print(sol.reverseWords(\"the sky is blue\"))  # Output: \"blue is sky the\"\n# print(sol.reverseWords(\"  hello world  \"))  # Output: \"world hello\"\n# print(sol.reverseWords(\"a good   example\"))  # Output: \"example good a\"",
            "runtimes": [
                0.0002963542938232422,
                0.000301361083984375,
                0.0003254413604736328,
                0.00033664703369140625,
                0.00034236907958984375,
                0.0003437995910644531,
                0.0003552436828613281,
                0.0003619194030761719,
                0.0003933906555175781,
                0.00043845176696777344,
                0.0004956722259521484,
                0.0005197525024414062,
                0.0005657672882080078,
                0.0006816387176513672,
                0.0009291172027587891,
                0.0011897087097167969,
                0.0015027523040771484,
                0.03057098388671875
            ],
            "beyond_p": 0.9983304588875501
        }
    ],
    "excel-sheet-column-number": [
        {
            "slug_name": "excel-sheet-column-number",
            "result": {
                "result": "passed",
                "runtime": 0.00035452842712402344,
                "index": 0
            },
            "solution": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        result = 0\n        for char in columnTitle:\n            result = result * 26 + (ord(char) - ord('A') + 1)\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.titleToNumber('A'))  # Output: 1\n# print(sol.titleToNumber('AB')) # Output: 28\n# print(sol.titleToNumber('ZY')) # Output: 701",
            "runtimes": [
                0.000274658203125,
                0.0002810955047607422,
                0.0002815723419189453,
                0.0002837181091308594,
                0.00031113624572753906,
                0.0003139972686767578,
                0.0003180503845214844,
                0.00032591819763183594,
                0.0003314018249511719,
                0.0003437995910644531,
                0.00034809112548828125,
                0.00036025047302246094,
                0.0004229545593261719
            ],
            "beyond_p": 0.46141479099678456
        }
    ],
    "candy": [
        {
            "slug_name": "candy",
            "result": {
                "result": "passed",
                "runtime": 0.0020182132720947266,
                "index": 0
            },
            "solution": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(ratings)\n        if n == 0:\n            return 0\n\n        candies = [1] * n\n\n        # Left to right pass\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Right to left pass\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        # Sum up the candies\n        return sum(candies)",
            "runtimes": [
                0.0009837150573730469,
                0.0016262531280517578,
                0.0017185211181640625,
                0.001789093017578125,
                0.0019752979278564453,
                0.0019922256469726562,
                0.0020809173583984375,
                0.002082347869873047,
                0.002178668975830078,
                0.002277851104736328,
                0.002516508102416992,
                0.0026662349700927734,
                0.003011465072631836,
                0.003284931182861328,
                0.003353118896484375,
                0.003484010696411133,
                0.003651142120361328,
                0.0038535594940185547,
                0.0045452117919921875,
                0.006677150726318359,
                0.009566068649291992,
                0.012498140335083008,
                0.013020992279052734,
                0.01310586929321289
            ],
            "beyond_p": 0.9146605302493903
        }
    ],
    "same-tree": [
        {
            "slug_name": "same-tree",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# If both nodes are None, trees are structurally identical here\n        if not p and not q:\n            return True\n\n        # If one of the nodes is None, trees are not identical\n        if not p or not q:\n            return False\n\n        # If the value of nodes are different, trees are not identical\n        if p.val != q.val:\n            return False\n\n        # Recursively check the left subtree and the right subtree\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
            "runtimes": [
                0.0005509853363037109,
                0.0005679130554199219,
                0.000568389892578125,
                0.0006055831909179688,
                0.0006251335144042969,
                0.0006251335144042969,
                0.0006313323974609375,
                0.0006361007690429688,
                0.0006403923034667969,
                0.0006413459777832031,
                0.0006420612335205078,
                0.0007646083831787109,
                0.0010333061218261719,
                0.007494211196899414
            ],
            "beyond_p": 0.0
        }
    ],
    "reorder-list": [
        {
            "slug_name": "reorder-list",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Helper function to reverse a linked list\n        def reverseList(head):\n            prev = None\n            current = head\n            while current:\n                next_temp = current.next\n                current.next = prev\n                prev = current\n                current = next_temp\n            return prev\n\n        # Helper function to merge two lists\n        def mergeLists(l1, l2):\n            while l1 and l2:\n                l1_next = l1.next\n                l2_next = l2.next\n\n                l1.next = l2\n                if l1_next is None:\n                    break\n                l2.next = l1_next\n\n                l1 = l1_next\n                l2 = l2_next\n\n        # Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Reverse the second half of the list\n        second_half = reverseList(slow.next)\n        slow.next = None\n\n        # Merge the two halves\n        mergeLists(head, second_half)",
            "runtimes": [
                0.0009374618530273438,
                0.0009522438049316406,
                0.0009715557098388672,
                0.0010371208190917969,
                0.0010676383972167969,
                0.0010693073272705078,
                0.0010797977447509766,
                0.001092672348022461,
                0.0011165142059326172,
                0.0011370182037353516,
                0.0011539459228515625,
                0.0011739730834960938,
                0.0011856555938720703,
                0.0011887550354003906,
                0.0012133121490478516,
                0.0012195110321044922,
                0.001237630844116211,
                0.0012390613555908203,
                0.0012602806091308594,
                0.0012731552124023438,
                0.002482891082763672,
                0.010431528091430664,
                0.010745763778686523
            ],
            "beyond_p": 0.0
        }
    ],
    "word-pattern": [
        {
            "slug_name": "word-pattern",
            "result": {
                "result": "passed",
                "runtime": 0.00027751922607421875,
                "index": 0
            },
            "solution": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        char_to_word = {}\n        word_to_char = {}\n        for c, w in zip(pattern, words):\n            if c not in char_to_word and w not in word_to_char:\n                char_to_word[c] = w\n                word_to_char[w] = c\n            elif char_to_word.get(c) != w or word_to_char.get(w) != c:\n                return False\n        return True",
            "runtimes": [
                0.00027751922607421875,
                0.0003120899200439453,
                0.0003180503845214844,
                0.0003235340118408203,
                0.000324249267578125,
                0.00032520294189453125,
                0.00032830238342285156,
                0.0003345012664794922,
                0.0003349781036376953,
                0.0003457069396972656,
                0.0003464221954345703,
                0.0004057884216308594,
                0.0010349750518798828
            ],
            "beyond_p": 1.0
        }
    ],
    "permutations": [
        {
            "slug_name": "permutations",
            "result": {
                "result": "passed",
                "runtime": 0.0023643970489501953,
                "index": 0
            },
            "solution": "class Solution(object):\n    def permute(self, nums):\n        def backtrack(first=0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output\n\n# Example usage:\n# sol = Solution()\n# print(sol.permute([1,2,3]))",
            "runtimes": [
                0.001552581787109375,
                0.0018875598907470703,
                0.0019197463989257812,
                0.0019555091857910156,
                0.0019826889038085938,
                0.002084493637084961,
                0.002200603485107422,
                0.0024547576904296875,
                0.002511739730834961,
                0.002599954605102539,
                0.002721071243286133,
                0.0030994415283203125,
                0.00453639030456543,
                0.008830547332763672,
                0.018040895462036133,
                0.02120804786682129
            ],
            "beyond_p": 0.9586977353501291
        }
    ],
    "search-a-2d-matrix": [
        {
            "slug_name": "search-a-2d-matrix",
            "result": {
                "result": "passed",
                "runtime": 0.0003762245178222656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        if not matrix or not matrix[0]:\n            return False\n\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n            mid_value = matrix[mid // n][mid % n]\n\n            if mid_value == target:\n                return True\n            elif mid_value < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return False",
            "runtimes": [
                0.00025010108947753906,
                0.0002574920654296875,
                0.0002579689025878906,
                0.0002796649932861328,
                0.0002837181091308594,
                0.000286102294921875,
                0.00028777122497558594,
                0.0002880096435546875,
                0.00028896331787109375,
                0.00029158592224121094,
                0.00029468536376953125,
                0.0002951622009277344,
                0.0002989768981933594,
                0.0003085136413574219,
                0.00032067298889160156,
                0.0004165172576904297,
                0.0004775524139404297,
                0.008133649826049805
            ],
            "beyond_p": 0.9840016935825319
        }
    ],
    "add-two-numbers": [
        {
            "slug_name": "add-two-numbers",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize current node to dummy head of the returning list.\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        # Loop through lists l1 and l2 until you reach both ends.\n        while l1 is not None or l2 is not None:\n            # At the start of each iteration, we should add carry from last iteration.\n            x = l1.val if l1 is not None else 0\n            y = l2.val if l2 is not None else 0\n            sum = carry + x + y\n\n            # Update carry for next iteration.\n            carry = sum // 10\n\n            # Create a new node with the digit value of (sum mod 10) and set it to current node's next,\n            # then advance current node to next.\n            current.next = ListNode(sum % 10)\n            current = current.next\n\n            # Advance both l1 and l2.\n            if l1 is not None:\n                l1 = l1.next\n            if l2 is not None:\n                l2 = l2.next\n\n        # After the final iteration, we should check if there is a remaining carry and add it if so.\n        if carry > 0:\n            current.next = ListNode(carry)\n\n        # The dummy head's next node is the beginning of the reversed result list.\n        return dummy_head.next",
            "runtimes": [
                0.0007722377777099609,
                0.0007948875427246094,
                0.0008482933044433594,
                0.0008525848388671875,
                0.0008585453033447266,
                0.0008590221405029297,
                0.0008635520935058594,
                0.0008757114410400391,
                0.0008862018585205078,
                0.000888824462890625,
                0.0008993148803710938,
                0.0009024143218994141,
                0.0009047985076904297,
                0.0009438991546630859,
                0.0009441375732421875,
                0.0009455680847167969,
                0.0012812614440917969,
                0.0015532970428466797,
                0.02906632423400879
            ],
            "beyond_p": 0.0
        }
    ],
    "number-complement": [
        {
            "slug_name": "number-complement",
            "result": {
                "result": "passed",
                "runtime": 0.0002994537353515625,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findComplement(self, num):\n        # Convert the number to binary and remove the '0b' prefix\n        binary_num = bin(num)[2:]\n\n        # Flip the bits in the binary representation\n        complement_bits = ''.join('1' if x == '0' else '0' for x in binary_num)\n\n        # Convert the binary string back to an integer\n        complement = int(complement_bits, 2)\n\n        return complement",
            "runtimes": [
                0.0002593994140625,
                0.0002598762512207031,
                0.0002760887145996094,
                0.00027751922607421875,
                0.00027942657470703125,
                0.0002827644348144531,
                0.00028395652770996094,
                0.0002853870391845703,
                0.0002856254577636719,
                0.00029730796813964844,
                0.00030612945556640625,
                0.00032520294189453125,
                0.0004012584686279297
            ],
            "beyond_p": 0.7176470588235294
        }
    ],
    "arithmetic-slices-ii-subsequence": [
        {
            "slug_name": "arithmetic-slices-ii-subsequence",
            "result": {
                "result": "passed",
                "runtime": 0.8858146667480469,
                "index": 0
            },
            "solution": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        from collections import defaultdict\n        n = len(nums)\n        if n < 3:\n            return 0\n\n        dp = [defaultdict(int) for _ in range(n)]\n        count = 0\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                dp[i][diff] += 1\n                if diff in dp[j]:\n                    dp[i][diff] += dp[j][diff]\n                    count += dp[j][diff]\n        return count\n\n# Example usage:\n# sol = Solution()\n# print(sol.numberOfArithmeticSlices([2,4,6,8,10]))  # Output: 7\n# print(sol.numberOfArithmeticSlices([7,7,7,7,7]))  # Output: 16",
            "runtimes": [
                0.3224337100982666,
                0.6015851497650146,
                0.6037993431091309,
                0.7202351093292236,
                0.8133640289306641,
                0.858797550201416,
                0.8625118732452393,
                1.3250889778137207,
                1.4559738636016846,
                1.522657871246338,
                2.045367956161499,
                2.648862361907959
            ],
            "beyond_p": 0.757834414474076
        }
    ],
    "text-justification": [
        {
            "slug_name": "text-justification",
            "result": {
                "result": "passed",
                "runtime": 0.0006122589111328125,
                "index": 0
            },
            "solution": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        def justify_line(line, width, is_last=False):\n            if is_last or len(line) == 1:\n                return ' '.join(line).ljust(width)\n            total_spaces = width - sum(len(word) for word in line)\n            space_slots = len(line) - 1\n            even_space = total_spaces // space_slots\n            extra_space = total_spaces % space_slots\n            for i in range(extra_space):\n                line[i] += ' '\n            return (' ' * even_space).join(line)\n\n        result, current_line, current_length = [], [], 0\n        for word in words:\n            if current_length + len(word) + len(current_line) > maxWidth:\n                result.append(justify_line(current_line, maxWidth))\n                current_line, current_length = [], 0\n            current_line.append(word)\n            current_length += len(word)\n        result.append(justify_line(current_line, maxWidth, is_last=True))\n        return result\n\n# Example usage:\n# sol = Solution()\n# output = sol.fullJustify([\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], 16)\n# print(output)",
            "runtimes": [
                0.0006074905395507812,
                0.0006642341613769531,
                0.0007238388061523438,
                0.0007679462432861328,
                0.0007803440093994141,
                0.0008399486541748047,
                0.0008664131164550781,
                0.0008668899536132812,
                0.0009138584136962891,
                0.0010952949523925781,
                0.0017242431640625,
                0.00968790054321289,
                0.016001224517822266
            ],
            "beyond_p": 0.9996902394449091
        }
    ],
    "binary-tree-postorder-traversal": [
        {
            "slug_name": "binary-tree-postorder-traversal",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "# Initialize an empty list to store the postorder traversal\n        postorder = []\n\n        # Check if the tree is empty\n        if not root:\n            return postorder\n\n        # Initialize a stack to store the nodes\n        stack = []\n        current = root\n\n        # Iterate until the stack is empty\n        while stack or current:\n            # Reach the leftmost node of the current node\n            while current:\n                stack.append(current)\n                current = current.left if current.left else current.right\n\n            # Process the nodes from the stack\n            node = stack.pop()\n            postorder.append(node.val)\n\n            # If the stack is not empty and the current node is the left child of the top node in the stack\n            if stack and stack[-1].left == node:\n                current = stack[-1].right\n            else:\n                current = None\n\n        return postorder",
            "runtimes": [
                0.0004177093505859375,
                0.0004405975341796875,
                0.00048804283142089844,
                0.0005140304565429688,
                0.0005152225494384766,
                0.0005626678466796875,
                0.0005950927734375,
                0.0006945133209228516
            ],
            "beyond_p": 0.0
        }
    ],
    "container-with-most-water": [
        {
            "slug_name": "container-with-most-water",
            "result": {
                "result": "passed",
                "runtime": 0.001538991928100586,
                "index": 0
            },
            "solution": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        left = 0\n        right = len(height) - 1\n        max_area = 0\n\n        while left < right:\n            width = right - left\n            current_area = min(height[left], height[right]) * width\n            max_area = max(max_area, current_area)\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxArea([1,8,6,2,5,4,8,3,7]))  # Output: 49\n# print(sol.maxArea([1,1]))  # Output: 1",
            "runtimes": [
                0.0005054473876953125,
                0.0006155967712402344,
                0.0008454322814941406,
                0.0011377334594726562,
                0.0011484622955322266,
                0.0012478828430175781,
                0.001276254653930664,
                0.0013079643249511719,
                0.0013499259948730469,
                0.0014736652374267578,
                0.0014786720275878906,
                0.0015015602111816406,
                0.001512289047241211,
                0.001581430435180664,
                0.0016293525695800781,
                0.0019030570983886719,
                0.0021524429321289062,
                0.002565145492553711,
                0.004324436187744141,
                0.006608247756958008,
                0.007687091827392578,
                0.00800180435180664
            ],
            "beyond_p": 0.8621270911519623
        }
    ],
    "concatenated-words": [
        {
            "slug_name": "concatenated-words",
            "result": {
                "result": "failed@cases",
                "runtime": 0.0012700557708740234,
                "index": 0
            },
            "solution": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        def canForm(word, wordSet):\n            if word in wordSet:\n                return True\n            for i in range(1, len(word)):\n                prefix, suffix = word[:i], word[i:]\n                if prefix in wordSet and canForm(suffix, wordSet):\n                    return True\n            return False\n\n        words.sort(key=len)\n        wordSet = set()\n        result = []\n        for word in words:\n            if canForm(word, wordSet):\n                result.append(word)\n            wordSet.add(word)\n        return result\n\n# Example usage:\nsol = Solution()\nexample1 = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\nexample2 = [\"cat\",\"dog\",\"catdog\"]\nprint(sol.findAllConcatenatedWordsInADict(example1))\nprint(sol.findAllConcatenatedWordsInADict(example2))",
            "runtimes": [
                0.0010652542114257812,
                0.0013053417205810547,
                0.0013129711151123047,
                0.001371622085571289,
                0.0013756752014160156,
                0.002466917037963867,
                0.0042569637298583984,
                0.004323244094848633,
                0.004611968994140625,
                0.005471229553222656,
                0.006388187408447266,
                0.008028984069824219,
                0.014029979705810547,
                0.01669454574584961,
                0.04232954978942871
            ],
            "beyond_p": 0.0
        }
    ],
    "base-7": [
        {
            "slug_name": "base-7",
            "result": {
                "result": "passed",
                "runtime": 0.00038313865661621094,
                "index": 0
            },
            "solution": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return '0'\n        negative = num < 0\n        num = abs(num)\n        base7 = ''\n        while num > 0:\n            base7 = str(num % 7) + base7\n            num //= 7\n        if negative:\n            base7 = '-' + base7\n        return base7",
            "runtimes": [
                0.0002512931823730469,
                0.0002865791320800781,
                0.00028896331787109375,
                0.00028896331787109375,
                0.00029087066650390625,
                0.00029468536376953125,
                0.0002982616424560547,
                0.00030350685119628906,
                0.0003046989440917969,
                0.0003085136413574219,
                0.00035643577575683594,
                0.00844430923461914
            ],
            "beyond_p": 0.9839075776975905
        }
    ],
    "nim-game": [
        {
            "slug_name": "nim-game",
            "result": {
                "result": "passed",
                "runtime": 0.00033354759216308594,
                "index": 0
            },
            "solution": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        # The key observation is that if the number of stones is a multiple of 4,\n        # the player who starts will always lose if the opponent plays optimally.\n        # This is because no matter how many stones the first player takes (1, 2, or 3),\n        # the second player can always take enough stones to make the total number\n        # of stones taken by both players a multiple of 4.\n        # Therefore, the strategy for the second player is to always take\n        # (4 - x) stones where x is the number of stones the first player took.\n        # When the number of stones left is 4, the first player will have no choice\n        # but to take the last stone on their turn.\n        \n        # If the initial number of stones is not a multiple of 4,\n        # the first player can always ensure that the number of stones left\n        # after their first turn is a multiple of 4, putting the second player\n        # in the losing position.\n        \n        # Therefore, the first player wins if and only if n % 4 != 0.\n        return n % 4 != 0\n\n# Example usage:\n# sol = Solution()\n# print(sol.canWinNim(4))  # Output: false\n# print(sol.canWinNim(1))  # Output: true\n# print(sol.canWinNim(2))  # Output: true",
            "runtimes": [
                0.0002582073211669922,
                0.0002789497375488281,
                0.0003037452697753906,
                0.0003056526184082031,
                0.0003070831298828125,
                0.0003256797790527344,
                0.00036835670471191406,
                0.0003724098205566406
            ],
            "beyond_p": 0.34029227557411273
        }
    ],
    "n-queens-ii": [
        {
            "slug_name": "n-queens-ii",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "class Solution(object):\n    def totalNQueens(self, n):\n        def is_not_under_attack(row, col):\n            for prev_row in range(row):\n                if board[prev_row] == col or \n                   board[prev_row] - prev_row == col - row or \n                   board[prev_row] + prev_row == col + row:\n                    return False\n            return True\n\n        def place_queen(row):\n            if row == n:\n                nonlocal count\n                count += 1\n                return\n            for col in range(n):\n                if is_not_under_attack(row, col):\n                    board[row] = col\n                    place_queen(row + 1)\n                    board[row] = -1\n\n        count = 0\n        board = [-1] * n\n        place_queen(0)\n        return count\n\n# Example usage:\n# sol = Solution()\n# print(sol.totalNQueens(4))  # Output: 2\n# print(sol.totalNQueens(1))  # Output: 1",
            "runtimes": [
                0.00035262107849121094,
                0.0005946159362792969,
                0.0008444786071777344,
                0.0008685588836669922,
                0.0011458396911621094,
                0.0012264251708984375,
                0.0013322830200195312,
                0.0013959407806396484,
                0.0015528202056884766,
                0.001630544662475586,
                0.002033233642578125,
                0.0020439624786376953,
                0.002477407455444336,
                0.0036029815673828125,
                0.003750324249267578,
                0.00500035285949707,
                0.006793498992919922,
                0.008629083633422852,
                0.028742313385009766
            ],
            "beyond_p": 0.0
        }
    ],
    "n-queens": [
        {
            "slug_name": "n-queens",
            "result": {
                "result": "failed@load",
                "runtime": 0,
                "index": 0
            },
            "solution": "class Solution(object):\n    def solveNQueens(self, n):\n        def is_not_under_attack(row, col):\n            for prev_row in range(row):\n                if board[prev_row] == col or \n                   board[prev_row] - prev_row == col - row or \n                   board[prev_row] + prev_row == col + row:\n                    return False\n            return True\n\n        def place_queen(row, col):\n            board[row] = col\n\n        def remove_queen(row, col):\n            board[row] = -1\n\n        def add_solution():\n            solution = []\n            for i in range(n):\n                row = ['.'] * n\n                row[board[i]] = 'Q'\n                solution.append(''.join(row))\n            result.append(solution)\n\n        def backtrack(row = 0):\n            for col in range(n):\n                if is_not_under_attack(row, col):\n                    place_queen(row, col)\n                    if row + 1 == n:\n                        add_solution()\n                    else:\n                        backtrack(row + 1)\n                    remove_queen(row, col)\n\n        result = []\n        board = [-1] * n\n        backtrack()\n        return result\n\n# Example usage:\n# sol = Solution()\n# print(sol.solveNQueens(4))",
            "runtimes": [
                0.0006399154663085938,
                0.0006468296051025391,
                0.0010254383087158203,
                0.0010499954223632812,
                0.0013256072998046875,
                0.0014116764068603516,
                0.0018455982208251953,
                0.0022656917572021484,
                0.002866029739379883,
                0.0029473304748535156,
                0.0029718875885009766,
                0.0031309127807617188,
                0.0031926631927490234,
                0.003280162811279297,
                0.003454446792602539,
                0.007330894470214844,
                0.008458375930786133,
                0.009545087814331055,
                0.018056392669677734
            ],
            "beyond_p": 0.0
        }
    ],
    "word-search": [
        {
            "slug_name": "word-search",
            "result": {
                "result": "passed",
                "runtime": 0.00037789344787597656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def exist(self, board, word):\n        def dfs(i, j, k):\n            if not (0 <= i < len(board)) or not (0 <= j < len(board[0])) or board[i][j] != word[k]:\n                return False\n            if k == len(word) - 1:\n                return True\n            tmp, board[i][j] = board[i][j], '/'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = tmp\n            return res\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False\n\n# Example usage:\n# sol = Solution()\n# print(sol.exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCCED'))  # Output: true\n# print(sol.exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'SEE'))  # Output: true\n# print(sol.exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCB'))  # Output: false",
            "runtimes": [
                0.00031948089599609375,
                0.00032806396484375,
                0.0003371238708496094,
                0.0003371238708496094,
                0.00033783912658691406,
                0.00033974647521972656,
                0.0003407001495361328,
                0.0003428459167480469,
                0.00034999847412109375,
                0.0003502368927001953,
                0.00035500526428222656,
                0.00036525726318359375,
                0.0003781318664550781,
                0.0003788471221923828,
                0.0003790855407714844,
                0.00038051605224609375,
                0.00038361549377441406,
                0.00038504600524902344,
                0.00039196014404296875,
                0.0003993511199951172,
                0.0004010200500488281,
                0.0004036426544189453,
                0.00046372413635253906,
                0.0004935264587402344
            ],
            "beyond_p": 0.6643835616438356
        }
    ],
    "merge-sorted-array": [
        {
            "slug_name": "merge-sorted-array",
            "result": {
                "result": "passed",
                "runtime": 0.0005745887756347656,
                "index": 0
            },
            "solution": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        # Initialize two pointers for nums1 and nums2 respectively\n        p1, p2 = m - 1, n - 1\n        # Pointer for the last element in the merged array\n        p = m + n - 1\n\n        # Merge in reverse order\n        while p1 >= 0 and p2 >= 0:\n            if nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n\n        # If there are remaining elements in nums2, add them\n        nums1[:p2 + 1] = nums2[:p2 + 1]\n\n# Example usage:\n# sol = Solution()\n# nums1 = [1,2,3,0,0,0]\n# m = 3\n# nums2 = [2,5,6]\n# n = 3\n# sol.merge(nums1, m, nums2, n)\n# print(nums1)  # Output: [1,2,2,3,5,6]",
            "runtimes": [
                0.0003306865692138672,
                0.0003345012664794922,
                0.00035119056701660156,
                0.0003514289855957031,
                0.0003571510314941406,
                0.0003635883331298828,
                0.0003638267517089844,
                0.0003781318664550781,
                0.0003898143768310547,
                0.0003981590270996094,
                0.0004024505615234375,
                0.00040340423583984375,
                0.0005011558532714844,
                0.0006365776062011719,
                0.0006706714630126953,
                0.0025043487548828125
            ],
            "beyond_p": 0.8877920368542284
        }
    ],
    "third-maximum-number": [
        {
            "slug_name": "third-maximum-number",
            "result": {
                "result": "passed",
                "runtime": 0.0008790493011474609,
                "index": 0
            },
            "solution": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # Initialize three variables to store the maximums\n        first_max = second_max = third_max = float('-inf')\n        for num in nums:\n            if num > first_max:\n                third_max = second_max\n                second_max = first_max\n                first_max = num\n            elif first_max > num > second_max:\n                third_max = second_max\n                second_max = num\n            elif second_max > num > third_max:\n                third_max = num\n        # If the third maximum does not exist, return the maximum number\n        return first_max if third_max == float('-inf') else third_max\n\n# Example usage:\n# sol = Solution()\n# print(sol.thirdMax([3,2,1]))  # Output: 1\n# print(sol.thirdMax([1,2]))    # Output: 2\n# print(sol.thirdMax([2,2,3,1])) # Output: 1",
            "runtimes": [
                0.0008330345153808594,
                0.0008339881896972656,
                0.0008435249328613281,
                0.0009157657623291016,
                0.0009188652038574219,
                0.0009236335754394531,
                0.0009274482727050781,
                0.0009453296661376953,
                0.0009527206420898438,
                0.0009746551513671875,
                0.0009877681732177734,
                0.0009922981262207031,
                0.0010318756103515625,
                0.0010483264923095703,
                0.0010647773742675781,
                0.001950979232788086,
                0.004313468933105469
            ],
            "beyond_p": 0.9867790108234005
        }
    ]
}