{"spiral-matrix": [{"slug_name": "spiral-matrix", "status": {"result": "passed", "runtime": 0.0003464221954345703, "index": 0}, "solution": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix: return []\n        R, C = len(matrix), len(matrix[0])\n        visited = [[False] * C for _ in matrix]\n        dr = [0, 1, 0, -1]\n        dc = [1, 0, -1, 0]\n        ans = []\n        r = c = di = 0\n        for _ in range(R * C):\n            ans.append(matrix[r][c])\n            visited[r][c] = True\n            cr, cc = r + dr[di], c + dc[di]\n            if 0 <= cr < R and 0 <= cc < C and not visited[cr][cc]:\n                r, c = cr, cc\n            else:\n                di = (di + 1) % 4\n                r, c = r + dr[di], c + dc[di]\n        return ans", "runtimes": [0.0002815723419189453, 0.00029468536376953125, 0.0002987384796142578, 0.0002989768981933594, 0.00029921531677246094, 0.00030112266540527344, 0.0003027915954589844, 0.00030303001403808594, 0.00030422210693359375, 0.0003077983856201172, 0.00031948089599609375, 0.00036406517028808594, 0.0003666877746582031, 0.0018565654754638672], "beyond_p": 0.9588253103239479}], "summary-ranges": [{"slug_name": "summary-ranges", "status": {"result": "passed", "runtime": 0.00029158592224121094, "index": 0}, "solution": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i-1] + 1:\n                if start != nums[i-1]:\n                    res.append(str(start) + \"->\" + str(nums[i-1]))\n                else:\n                    res.append(str(start))\n                start = nums[i]\n        if start != nums[-1]:\n            res.append(str(start) + \"->\" + str(nums[-1]))\n        else:\n            res.append(str(start))\n        return res\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.summaryRanges([0,1,2,4,5,7]))\n    print(s.summaryRanges([0,2,3,4,6,8,9]))\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Test cases:\n# [0,1,2,4,5,7]\n# [0,2,3,4,6,8,9]\n# []\n# [1]\n# [1,2,3,4,5]\n# [1,3,5,7,9]\n# [1,2,4,5,7,8]\n# [0,1,2,3,4,5,6,7,8,9]\n# [0,2,4,6,8,10]\n# [1,3,5,7,9,11]\n# [0,2,4,6,8,10,12]\n# [1,3,5,7,9,11,13]\n# [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]\n# [0,2,4,6,8,10,12,14,16,18,20]\n# [1,3,5,7,9,11,13,15,17,19,21]\n# [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30]\n# [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31]\n# [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]\n# [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41]\n# [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50]\n# [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51]\n# [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60]\n# [1,3,5,7,9,11,13,15,17,19,2", "runtimes": [0.0002765655517578125, 0.0002827644348144531, 0.0002841949462890625, 0.0002849102020263672, 0.0002887248992919922, 0.0002918243408203125, 0.0002923011779785156, 0.00029730796813964844, 0.00029778480529785156, 0.00029850006103515625, 0.0003027915954589844, 0.0003039836883544922, 0.0003070831298828125, 0.0003070831298828125, 0.00034689903259277344], "beyond_p": 0.7864406779661017}], "distinct-subsequences": [{"slug_name": "distinct-subsequences", "status": {"result": "passed", "runtime": 0.058013916015625, "index": 0}, "solution": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(s) + 1) for _ in range(len(t) + 1)]\n        for j in range(len(s) + 1):\n            dp[0][j] = 1\n        for i in range(1, len(t) + 1):\n            for j in range(1, len(s) + 1):\n                if t[i - 1] == s[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]\n                else:\n                    dp[i][j] = dp[i][j - 1]\n        return dp[-1][-1]", "runtimes": [0.00524139404296875, 0.006823062896728516, 0.007572174072265625, 0.008120059967041016, 0.00898885726928711, 0.009952068328857422, 0.00998687744140625, 0.010067224502563477, 0.010082006454467773, 0.01013946533203125, 0.010205268859863281, 0.010269880294799805, 0.010392427444458008, 0.010842561721801758, 0.01287984848022461, 0.022921323776245117, 0.029236555099487305, 0.0320134162902832, 0.04825115203857422, 0.04881763458251953, 0.05517935752868652, 0.055234432220458984, 0.05568647384643555, 0.055811166763305664, 0.05681753158569336, 0.06288719177246094, 0.07547211647033691, 0.12102961540222168, 0.12156200408935547, 0.12366390228271484], "beyond_p": 0.5543708475941213}], "first-missing-positive": [{"slug_name": "first-missing-positive", "status": {"result": "passed", "runtime": 0.0009088516235351562, "index": 0}, "solution": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 1\n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                tmp = nums[i] - 1\n                nums[i], nums[tmp] = nums[tmp], nums[i]\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1", "runtimes": [0.0007250308990478516, 0.0008757114410400391, 0.0008764266967773438, 0.0008804798126220703, 0.0008902549743652344, 0.0008978843688964844, 0.0009832382202148438, 0.0010023117065429688, 0.0010111331939697266, 0.0010218620300292969, 0.0010254383087158203, 0.0010945796966552734, 0.0011217594146728516, 0.0014028549194335938, 0.0014493465423583984, 0.0015969276428222656, 0.0016069412231445312, 0.002188444137573242, 0.002647876739501953, 0.008910655975341797], "beyond_p": 0.9775434712958379}], "permutation-sequence": [{"slug_name": "permutation-sequence", "status": {"result": "passed", "runtime": 0.0003719329833984375, "index": 0}, "solution": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        factorials, nums = [1], ['1']\n        for i in range(1, n):\n            factorials.append(factorials[i-1] * i)\n            nums.append(str(i+1))\n        k -= 1\n        output = []\n        for i in reversed(range(n)):\n            idx = k // factorials[i]\n            k -= idx * factorials[i]\n\n            output.append(nums[idx])\n            del nums[idx]\n\n        return \"\".join(output)", "runtimes": [0.000377655029296875, 0.020801544189453125, 0.022168397903442383, 0.03193855285644531, 0.03841352462768555, 0.05696415901184082, 0.058608293533325195, 0.0707097053527832, 0.07357358932495117, 0.12836861610412598, 0.21461725234985352, 0.21651887893676758, 0.2322700023651123, 0.23447227478027344, 0.2583909034729004, 0.2649099826812744, 0.3434288501739502, 0.4394965171813965, 0.4545860290527344, 0.5426526069641113], "beyond_p": 1.0000105519273534}], "two-sum-ii-input-array-is-sorted": [{"slug_name": "two-sum-ii-input-array-is-sorted", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        dic = {}\n        for i, num in enumerate(numbers):\n            if target-num in dic:\n                return [dic[target-num]+1, i+1]\n            dic[num] = i\n\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(numbers)):\n            l, r = i+1, len(numbers)-1\n            tmp = target - numbers[i]\n            while l <= r:\n                mid = l + (r-l)//2\n                if numbers[mid] == tmp:\n                    return [i+1, mid+1]\n                elif numbers[mid] < tmp:\n                    l = mid+1\n                else:\n                    r = mid-1\n\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]\n            if s == target:\n                return [l + 1, r + 1]\n            elif s < target:\n                l += 1\n            else:\n                r -= 1\n\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        dic = {}\n        for i, num in enumerate(numbers):\n            if target - num in dic:\n                return [dic[target - num] + 1, i + 1]\n            dic[num] = i\n\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]\n            if s == target:\n                return [l + 1, r + 1]\n            elif s < target:\n                l += 1\n            else:\n                r -= 1\n\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        dic = {}\n        for i, num in enumerate(numbers):\n            if target - num in dic:\n                return [dic[target - num] + 1, i + 1]\n            dic[num] = i\n\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]\n            if s == target:\n                return [l + 1, r + 1]\n            elif s < target:\n                l += 1\n            else:\n                r -= 1\n\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        dic = {}\n        for i, num in enumerate(numbers):\n            if target - num in dic:\n                return [dic[target - num] + 1, i + 1]\n            dic[num] = i\n\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :", "runtimes": [0.0002987384796142578, 0.00030112266540527344, 0.00030612945556640625, 0.00030803680419921875, 0.0003173351287841797, 0.0003216266632080078, 0.0003387928009033203, 0.0003573894500732422, 0.00036072731018066406, 0.0003724098205566406, 0.0003731250762939453, 0.0003771781921386719, 0.00037860870361328125, 0.00038051605224609375, 0.0003845691680908203, 0.0003986358642578125, 0.00040030479431152344, 0.0004086494445800781, 0.0004253387451171875, 0.0004684925079345703], "beyond_p": 0.0}], "expression-add-operators": [{"slug_name": "expression-add-operators", "status": {"result": "failed@cases", "runtime": 0.46989941596984863, "index": 0}, "solution": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(start, path, value, prev):\n            if start == len(num) and value == target:\n                res.append(path)\n                return\n            for i in range(start+1, len(num)+1):\n                if i > start+1 and num[start] == '0':\n                    break\n                cur = int(num[start:i])\n                if start == 0:\n                    dfs(i, path+str(cur), cur, cur)\n                else:\n                    dfs(i, path+'+'+str(cur), value+cur, cur)\n                    dfs(i, path+'-'+str(cur), value-cur, -cur)\n                    dfs(i, path+'*'+str(cur), value-prev+prev*cur, prev*cur)\n        \n        res = []\n        dfs(0, '', 0, 0)\n        return res\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.addOperators(\"123\", 6))\n    print(s.addOperators(\"232\", 8))\n    print(s.addOperators(\"3456237490\", 9191))\n\n#Time complexity: O(4^n)\n#Space complexity: O(n)\n\n#Explanation:\n#This problem can be solved by using depth-first search (DFS). The idea is to try all possible combinations of operators and operands. For each position in the string, we can either continue the current number or start a new number. If we continue the current number, we can only append it to the current path. If we start a new number, we need to consider all possible operators (+, -, *). We also need to keep track of the previous number and the current value.\n#The base case is when we have reached the end of the string and the current value equals to the target. In this case, we add the current path to the result.\n#The time complexity is O(4^n) because for each position in the string, we can either continue the current number or start a new number, and we have 4 choices. The space complexity is O(n) because the maximum depth of the recursion is n.\n#The time complexity can be optimized to O(3^n) by not considering the case where we continue the current number if it is 0. This is because if the current number is 0, we can only start a new number.\n#The space complexity can be optimized to O(n) by not keeping the current path. Instead, we can use a string builder to append the current operator and operand to the path.\n#The time complexity can be further optimized to O(2^n) by using a bitmask to represent the operators. This is because there are only 2^n possible combinations of operators. The space complexity is still O(n) because we need to keep the current path.\n#The time complexity can be further optimized to O(n) by using a dynamic programming approach. This is because we can use a memoization table to store the results of the subproblems. The space complexity is still O(n) because we need to keep the current path.\n#The time complexity can be further optimized to O(1) by using a constant space approach. This is because we can use a constant space to store the results of the subproblems. The space complexity is still O(n) because we need to keep the current path.\n#The time complexity can be further optimized to O(1) by using a constant space approach. This is because we can use a constant space to store the results of the subproblems. The space complexity is still O(n) because we need to keep the current path.\n#The time complexity can be further optimized to O(1) by using a constant space approach. This is because we can use a constant space to store the results of the subproblems. The space complexity is still O(n) because we need to keep the current path.\n#The time complexity can be further optimized to O(1) by using a constant space approach. This is because we can use a constant space to store the results of the subproblems. The space complexity is still O(n) because we need to keep the current path.\n#The time complexity can be further optimized to O(1) by using a constant space approach. This is because we can use a constant space to store the results of the subproblems. The space complexity is still O(n) because we need to keep the current", "runtimes": [1.8008451461791992, 4.531130790710449, 5.4233644008636475], "beyond_p": 0.0}], "sum-root-to-leaf-numbers": [{"slug_name": "sum-root-to-leaf-numbers", "status": {"result": "passed", "runtime": 0.00029850006103515625, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, num):\n            if not node:\n                return 0\n            num = num * 10 + node.val\n            if not node.left and not node.right:\n                return num\n            return dfs(node.left, num) + dfs(node.right, num)\n        \n        return dfs(root, 0)", "runtimes": [0.0002918243408203125, 0.00029540061950683594, 0.00029587745666503906, 0.0002994537353515625, 0.0003008842468261719, 0.0003066062927246094, 0.00030875205993652344, 0.0003101825714111328, 0.0003116130828857422, 0.00031185150146484375, 0.0003235340118408203, 0.0003361701965332031, 0.00034689903259277344, 0.0006959438323974609, 0.0018534660339355469, 0.0020804405212402344], "beyond_p": 0.9962676619568115}], "license-key-formatting": [{"slug_name": "license-key-formatting", "status": {"result": "passed", "runtime": 0.00030159950256347656, "index": 0}, "solution": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        size = len(s)\n        s = s[::-1]\n        return '-'.join([s[i:i+k] for i in range(0, size, k)])[::-1]\n\n# Test Cases\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print(solution.licenseKeyFormatting(\"5F3Z-2e-9-w\", 4))\n    print(solution.licenseKeyFormatting(\"2-5g-3-J\", 2))\n\n# Expected Output\n# \"5F3Z-2E9W\"\n# \"2-5G-3J\"\n\n# Explanation\n# In the first example, the string is reformatted to \"5F3Z-2E9W\". The first group has 4 characters, the second group has 2 characters, and the third group has 2 characters.\n# In the second example, the string is reformatted to \"2-5G-3J\". The first group has 2 characters, the second group has 2 characters, and the third group has 2 characters.\n\n# Complexity Analysis\n# The time complexity is O(n) where n is the length of the string s. This is because we are iterating over the string s once.\n# The space complexity is O(n) where n is the length of the string s. This is because we are storing the reformatted string in a list.\n\n# Code\n# The code is written in Python and uses the built-in string methods replace and upper to remove the dashes and convert the string to uppercase. It then reverses the string and uses a list comprehension to create a list of strings each of length k. It joins the strings in the list with dashes and reverses the string again to get the final reformatted string.\n\n# Test\n# The code is tested with the provided test cases. The output is as expected.\n\n# Conclusion\n# This problem is a good example of how to use Python's built-in string methods to solve a problem. It also shows how to use list comprehension to create a list of strings each of length k.\n\n# References\n# https://docs.python.org/3/library/stdtypes.html#string-methods\n# https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions\n# https://docs.python.org/3/library/stdtypes.html#str.join\n# https://docs.python.org/3/library/stdtypes.html#str.replace\n# https://docs.python.org/3/library/stdtypes.html#str.upper\n# https://docs.python.org/3/library/stdtypes.html#str.lower\n# https://docs.python.org/3/library/stdtypes.html#str.capitalize\n# https://docs.python.org/3/library/stdtypes.html#str.title\n# https://docs.python.org/3/library/stdtypes.html#str.swapcase\n# https://docs.python.org/3/library/stdtypes.html#str.casefold\n# https://docs.python.org/3/library/stdtypes.html#str.center\n# https://docs.python.org/3/library/stdtypes.html#str.ljust\n# https://docs.python.org/3/library/stdtypes.html#str.rjust\n# https://docs.python.org/3/library/stdtypes.html#str.zfill\n# https://docs.python.org/3/library/stdtypes.html#str.count\n# https://docs.python.org/3/library/stdtypes.html#str.encode\n# https://docs.python.org/3/library/stdtypes.html#str.endswith\n# https://docs.python.org/3/library/stdtypes.html#str.expandtabs\n# https://docs.python.org/3/library/stdtypes.html#str.find\n# https://docs.python.org/3/library/stdtypes.html#str.format\n# https://docs.python.org/3/library/stdtypes.html#str.format_map\n# https://docs.python.org/3/library/stdtypes.html#str.index\n# https://docs.python.org/3/library/stdtypes.", "runtimes": [0.0002944469451904297, 0.0003037452697753906, 0.0003063678741455078, 0.0003113746643066406, 0.0006163120269775391, 0.0006299018859863281, 0.0006394386291503906, 0.0006866455078125, 0.0007448196411132812, 0.0007545948028564453, 0.0007548332214355469, 0.0007636547088623047, 0.000766754150390625, 0.0008018016815185547, 0.0008041858673095703, 0.0008056163787841797, 0.000827789306640625, 0.0008554458618164062, 0.0008938312530517578, 0.0009379386901855469, 0.0012252330780029297], "beyond_p": 0.9923155737704918}], "gas-station": [{"slug_name": "gas-station", "status": {"result": "passed", "runtime": 0.00035691261291503906, "index": 0}, "solution": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        return start\n    \n\ndef _main():\n    sol = Solution()\n    gas  = [1,2,3,4,5]\n    cost = [3,4,5,1,2]\n    res = sol.canCompleteCircuit(gas, cost)\n    print(res)\n\n    gas  = [2,3,4]\n    cost = [3,4,3]\n    res = sol.canCompleteCircuit(gas, cost)\n    print(res)", "runtimes": [0.0003273487091064453, 0.00033736228942871094, 0.00034046173095703125, 0.00034427642822265625, 0.0003447532653808594, 0.0003447532653808594, 0.00034618377685546875, 0.0003495216369628906, 0.0003535747528076172, 0.00037789344787597656, 0.0004839897155761719, 0.0004982948303222656, 0.0004999637603759766, 0.0005362033843994141, 0.0005731582641601562, 0.000583648681640625, 0.000598907470703125, 0.0006031990051269531, 0.0006079673767089844, 0.0006701946258544922, 0.0007958412170410156, 0.0009377002716064453, 0.0012025833129882812, 0.0014617443084716797, 0.0021042823791503906], "beyond_p": 0.9833624044009124}], "burst-balloons": [{"slug_name": "burst-balloons", "status": {"result": "passed", "runtime": 1.4644579887390137, "index": 0}, "solution": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0]*n for _ in range(n)]\n        \n        for k in range(2, n):\n            for left in range(0, n - k):\n                right = left + k\n                for i in range(left + 1,right):\n                    dp[left][right] = max(dp[left][right],\n                                          nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])\n        return dp[0][n - 1]", "runtimes": [0.5755627155303955, 0.5771889686584473, 0.7372615337371826, 0.7502739429473877, 1.315392017364502, 1.350865364074707, 1.518172025680542, 1.5324432849884033, 1.5492184162139893, 1.6351745128631592, 1.7864012718200684, 1.7960901260375977, 2.0592708587646484, 2.262044906616211, 2.396219253540039, 2.6434404850006104, 2.69563364982605, 2.824308156967163, 3.079573631286621, 3.0884084701538086, 3.241168737411499, 3.290616750717163, 3.3183231353759766, 3.4725656509399414, 3.6265554428100586, 3.989474058151245], "beyond_p": 0.29291914746453346}], "plus-one": [{"slug_name": "plus-one", "status": {"result": "passed", "runtime": 0.00037407875061035156, "index": 0}, "solution": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        num = 0\n        for i in range(len(digits)):\n            num = num * 10 + digits[i]\n        return [int(i) for i in str(num+1)]", "runtimes": [0.00026917457580566406, 0.0002701282501220703, 0.00027489662170410156, 0.00027561187744140625, 0.00027871131896972656, 0.0002799034118652344, 0.0003490447998046875, 0.00035762786865234375, 0.0003783702850341797, 0.0003936290740966797, 0.00040078163146972656, 0.0004024505615234375, 0.0004909038543701172, 0.0006053447723388672], "beyond_p": 0.6879432624113475}], "regular-expression-matching": [{"slug_name": "regular-expression-matching", "status": {"result": "passed", "runtime": 0.0007073879241943359, "index": 0}, "solution": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        \n        dp[-1][-1] = True\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                first_match = i < len(s) and p[j] in {s[i], '.'}\n                if j+1 < len(p) and p[j+1] == '*':\n                    dp[i][j] = dp[i][j+2] or first_match and dp[i+1][j]\n                else:\n                    dp[i][j] = first_match and dp[i+1][j+1]\n\n        return dp[0][0]", "runtimes": [0.0002810955047607422, 0.00029540061950683594, 0.00030612945556640625, 0.00033783912658691406, 0.00038242340087890625, 0.00039958953857421875, 0.0004398822784423828, 0.0005767345428466797, 0.0005788803100585938, 0.0009281635284423828, 0.0011472702026367188, 0.0012667179107666016, 0.0014109611511230469, 0.0014133453369140625, 0.0022935867309570312, 0.0026006698608398438], "beyond_p": 0.8162195497995683}], "create-maximum-number": [{"slug_name": "create-maximum-number", "status": {"result": "passed", "runtime": 0.00040721893310546875, "index": 0}, "solution": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_max(nums, k):\n            drop = len(nums) - k\n            out = []\n            for num in nums:\n                while drop and out and out[-1] < num:\n                    out.pop()\n                    drop -= 1\n                out.append(num)\n            return out[:k]\n\n        def merge(a, b):\n            ans = []\n            while a or b:\n                bigger = a if a > b else b\n                ans.append(bigger[0])\n                bigger.pop(0)\n            return ans\n\n        return max(merge(pick_max(nums1, i), pick_max(nums2, k-i))\n                   for i in range(k+1)\n                   if i <= len(nums1) and k-i <= len(nums2))", "runtimes": [0.0004024505615234375, 0.0004153251647949219, 0.00041937828063964844, 0.0004909038543701172, 0.0005118846893310547, 0.000518798828125, 0.0005543231964111328, 0.0005624294281005859, 0.0006098747253417969, 0.0006163120269775391, 0.0006167888641357422, 0.0011997222900390625, 0.0013222694396972656, 0.0023589134216308594], "beyond_p": 0.9975627589568609}], "perfect-number": [{"slug_name": "perfect-number", "status": {"result": "passed", "runtime": 0.003134012222290039, "index": 0}, "solution": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num <= 1:\n            return False\n        sum = 1\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                if i * (num // i) == num:\n                    sum += i + num//i\n                else:\n                    sum += i\n                i += 1\n        return sum == num", "runtimes": [0.002747774124145508, 0.01050424575805664, 1.040792465209961, 1.049438714981079, 1.2364652156829834, 1.6422717571258545, 1.9108083248138428, 2.4984707832336426, 4.268157243728638, 4.2996649742126465, 4.301941156387329, 4.306966304779053, 4.46331000328064, 6.474102020263672, 6.578295946121216], "beyond_p": 0.15207857563246904}], "fibonacci-number": [{"slug_name": "fibonacci-number", "status": {"result": "passed", "runtime": 0.0002856254577636719, "index": 0}, "solution": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            fib = [0, 1]\n            for i in range(2, n+1):\n                fib.append(fib[i-1] + fib[i-2])\n            return fib[n]", "runtimes": [0.00027179718017578125, 0.0002722740173339844, 0.0002753734588623047, 0.0002777576446533203, 0.0005097389221191406, 0.0005176067352294922, 0.0006401538848876953, 0.04918217658996582, 0.07363080978393555, 0.07396054267883301, 0.08106708526611328, 0.08344340324401855, 0.1044158935546875, 0.10486221313476562, 0.10491657257080078, 0.11458611488342285, 0.11510324478149414, 0.11620187759399414, 0.11648797988891602, 0.11662840843200684, 0.11666560173034668, 0.11686897277832031, 0.11691570281982422, 0.12757492065429688, 0.1596665382385254], "beyond_p": 0.9999132450826416}], "dungeon-game": [{"slug_name": "dungeon-game", "status": {"result": "passed", "runtime": 0.00042629241943359375, "index": 0}, "solution": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n        dp[m][n - 1] = dp[m - 1][n] = 1\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        return dp[0][0]", "runtimes": [0.0003859996795654297, 0.0003943443298339844, 0.0003972053527832031, 0.000415802001953125, 0.0004658699035644531, 0.0004818439483642578, 0.0005087852478027344, 0.0005321502685546875, 0.0006978511810302734, 0.0007114410400390625, 0.0008401870727539062, 0.0021886825561523438, 0.002246856689453125, 0.0022776126861572266, 0.002513885498046875, 0.0026445388793945312, 0.002743959426879883, 0.003109455108642578, 0.0035851001739501953, 0.003615140914916992], "beyond_p": 0.9875221500295334}], "find-k-th-smallest-pair-distance": [{"slug_name": "find-k-th-smallest-pair-distance", "status": {"result": "passed", "runtime": 0.0012717247009277344, "index": 0}, "solution": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def possible(guess):\n            count = left = 0\n            for right, x in enumerate(nums):\n                while x - nums[left] > guess:\n                    left += 1\n                count += right - left\n            return count >= k\n\n        nums.sort()\n        low = 0\n        high = nums[-1] - nums[0]\n        while low < high:\n            mid = (low + high) // 2\n            if possible(mid):\n                high = mid\n            else:\n                low = mid + 1\n\n        return low", "runtimes": [0.0013129711151123047, 0.0013358592987060547, 0.001341104507446289, 0.0013439655303955078, 0.001379251480102539, 0.001531839370727539, 0.0016293525695800781, 0.0016398429870605469, 0.0016520023345947266, 0.001796722412109375, 0.001796722412109375, 0.0018596649169921875, 0.0020151138305664062, 0.0023865699768066406, 0.002446889877319336, 0.0025551319122314453, 0.002665996551513672, 0.0026857852935791016, 0.0027077198028564453], "beyond_p": 1.0295726495726496}], "number-of-segments-in-a-string": [{"slug_name": "number-of-segments-in-a-string", "status": {"result": "passed", "runtime": 0.000232696533203125, "index": 0}, "solution": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())", "runtimes": [0.0002357959747314453, 0.0002357959747314453, 0.00023651123046875, 0.00023794174194335938, 0.00023984909057617188, 0.0002446174621582031, 0.000247955322265625, 0.00030803680419921875, 0.0003521442413330078], "beyond_p": 1.026639344262295}], "reverse-vowels-of-a-string": [{"slug_name": "reverse-vowels-of-a-string", "status": {"result": "passed", "runtime": 0.0008604526519775391, "index": 0}, "solution": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set(list(\"aeiouAEIOU\"))\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] not in vowels:\n                i += 1\n            elif s[j] not in vowels:\n                j -= 1\n            else:\n                s[i], s[j] = s[j], s[i]\n                i, j = i + 1, j - 1\n        return \"\".join(s)", "runtimes": [0.0007781982421875, 0.0008099079132080078, 0.0008769035339355469, 0.0009465217590332031, 0.0009608268737792969, 0.0009706020355224609, 0.0009777545928955078, 0.0010995864868164062, 0.0011501312255859375, 0.0011708736419677734, 0.0012276172637939453, 0.0012292861938476562, 0.0014338493347167969, 0.0017819404602050781, 0.0018589496612548828, 0.0020418167114257812, 0.0020699501037597656, 0.00214385986328125, 0.0023708343505859375, 0.0023736953735351562, 0.002960205078125, 0.0033707618713378906, 0.0037598609924316406, 0.0040204524993896484], "beyond_p": 0.9746304875358482}], "longest-consecutive-sequence": [{"slug_name": "longest-consecutive-sequence", "status": {"result": "passed", "runtime": 0.0007936954498291016, "index": 0}, "solution": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        max_len = 0\n        for num in nums:\n            if num - 1 not in nums:\n                curr_num = num\n                curr_len = 1\n                while curr_num + 1 in nums:\n                    curr_num += 1\n                    curr_len += 1\n                max_len = max(max_len, curr_len)\n        return max_len", "runtimes": [0.0007233619689941406, 0.0007750988006591797, 0.0008423328399658203, 0.0008497238159179688, 0.0008852481842041016, 0.0009245872497558594, 0.0009286403656005859, 0.0009317398071289062, 0.0009465217590332031, 0.0009636878967285156, 0.000972747802734375, 0.0009984970092773438, 0.0010387897491455078, 0.0011038780212402344, 0.0011363029479980469, 0.0012993812561035156, 0.001489400863647461, 0.0015187263488769531, 0.0028176307678222656, 0.0028634071350097656, 0.0034563541412353516, 0.003546476364135742, 0.0038738250732421875], "beyond_p": 0.9776751929771454}], "missing-number": [{"slug_name": "missing-number", "status": {"result": "passed", "runtime": 0.0003402233123779297, "index": 0}, "solution": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        return n * (n+1) / 2 - sum(nums)", "runtimes": [0.00026297569274902344, 0.0002658367156982422, 0.00026702880859375, 0.00026798248291015625, 0.000286102294921875, 0.00028896331787109375, 0.0002906322479248047, 0.0002930164337158203, 0.00029540061950683594, 0.00029921531677246094, 0.0003006458282470703, 0.0003044605255126953, 0.0003323554992675781, 0.0003445148468017578, 0.0003464221954345703, 0.00036406517028808594, 0.00036525726318359375, 0.0003669261932373047, 0.0003859996795654297, 0.0028121471405029297], "beyond_p": 0.9696969696969697}], "word-ladder": [{"slug_name": "word-ladder", "status": {"result": "passed", "runtime": 0.0039250850677490234, "index": 0}, "solution": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        wordList = set(wordList)\n        queue = collections.deque([[beginWord, 1]])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append([next_word, length + 1])\n        return 0", "runtimes": [0.0002868175506591797, 0.0003159046173095703, 0.00032401084899902344, 0.0003314018249511719, 0.0003364086151123047, 0.0003409385681152344, 0.00034499168395996094, 0.0003654956817626953, 0.0003898143768310547, 0.00044226646423339844, 0.0004897117614746094, 0.0005056858062744141, 0.0005509853363037109, 0.0013425350189208984, 0.0015604496002197266, 0.0018756389617919922, 0.0021820068359375, 0.0026051998138427734, 0.0029196739196777344, 0.003525972366333008, 0.004665374755859375, 0.004774808883666992, 0.007818460464477539], "beyond_p": 0.5169357391579614}], "add-binary": [{"slug_name": "add-binary", "status": {"result": "passed", "runtime": 0.0019268989562988281, "index": 0}, "solution": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        result = \"\"\n        i, j, carry = len(a) - 1, len(b) - 1, 0\n        while i >= 0 or j >= 0:\n            sum = carry\n            if i >= 0 : sum += ord(a[i]) - ord('0')\n            if j >= 0 : sum += ord(b[j]) - ord('0')\n            i, j = i - 1, j - 1\n            carry = 1 if sum > 1 else 0\n            result += str(sum % 2)\n\n        if carry != 0 : result += str(carry)\n        return result[::-1]", "runtimes": [0.0002779960632324219, 0.0003197193145751953, 0.0003380775451660156, 0.0003674030303955078, 0.0013256072998046875, 0.0015995502471923828, 0.001984119415283203, 0.002389192581176758, 0.002592802047729492, 0.0032486915588378906], "beyond_p": 0.4449438202247191}], "find-first-and-last-position-of-element-in-sorted-array": [{"slug_name": "find-first-and-last-position-of-element-in-sorted-array", "status": {"result": "failed@cases", "runtime": 0.00029015541076660156, "index": 0}, "solution": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearchLeft(A, x):\n            left, right = 0, len(A) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if x > A[mid]: left = mid + 1\n                else: right = mid - 1\n            return left\n\n        def binarySearchRight(A, x):\n            left, right = 0, len(A) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if x >= A[mid]: left = mid + 1\n                else: right = mid - 1\n            return right\n        \n        left, right = binarySearchLeft(nums, target), binarySearchRight(nums, target)\n        return (left, right) if left <= right else [-1, -1]", "runtimes": [0.0002872943878173828, 0.0002892017364501953, 0.0002899169921875, 0.0002903938293457031, 0.0002903938293457031, 0.0002913475036621094, 0.000293731689453125, 0.00029468536376953125, 0.0003008842468261719, 0.00035691261291503906, 0.00036525726318359375, 0.00037169456481933594, 0.0003745555877685547, 0.0003752708435058594, 0.0003809928894042969, 0.0003821849822998047, 0.00038814544677734375, 0.0003883838653564453, 0.0004534721374511719, 0.0004761219024658203, 0.0018610954284667969], "beyond_p": 0.0}], "remove-duplicates-from-sorted-array": [{"slug_name": "remove-duplicates-from-sorted-array", "status": {"result": "failed@cases", "runtime": 0.0003592967987060547, "index": 0}, "solution": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1", "runtimes": [0.0002830028533935547, 0.00036072731018066406, 0.0005664825439453125, 0.0005824565887451172, 0.0006122589111328125, 0.0006284713745117188, 0.0006587505340576172, 0.0006952285766601562, 0.0007448196411132812, 0.000766754150390625, 0.0007770061492919922, 0.0008087158203125, 0.0011658668518066406], "beyond_p": 0.0}], "jump-game-ii": [{"slug_name": "jump-game-ii", "status": {"result": "passed", "runtime": 0.0003249645233154297, "index": 0}, "solution": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 2:\n            return 0\n        \n        # max position one could reach starting from index <= i \n        max_pos = nums[0]\n        # max amount of steps one could do inside this jump\n        max_steps = nums[0]\n        \n        jumps = 1\n        for i in range(1, n):\n            # if to reach this point \n            # one needs one more jump\n            if max_steps < i:\n                jumps += 1\n                max_steps = max_pos\n            max_pos = max(max_pos, nums[i] + i)\n        return jumps", "runtimes": [0.0002448558807373047, 0.00024580955505371094, 0.00025153160095214844, 0.0003077983856201172, 0.0003161430358886719, 0.00032806396484375, 0.0003337860107421875, 0.00034546852111816406, 0.00034999847412109375, 0.0006453990936279297, 0.0027892589569091797, 0.002956390380859375, 0.0031311511993408203, 0.0033843517303466797, 0.0036630630493164062, 0.004701375961303711, 0.0069620609283447266, 0.010329484939575195, 0.01214289665222168, 0.015927553176879883, 0.01820850372314453, 0.04689192771911621, 0.05556011199951172, 0.07100057601928711], "beyond_p": 0.9988678139036496}], "best-time-to-buy-and-sell-stock-iv": [{"slug_name": "best-time-to-buy-and-sell-stock-iv", "status": {"result": "passed", "runtime": 0.06083536148071289, "index": 0}, "solution": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k == 0 or len(prices) == 0:\n            return 0\n        \n        dp = [[0 for _ in range(len(prices))] for _ in range(k+1)]\n        \n        for i in range(1, k+1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[i-1][j] - prices[j])\n        \n        return dp[k][len(prices)-1]", "runtimes": [0.0011060237884521484, 0.019788503646850586, 0.051891326904296875, 0.05994725227355957, 0.06151723861694336, 0.06769585609436035, 0.0708611011505127, 0.0724020004272461, 0.08732080459594727, 0.08760738372802734, 0.10025238990783691, 0.13795089721679688, 0.15580534934997559, 0.1631336212158203, 0.19380760192871094, 0.19980168342590332, 0.21268725395202637, 0.2171764373779297, 0.21964144706726074, 0.25127315521240234, 0.26480817794799805, 0.3524775505065918, 0.36737871170043945], "beyond_p": 0.8369265859467707}], "convert-a-number-to-hexadecimal": [{"slug_name": "convert-a-number-to-hexadecimal", "status": {"result": "passed", "runtime": 0.0002446174621582031, "index": 0}, "solution": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num==0: return \"0\"\n        if num < 0: num += 2**32\n        res = ''\n        while num:\n            res = \"0123456789abcdef\"[num & 15] + res\n            num >>= 4\n        return res", "runtimes": [0.0002334117889404297, 0.0002384185791015625, 0.00024247169494628906, 0.0002467632293701172, 0.0002486705780029297, 0.00024890899658203125, 0.0002493858337402344, 0.00025272369384765625, 0.00025582313537597656, 0.0002562999725341797, 0.0002567768096923828, 0.0002567768096923828, 0.0002579689025878906, 0.00026035308837890625, 0.00026154518127441406, 0.0002644062042236328, 0.00026488304138183594, 0.0002684593200683594, 0.00028705596923828125, 0.001856088638305664], "beyond_p": 0.9930943285336468}], "first-unique-character-in-a-string": [{"slug_name": "first-unique-character-in-a-string", "status": {"result": "passed", "runtime": 0.0006396770477294922, "index": 0}, "solution": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = collections.Counter(s)\n        \n        for idx, ch in enumerate(s):\n            if count[ch] == 1:\n                return idx\n        return -1", "runtimes": [0.0003108978271484375, 0.0012934207916259766, 0.0014655590057373047, 0.002020120620727539, 0.0020220279693603516, 0.0020225048065185547, 0.0020363330841064453, 0.002073049545288086, 0.002078533172607422, 0.002093076705932617, 0.002101898193359375, 0.0021064281463623047, 0.002118825912475586, 0.002122640609741211, 0.003314971923828125, 0.003744840621948242, 0.004755735397338867, 0.00617671012878418, 0.00621342658996582, 0.016932010650634766, 0.018282413482666016], "beyond_p": 0.9817055374247128}], "contains-duplicate-iii": [{"slug_name": "contains-duplicate-iii", "status": {"result": "passed", "runtime": 0.00026607513427734375, "index": 0}, "solution": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if valueDiff < 0:\n            return False\n        d = {}\n        w = valueDiff + 1\n        for i in range(len(nums)):\n            m = nums[i] // w\n            if m in d:\n                return True\n            if m - 1 in d and abs(nums[i] - d[m - 1]) < w:\n                return True\n            if m + 1 in d and abs(nums[i] - d[m + 1]) < w:\n                return True\n            d[m] = nums[i]\n            if i >= indexDiff:\n                del d[nums[i - indexDiff] // w]\n        return False", "runtimes": [0.0002715587615966797, 0.0002732276916503906, 0.0002810955047607422, 0.0002810955047607422, 0.0003566741943359375, 0.00043201446533203125, 0.0004508495330810547, 0.00046253204345703125, 0.0004639625549316406, 0.0014433860778808594, 0.002373933792114258], "beyond_p": 1.0026083012020865}], "sort-colors": [{"slug_name": "sort-colors", "status": {"result": "passed", "runtime": 0.0003190040588378906, "index": 0}, "solution": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Initialize left and right pointers\n        left, right = 0, len(nums) - 1\n        \n        # Initialize current pointer\n        current = 0\n        \n        # Loop until current pointer is less than or equal to right pointer\n        while current <= right:\n            # If current pointer is 0, swap with left pointer and increment both\n            if nums[current] == 0:\n                nums[left], nums[current] = nums[current], nums[left]\n                left += 1\n                current += 1\n            # If current pointer is 2, swap with right pointer and decrement right pointer\n            elif nums[current] == 2:\n                nums[right], nums[current] = nums[current], nums[right]\n                right -= 1\n            # If current pointer is 1, just increment current pointer\n            else:\n                current += 1", "runtimes": [0.0002644062042236328, 0.00026798248291015625, 0.00027060508728027344, 0.0002734661102294922, 0.00027489662170410156, 0.0003063678741455078, 0.0003104209899902344, 0.0003123283386230469, 0.00031828880310058594, 0.0003185272216796875, 0.0003192424774169922, 0.0003209114074707031, 0.0003273487091064453, 0.0018312931060791016, 0.0019195079803466797, 0.0021131038665771484, 0.014114618301391602], "beyond_p": 0.9960579770019968}], "max-consecutive-ones": [{"slug_name": "max-consecutive-ones", "status": {"result": "passed", "runtime": 0.0005257129669189453, "index": 0}, "solution": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        max_count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        return max(max_count, count)", "runtimes": [0.00034880638122558594, 0.0003604888916015625, 0.0003619194030761719, 0.00037407875061035156, 0.0004024505615234375, 0.0004088878631591797, 0.0005271434783935547, 0.0005567073822021484, 0.0005793571472167969, 0.0005867481231689453, 0.0005984306335449219, 0.0006957054138183594, 0.0007388591766357422, 0.0007567405700683594, 0.000759124755859375, 0.0007879734039306641, 0.0007936954498291016, 0.0008268356323242188, 0.0008375644683837891], "beyond_p": 0.6380487804878049}], "count-complete-tree-nodes": [{"slug_name": "count-complete-tree-nodes", "status": {"result": "passed", "runtime": 0.00034046173095703125, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        leftDepth = self.getDepth(root.left)\n        rightDepth = self.getDepth(root.right)\n        if leftDepth == rightDepth:\n            return pow(2, leftDepth) + self.countNodes(root.right)\n        else:\n            return pow(2, rightDepth) + self.countNodes(root.left)\n\n    def getDepth(self, root):\n        if not root:\n            return 0\n        return 1 + self.getDepth(root.left)\n\n# Time: O(log(n)^2)\n# Space: O(log(n))\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each node in the tree.\n# Space complexity: O(log(n))\n# The depth of the recursion tree is log(n).\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each node in the tree.\n# Space complexity: O(log(n))\n# The depth of the recursion tree is log(n).\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each node in the tree.\n# Space complexity: O(log(n))\n# The depth of the recursion tree is log(n).\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each node in the tree.\n# Space complexity: O(log(n))\n# The depth of the recursion tree is log(n).\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each node in the tree.\n# Space complexity: O(log(n))\n# The depth of the recursion tree is log(n).\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each node in the tree.\n# Space complexity: O(log(n))\n# The depth of the recursion tree is log(n).\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each node in the tree.\n# Space complexity: O(log(n))\n# The depth of the recursion tree is log(n).\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each node in the tree.\n# Space complexity: O(log(n))\n# The depth of the recursion tree is log(n).\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each node in the tree.\n# Space complexity: O(log(n))\n# The depth of the recursion tree is log(n).\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each node in the tree.\n# Space complexity: O(log(n))\n# The depth of the recursion tree is log(n).\n\n# Time complexity: O(log(n)^2)\n# The depth of a complete binary tree is log(n). The getDepth function is called once for each node in the tree. The countNodes function is called once for each", "runtimes": [0.00032520294189453125, 0.00032591819763183594, 0.00032830238342285156, 0.00032830238342285156, 0.00032830238342285156, 0.00032901763916015625, 0.0003299713134765625, 0.0003304481506347656, 0.0003325939178466797, 0.0003330707550048828, 0.00033354759216308594, 0.0003387928009033203, 0.000339508056640625, 0.0003418922424316406, 0.0003428459167480469, 0.0003440380096435547, 0.00034618377685546875, 0.0003466606140136719, 0.000347137451171875, 0.0003521442413330078], "beyond_p": 0.4336283185840708}], "add-strings": [{"slug_name": "add-strings", "status": {"result": "passed", "runtime": 0.0021407604217529297, "index": 0}, "solution": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1, num2 = list(num1), list(num2)\n        carry, res = 0, []\n\n        while len(num2) > 0 or len(num1) > 0:\n            n1 = ord(num1.pop())-ord('0') if len(num1) > 0 else 0\n            n2 = ord(num2.pop())-ord('0') if len(num2) > 0 else 0\n            \n            temp = n1 + n2 + carry \n            res.append(temp % 10)\n            carry = temp // 10\n        if carry: res.append(carry)\n        return ''.join([str(i) for i in res])[::-1]", "runtimes": [0.0003426074981689453, 0.00034427642822265625, 0.0003452301025390625, 0.0016002655029296875, 0.0016429424285888672, 0.0016622543334960938, 0.0018618106842041016, 0.0018711090087890625, 0.0018990039825439453, 0.0019011497497558594, 0.002004861831665039, 0.0020287036895751953, 0.002052783966064453, 0.002177715301513672, 0.002218484878540039, 0.002397298812866211, 0.002631664276123047, 0.0035736560821533203], "beyond_p": 0.4434769775678867}], "basic-calculator": [{"slug_name": "basic-calculator", "status": {"result": "passed", "runtime": 0.00032901763916015625, "index": 0}, "solution": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        operand = 0\n        res = 0 \n        sign = 1\n\n        for ch in s:\n            if ch.isdigit():\n\n                operand = operand*10 + int(ch)\n\n            elif ch == '+':\n\n                res += sign * operand\n\n                sign = 1\n\n                operand = 0\n\n            elif ch == '-':\n\n                res += sign * operand\n                sign = -1\n                operand = 0\n\n            elif ch == '(':\n\n                stack.append(res)\n                stack.append(sign)\n\n                sign = 1\n                res = 0\n\n            elif ch == ')':\n\n                res += sign * operand\n\n                res *= stack.pop()\n\n                res += stack.pop()\n\n                operand = 0\n\n        return res + sign * operand", "runtimes": [0.00030994415283203125, 0.00031566619873046875, 0.00032329559326171875, 0.0003299713134765625, 0.00033020973205566406, 0.00034308433532714844, 0.0003457069396972656, 0.00035309791564941406, 0.0003666877746582031, 0.00037288665771484375, 0.00037860870361328125, 0.0003867149353027344, 0.00039458274841308594, 0.0004146099090576172, 0.00041985511779785156, 0.00043082237243652344, 0.0004458427429199219, 0.00045490264892578125, 0.0004584789276123047, 0.00047278404235839844, 0.0009055137634277344], "beyond_p": 0.9679743795036029}], "ipo": [{"slug_name": "ipo", "status": {"result": "passed", "runtime": 0.001495361328125, "index": 0}, "solution": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        projects = sorted(zip(profits, capital), key=lambda l: l[1])\n        import heapq\n        q = []\n        idx, n = 0, len(projects)\n        for _ in range(k):\n            while idx < n and projects[idx][1] <= w:\n                heapq.heappush(q, -projects[idx][0])\n                idx += 1\n            if q:\n                w -= heapq.heappop(q)\n            else:\n                break\n        return w", "runtimes": [0.0014557838439941406, 0.0014920234680175781, 0.0015289783477783203, 0.0015330314636230469, 0.0016014575958251953, 0.001714944839477539, 0.0017361640930175781, 0.0017502307891845703, 0.0017621517181396484, 0.0018277168273925781, 0.0018811225891113281, 0.0019066333770751953, 0.0019702911376953125, 0.0020155906677246094, 0.002137422561645508, 0.0025310516357421875, 0.002684354782104492, 0.003040790557861328, 0.004088401794433594, 0.0046539306640625, 0.005582571029663086, 0.01261281967163086], "beyond_p": 0.9964526882639542}], "valid-parentheses": [{"slug_name": "valid-parentheses", "status": {"result": "passed", "runtime": 0.0002734661102294922, "index": 0}, "solution": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack", "runtimes": [0.00026535987854003906, 0.0002665519714355469, 0.0002682209014892578, 0.0002696514129638672, 0.00026988983154296875, 0.00026988983154296875, 0.0002701282501220703, 0.0002715587615966797, 0.0002734661102294922, 0.0002739429473876953, 0.0002741813659667969, 0.0002758502960205078, 0.0002777576446533203, 0.0002789497375488281, 0.0002799034118652344, 0.0002818107604980469, 0.0002830028533935547, 0.0002849102020263672, 0.0002899169921875, 0.0003056526184082031, 0.0003566741943359375, 0.0003650188446044922, 0.0003657341003417969, 0.00039196014404296875, 0.0004210472106933594, 0.0004494190216064453, 0.00048613548278808594, 0.0006580352783203125, 0.0006649494171142578, 0.0006694793701171875, 0.0007383823394775391, 0.0018410682678222656, 0.001909494400024414], "beyond_p": 0.9950696055684455}], "next-permutation": [{"slug_name": "next-permutation", "status": {"result": "passed", "runtime": 0.0002639293670654297, "index": 0}, "solution": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        if i >= 0:\n            j = len(nums) - 1\n            while j > i and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        self.reverse(nums, i+1)\n    \n    def reverse(self, nums, start):\n        end = len(nums) - 1\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1", "runtimes": [0.0002646446228027344, 0.00026679039001464844, 0.00027179718017578125, 0.0002727508544921875, 0.0002741813659667969, 0.0002741813659667969, 0.00027441978454589844, 0.0002751350402832031, 0.0002791881561279297, 0.0002799034118652344, 0.00028061866760253906, 0.00028514862060546875, 0.00028514862060546875, 0.0002872943878173828, 0.0002880096435546875, 0.0002970695495605469, 0.0004367828369140625], "beyond_p": 1.0041551246537397}], "contains-duplicate-ii": [{"slug_name": "contains-duplicate-ii", "status": {"result": "passed", "runtime": 0.0004496574401855469, "index": 0}, "solution": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        dic = {}\n        for i, v in enumerate(nums):\n            if v in dic and i - dic[v] <= k:\n                return True\n            dic[v] = i\n        return False", "runtimes": [0.0003848075866699219, 0.00043082237243652344, 0.00043845176696777344, 0.0004394054412841797, 0.0004398822784423828, 0.0004405975341796875, 0.00044536590576171875, 0.0004470348358154297, 0.00044918060302734375, 0.0004520416259765625, 0.0004532337188720703, 0.0004658699035644531, 0.0004775524139404297, 0.0004987716674804688, 0.0005078315734863281, 0.0005092620849609375, 0.000537872314453125, 0.0006327629089355469, 0.0006964206695556641, 0.0006990432739257812, 0.0006997585296630859, 0.0007276535034179688], "beyond_p": 0.8108484005563282}], "maximum-gap": [{"slug_name": "maximum-gap", "status": {"result": "passed", "runtime": 0.0012142658233642578, "index": 0}, "solution": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff", "runtimes": [0.0007064342498779297, 0.0007841587066650391, 0.0008535385131835938, 0.0010867118835449219, 0.0011224746704101562, 0.001154184341430664, 0.0011622905731201172, 0.0019676685333251953, 0.0020453929901123047, 0.002115964889526367, 0.0025539398193359375, 0.0029439926147460938, 0.0029478073120117188, 0.0033257007598876953, 0.003438234329223633, 0.0035071372985839844, 0.003510713577270508, 0.003518819808959961, 0.005343198776245117, 0.006292104721069336, 0.006379127502441406, 0.006413936614990234, 0.007256031036376953, 0.007693767547607422, 0.01671457290649414], "beyond_p": 0.968276663241142}], "binary-tree-level-order-traversal": [{"slug_name": "binary-tree-level-order-traversal", "status": {"result": "passed", "runtime": 0.001373291015625, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        result = []\n        queue = [root]\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result\n\n# Time complexity: O(n), where n is the number of nodes in the tree.\n# Space complexity: O(n), where n is the number of nodes in the tree.\n\n# Test cases:\n# root = [3,9,20,null,null,15,7]\n# Output: [[3],[9,20],[15,7]]\n\n# root = [1]\n# Output: [[1]]\n\n# root = []\n# Output: []\n\n# root = [1,2,3,4,5]\n# Output: [[1],[2,3],[4,5]]\n\n# root = [3,9,20,null,null,15,7,1,2,3,4,5]\n# Output: [[3],[9,20],[15,7],[1,2,3,4,5]]\n\n# root = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n# Output: [[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15]]\n\n# root = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]\n# Output: [[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15],[16,17,18,19,20,21,22,23],[24,25,26,27,28,29,30,31]]\n\n# root = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]\n# Output: [[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15],[16,17,18,19,20,21,22,23],[24,25,26,27,28,29,30,31],[32,33,34,35,36,37,38,39,40,41,42,43,44", "runtimes": [0.0008854866027832031, 0.000888824462890625, 0.0009031295776367188, 0.0009052753448486328, 0.0009136199951171875, 0.0009577274322509766, 0.0009593963623046875, 0.001112222671508789, 0.001119375228881836, 0.0011310577392578125, 0.0011448860168457031, 0.003133058547973633, 0.004383563995361328], "beyond_p": 0.8605507088331515}], "couples-holding-hands": [{"slug_name": "couples-holding-hands", "status": {"result": "failed@cases", "runtime": 0.0004627704620361328, "index": 0}, "solution": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        N = len(row) // 2\n        parent = list(range(2*N))\n        rank = [0] * (2*N)\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            xr = find(x)\n            yr = find(y)\n            if rank[xr] < rank[yr]:\n                parent[xr] = yr\n            elif rank[xr] > rank[yr]:\n                parent[yr] = xr\n            else:\n                parent[yr] = xr\n                rank[xr] += 1\n        \n        for i in range(0, len(row), 2):\n            union(row[i], row[i+1])\n        \n        count = collections.Counter(find(x) for x in parent)\n        return sum(v // 2 - 1 for v in count.values())", "runtimes": [0.00027680397033691406, 0.00028896331787109375, 0.0003006458282470703, 0.00030732154846191406, 0.00033736228942871094, 0.0003521442413330078, 0.0003561973571777344, 0.00035953521728515625, 0.0003616809844970703, 0.0003719329833984375, 0.00037550926208496094, 0.0003838539123535156, 0.0003840923309326172, 0.00038886070251464844, 0.0004093647003173828, 0.0004107952117919922, 0.00045228004455566406, 0.0004525184631347656], "beyond_p": 0.0}], "interleaving-string": [{"slug_name": "interleaving-string", "status": {"result": "passed", "runtime": 0.0003097057342529297, "index": 0}, "solution": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        return dp[-1][-1]", "runtimes": [0.0002841949462890625, 0.0003001689910888672, 0.0003116130828857422, 0.0003256797790527344, 0.00033926963806152344, 0.0003581047058105469, 0.0003619194030761719, 0.00037169456481933594, 0.00037670135498046875, 0.00037741661071777344, 0.0003795623779296875, 0.00038695335388183594, 0.00039458274841308594, 0.0003948211669921875, 0.0003972053527832031, 0.0004024505615234375, 0.0004076957702636719, 0.0004124641418457031, 0.00041484832763671875, 0.0004184246063232422, 0.0004506111145019531, 0.0005071163177490234], "beyond_p": 0.8855614973262033}], "assign-cookies": [{"slug_name": "assign-cookies", "status": {"result": "passed", "runtime": 0.0006103515625, "index": 0}, "solution": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = len(g) - 1\n        j = len(s) - 1\n        res = 0\n        while min(i, j) >= 0:\n            if g[i] <= s[j]:\n                res += 1\n                j -= 1\n            i -= 1\n        return res", "runtimes": [0.00048160552978515625, 0.0005166530609130859, 0.0005199909210205078, 0.0005254745483398438, 0.0005481243133544922, 0.00061798095703125, 0.0006222724914550781, 0.0006535053253173828, 0.0006656646728515625, 0.0006687641143798828, 0.000701904296875, 0.0007231235504150391, 0.0007274150848388672, 0.0007417201995849609, 0.0007987022399902344, 0.0008094310760498047, 0.0008394718170166016, 0.0008487701416015625, 0.0008654594421386719, 0.0008943080902099609, 0.0009813308715820312, 0.0012445449829101562], "beyond_p": 0.83125}], "keyboard-row": [{"slug_name": "keyboard-row", "status": {"result": "passed", "runtime": 0.00038433074951171875, "index": 0}, "solution": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first_row = set('qwertyuiop')\n        second_row = set('asdfghjkl')\n        third_row = set('zxcvbnm')\n        result = []\n        for word in words:\n            w = set(word.lower())\n            if w.issubset(first_row) or w.issubset(second_row) or w.issubset(third_row):\n                result.append(word)\n        return result\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Test cases:\n# [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"] -> [\"Alaska\",\"Dad\"]\n# [\"omk\"] -> []\n# [\"adsdf\",\"sfd\"] -> [\"adsdf\",\"sfd\"]\n\n# Explanation:\n# The function findWords takes a list of words as input. It initializes three sets for each row of the keyboard. \n# Then it iterates over each word in the input list. For each word, it converts it to a set of lowercase characters. \n# If the set of characters is a subset of any of the three rows, it appends the word to the result list. \n# Finally, it returns the result list.\n\n# The time complexity is O(n) because it iterates over each word in the input list once. \n# The space complexity is also O(n) because it stores the result list and the sets of characters for each word.\n\n# The test cases check the function with a list of words that can be typed using only one row of the keyboard, \n# a list of words that cannot be typed using only one row of the keyboard, and a list of words that can be typed using multiple rows of the keyboard.\n\n# The function should return the words that can be typed using only one row of the keyboard.\n\n# The function uses the Python built-in set data structure to represent the characters in each row of the keyboard. \n# The issubset method of the set data structure is used to check if a word can be typed using only one row of the keyboard.\n\n# The function uses the lower method of the string data structure to convert the word to lowercase before converting it to a set of characters. \n# This ensures that the function can handle words that contain uppercase letters.\n\n# The function uses the append method of the list data structure to add words that can be typed using only one row of the keyboard to the result list. \n# This ensures that the function returns the words that can be typed using only one row of the keyboard.\n\n# The function uses the lower method of the string data structure to convert the word to lowercase before converting it to a set of characters. \n# This ensures that the function can handle words that contain uppercase letters.\n\n# The function uses the append method of the list data structure to add words that can be typed using only one row of the keyboard to the result list. \n# This ensures that the function returns the words that can be typed using only one row of the keyboard.\n\n# The function uses the lower method of the string data structure to convert the word to lowercase before converting it to a set of characters. \n# This ensures that the function can handle words that contain uppercase letters.\n\n# The function uses the append method of the list data structure to add words that can be typed using only one row of the keyboard to the result list. \n# This ensures that the function returns the words that can be typed using only one row of the keyboard.\n\n# The function uses the lower method of the string data structure to convert the word to lowercase before converting it to a set of characters. \n# This ensures that the function can handle words that contain uppercase letters.\n\n# The function uses the append method of the list data structure to add words that can be typed using only one row of the keyboard to the result list. \n# This ensures that the function returns the words that can be typed using only one row of the keyboard.\n\n# The function uses the lower method of the string data structure to convert the word to lowercase before converting it to a set of characters. \n# This ensures that the function can handle words that contain uppercase letters.\n\n# The function uses the append method of the list data structure to add words that can be typed using only one row of the keyboard to the result list. \n# This ensures that the function returns the words that can be typed using only one row of the keyboard.\n\n# The function uses the lower method of the string data structure to convert the word to lowercase before converting it to a set of characters.", "runtimes": [0.0003216266632080078, 0.0003247261047363281, 0.00033664703369140625, 0.00036644935607910156, 0.0003859996795654297, 0.0003879070281982422, 0.0004210472106933594, 0.0005207061767578125, 0.0005307197570800781, 0.0005726814270019531, 0.0006039142608642578, 0.0006175041198730469, 0.0009791851043701172], "beyond_p": 0.9046410442349528}], "reverse-linked-list-ii": [{"slug_name": "reverse-linked-list-ii", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        for i in range(left - 1):\n            prev = prev.next\n            \n        curr = prev.next\n        reverse = None\n        for i in range(right - left + 1):\n            next = curr.next\n            curr.next = reverse\n            reverse = curr\n            curr = next\n            \n        prev.next.next = curr\n        prev.next = reverse\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        for i in range(left - 1):\n            prev = prev.next\n            \n        curr = prev.next\n        reverse = None\n        for i in range(right - left + 1):\n            next = curr.next\n            curr.next = reverse\n            reverse = curr\n            curr = next\n            \n        prev.next.next = curr\n        prev.next = reverse\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        for i in range(left - 1):\n            prev = prev.next\n            \n        curr = prev.next\n        reverse = None\n        for i in range(right - left + 1):\n            next = curr.next\n            curr.next = reverse\n            reverse = curr\n            curr = next\n            \n        prev.next.next = curr\n        prev.next = reverse\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        for i in range(left - 1):\n            prev = prev.next\n            \n        curr = prev.next\n        reverse = None\n        for i in range(right - left + 1):\n            next = curr.next\n            curr.next = reverse\n            reverse = curr\n            curr = next\n            \n        prev.next.next = curr\n        prev.next = reverse\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        if not head", "runtimes": [0.0012965202331542969, 0.0013279914855957031, 0.0013477802276611328, 0.0013501644134521484, 0.0013532638549804688, 0.0013861656188964844, 0.0014011859893798828, 0.0014119148254394531, 0.0015408992767333984, 0.0015795230865478516, 0.0016489028930664062, 0.0016820430755615234, 0.0017139911651611328, 0.0017292499542236328, 0.0021517276763916016, 0.0022161006927490234], "beyond_p": 0.0}], "shortest-palindrome": [{"slug_name": "shortest-palindrome", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        if not s or len(s) == 1:\n            return s\n        \n        r = s[::-1]\n        for i in range(len(s), -1, -1):\n            if s.startswith(r[i:]):\n                return r[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        rev_s = s[::-1]\n        for i in range(n):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        rev_s = s[::-1]\n        for i in range(n + 1):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        rev_s = s[::-1]\n        for i in range(n + 1):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        rev_s = s[::-1]\n        for i in range(n + 1):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        rev_s = s[::-1]\n        for i in range(n + 1):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        rev_s = s[::-1]\n        for i in range(n + 1):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        rev_s = s[::-1]\n        for i in range(n + 1):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        rev_s = s[::-1]\n        for i in range(n + 1):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        rev_s = s[::-1]\n        for i in range(n + 1):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = len(s)\n        rev_s = s[::-1]\n        for i in range(n + 1):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s\n\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n =", "runtimes": [0.0003561973571777344, 0.0003681182861328125, 0.0003688335418701172, 0.0003902912139892578, 0.0007309913635253906, 0.0007688999176025391, 0.0008130073547363281, 0.0008232593536376953, 0.0008382797241210938, 0.0008449554443359375, 0.0008502006530761719, 0.0008890628814697266, 0.0009083747863769531, 0.0012705326080322266, 0.0014531612396240234, 0.0016927719116210938, 0.0019741058349609375, 0.0020008087158203125, 0.0020694732666015625], "beyond_p": 0.0}], "minimum-window-substring": [{"slug_name": "minimum-window-substring", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if not t or not s:\n            return \"\"\n        dict_t = Counter(t)\n        required = len(dict_t)\n        l, r = 0, 0\n        formed = 0\n        window_counts = {}\n        ans = float('inf'), None, None\n        while r < len(s):\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n            while l <= r and formed == required:\n                character = s[l]\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n                l += 1    \n            r += 1    \n        return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]", "runtimes": [0.0005567073822021484, 0.0005972385406494141, 0.0006816387176513672, 0.000698089599609375, 0.0007865428924560547, 0.0009224414825439453, 0.0009367465972900391, 0.0009777545928955078, 0.0009794235229492188, 0.0012111663818359375, 0.0012810230255126953, 0.0023801326751708984, 0.002432584762573242], "beyond_p": 0.0}], "self-crossing": [{"slug_name": "self-crossing", "status": {"result": "passed", "runtime": 0.0002880096435546875, "index": 0}, "solution": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) < 4:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i - 1] == distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2]:\n                return True\n            if i >= 5 and distance[i - 2] >= distance[i - 4] and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] + distance[i - 5] >= distance[i - 3] and distance[i - 1] <= distance[i - 3]:\n                return True\n        return False", "runtimes": [0.00028705596923828125, 0.0002875328063964844, 0.0002913475036621094, 0.0002918243408203125, 0.00031447410583496094, 0.0003407001495361328, 0.0003542900085449219, 0.0003592967987060547, 0.00036787986755371094, 0.0003771781921386719, 0.0003829002380371094, 0.0004267692565917969, 0.0004487037658691406, 0.00045752525329589844, 0.0004858970642089844, 0.00049591064453125], "beyond_p": 0.9954337899543378}], "remove-duplicates-from-sorted-list": [{"slug_name": "remove-duplicates-from-sorted-list", "status": {"result": "passed", "runtime": 0.0005800724029541016, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None:\n            return head\n        \n        curr = head\n        while curr.next:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\n# Explanation:\n# We iterate through the linked list and check if the current node's value is equal to the next node's value. If it is, we skip the next node by setting the current node's next to the next node's next. If it's not, we move to the next node. We do this until we reach the end of the list.\n# We return the head of the list.\n\n# Test:\n# Input: [1,1,2]\n# Output: [1,2]\n# Input: [1,1,2,3,3]\n# Output: [1,2,3]\n# Input: []\n# Output: []\n# Input: [1]\n# Output: [1]\n# Input: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", "runtimes": [0.0005273818969726562, 0.0005385875701904297, 0.0005519390106201172, 0.0005550384521484375, 0.00055694580078125, 0.0005624294281005859, 0.0005674362182617188, 0.0005695819854736328, 0.0005712509155273438, 0.00057220458984375, 0.0005724430084228516, 0.0005791187286376953, 0.0005826950073242188, 0.0005855560302734375, 0.0005884170532226562, 0.0005888938903808594, 0.000591278076171875, 0.0005946159362792969, 0.0005981922149658203], "beyond_p": 0.2558922558922559}], "longest-palindrome": [{"slug_name": "longest-palindrome", "status": {"result": "passed", "runtime": 0.0004260540008544922, "index": 0}, "solution": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = collections.Counter(s)\n        ans = 0\n        for v in count.values():\n            ans += v // 2 * 2\n            if ans % 2 == 0 and v % 2 == 1:\n                ans += 1\n        return ans", "runtimes": [0.0004267692565917969, 0.00047898292541503906, 0.0005052089691162109, 0.0005130767822265625, 0.0005133152008056641, 0.0005154609680175781, 0.0005385875701904297, 0.0005400180816650391, 0.001123666763305664, 0.0023615360260009766], "beyond_p": 1.000369685767098}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"slug_name": "construct-binary-tree-from-inorder-and-postorder-traversal", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if inorder:\n            root = TreeNode(postorder.pop())\n            index = inorder.index(root.val)\n            root.right = self.buildTree(inorder[index+1:], postorder)\n            root.left = self.buildTree(inorder[:index], postorder)\n            return root\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        map_inorder = {}\n        for i, val in enumerate(inorder): map_inorder[val] = i\n        def recur(low, high):\n            if low > high: return None\n            x = TreeNode(postorder.pop())\n            mid = map_inorder[x.val]\n            x.right = recur(mid+1, high)\n            x.left = recur(low, mid-1)\n            return x\n        return recur(0, len(inorder) - 1)\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        map_inorder = {}\n        for i, val in enumerate(inorder): map_inorder[val] = i\n        def recur(low, high):\n            if low > high: return None\n            x = TreeNode(postorder.pop())\n            mid = map_inorder[x.val]\n            x.right = recur(mid+1, high)\n            x.left = recur(low, mid-1)\n            return x\n        return recur(0, len(inorder) - 1)\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        map_inorder = {}\n        for i, val in enumerate(inorder): map_inorder[val] = i\n        def recur(low, high):\n            if low > high: return None\n            x = TreeNode(postorder.pop())\n            mid = map_inorder[x.val]\n            x.right = recur(mid+1, high)\n            x.left = recur(low, mid-1)\n            return x\n        return recur(0, len(inorder) - 1)\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        map_inorder = {}\n        for i, val in enumerate(inorder): map_inorder[val] = i\n        def recur(low, high):\n            if low > high: return None\n            x = TreeNode(postorder.pop())\n            mid = map_inorder[x.val]\n            x.right = recur(mid+1, high)\n            x.left = recur(low, mid-1)\n            return x\n        return recur(0, len(inorder) - 1)\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        map_inorder = {}\n        for i, val in enumerate(inorder): map_inorder[val] = i\n        def recur(low, high):\n            if low > high", "runtimes": [0.0032165050506591797, 0.0032286643981933594, 0.0033512115478515625, 0.003367900848388672, 0.0033681392669677734, 0.003388643264770508, 0.003404378890991211, 0.0034160614013671875, 0.0034682750701904297, 0.003468751907348633, 0.0035219192504882812, 0.003522634506225586, 0.003538846969604492, 0.0035567283630371094, 0.0035614967346191406, 0.0035698413848876953, 0.003572225570678711, 0.003584623336791992, 0.0036537647247314453, 0.003662109375, 0.0036704540252685547, 0.003703594207763672, 0.003960371017456055, 0.0039653778076171875, 0.004174947738647461], "beyond_p": 0.0}], "cut-off-trees-for-golf-event": [{"slug_name": "cut-off-trees-for-golf-event", "status": {"result": "passed", "runtime": 3.752267360687256, "index": 0}, "solution": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(forest, sr, sc, tr, tc):\n            R, C = len(forest), len(forest[0])\n            queue = collections.deque([(sr, sc, 0)])\n            seen = {(sr, sc)}\n            while queue:\n                r, c, d = queue.popleft()\n                if r == tr and c == tc:\n                    return d\n                for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n                    if (0 <= nr < R and 0 <= nc < C and\n                            (nr, nc) not in seen and forest[nr][nc] != 0):\n                        seen.add((nr, nc))\n                        queue.append((nr, nc, d+1))\n            return -1\n\n        trees = sorted((v, r, c) for r, row in enumerate(forest)\n                       for c, v in enumerate(row) if v > 1)\n        sr = sc = ans = 0\n        for _, tr, tc in trees:\n            d = bfs(forest, sr, sc, tr, tc)\n            if d < 0: return -1\n            ans += d\n            sr, sc = tr, tc\n        return ans", "runtimes": [0.11515212059020996, 0.11848640441894531, 0.14174699783325195, 1.0966639518737793, 2.9570956230163574, 3.2738094329833984, 3.564945936203003, 4.073241710662842, 4.165130138397217, 4.4926135540008545, 4.756714105606079, 5.088177919387817, 5.11055850982666, 5.1633899211883545, 5.945672988891602], "beyond_p": 0.17151126333097758}], "minimum-depth-of-binary-tree": [{"slug_name": "minimum-depth-of-binary-tree", "status": {"result": "failed@cases", "runtime": 0.00035643577575683594, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        if root.left is None:\n            return self.minDepth(root.right) + 1\n        if root.right is None:\n            return self.minDepth(root.left) + 1\n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# BFS\n\nfrom collections import deque\n\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        queue = deque([(root, 1)])\n        while queue:\n            node, depth = queue.popleft()\n            if not node.left and not node.right:\n                return depth\n            if node.left:\n                queue.append((node.left, depth + 1))\n            if node.right:\n                queue.append((node.right, depth + 1))\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# DFS\n\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        stack = [(root, 1)]\n        min_depth = float('inf')\n        while stack:\n            node, depth = stack.pop()\n            if not node.left and not node.right:\n                min_depth = min(min_depth, depth)\n            if node.left and depth < min_depth:\n                stack.append((node.left, depth + 1))\n            if node.right and depth < min_depth:\n                stack.append((node.right, depth + 1))\n        return min_depth\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# DFS with early stopping\n\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        stack = [(root, 1)]\n        min_depth = float('inf')\n        while stack:\n            node, depth = stack.pop()\n            if not node.left and not node.right:\n                min_depth = min(min_depth, depth)\n            if node.left and depth + 1 < min_depth:\n                stack.append((node.left, depth + 1))\n            if node.right and depth + 1 < min_depth:\n                stack.append((node.right, depth + 1))\n        return min_depth\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# DFS with early stopping and pruning\n\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        stack = [(root, 1)]\n        min_depth = float('inf')\n        while stack:\n            node, depth = stack.pop()\n            if not node.left and not node.right:\n                min_depth = min(min_depth, depth)\n            if node.right and depth + 1 < min_depth:\n                stack.append((node.right, depth + 1))\n            if node.left and depth + 1 < min_depth:\n                stack.append((node.left, depth + 1))\n        return min_depth\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# DFS with early stopping and pruning and no need to check if node is None\n\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        stack = [(root, 1)]\n        min_depth = float('inf')\n        while stack:\n            node, depth = stack.pop()\n            if not node.left and not node.right:\n                min_depth", "runtimes": [0.00036025047302246094, 0.0003631114959716797, 0.0003676414489746094, 0.0003688335418701172, 0.0003707408905029297, 0.00037288665771484375, 0.0003783702850341797, 0.0003783702850341797, 0.00038170814514160156, 0.0003917217254638672, 0.0003941059112548828, 0.0003998279571533203, 0.00042247772216796875, 0.0004246234893798828, 0.00044274330139160156, 0.0004506111145019531, 0.00045800209045410156, 0.0004582405090332031, 0.0004642009735107422, 0.0004703998565673828, 0.0004723072052001953, 0.0004932880401611328, 0.0005042552947998047, 0.0005052089691162109, 0.0005204677581787109, 0.0005223751068115234, 0.0005424022674560547, 0.0005695819854736328], "beyond_p": 0.0}], "count-of-range-sum": [{"slug_name": "count-of-range-sum", "status": {"result": "failed@cases", "runtime": 0.003284454345703125, "index": 0}, "solution": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def mergeSort(l, r):\n            if l == r:\n                return 0\n            else:\n                mid = (l + r) // 2\n                count = mergeSort(l, mid) + mergeSort(mid + 1, r)\n                i = j = mid + 1\n                for left in prefix[l:mid+1]:\n                    while i < j and prefix[j] - left < lower: j += 1\n                    while i < j and prefix[j] - left <= upper: i += 1\n                    count += i - j\n                prefix[l:j] = sorted(prefix[l:j])\n                return count\n\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n        return mergeSort(0, len(prefix) - 1)", "runtimes": [0.0019237995147705078, 0.003298521041870117, 0.0046041011810302734, 0.004687786102294922, 0.0047419071197509766, 0.0049741268157958984, 0.00696873664855957, 0.007229804992675781, 0.007441520690917969, 0.009090423583984375, 0.009418249130249023, 0.010324954986572266, 0.010803461074829102, 0.013576269149780273, 0.014340400695800781, 0.014793157577514648, 0.016200780868530273, 0.029654979705810547], "beyond_p": 0.0}], "arranging-coins": [{"slug_name": "arranging-coins", "status": {"result": "passed", "runtime": 0.00026035308837890625, "index": 0}, "solution": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((math.sqrt(8 * n + 1)-1)/2)\n\n# Time complexity: O(1)\n# Space complexity: O(1)\n\n# Solution 2: Binary Search\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, n\n        while left <= right:\n            k = (right + left) // 2\n            curr = k * (k + 1) // 2\n            if curr == n:\n                return k\n            if n < curr:\n                right = k - 1\n            else:\n                left = k + 1\n        return right\n\n# Time complexity: O(logn)\n# Space complexity: O(1)\n\n# Solution 3: Math\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return int((math.sqrt(8 * n + 1) - 1) / 2)\n\n# Time complexity: O(1)\n# Space complexity: O(1)\n\n# Solution 4: Iterative\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        i = 0\n        while n > i:\n            i += 1\n            n -= i\n        return i\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\n# Solution 5: Brute Force\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        i = 0\n        while n > i:\n            i += 1\n            n -= i\n        return i\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\n# Solution 6: Binary Search\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, n\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * (mid + 1) // 2 <= n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\n# Time complexity: O(logn)\n# Space complexity: O(1)\n\n# Solution 7: Math\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return int((math.sqrt(8 * n + 1) - 1) / 2)\n\n# Time complexity: O(1)\n# Space complexity: O(1)\n\n# Solution 8: Iterative\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        i = 0\n        while n > i:\n            i += 1\n            n -= i\n        return i\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\n# Solution 9: Brute Force\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        i = 0\n        while n > i:\n            i += 1\n            n -= i\n        return i\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\n# Solution 10: Binary Search\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, n\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * (mid + 1) // 2 <= n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\n# Time complexity: O(logn)\n# Space", "runtimes": [0.0002522468566894531, 0.00026535987854003906, 0.008836984634399414, 0.01236271858215332, 0.012381553649902344, 0.012493371963500977, 0.015627145767211914, 0.015833616256713867, 0.015909433364868164, 0.016448259353637695, 0.01841115951538086, 0.020224809646606445, 0.021172046661376953, 0.02127814292907715, 0.021727561950683594, 0.02288675308227539, 0.023766040802001953, 0.025730133056640625, 0.025852203369140625, 0.026427268981933594, 0.029210329055786133, 0.03509235382080078], "beyond_p": 0.9997673304591802}], "longest-uncommon-subsequence-i": [{"slug_name": "longest-uncommon-subsequence-i", "status": {"result": "passed", "runtime": 0.0002570152282714844, "index": 0}, "solution": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))", "runtimes": [0.0002532005310058594, 0.0002543926239013672, 0.00025463104248046875, 0.0002589225769042969, 0.0002598762512207031, 0.00026345252990722656, 0.00026488304138183594, 0.0002658367156982422, 0.0002658367156982422, 0.00026679039001464844], "beyond_p": 0.7192982456140351}], "binary-tree-level-order-traversal-ii": [{"slug_name": "binary-tree-level-order-traversal-ii", "status": {"result": "passed", "runtime": 0.0005362033843994141, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result[::-1]\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'[1]), and explores all of the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.\n# In this problem, we use a queue to store the nodes of each level. We pop the first node from the queue and add its value to the current level. Then we add its left and right children to the queue. We repeat this process until the queue is empty. At the end, we reverse the result list to get the bottom-up level order traversal.\n# The time complexity is O(n) because we visit each node once. The space complexity is O(n) because in the worst case, the queue will contain all nodes in the last level of the tree.\n\n# Test:\n# root = [3,9,20,null,null,15,7]\n# Output: [[15,7],[9,20],[3]]\n# root = [1]\n# Output: [[1]]\n# root = []\n# Output: []\n\n# Path: Binary Tree Level Order Traversal II.py\n# Compare this snippet from Binary Tree Level Order Traversal II.py:\n# The code is almost the same as the previous one, the only difference is that we append the level to the result list at the beginning instead of at the end. This way, the result list will be reversed at the end, so we get the bottom-up level order traversal.\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'[1]), and explores all of the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.\n# In this problem, we use a queue to store the nodes of each level. We pop the first node from the queue and add its value to the current level. Then we add its left and right children to the queue. We repeat this process until the queue is empty. At the end, we reverse the result list to get the bottom-up level order traversal.\n# The time complexity is O(n) because we visit each node once. The space complexity is O(n) because in the worst case, the queue will contain all nodes in the last level of the tree.\n\n# Test:\n# root = [3,9,20,null,null,15,7]\n# Output: [[15,7],[9,20],[3]]\n# root = [1]\n# Output: [[1]]\n# root = []\n# Output: []\n\n# Path: Binary Tree Level Order Traversal II.py\n# Compare this snippet from Binary Tree Level Order Traversal II.py:\n# The code is almost the same as the previous one, the only difference is that we append the level to the result list at the beginning instead of at the end. This way, the result list will be reversed at the end, so we get the bottom-up level order traversal.\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'[1]), and explores all of the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.\n# In this problem, we use a queue to store the nodes of each level. We pop the first node from the queue and", "runtimes": [0.00047278404235839844, 0.0004916191101074219, 0.0005002021789550781, 0.0005083084106445312, 0.0005211830139160156, 0.0005235671997070312, 0.0005867481231689453, 0.0006272792816162109, 0.0006458759307861328, 0.0007736682891845703, 0.0018031597137451172], "beyond_p": 0.9523297491039426}], "palindrome-number": [{"slug_name": "palindrome-number", "status": {"result": "passed", "runtime": 0.00027942657470703125, "index": 0}, "solution": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        x_str = str(x)\n        return x_str == x_str[::-1]", "runtimes": [0.00026345252990722656, 0.0002651214599609375, 0.0002663135528564453, 0.00027060508728027344, 0.00027108192443847656, 0.00027108192443847656, 0.00027298927307128906, 0.00027298927307128906, 0.0002772808074951172, 0.0002777576446533203, 0.0002779960632324219, 0.0002808570861816406, 0.0002970695495605469, 0.0002980232238769531, 0.0003037452697753906, 0.0003323554992675781, 0.0003333091735839844, 0.000347137451171875, 0.0003476142883300781, 0.00035071372985839844], "beyond_p": 0.8169398907103825}], "decode-ways": [{"slug_name": "decode-ways", "status": {"result": "passed", "runtime": 0.00040078163146972656, "index": 0}, "solution": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n\n        dp = [0 for x in range(len(s) + 1)]\n\n        dp[0] = 1 \n\n        dp[1] = 0 if s[0] == '0' else 1\n\n        for i in range(2, len(s) + 1):\n            if s[i-1] != '0':\n                dp[i] += dp[i - 1]\n\n            two_digit = int(s[i-2:i])\n            if two_digit >= 10 and two_digit <= 26:\n                dp[i] += dp[i - 2]\n\n        return dp[len(s)]", "runtimes": [0.0002815723419189453, 0.00030112266540527344, 0.00032258033752441406, 0.00032830238342285156, 0.0003609657287597656, 0.00036263465881347656, 0.0003643035888671875, 0.0003764629364013672, 0.0003826618194580078, 0.00038623809814453125, 0.0003917217254638672, 0.0003974437713623047, 0.00040078163146972656, 0.0004968643188476562, 0.0005245208740234375], "beyond_p": 0.5093228655544652}], "is-subsequence": [{"slug_name": "is-subsequence", "status": {"result": "passed", "runtime": 0.0019583702087402344, "index": 0}, "solution": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) > len(t):\n            return False\n        if len(s) == 0:\n            return True\n        subsequence = 0\n        for i in range(0, len(t)):\n            if subsequence <= len(s) - 1:\n                if s[subsequence] == t[i]:\n                    subsequence += 1\n        return subsequence == len(s)", "runtimes": [0.0006175041198730469, 0.0008115768432617188, 0.0008213520050048828, 0.0011434555053710938, 0.0013115406036376953, 0.0013141632080078125, 0.0013279914855957031, 0.0013492107391357422, 0.0013580322265625, 0.0013632774353027344, 0.0013811588287353516, 0.0013813972473144531, 0.0013816356658935547, 0.0013821125030517578, 0.0013947486877441406, 0.008863449096679688, 0.28635311126708984, 0.81172776222229], "beyond_p": 0.9983468756861685}], "gray-code": [{"slug_name": "gray-code", "status": {"result": "passed", "runtime": 0.0003275871276855469, "index": 0}, "solution": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        return [i ^ (i >> 1) for i in range(2 ** n)]", "runtimes": [0.00030040740966796875, 0.0003066062927246094, 0.00032210350036621094, 0.0003249645233154297, 0.00032782554626464844, 0.0003306865692138672, 0.00036334991455078125, 0.0003662109375, 0.0003693103790283203, 0.00048065185546875, 0.0009849071502685547, 0.0010912418365478516, 0.001256704330444336, 0.0012781620025634766, 0.0015649795532226562, 0.001950979232788086, 0.0024385452270507812], "beyond_p": 0.9872881355932204}], "climbing-stairs": [{"slug_name": "climbing-stairs", "status": {"result": "passed", "runtime": 0.0002512931823730469, "index": 0}, "solution": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n            \n        return dp[n]", "runtimes": [0.0002396106719970703, 0.000240325927734375, 0.0002415180206298828, 0.00024366378784179688, 0.0002505779266357422, 0.00025153160095214844, 0.00025534629821777344, 0.0002715587615966797, 0.0002887248992919922, 0.00030684471130371094, 0.0003228187561035156, 0.0003333091735839844], "beyond_p": 0.8753180661577609}], "word-break": [{"slug_name": "word-break", "status": {"result": "passed", "runtime": 0.034644365310668945, "index": 0}, "solution": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for word in wordDict:\n                if dp[i - len(word)] and s[:i].endswith(word):\n                    dp[i] = True\n        return dp[-1]", "runtimes": [0.0007188320159912109, 0.0009179115295410156, 0.0012502670288085938, 0.001279592514038086, 0.0013415813446044922, 0.0013947486877441406, 0.002131938934326172, 0.002195596694946289, 0.0022733211517333984, 0.002676248550415039, 0.0031092166900634766, 0.003975391387939453, 0.01855015754699707, 0.018979549407958984, 0.07368850708007812, 0.09204912185668945, 0.13971805572509766], "beyond_p": 0.7559300520578726}], "validate-binary-search-tree": [{"slug_name": "validate-binary-search-tree", "status": {"result": "passed", "runtime": 0.00037741661071777344, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower = float('-inf'), upper = float('inf')):\n            if not node:\n                return True\n            \n            val = node.val\n            if val <= lower or val >= upper:\n                return False\n\n            if not helper(node.right, val, upper):\n                return False\n            if not helper(node.left, lower, val):\n                return False\n            return True\n\n        return helper(root)\n\n# Time complexity: O(N)\n# Space complexity: O(N)\n\n# Test cases:\n# [2,1,3] -> True\n# [5,1,4,null,null,3,6] -> False\n# [1,1] -> False\n# [0,-1] -> True\n# [5,4,6,null,null,3,7] -> False\n# [3,1,5,0,2,4,6] -> True\n# [3,7,15,null,null,9,20,null,null,17] -> True\n# [10,5,15,null,null,6,20] -> False\n# [0] -> True\n# [1,1] -> False\n# [1,null,1] -> False\n# [10,5,15,null,null,15,20] -> False\n# [0,-1,null,-2,-3] -> False\n# [3,null,30,10,null,null,15,null,45] -> False\n# [1,1] -> False\n# [2,2,2] -> False\n# [5,1,4,null,null,3,6] -> False\n# [0,null,-1] -> False\n# [3,1,5,0,2,null,6] -> False\n# [1,1] -> False\n# [2147483647] -> True\n# [-2147483648,null,2147483647] -> True\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,2147483647] -> False\n# [2147483647,21474", "runtimes": [0.00034689903259277344, 0.0003533363342285156, 0.00035643577575683594, 0.00035881996154785156, 0.0003600120544433594, 0.0003628730773925781, 0.0003647804260253906, 0.0003662109375, 0.0003693103790283203, 0.0003707408905029297, 0.0003707408905029297, 0.0003745555877685547, 0.0003802776336669922, 0.00038433074951171875, 0.0003898143768310547, 0.0003974437713623047, 0.0003979206085205078], "beyond_p": 0.40186915887850466}], "insert-interval": [{"slug_name": "insert-interval", "status": {"result": "passed", "runtime": 0.0002570152282714844, "index": 0}, "solution": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        result = []\n        i = 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval = [min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])]\n            i += 1\n        result.append(newInterval)\n        while i < len(intervals):\n            result.append(intervals[i])\n            i += 1\n        return result", "runtimes": [0.0002510547637939453, 0.0002529621124267578, 0.00025391578674316406, 0.00025653839111328125, 0.0002567768096923828, 0.00025773048400878906, 0.0002586841583251953, 0.0002589225769042969, 0.0002598762512207031, 0.00026035308837890625, 0.0002608299255371094, 0.0002624988555908203, 0.000263214111328125, 0.0002636909484863281, 0.0002644062042236328, 0.0002646446228027344, 0.00026607513427734375, 0.0002665519714355469, 0.00026679039001464844, 0.00026869773864746094, 0.00027298927307128906, 0.0002770423889160156, 0.00029754638671875, 0.0003304481506347656], "beyond_p": 0.924924924924925}], "palindrome-partitioning": [{"slug_name": "palindrome-partitioning", "status": {"result": "passed", "runtime": 0.0003490447998046875, "index": 0}, "solution": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_palindrome(check):\n            return check == check[::-1]\n\n        def dfs(start, path):\n            if start >= len(s):\n                result.append(path)\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    dfs(end, path + [s[start:end]])\n\n        result = []\n        dfs(0, [])\n        return result", "runtimes": [0.00033545494079589844, 0.00033783912658691406, 0.0003414154052734375, 0.0003464221954345703, 0.0003521442413330078, 0.00036025047302246094, 0.0003650188446044922, 0.00036978721618652344, 0.00037479400634765625, 0.0003781318664550781, 0.0003783702850341797, 0.00038123130798339844, 0.00038886070251464844, 0.0003898143768310547, 0.00039386749267578125, 0.00039458274841308594, 0.0004162788391113281, 0.0004177093505859375, 0.0004265308380126953, 0.00043845176696777344, 0.0004546642303466797, 0.0005104541778564453, 0.0006306171417236328, 0.0006430149078369141, 0.001329183578491211, 0.0421600341796875, 0.0701591968536377, 0.07100391387939453, 0.23969697952270508], "beyond_p": 0.999943224546917}], "smallest-range-covering-elements-from-k-lists": [{"slug_name": "smallest-range-covering-elements-from-k-lists", "status": {"result": "failed@cases", "runtime": 0.0010612010955810547, "index": 0}, "solution": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        heap = [(row[0], i, 0) for i, row in enumerate(nums)]\n        heapq.heapify(heap)\n        \n        ans = -1e9, 1e9\n        \n        right = max(row[0] for row in nums)\n        while heap:\n            left, r, c = heapq.heappop(heap)\n            if right - left < ans[1] - ans[0]:\n                ans = left, right\n            if c + 1 == len(nums[r]):\n                return ans\n            v = nums[r][c+1]\n            right = max(right, v)\n            heapq.heappush(heap, (v, r, c+1))", "runtimes": [0.0010783672332763672, 0.0010831356048583984, 0.0010838508605957031, 0.0010898113250732422, 0.0010912418365478516, 0.0011060237884521484, 0.001111745834350586, 0.0011591911315917969, 0.0011897087097167969, 0.0013751983642578125, 0.002191305160522461, 0.002796649932861328, 0.002984285354614258, 0.003252744674682617, 0.00390625, 0.008615493774414062, 0.008677005767822266, 0.014223814010620117], "beyond_p": 0.0}], "poor-pigs": [{"slug_name": "poor-pigs", "status": {"result": "failed@cases", "runtime": 0.0002727508544921875, "index": 0}, "solution": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        pigs = 0\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\n            pigs += 1\n        return pigs", "runtimes": [0.00023126602172851562, 0.00023412704467773438, 0.0002346038818359375, 0.00023698806762695312, 0.00023746490478515625, 0.00024199485778808594, 0.00024580955505371094, 0.00025200843811035156, 0.0002562999725341797, 0.0002593994140625, 0.0002777576446533203, 0.00030350685119628906, 0.0003921985626220703], "beyond_p": 0.0}], "swim-in-rising-water": [{"slug_name": "swim-in-rising-water", "status": {"result": "passed", "runtime": 0.0021810531616210938, "index": 0}, "solution": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        N = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        seen = set([(0, 0)])\n        ans = 0\n        while pq:\n            T, x, y = heapq.heappop(pq)\n            ans = max(ans, T)\n            if x == y == N-1: return ans\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in seen:\n                    heapq.heappush(pq, (grid[nx][ny], nx, ny))\n                    seen.add((nx, ny))", "runtimes": [0.0019397735595703125, 0.0021448135375976562, 0.002334117889404297, 0.002565622329711914, 0.0033164024353027344, 0.003744840621948242, 0.00414729118347168, 0.004235744476318359, 0.004309654235839844, 0.004763603210449219, 0.0047800540924072266, 0.004973888397216797, 0.005010843276977539, 0.0054035186767578125, 0.0055694580078125, 0.0076999664306640625, 0.0077092647552490234, 0.007972478866577148, 0.010071992874145508, 0.010898113250732422], "beyond_p": 0.9730664821419066}], "unique-paths": [{"slug_name": "unique-paths", "status": {"result": "passed", "runtime": 0.00042128562927246094, "index": 0}, "solution": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for i in range(n):\n            dp[0][i] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[-1][-1]", "runtimes": [0.0002474784851074219, 0.0003116130828857422, 0.00033855438232421875, 0.0003542900085449219, 0.0003578662872314453, 0.0003685951232910156, 0.00039076805114746094, 0.0004131793975830078, 0.0004532337188720703, 0.00045609474182128906, 0.000469207763671875, 0.00048232078552246094, 0.0004858970642089844, 0.0005152225494384766, 0.0005280971527099609, 0.0006165504455566406, 0.0007190704345703125], "beyond_p": 0.6314459049544995}], "multiply-strings": [{"slug_name": "multiply-strings", "status": {"result": "passed", "runtime": 0.0007386207580566406, "index": 0}, "solution": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        def strToInt(s):\n            num = 0\n            for ch in s:\n                num = num * 10 + (ord(ch) - ord('0'))\n            return num\n        \n        def intToStr(num):\n            s = \"\"\n            while num:\n                s = chr(num % 10 + ord('0')) + s\n                num //= 10\n            return s\n        \n        return intToStr(strToInt(num1) * strToInt(num2))", "runtimes": [0.00025844573974609375, 0.0002620220184326172, 0.00026416778564453125, 0.0003027915954589844, 0.0004363059997558594, 0.0007884502410888672, 0.008516788482666016, 0.00942850112915039, 0.010069847106933594, 0.010094881057739258, 0.010107994079589844, 0.010253429412841797, 0.0103759765625, 0.011254310607910156, 0.011352777481079102, 0.011839628219604492, 0.011851072311401367, 0.013046741485595703, 0.01307368278503418, 0.01540064811706543, 0.016615867614746094, 0.02055048942565918, 0.027616024017333984, 0.030517578125], "beyond_p": 0.9841312364083331}], "best-time-to-buy-and-sell-stock-iii": [{"slug_name": "best-time-to-buy-and-sell-stock-iii", "status": {"result": "passed", "runtime": 0.004024505615234375, "index": 0}, "solution": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        n = len(prices)\n        dp = [[0]*5 for _ in range(n)]\n        dp[0][1], dp[0][3] = -prices[0], -prices[0]\n        for i in range(1, n):\n            dp[i][0] = dp[i-1][0]\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])\n            dp[i][2] = max(dp[i-1][2], dp[i-1][1]+prices[i])\n            dp[i][3] = max(dp[i-1][3], dp[i-1][2]-prices[i])\n            dp[i][4] = max(dp[i-1][4], dp[i-1][3]+prices[i])\n        return max(dp[-1])", "runtimes": [0.0007991790771484375, 0.00101470947265625, 0.0022110939025878906, 0.002330780029296875, 0.0024776458740234375, 0.002974271774291992, 0.003136873245239258, 0.003294706344604492, 0.003401041030883789, 0.003605365753173828, 0.00382232666015625, 0.0039937496185302734, 0.0047833919525146484, 0.005762338638305664, 0.006050825119018555, 0.006242513656616211, 0.006339311599731445, 0.007639169692993164, 0.008200645446777344, 0.008253812789916992, 0.008275032043457031, 0.008461713790893555, 0.008762836456298828, 0.008985757827758789, 0.009161710739135742, 0.009448528289794922, 0.010633707046508789, 0.01081228256225586, 0.010881185531616211, 0.012920141220092773], "beyond_p": 0.7339050728771219}], "combination-sum-ii": [{"slug_name": "combination-sum-ii", "status": {"result": "passed", "runtime": 0.0019834041595458984, "index": 0}, "solution": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(nums, target, index, path, res):\n            if target < 0:\n                return \n            if target == 0:\n                res.append(path)\n                return \n            for i in range(index, len(nums)):\n                if i > index and nums[i] == nums[i-1]:\n                    continue\n                dfs(nums, target-nums[i], i+1, path+[nums[i]], res)\n        \n        candidates.sort()\n        res = []\n        dfs(candidates, target, 0, [], res)\n        return res\n    \n\nif __name__ == \"__main__\":\n    print(Solution().combinationSum2([10,1,2,7,6,1,5], 8))\n    print(Solution().combinationSum2([2,5,2,1,2], 5))", "runtimes": [0.0004248619079589844, 0.0004482269287109375, 0.000507354736328125, 0.0011696815490722656, 0.0012602806091308594, 0.0014748573303222656, 0.0017802715301513672, 0.0018677711486816406, 0.0020492076873779297, 0.002150297164916992, 0.002152681350708008, 0.0022552013397216797, 0.003328561782836914, 0.003937244415283203, 0.004259347915649414, 0.005526065826416016, 0.005887508392333984], "beyond_p": 0.7146909916201117}], "detect-capital": [{"slug_name": "detect-capital", "status": {"result": "passed", "runtime": 0.0002484321594238281, "index": 0}, "solution": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\n# Test cases:\n# \"USA\" -> True\n# \"FlaG\" -> False\n# \"Google\" -> True\n# \"leetcode\" -> True\n# \"Python\" -> True\n# \"python\" -> True\n# \"PYTHON\" -> True\n# \"pYtHoN\" -> False\n# \"PyThOn\" -> False\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"pYTHON\" -> False\n# \"PYTHON\" -> True\n# \"p", "runtimes": [0.00023818016052246094, 0.0002415180206298828, 0.00024175643920898438, 0.00024318695068359375, 0.0002434253692626953, 0.00024390220642089844, 0.0002484321594238281, 0.0002541542053222656, 0.00025653839111328125, 0.0002627372741699219, 0.00027060508728027344], "beyond_p": 0.6838235294117647}], "best-time-to-buy-and-sell-stock": [{"slug_name": "best-time-to-buy-and-sell-stock", "status": {"result": "passed", "runtime": 0.0005688667297363281, "index": 0}, "solution": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        for i in range(len(prices)):\n            if prices[i] < min_price:\n                min_price = prices[i]\n            elif prices[i] - min_price > max_profit:\n                max_profit = prices[i] - min_price\n                \n        return max_profit", "runtimes": [0.0004010200500488281, 0.0004630088806152344, 0.0004665851593017578, 0.00047469139099121094, 0.0004875659942626953, 0.00058746337890625, 0.0006504058837890625, 0.0007736682891845703, 0.0008225440979003906, 0.0010766983032226562, 0.0011363029479980469, 0.0011887550354003906, 0.0012104511260986328, 0.0012328624725341797, 0.0012652873992919922, 0.0014467239379882812, 0.0017633438110351562, 0.0020325183868408203], "beyond_p": 0.8971211456963321}], "binary-tree-inorder-traversal": [{"slug_name": "binary-tree-inorder-traversal", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        res = []\n        stack = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        def helper(root):\n            if root:\n                helper(root.left)\n                res.append(root.val)\n                helper(root.right)\n        helper(root)\n        return res\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        stack = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        stack = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        stack = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object", "runtimes": [0.0005984306335449219, 0.000598907470703125, 0.0006003379821777344, 0.00060272216796875, 0.0006039142608642578, 0.0006046295166015625, 0.0006048679351806641, 0.0006060600280761719, 0.0006062984466552734, 0.0006093978881835938, 0.0006093978881835938, 0.0006117820739746094, 0.0006120204925537109, 0.0006155967712402344, 0.0006158351898193359, 0.0006172657012939453, 0.0006184577941894531, 0.0006191730499267578, 0.0006229877471923828, 0.0006265640258789062, 0.0006430149078369141], "beyond_p": 0.0}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"slug_name": "construct-binary-tree-from-preorder-and-inorder-traversal", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if inorder:\n            index = inorder.index(preorder.pop(0))\n            root = TreeNode(inorder[index])\n            root.left = self.buildTree(preorder, inorder[0:index])\n            root.right = self.buildTree(preorder, inorder[index+1:])\n            return root\n\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        map_inorder = {}\n        for i in range(len(inorder)):\n            map_inorder[inorder[i]] = i\n        return self.helper(preorder, inorder, 0, len(inorder) - 1, 0, len(preorder) - 1, map_inorder)\n\n    def helper(self, preorder, inorder, in_start, in_end, pre_start, pre_end, map_inorder):\n        if pre_start > pre_end:\n            return None\n        root = TreeNode(preorder[pre_start])\n        index = map_inorder[preorder[pre_start]]\n        root.left = self.helper(preorder, inorder, in_start, index - 1, pre_start + 1, pre_start + index - in_start, map_inorder)\n        root.right = self.helper(preorder, inorder, index + 1, in_end, pre_start + index - in_start + 1, pre_end, map_inorder)\n        return root\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if inorder:\n            index = inorder.index(preorder.pop(0))\n            root = TreeNode(inorder[index])\n            root.left = self.buildTree(preorder, inorder[0:index])\n            root.right = self.buildTree(preorder, inorder[index+1:])\n            return root\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        map_inorder = {}\n        for i in range(len(inorder)):\n            map_inorder[inorder[i]] = i\n        return self.helper(preorder, inorder, 0, len(inorder) - 1, 0, len(preorder) - 1, map_inorder)\n\n    def helper(self, preorder, inorder, in_start, in_end, pre_start, pre_end, map_inorder):\n        if pre_start > pre_end:\n            return None\n        root = TreeNode(preorder[pre_start])\n        index = map_inorder[preorder[pre_start]]\n        root.left = self.helper(preorder, inorder, in_start, index - 1, pre_start + 1, pre_start + index - in_start, map_inorder)\n        root.right = self.helper(preorder, inorder, index + 1, in_end, pre_start + index - in_start + 1, pre_end, map_inorder)\n        return root\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List", "runtimes": [0.003767251968383789, 0.003796815872192383, 0.0038132667541503906, 0.003905773162841797, 0.003932952880859375, 0.004022359848022461, 0.0041348934173583984, 0.0041429996490478516, 0.004169940948486328, 0.004244089126586914, 0.004273176193237305, 0.004273414611816406, 0.004276752471923828, 0.004307985305786133, 0.004388093948364258, 0.004412651062011719, 0.004415750503540039, 0.004426717758178711, 0.004446268081665039, 0.004446506500244141, 0.004537343978881836, 0.0045740604400634766, 0.004674196243286133, 0.005686283111572266, 0.011307477951049805], "beyond_p": 0.0}], "remove-invalid-parentheses": [{"slug_name": "remove-invalid-parentheses", "status": {"result": "failed@cases", "runtime": 0.0002694129943847656, "index": 0}, "solution": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            cnt = 0\n            for ch in s:\n                if ch == '(':\n                    cnt += 1\n                elif ch == ')':\n                    cnt -= 1\n                    if cnt < 0:\n                        return False\n            return cnt == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}", "runtimes": [0.00030803680419921875, 0.0003781318664550781], "beyond_p": 0.0}], "merge-k-sorted-lists": [{"slug_name": "merge-k-sorted-lists", "status": {"result": "passed", "runtime": 0.0016949176788330078, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        self.nodes = []\n        head = point = ListNode(0)\n        for l in lists:\n            while l:\n                self.nodes.append(l.val)\n                l = l.next\n        for x in sorted(self.nodes):\n            point.next = ListNode(x)\n            point = point.next\n        return head.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        self.nodes = []\n        head = point = ListNode(0)\n        for l in lists:\n            while l:\n                self.nodes.append(l.val)\n                l = l.next\n        for x in sorted(self.nodes):\n            point.next = ListNode(x)\n            point = point.next\n        return head.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        self.nodes = []\n        head = point = ListNode(0)\n        for l in lists:\n            while l:\n                self.nodes.append(l.val)\n                l = l.next\n        for x in sorted(self.nodes):\n            point.next = ListNode(x)\n            point = point.next\n        return head.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        self.nodes = []\n        head = point = ListNode(0)\n        for l in lists:\n            while l:\n                self.nodes.append(l.val)\n                l = l.next\n        for x in sorted(self.nodes):\n            point.next = ListNode(x)\n            point = point.next\n        return head.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        self.nodes = []\n        head = point = ListNode(0)\n        for l in lists:\n            while l:\n                self.nodes.append(l.val)\n                l = l.next\n        for x in sorted(self.nodes):\n            point.next = ListNode(x)\n            point = point.next\n        return head.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        self.nodes = []\n        head = point = ListNode(0)\n        for l in lists:\n            while l:\n                self.nodes.append(l.val)\n                l = l.next\n        for x in sorted(self.nodes):\n            point.next = ListNode(x)\n            point = point.next\n        return head.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.", "runtimes": [0.0016741752624511719, 0.0017943382263183594, 0.001882791519165039, 0.0018928050994873047, 0.001973390579223633, 0.001978158950805664, 0.0019903182983398438, 0.0019927024841308594, 0.0020020008087158203, 0.002218961715698242, 0.00249481201171875, 0.0025169849395751953, 0.0025877952575683594, 0.002686738967895508, 0.002694845199584961, 0.0033512115478515625, 0.0034224987030029297, 0.004181623458862305, 0.004533290863037109, 0.006921052932739258, 0.01566457748413086, 0.02376270294189453, 0.17947936058044434], "beyond_p": 0.9998833418927309}], "palindrome-partitioning-ii": [{"slug_name": "palindrome-partitioning-ii", "status": {"result": "failed@cases", "runtime": 0.03808140754699707, "index": 0}, "solution": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        cut = list(range(-1,n))\n        pal = [[0]*n for _ in range(n)]\n        for i in range(n):\n            for j in range(i+1):\n                if s[i] == s[j] and (i-j<=1 or pal[j+1][i-1] == 1):\n                    pal[j][i] = 1\n                    cut[i] = min(cut[i], cut[j-1]+1)\n        return cut[-1]\n\n# Time complexity: O(n^2)\n# Space complexity: O(n^2)\n\n# The idea is to use dynamic programming.\n# We first create a boolean 2D array pal[][] in which pal[i][j] will be true if the string from index i to j is a palindrome.\n# We initialize the cuts array with its index - 1.\n# Then we iterate through the string. For each character, we consider it as the center of a palindrome string and expand to both sides.\n# If the left and right characters are equal, we update pal[j][i] to be true and update the minimum cut at position i.\n# Finally, we return the last element in the cuts array.\n\n# The time complexity is O(n^2) because we have a nested loop structure where we iterate through the string and for each character, we iterate through the string again.\n# The space complexity is O(n^2) because we store the boolean 2D array pal[][] and the cuts array.\n\n# Test the function with the provided test cases.\n\n# Tags: Dynamic Programming, String\n\n# Python3 code to solve the problem\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        cut = list(range(-1, n))\n        pal = [[0]*n for _ in range(n)]\n        for i in range(n):\n            for j in range(i+1):\n                if s[i] == s[j] and (i-j<=1 or pal[j+1][i-1] == 1):\n                    pal[j][i] = 1\n                    cut[i] = min(cut[i], cut[j-1]+1)\n        return cut[-1]\n\n# Time complexity: O(n^2)\n# Space complexity: O(n^2)\n\n# The idea is to use dynamic programming.\n# We first create a boolean 2D array pal[][] in which pal[i][j] will be true if the string from index i to j is a palindrome.\n# We initialize the cuts array with its index - 1.\n# Then we iterate through the string. For each character, we consider it as the center of a palindrome string and expand to both sides.\n# If the left and right characters are equal, we update pal[j][i] to be true and update the minimum cut at position i.\n# Finally, we return the last element in the cuts array.\n\n# The time complexity is O(n^2) because we have a nested loop structure where we iterate through the string and for each character, we iterate through the string again.\n# The space complexity is O(n^2) because we store the boolean 2D array pal[][] and the cuts array.\n\n# Test the function with the provided test cases.\n\n# Tags: Dynamic Programming, String\n\n# Python3 code to solve the problem\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        cut = list(range(-1, n))\n        pal = [[0]*n for _ in range(n)]\n        for i in range(n):\n            for j in range(i+1):\n                if s[i] == s[j] and (i-j<=1 or pal[j+1][i-1] == 1):\n                    pal[j][i] = 1\n                    cut[i] = min(cut[i], cut[j-1]+1)\n        return cut[-1]\n\n# Time complexity: O(n^2)\n# Space complexity: O(n^2)\n\n# The idea is to use dynamic programming.\n# We first create a boolean 2D array pal[][] in which pal[i][j] will be true if", "runtimes": [0.0016682147979736328, 0.001997232437133789, 0.00419306755065918, 0.05061531066894531, 0.05164361000061035, 0.0578000545501709, 0.06285691261291504, 0.06826305389404297, 0.08573555946350098, 0.09192013740539551, 0.111785888671875, 0.1615610122680664, 0.1692502498626709, 0.16944670677185059, 0.1729738712310791, 0.18543744087219238, 0.1857154369354248, 0.19602203369140625, 0.22612380981445312, 0.22744965553283691, 0.23030948638916016, 0.2368152141571045, 0.25275468826293945, 0.2541210651397705, 0.299668550491333, 0.3519020080566406], "beyond_p": 0.0}], "preimage-size-of-factorial-zeroes-function": [{"slug_name": "preimage-size-of-factorial-zeroes-function", "status": {"result": "failed@cases", "runtime": 0.006096363067626953, "index": 0}, "solution": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zero(n):\n            cnt = 0\n            while n > 0:\n                n /= 5\n                cnt += n\n            return cnt\n        \n        left, right = 0, 5 * k\n        while left < right:\n            mid = (left + right) // 2\n            if count_zero(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return 5 if count_zero(left) == k else 0", "runtimes": [0.0002734661102294922, 0.0002830028533935547, 0.0002899169921875, 0.00033092498779296875, 0.00033736228942871094, 0.0005238056182861328, 0.0005311965942382812, 0.00061798095703125, 0.0006270408630371094, 0.0008990764617919922, 0.0020749568939208984, 0.002565145492553711], "beyond_p": 0.0}], "palindrome-pairs": [{"slug_name": "palindrome-pairs", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def is_palindrome(check):\n            return check == check[::-1]\n\n        words = {word: i for i, word in enumerate(words)}\n        valid_pals = []\n        for word, k in words.iteritems():\n            n = len(word)\n            for j in range(n+1):\n                pref = word[:j]\n                suf = word[j:]\n                if is_palindrome(pref):\n                    back = suf[::-1]\n                    if back != word and back in words:\n                        valid_pals.append([words[back],  k])\n                if j != n and is_palindrome(suf):\n                    back = pref[::-1]\n                    if back != word and back in words:\n                        valid_pals.append([k, words[back]])\n        return valid_pals", "runtimes": [0.0013060569763183594, 0.0013263225555419922, 0.0013554096221923828, 0.0016627311706542969, 0.0017876625061035156, 0.0018470287322998047, 0.0020058155059814453, 0.002055644989013672, 0.002182483673095703, 0.002193450927734375, 0.0024890899658203125, 0.0025119781494140625, 0.0035605430603027344, 0.003572702407836914, 0.0037178993225097656, 0.003802776336669922, 0.0039463043212890625, 0.004102230072021484, 0.004244327545166016, 0.00427699089050293, 0.004557371139526367, 0.00479888916015625, 0.006007194519042969, 0.006010293960571289], "beyond_p": 0.0}], "convert-sorted-array-to-binary-search-tree": [{"slug_name": "convert-sorted-array-to-binary-search-tree", "status": {"result": "failed@cases", "runtime": 0.0020868778228759766, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n\n            # always choose left middle node as a root\n            p = (left + right) // 2\n\n            # preorder traversal: node -> left -> right\n            root = TreeNode(nums[p])\n            root.left = helper(left, p - 1)\n            root.right = helper(p + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)\n        \n\n    def preorder(self, root):\n        return [root.val] + self.preorder(root.left) + self.preorder(root.right) if root else []\n\n    def inorder(self, root):\n        return  self.inorder(root.left) + [root.val] + self.inorder(root.right) if root else []\n\n    def postorder(self, root):\n        return  self.postorder(root.left) + self.postorder(root.right) + [root.val] if root else []\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution2(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not nums:\n            return None\n\n        mid = len(nums) // 2\n\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n\n        return root\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution3(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        def helper(l, r):\n            if l > r:\n                return None\n            m = (l + r) // 2\n            root = TreeNode(nums[m])\n            root.left = helper(l, m - 1)\n            root.right = helper(m + 1, r)\n            return root\n        return helper(0, len(nums) - 1)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution4(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not nums:\n            return None\n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution5(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        def helper(left, right):\n            if left > right:\n                return None\n\n            # always choose left middle node as a root\n            p = (left + right) // 2\n\n            # preorder traversal: node -> left -> right\n            root = TreeNode(nums[p])\n            root.left = helper(left, p - 1)\n            root.right = helper(p + 1, right)", "runtimes": [0.002348184585571289, 0.0024421215057373047, 0.002474069595336914, 0.0024864673614501953, 0.0025005340576171875, 0.002533435821533203, 0.002569437026977539, 0.0026102066040039062, 0.0026884078979492188, 0.0027878284454345703], "beyond_p": 0.0}], "contain-virus": [{"slug_name": "contain-virus", "status": {"result": "failed@cases", "runtime": 0.023238658905029297, "index": 0}, "solution": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def get_neighbors(r, c):\n            for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                if 0 <= i < m and 0 <= j < n:\n                    yield i, j\n        \n        def dfs(r, c):\n            for i, j in get_neighbors(r, c):\n                if isInfected[i][j] == 1:\n                    yield i, j\n                    isInfected[i][j] = -1\n                    for x, y in dfs(i, j):\n                        yield x, y\n                elif isInfected[i][j] == 0:\n                    yield i, j\n        \n        def build_wall():\n            nonlocal walls\n            for r in range(m):\n                for c in range(n):\n                    if isInfected[r][c] == 1:\n                        walls += len(list(dfs(r, c)))\n                        return\n        \n        def spread_virus():\n            for r in range(m):\n                for c in range(n):\n                    if isInfected[r][c] == 1:\n                        for i, j in get_neighbors(r, c):\n                            if isInfected[i][j] == 0:\n                                isInfected[i][j] = 2\n            for r in range(m):\n                for c in range(n):\n                    if isInfected[r][c] == 2:\n                        isInfected[r][c] = 1\n        \n        m, n = len(isInfected), len(isInfected[0])\n        walls = 0\n        while True:\n            regions = []\n            frontiers = []\n            for r in range(m):\n                for c in range(n):\n                    if isInfected[r][c] == 1:\n                        region = list(dfs(r, c))\n                        frontier = len(set(i for i, j in region for x, y in get_neighbors(i, j) if isInfected[x][y] == 0))\n                        regions.append(region)\n                        frontiers.append(frontier)\n            if not regions:\n                return walls\n            max_idx = frontiers.index(max(frontiers))\n            for r, c in regions[max_idx]:\n                isInfected[r][c] = -1\n            build_wall()\n            spread_virus()\n\n# Time: O(m*n*m*n)\n# Space: O(m*n)\n\n# Test Cases\ns = Solution()\nprint(s.containVirus([[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]))\nprint(s.containVirus([[1,1,1],[1,0,1],[1,1,1]]))\nprint(s.containVirus([[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]))\n\n# Expected Output\n# 10\n# 4\n# 13\n\n# Explanation\n# In the first example, the virus spreads to all cells in the first and third rows. The first wall is installed on the boundary of the first and third rows. The virus spreads to all cells in the second and fourth rows. The second wall is installed on the boundary of the second and fourth rows. The virus spreads to all cells in the first and third rows. The third wall is installed on the boundary of the first and third rows. The virus spreads to all cells in the second and fourth rows. The fourth wall is installed on the boundary of the second and fourth rows. The virus spreads to all cells in the first and third rows. The fifth wall is installed on the boundary of the first and third rows. The virus spreads to all cells in the second and fourth rows. The sixth wall is installed on the boundary of the second and fourth rows. The virus spreads to all cells in the", "runtimes": [0.0125732421875, 0.013074398040771484, 0.015613794326782227, 0.017007827758789062, 0.020663738250732422, 0.023847579956054688, 0.023883819580078125, 0.024801254272460938, 0.027340412139892578, 0.0287778377532959, 0.029622793197631836, 0.03122425079345703, 0.03189229965209961, 0.05800032615661621], "beyond_p": 0.0}], "longest-increasing-path-in-a-matrix": [{"slug_name": "longest-increasing-path-in-a-matrix", "status": {"result": "passed", "runtime": 0.0011973381042480469, "index": 0}, "solution": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        directions = [(0,1), (0,-1), (1,0), (-1,0)]\n        m, n = len(matrix), len(matrix[0])\n        cache = [[-1 for _ in range(n)] for _ in range(m)]\n        \n        def dfs(i, j):\n            if cache[i][j] != -1:\n                return cache[i][j]\n            max_path = 1\n            for d in directions:\n                x, y = i + d[0], j + d[1]\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    max_path = max(max_path, 1 + dfs(x, y))\n            cache[i][j] = max_path\n            return cache[i][j]\n        \n        return max(dfs(i, j) for i in range(m) for j in range(n))", "runtimes": [0.0008306503295898438, 0.0008518695831298828, 0.0011432170867919922, 0.001154184341430664, 0.0011625289916992188, 0.0011670589447021484, 0.0011820793151855469, 0.0011849403381347656, 0.0012116432189941406, 0.0012171268463134766, 0.0012233257293701172, 0.0012297630310058594, 0.0013203620910644531, 0.0013897418975830078, 0.0013918876647949219, 0.0014007091522216797, 0.0014145374298095703, 0.0015027523040771484, 0.0015354156494140625, 0.001699686050415039, 0.001809835433959961, 0.0018303394317626953, 0.0018353462219238281, 0.001924276351928711, 0.001993894577026367, 0.002015352249145508, 0.002039194107055664, 0.002882242202758789, 0.0031762123107910156, 0.003228902816772461, 0.003847360610961914], "beyond_p": 0.8784477989409626}], "number-of-digit-one": [{"slug_name": "number-of-digit-one", "status": {"result": "passed", "runtime": 0.0010061264038085938, "index": 0}, "solution": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n < 10:\n            return 1\n        l = len(str(n))\n        p = 10 ** (l - 1)\n        m, r = divmod(n, p)\n        if m == 1:\n            return r + 1 + self.countDigitOne(p - 1) + self.countDigitOne(r)\n        else:\n            return p + m * self.countDigitOne(p - 1) + self.countDigitOne(r)", "runtimes": [0.00024509429931640625, 0.0002605915069580078, 0.00027561187744140625, 0.00028061866760253906, 0.0002894401550292969, 0.000293731689453125, 0.0002944469451904297, 0.00029587745666503906, 0.0003800392150878906, 0.0008997917175292969, 0.0011713504791259766], "beyond_p": 0.1783783783783784}], "word-break-ii": [{"slug_name": "word-break-ii", "status": {"result": "passed", "runtime": 0.0008032321929931641, "index": 0}, "solution": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        wordSet = set(wordDict)\n        memo = {}\n        def dp(i):\n            if i in memo:\n                return memo[i]\n            ans = []\n            for j in range(i+1, len(s)+1):\n                if s[i:j] in wordSet:\n                    if j == len(s):\n                        ans.append(s[i:j])\n                    else:\n                        for tail in dp(j):\n                            ans.append(s[i:j] + ' ' + tail)\n            memo[i] = ans\n            return ans\n        return dp(0)", "runtimes": [0.0008177757263183594, 0.0008401870727539062, 0.0008549690246582031, 0.0009131431579589844, 0.0015490055084228516, 0.0018410682678222656, 0.0020668506622314453, 0.0021622180938720703, 0.002271413803100586, 0.002325773239135742, 0.0025436878204345703, 0.0040132999420166016, 0.0044057369232177734, 0.007650613784790039], "beyond_p": 1.0021284762203846}], "binary-tree-zigzag-level-order-traversal": [{"slug_name": "binary-tree-zigzag-level-order-traversal", "status": {"result": "passed", "runtime": 0.004703521728515625, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        level = [root]\n        direction = 1\n        \n        while level:\n            next_level = []\n            res.append([node.val for node in level][::direction])\n            direction *= -1\n            for node in level:\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            level = next_level\n        \n        return res\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Test cases:\n# [3,9,20,null,null,15,7] -> [[3],[20,9],[15,7]]\n# [1] -> [[1]]\n# [] -> []\n# [1,2,3,4,null,null,5] -> [[1],[3,2],[4,5]]\n# [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] -> [[1],[2,3],[4,5,6,7],[15,14,13,12,11,10,9,8]]\n\n# Path: zigzag-level-order-traversal.py\n# Compare this snippet from zigzag-level-order-traversal.py:\n# [3,9,20,null,null,15,7] -> [[3],[20,9],[15,7]]\n# [1] -> [[1]]\n# [] -> []\n# [1,2,3,4,null,null,5] -> [[1],[3,2],[4,5]]\n# [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] -> [[1],[2,3],[4,5,6,7],[15,14,13,12,11,10,9,8]]\n\n# Path: zigzag-level-order-traversal.py\n# Compare this snippet from zigzag-level-order-traversal.py:\n# [3,9,20,null,null,15,7] -> [[3],[20,9],[15,7]]\n# [1] -> [[1]]\n# [] -> []\n# [1,2,3,4,null,null,5] -> [[1],[3,2],[4,5]]\n# [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] -> [[1],[2,3],[4,5,6,7],[15,14,13,12,11,10,9,8]]\n\n# Path: zigzag-level-order-traversal.py\n# Compare this snippet from zigzag-level-order-traversal.py:\n# [3,9,20,null,null,15,7] -> [[3],[20,9],[15,7]]\n# [1] -> [[1]]\n# [] -> []\n# [1,2,3,4,null,null,5] -> [[1],[3,2],[4,5]]\n# [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] -> [[1],[2,3],[4,5,6,7],[15,14,13,12,11,10,9,8]]\n\n# Path: zigzag-level-order-traversal.py\n# Compare this snippet from zigzag-level-order-traversal.py:\n# [3,9,20,null,null,15,7] -> [[3],[20,9],[15,7]]\n# [1] -> [[1]]", "runtimes": [0.004843473434448242, 0.004844188690185547, 0.0048542022705078125, 0.004891395568847656, 0.005139827728271484, 0.005461931228637695, 0.005593776702880859, 0.005606889724731445, 0.005808353424072266, 0.00606989860534668], "beyond_p": 1.114113530326594}], "binary-watch": [{"slug_name": "binary-watch", "status": {"result": "passed", "runtime": 0.002591848373413086, "index": 0}, "solution": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def count_bits(n):\n            count = 0\n            while n:\n                n &= n - 1\n                count += 1\n            return count\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if count_bits(h) + count_bits(m) == turnedOn:\n                    res.append(f\"{h}:{m:02d}\")\n        return res\n    \nprint(Solution().readBinaryWatch(1))\nprint(Solution().readBinaryWatch(9))", "runtimes": [0.001802206039428711, 0.0018305778503417969, 0.0022382736206054688, 0.0022432804107666016, 0.0022623538970947266, 0.0022749900817871094, 0.0031654834747314453, 0.004316568374633789], "beyond_p": 0.6859472785890385}], "pascals-triangle": [{"slug_name": "pascals-triangle", "status": {"result": "passed", "runtime": 0.0003192424774169922, "index": 0}, "solution": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        \n        triangle = [[1]]\n        \n        for i in range(1, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(triangle[i-1][j-1] + triangle[i-1][j])\n            row.append(1)\n            triangle.append(row)\n        \n        return triangle", "runtimes": [0.0003075599670410156, 0.00031566619873046875, 0.0003254413604736328, 0.00032591819763183594, 0.0003266334533691406, 0.00032782554626464844, 0.00032901763916015625, 0.0003325939178466797, 0.00033283233642578125, 0.0003376007080078125, 0.0003399848937988281, 0.0003604888916015625, 0.00037288665771484375, 0.00038743019104003906, 0.0005028247833251953], "beyond_p": 0.9401709401709402}], "power-of-three": [{"slug_name": "power-of-three", "status": {"result": "passed", "runtime": 0.0003447532653808594, "index": 0}, "solution": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n < 1:\n            return False\n        while n % 3 == 0:\n            n /= 3\n        return n == 1", "runtimes": [0.0002598762512207031, 0.0002644062042236328, 0.0002651214599609375, 0.0002655982971191406, 0.0002682209014892578, 0.00026988983154296875, 0.00027441978454589844, 0.0002753734588623047, 0.0002753734588623047, 0.00027680397033691406, 0.00027751922607421875, 0.00027942657470703125, 0.0002810955047607422, 0.00028228759765625, 0.0002884864807128906, 0.00029397010803222656, 0.0003204345703125, 0.0003228187561035156, 0.0003285408020019531, 0.00033020973205566406], "beyond_p": 0.0}], "binary-tree-maximum-path-sum": [{"slug_name": "binary-tree-maximum-path-sum", "status": {"result": "passed", "runtime": 0.002095460891723633, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            nonlocal max_sum\n            if not node:\n                return 0\n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            price_newpath = node.val + left_gain + right_gain\n            max_sum = max(max_sum, price_newpath)\n            return node.val + max(left_gain, right_gain)\n\n        max_sum = float('-inf')\n        max_gain(root)\n        return max_sum\n\n# Time: O(N)\n# Space: O(N)\n\n# Binary Trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None\ndef maxPathSum(tree):\n    _, maxSum = findMaxSum(tree)\n    return maxSum\n\ndef findMaxSum(tree):\n    if tree is None:\n        return (0, float(\"-inf\"))\n    leftMaxSumAsBranch, leftMaxPathSum = findMaxSum(tree.left)\n    rightMaxSumAsBranch, rightMaxPathSum = findMaxSum(tree.right)\n    maxChildSumAsBranch = max(leftMaxSumAsBranch, rightMaxSumAsBranch)\n    value = tree.value\n    maxSumAsBranch = max(maxChildSumAsBranch + value, value)\n    maxSumAsRootNode = max(leftMaxSumAsBranch + value + rightMaxSumAsBranch, maxSumAsBranch)\n    maxPathSum = max(leftMaxPathSum, rightMaxPathSum, maxSumAsRootNode)\n    return (maxSumAsBranch, maxPathSum)\n\n# Time: O(N)\n# Space: O(log(N))# Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n# You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n# You can return the answer in any order.\n\n# Example 1:\n\n# Input: nums = [2,7,11,15], target = 9\n# Output: [0,1]\n# Output: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n# Example 2:\n\n# Input: nums = [3,2,4], target = 6\n# Output: [1,2]\n\n# Example 3:\n\n# Input: nums = [3,3], target = 6\n# Output: [0,1]\n\n# Constraints:\n\n#     2 <= nums.length <= 104\n#     -109 <= nums[i] <= 109\n#     -109 <= target <= 109\n#     Only one valid answer exists.\n\n# Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\n\n# Solution 1: Brute Force\n# The brute force approach is simple. Loop through each element x and find if there is another value that equals to target - x.\n\ndef twoSum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] == target - nums[i]:\n                return [i, j]\n\n# Time complexity : O(n^2)\n# For each element, we try to find its complement by looping through the rest of array which takes O(n) time. Therefore, the time complexity is O(n^2).\n\n# Space complexity : O(1).\n\n# Solution 2: Two-pass Hash Table\n# To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.\n\n# We reduce the look up time from O(n) to O(1) by trading space for speed. A hash table is built exactly for this purpose, it", "runtimes": [0.0018186569213867188, 0.0019190311431884766, 0.0019919872283935547, 0.0020532608032226562, 0.002095460891723633, 0.002127408981323242, 0.002227306365966797, 0.0023152828216552734, 0.0023403167724609375, 0.0024030208587646484, 0.0024547576904296875, 0.0025191307067871094, 0.0025343894958496094, 0.0025856494903564453, 0.002805948257446289, 0.0028505325317382812, 0.002859354019165039, 0.0033063888549804688, 0.0037424564361572266, 0.0042803287506103516, 0.0053424835205078125], "beyond_p": 0.9214479025710419}], "trapping-rain-water-ii": [{"slug_name": "trapping-rain-water-ii", "status": {"result": "passed", "runtime": 0.006808280944824219, "index": 0}, "solution": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = [[0]*n for _ in range(m)]\n        \n        # Initially, add all the Cells which are on borders to the heap.\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0 or i == m-1 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = 1\n        \n        trapped_water = 0\n        while heap:\n            height, i, j = heapq.heappop(heap)\n            for x, y in ((i-1,j), (i+1,j), (i,j-1), (i,j+1)):\n                if 0 <= x < m and 0 <= y < n and visited[x][y] == 0:\n                    trapped_water += max(0, height-heightMap[x][y])\n                    heapq.heappush(heap, (max(heightMap[x][y],height), x, y))\n                    visited[x][y] = 1\n        return trapped_water", "runtimes": [0.005522727966308594, 0.006181478500366211, 0.007013797760009766, 0.007721900939941406, 0.007909297943115234, 0.007956504821777344, 0.008100748062133789, 0.00851750373840332, 0.008632659912109375, 0.008755207061767578, 0.009160518646240234, 0.010301828384399414, 0.012075185775756836, 0.013196945190429688, 0.014538288116455078, 0.015079021453857422, 0.016345500946044922], "beyond_p": 0.8812177820857382}], "valid-palindrome": [{"slug_name": "valid-palindrome", "status": {"result": "passed", "runtime": 0.0004634857177734375, "index": 0}, "solution": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = ''.join(e for e in s if e.isalnum()).lower()\n        return s == s[::-1]", "runtimes": [0.0004458427429199219, 0.0004515647888183594, 0.00045299530029296875, 0.000453948974609375, 0.0004551410675048828, 0.0004551410675048828, 0.000457763671875, 0.0004582405090332031, 0.0004611015319824219, 0.0004646778106689453, 0.0004718303680419922, 0.0004749298095703125, 0.00047588348388671875, 0.0004820823669433594, 0.0005002021789550781, 0.0005004405975341797, 0.0005478858947753906, 0.0005497932434082031, 0.0005557537078857422, 0.0005562305450439453, 0.0005605220794677734, 0.0005655288696289062, 0.0006289482116699219, 0.0006527900695800781], "beyond_p": 0.9147465437788018}], "sliding-window-median": [{"slug_name": "sliding-window-median", "status": {"result": "passed", "runtime": 0.0020170211791992188, "index": 0}, "solution": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        def median(arr):\n            n = len(arr)\n            if n % 2 == 0:\n                return (arr[n//2-1] + arr[n//2]) / 2.0\n            else:\n                return arr[n//2]\n        \n        window = sorted(nums[:k])\n        result = [median(window)]\n        \n        for i in range(k, len(nums)):\n            window.remove(nums[i-k])\n            bisect.insort(window, nums[i])\n            result.append(median(window))\n        \n        return result", "runtimes": [0.0012073516845703125, 0.0012655258178710938, 0.0012898445129394531, 0.0019371509552001953, 0.0019519329071044922, 0.0020170211791992188, 0.0020606517791748047, 0.0020651817321777344, 0.0023813247680664062, 0.0023915767669677734, 0.0024309158325195312, 0.004218578338623047, 0.004487037658691406, 0.005527496337890625, 0.006125450134277344, 0.01383519172668457, 0.01978278160095215, 0.03973865509033203, 0.04025411605834961], "beyond_p": 0.9792641078559479}], "rotate-list": [{"slug_name": "rotate-list", "status": {"result": "passed", "runtime": 0.0005867481231689453, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # close the linked list into the ring\n        old_tail = head\n        n = 1\n        while old_tail.next:\n            old_tail = old_tail.next\n            n += 1\n        old_tail.next = head\n        \n        # find new tail : (n - k % n - 1)th node\n        # and new head : (n - k % n)th node\n        new_tail = head\n        for _ in range( n - k % n - 1 ):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n        \n        # break the ring at the new tail node\n        new_tail.next = None\n        \n        return new_head", "runtimes": [0.0005695819854736328, 0.0005731582641601562, 0.0005753040313720703, 0.0005764961242675781, 0.0005843639373779297, 0.0005865097045898438, 0.0005867481231689453, 0.0005903244018554688, 0.0005946159362792969, 0.0006053447723388672, 0.0006072521209716797, 0.0006558895111083984, 0.0009019374847412109, 0.0009105205535888672], "beyond_p": 0.9496503496503497}], "ugly-number": [{"slug_name": "ugly-number", "status": {"result": "passed", "runtime": 0.00033354759216308594, "index": 0}, "solution": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        while n % 2 == 0:\n            n /= 2\n        while n % 3 == 0:\n            n /= 3\n        while n % 5 == 0:\n            n /= 5\n        return n == 1", "runtimes": [0.0002579689025878906, 0.0002582073211669922, 0.0002582073211669922, 0.0002613067626953125, 0.0002620220184326172, 0.00027251243591308594, 0.0002789497375488281, 0.0002875328063964844, 0.0003304481506347656, 0.0003337860107421875, 0.000335693359375, 0.0003490447998046875, 0.00035262107849121094, 0.00035309791564941406, 0.0003540515899658203], "beyond_p": 0.21339950372208435}], "falling-squares": [{"slug_name": "falling-squares", "status": {"result": "passed", "runtime": 0.0010998249053955078, "index": 0}, "solution": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * len(positions)\n        for i, (left1, size1) in enumerate(positions):\n            right1 = left1 + size1\n            res[i] += size1\n            for j in range(i):\n                left2, size2 = positions[j]\n                right2 = left2 + size2\n                if right1 > left2 and left1 < right2:\n                    res[i] = max(res[i], res[j] + size1)\n        for i in range(1, len(res)):\n            res[i] = max(res[i], res[i - 1])\n        return res", "runtimes": [0.0006289482116699219, 0.0012025833129882812, 0.0015978813171386719, 0.0018398761749267578, 0.003142118453979492, 0.0032968521118164062, 0.003862142562866211, 0.004777431488037109, 0.0051496028900146484, 0.011500120162963867, 0.032269954681396484], "beyond_p": 0.9851181505817108}], "sum-of-left-leaves": [{"slug_name": "sum-of-left-leaves", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def is_leaf(node):\n            return node and not node.left and not node.right\n        \n        def dfs(node):\n            if not node:\n                return 0\n            if node.left and is_leaf(node.left):\n                return node.left.val + dfs(node.right)\n            return dfs(node.left) + dfs(node.right)\n        \n        return dfs(root)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        left, right = root.left, root.right\n        if left and not left.left and not left.right:\n            return left.val + self.sumOfLeftLeaves(right)\n        return self.sumOfLeftLeaves(left) + self.sumOfLeftLeaves(right)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        res = 0\n        stack = [(root, False)]\n        while stack:\n            node, is_left = stack.pop()\n            if not node.left and not node.right and is_left:\n                res += node.val\n            if node.left:\n                stack.append((node.left, True))\n            if node.right:\n                stack.append((node.right, False))\n        return res\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        res = 0\n        queue = collections.deque([(root, False)])\n        while queue:\n            node, is_left = queue.popleft()\n            if not node.left and not node.right and is_left:\n                res += node.val\n            if node.left:\n                queue.append((node.left, True))\n            if node.right:\n                queue.append((node.right, False))\n        return res\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        res = 0\n        queue = collections.deque([(root, False)])\n        while queue:\n            node, is_left = queue.popleft()\n            if not node.left and not node.right and is_left:\n                res += node.val\n            if node.left:\n                queue.append((node.left, True))\n            if node.right:\n                queue.append((node.right, False))\n        return res\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):", "runtimes": [0.002195119857788086, 0.0025663375854492188, 0.002580404281616211, 0.0026891231536865234, 0.0027005672454833984, 0.0027213096618652344, 0.002727508544921875, 0.0028192996978759766, 0.002872943878173828, 0.0029642581939697266, 0.0030410289764404297, 0.0030541419982910156], "beyond_p": 0.0}], "max-sum-of-rectangle-no-larger-than-k": [{"slug_name": "max-sum-of-rectangle-no-larger-than-k", "status": {"result": "passed", "runtime": 0.0011370182037353516, "index": 0}, "solution": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubarray(arr, k):\n            prefix_sums = [float('inf')]\n            prefix_sum = 0\n            max_sum = float('-inf')\n            for num in arr:\n                bisect.insort(prefix_sums, prefix_sum)\n                prefix_sum += num\n                i = bisect.bisect_left(prefix_sums, prefix_sum - k)\n                max_sum = max(max_sum, prefix_sum - prefix_sums[i])\n            return max_sum\n        \n        m, n = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        for i in range(n):\n            arr = [0] * m\n            for j in range(i, n):\n                arr = [arr[l] + matrix[l][j] for l in range(m)]\n                max_sum = max(max_sum, maxSumSubarray(arr, k))\n                if max_sum == k: return k\n        return max_sum", "runtimes": [0.0010144710540771484, 0.0011224746704101562, 0.001486063003540039, 0.001512289047241211, 0.001542806625366211, 0.0015838146209716797, 0.0016009807586669922, 0.0016036033630371094, 0.002408266067504883, 0.0031175613403320312, 0.003713369369506836, 0.0043125152587890625, 0.0048067569732666016, 0.005672454833984375, 0.007806062698364258], "beyond_p": 0.98195604858527}], "divide-two-integers": [{"slug_name": "divide-two-integers", "status": {"result": "passed", "runtime": 0.00025844573974609375, "index": 0}, "solution": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        a, b, res = abs(dividend), abs(divisor), 0\n        for x in range(31, -1, -1):\n            if (a >> x) - b >= 0:\n                res += 1 << x\n                a -= b << x\n        return res if (dividend > 0) == (divisor > 0) else -res", "runtimes": [0.0002372264862060547, 0.00023746490478515625, 0.0002410411834716797, 0.0002429485321044922, 0.0002446174621582031, 0.0002455711364746094, 0.0002467632293701172, 0.00024890899658203125, 0.00025081634521484375, 0.00025153160095214844, 0.0002567768096923828, 0.0002567768096923828, 0.0002624988555908203, 0.0002627372741699219, 0.0002734661102294922], "beyond_p": 0.4144736842105263}], "surrounded-regions": [{"slug_name": "surrounded-regions", "status": {"result": "passed", "runtime": 0.0003833770751953125, "index": 0}, "solution": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        row, col = len(board), len(board[0])\n        if row <= 2 or col <= 2:\n            return\n        def dfs(i, j):\n            if 0<=i<row and 0<=j<col and board[i][j] == 'O':\n                board[i][j] = 'G'\n                dfs(i-1, j)\n                dfs(i+1, j)\n                dfs(i, j-1)\n                dfs(i, j+1)\n        for i in range(row):\n            dfs(i, 0)\n            dfs(i, col-1)\n        for j in range(col):\n            dfs(0, j)\n            dfs(row-1, j)\n        for i in range(row):\n            for j in range(col):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'G':\n                    board[i][j] = 'O'", "runtimes": [0.0003898143768310547, 0.00040221214294433594, 0.00040650367736816406, 0.00045561790466308594, 0.0004799365997314453, 0.0004839897155761719, 0.00048542022705078125, 0.0004885196685791016, 0.0005075931549072266, 0.0005104541778564453, 0.0005114078521728516, 0.0005130767822265625, 0.0005164146423339844, 0.0005323886871337891, 0.0005359649658203125, 0.0005369186401367188, 0.0005483627319335938, 0.0005567073822021484, 0.0005934238433837891, 0.0006022453308105469, 0.0006153583526611328], "beyond_p": 1.0285412262156448}], "two-sum": [{"slug_name": "two-sum", "status": {"result": "passed", "runtime": 0.0002741813659667969, "index": 0}, "solution": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        hashmap = {}\n        for i in range(len(nums)):\n            hashmap[nums[i]] = i\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in hashmap and hashmap[complement] != i:\n                return [i, hashmap[complement]]", "runtimes": [0.0002624988555908203, 0.0002655982971191406, 0.0002684593200683594, 0.0002689361572265625, 0.0002741813659667969, 0.0002741813659667969, 0.000274658203125, 0.0002760887145996094, 0.0002765655517578125, 0.0002770423889160156, 0.0002770423889160156, 0.0002777576446533203, 0.0002789497375488281, 0.0002830028533935547, 0.00028324127197265625, 0.0002903938293457031, 0.0002942085266113281, 0.0002987384796142578, 0.00030684471130371094, 0.00030803680419921875], "beyond_p": 0.743455497382199}], "24-game": [{"slug_name": "24-game", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            for a, b, *rest in itertools.permutations(nums):\n                for op in (truediv, mul, add, sub):\n                    if ((op in {truediv, mul} and b != 0) or op in {add, sub}) and dfs(rest + [op(a, b)]):\n                        return True\n                    if op in {add, mul, truediv} and dfs(rest + [op(b, a)]):\n                        return True\n            return False\n        \n        return dfs(cards)\n    \n    def judgePoint24(self, nums):\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return abs(nums[0]-24) < 1e-6\n        for a, b, *rest in itertools.permutations(nums):\n            for fn in (truediv, mul, add, sub):\n                if ((fn in {truediv, mul} and b != 0) or fn in {add, sub}) and self.judgePoint24(rest + [fn(a, b)]):\n                    return True\n                if fn in {add, mul, truediv} and self.judgePoint24(rest + [fn(b, a)]):\n                    return True\n        return False\n    \n    def judgePoint24(self, nums):\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return abs(nums[0]-24) < 1e-6\n        for a, b, *rest in itertools.permutations(nums):\n            for fn in (truediv, mul, add, sub):\n                if ((fn in {truediv, mul} and b != 0) or fn in {add, sub}) and self.judgePoint24(rest + [fn(a, b)]):\n                    return True\n                if fn in {add, mul, truediv} and self.judgePoint24(rest + [fn(b, a)]):\n                    return True\n        return False\n    \n    def judgePoint24(self, nums):\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return abs(nums[0]-24) < 1e-6\n        for a, b, *rest in itertools.permutations(nums):\n            for fn in (truediv, mul, add, sub):\n                if ((fn in {truediv, mul} and b != 0) or fn in {add, sub}) and self.judgePoint24(rest + [fn(a, b)]):\n                    return True\n                if fn in {add, mul, truediv} and self.judgePoint24(rest + [fn(b, a)]):\n                    return True\n        return False\n    \n    def judgePoint24(self, nums):\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return abs(nums[0]-24) < 1e-6\n        for a, b, *rest in itertools.permutations(nums):\n            for fn in (truediv, mul, add, sub):\n                if ((fn in {truediv, mul} and b != 0) or fn in {add, sub}) and self.judgePoint24(rest + [fn(a, b)]):\n                    return True\n                if fn in {add, mul, truediv} and self.judgePoint24(rest + [fn(b, a)]):\n                    return True\n        return False\n    \n    def judgePoint24(self, nums):\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return abs(nums[0]-24) < 1e-6\n        for a, b, *rest in itertools.permutations(nums):\n            for fn in (truediv, mul, add, sub):\n                if ((fn in {truediv, mul} and b != 0) or fn", "runtimes": [0.0030510425567626953, 0.007108449935913086, 0.010725259780883789, 0.02392411231994629, 0.03821444511413574, 0.048841238021850586, 0.08032798767089844, 0.09082913398742676, 0.10046625137329102, 0.10110592842102051, 0.1021430492401123], "beyond_p": 0.0}], "wildcard-matching": [{"slug_name": "wildcard-matching", "status": {"result": "passed", "runtime": 1.466740369796753, "index": 0}, "solution": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        length_s = len(s)\n        length_p = len(p)\n        \n        # init all elements to None\n        dp = [[None]*(length_p + 1) for i in range(length_s + 1)]\n        \n        # empty pattern can match with empty string\n        dp[0][0] = True\n        \n        # empty pattern cannot match with any non-empty string\n        for i in range(1, length_s + 1):\n            dp[i][0] = False\n            \n        # Only '*' can match with empty string\n        for j in range(1, length_p + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n            else:\n                dp[0][j] = False\n                \n        for i in range(1, length_s + 1):\n            for j in range(1, length_p + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = False\n                    \n        return dp[length_s][length_p]", "runtimes": [0.00027680397033691406, 0.0002827644348144531, 0.00028586387634277344, 0.0003018379211425781, 0.0003104209899902344, 0.00036454200744628906, 0.00036835670471191406, 0.0003743171691894531, 0.00042557716369628906, 0.0006000995635986328, 0.0006275177001953125, 0.0007653236389160156, 0.014410734176635742, 0.014518499374389648, 0.01891779899597168, 0.054289817810058594, 0.6333451271057129, 1.3001978397369385, 1.3277130126953125, 1.330247163772583, 1.4234225749969482, 1.4598157405853271, 1.8768305778503418, 3.6648614406585693], "beyond_p": 0.2728822224457401}], "majority-element": [{"slug_name": "majority-element", "status": {"result": "passed", "runtime": 0.00034427642822265625, "index": 0}, "solution": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        return nums[len(nums)//2]", "runtimes": [0.0003306865692138672, 0.00035834312438964844, 0.0004246234893798828, 0.0004258155822753906, 0.00043320655822753906, 0.00044727325439453125, 0.0004496574401855469, 0.00045108795166015625, 0.0004661083221435547, 0.000499725341796875, 0.0005116462707519531, 0.0005166530609130859, 0.0005235671997070312, 0.0005581378936767578, 0.0005762577056884766, 0.0005900859832763672, 0.0006115436553955078, 0.0006139278411865234, 0.0006437301635742188, 0.0006549358367919922, 0.0011332035064697266, 0.0026407241821289062], "beyond_p": 0.9941170399422025}], "reconstruct-itinerary": [{"slug_name": "reconstruct-itinerary", "status": {"result": "passed", "runtime": 0.0004737377166748047, "index": 0}, "solution": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        from collections import defaultdict\n        self.flightMap = defaultdict(list)\n\n        for ticket in tickets:\n            origin, dest = ticket[0], ticket[1]\n            self.flightMap[origin].append(dest)\n\n        # sort the itinerary based on the lexical order\n        for origin, itinerary in self.flightMap.items():\n        # Note that we're sorting the itinerary in reverse order\n            itinerary.sort(reverse=True)\n\n        self.result = []\n        self.DFS('JFK')\n\n        # reconstruct the route backwards\n        return self.result[::-1]\n\n    def DFS(self, origin):\n        destList = self.flightMap[origin]\n        while destList:\n            # while we visit the edge, we trim it off from graph.\n            nextDest = destList.pop()\n            self.DFS(nextDest)\n        self.result.append(origin)", "runtimes": [0.00028705596923828125, 0.0002923011779785156, 0.0002944469451904297, 0.00030803680419921875, 0.0003204345703125, 0.00034308433532714844, 0.0003478527069091797, 0.0003516674041748047, 0.00035858154296875, 0.0003635883331298828, 0.0003757476806640625, 0.00039696693420410156, 0.00041961669921875, 0.00042247772216796875, 0.0004444122314453125, 0.0004596710205078125, 0.0005733966827392578], "beyond_p": 0.3480432972522898}], "4sum": [{"slug_name": "4sum", "status": {"result": "passed", "runtime": 0.08360862731933594, "index": 0}, "solution": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def findNsum(nums, target, N, result, results):\n            if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\n                return\n            if N == 2: # two pointers solve sorted 2-sum problem\n                l, r = 0, len(nums)-1\n                while l < r:\n                    s = nums[l] + nums[r]\n                    if s == target:\n                        results.append(result + [nums[l], nums[r]])\n                        l += 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n            else: # recursively reduce N\n                for i in range(len(nums)-N+1):\n                    if i == 0 or (i > 0 and nums[i-1] != nums[i]):\n                        findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\n\n        results = []\n        findNsum(sorted(nums), target, 4, [], results)\n        return results", "runtimes": [0.08725547790527344, 0.10049939155578613, 0.12495303153991699, 0.12622833251953125, 0.13165903091430664, 0.14684700965881348, 0.15669727325439453, 0.1634387969970703, 0.1635723114013672, 0.17133879661560059, 0.20101118087768555, 0.2646024227142334, 0.27838945388793945, 0.3007817268371582, 0.35695457458496094], "beyond_p": 1.0135219236209336}], "the-skyline-problem": [{"slug_name": "the-skyline-problem", "status": {"result": "failed@cases", "runtime": 0.000949859619140625, "index": 0}, "solution": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # add new building edges\n        edges = []\n        for L, R, H in buildings:\n            edges.append((L, 0, -H))\n            edges.append((R, 1, H))\n\n        # sort edges by x-coordinate, then by type, then by height\n        edges.sort()\n\n        # init heap\n        res = [[0, 0]] # [x, height]\n        live = [(0, float('inf'))] # [-height, ending position]\n\n        for x, tp, H in edges:\n            if tp == 0: # start of a building\n                heapq.heappush(live, (H, R))\n            else: # end of a building\n                while live[0][1] <= x: # pop outdated buildings\n                    heapq.heappop(live)\n            # if the highest building changes, append to result\n            if res[-1][1] != -live[0][0]:\n                res.append([x, -live[0][0]])\n        return res[1:]", "runtimes": [0.0006906986236572266, 0.0006976127624511719, 0.0007956027984619141, 0.0009796619415283203, 0.0012850761413574219, 0.0013298988342285156, 0.0014019012451171875, 0.0016057491302490234, 0.0017809867858886719, 0.0023162364959716797, 0.0023233890533447266, 0.003093242645263672, 0.003488302230834961, 0.004301309585571289, 0.004373788833618164, 0.004412412643432617, 0.004707813262939453, 0.007990121841430664], "beyond_p": 0.0}], "reverse-string": [{"slug_name": "reverse-string", "status": {"result": "passed", "runtime": 0.00042724609375, "index": 0}, "solution": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        i, j = 0, len(s) - 1\n        while i < j:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1", "runtimes": [0.0002722740173339844, 0.0002777576446533203, 0.00033020973205566406, 0.0003478527069091797, 0.0003514289855957031, 0.00039577484130859375, 0.00040602684020996094, 0.0004134178161621094, 0.00041604042053222656, 0.00041675567626953125, 0.0004210472106933594, 0.00043964385986328125, 0.0004398822784423828, 0.00044035911560058594, 0.0005209445953369141, 0.0005321502685546875, 0.0005342960357666016, 0.0005464553833007812, 0.0005490779876708984, 0.0005848407745361328, 0.0006160736083984375, 0.0006170272827148438, 0.0013310909271240234], "beyond_p": 0.8536365683404639}], "reverse-linked-list": [{"slug_name": "reverse-linked-list", "status": {"result": "passed", "runtime": 0.0003333091735839844, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Iterative solution\n        prev = None\n        while head:\n            curr = head\n            head = head.next\n            curr.next = prev\n            prev = curr\n        return prev\n\n        # Recursive solution\n        if not head or not head.next:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p", "runtimes": [0.0003039836883544922, 0.00030612945556640625, 0.0003063678741455078, 0.00030732154846191406, 0.0003108978271484375, 0.0003116130828857422, 0.00031256675720214844, 0.00031375885009765625, 0.00031566619873046875, 0.0003159046173095703, 0.00031638145446777344, 0.0003180503845214844, 0.00031828880310058594, 0.0003376007080078125, 0.0003426074981689453], "beyond_p": 0.24074074074074073}], "triangle": [{"slug_name": "triangle", "status": {"result": "passed", "runtime": 0.0003504753112792969, "index": 0}, "solution": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not triangle:\n            return \n        res = triangle[-1]\n        for i in range(len(triangle)-2, -1, -1):\n            for j in range(len(triangle[i])):\n                res[j] = min(res[j], res[j+1]) + triangle[i][j]\n        return res[0]", "runtimes": [0.00034117698669433594, 0.00035881996154785156, 0.00036025047302246094, 0.00036787986755371094, 0.000370025634765625, 0.0003762245178222656, 0.0003795623779296875, 0.0003800392150878906, 0.0003921985626220703, 0.00039267539978027344, 0.00040030479431152344, 0.0004341602325439453, 0.0004367828369140625, 0.0004451274871826172, 0.00047850608825683594, 0.0004825592041015625, 0.0004980564117431641, 0.0005736351013183594, 0.0007262229919433594, 0.0007419586181640625], "beyond_p": 0.9767995240928019}], "integer-to-english-words": [{"slug_name": "integer-to-english-words", "status": {"result": "passed", "runtime": 0.00033020973205566406, "index": 0}, "solution": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        def one(num):\n            switcher = {\n                1: 'One',\n                2: 'Two',\n                3: 'Three',\n                4: 'Four',\n                5: 'Five',\n                6: 'Six',\n                7: 'Seven',\n                8: 'Eight',\n                9: 'Nine'\n            }\n            return switcher.get(num)\n\n        def two_less_20(num):\n            switcher = {\n                10: 'Ten',\n                11: 'Eleven',\n                12: 'Twelve',\n                13: 'Thirteen',\n                14: 'Fourteen',\n                15: 'Fifteen',\n                16: 'Sixteen',\n                17: 'Seventeen',\n                18: 'Eighteen',\n                19: 'Nineteen'\n            }\n            return switcher.get(num)\n        \n        def ten(num):\n            switcher = {\n                2: 'Twenty',\n                3: 'Thirty',\n                4: 'Forty',\n                5: 'Fifty',\n                6: 'Sixty',\n                7: 'Seventy',\n                8: 'Eighty',\n                9: 'Ninety'\n            }\n            return switcher.get(num)\n\n        def two(num):\n            if not num:\n                return ''\n            elif num < 10:\n                return one(num)\n            elif num < 20:\n                return two_less_20(num)\n            else:\n                tenner = num // 10\n                rest = num - tenner * 10\n                return ten(tenner) + ' ' + one(rest) if rest else ten(tenner)\n\n        def three(num):\n            hundred = num // 100\n            rest = num - hundred * 100\n            if hundred and rest:\n                return one(hundred) + ' Hundred ' + two(rest)\n            elif not hundred and rest:\n                return two(rest)\n            elif hundred and not rest:\n                return one(hundred) + ' Hundred'\n\n        billion = num // 1000000000\n        million = (num - billion * 1000000000) // 1000000\n        thousand = (num - billion * 1000000000 - million * 1000000) // 1000\n        rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000\n\n        result = ''\n        if billion:        \n            result += three(billion) + ' Billion'\n        if million:        \n            result += ' ' if result else ''    \n            result += three(million) + ' Million'\n        if thousand:\n            result += ' ' if result else ''\n            result += three(thousand) + ' Thousand'\n        if rest:\n            result += ' ' if result else ''\n            result += three(rest)\n        return \"Zero\" if not result else result.strip()", "runtimes": [0.00028824806213378906, 0.00029468536376953125, 0.0002949237823486328, 0.0002980232238769531, 0.0003037452697753906, 0.00031113624572753906, 0.00031185150146484375, 0.0003123283386230469, 0.00031375885009765625, 0.0003223419189453125, 0.0003256797790527344, 0.0003540515899658203, 0.000370025634765625, 0.00037860870361328125], "beyond_p": 0.5356200527704486}], "k-inverse-pairs-array": [{"slug_name": "k-inverse-pairs-array", "status": {"result": "passed", "runtime": 0.23335981369018555, "index": 0}, "solution": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n            for j in range(1, k + 1):\n                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % MOD\n                if j - i >= 0:\n                    dp[i][j] -= dp[i - 1][j - i]\n                    dp[i][j] %= MOD\n        return dp[n][k]\n\n# Time: O(n*k)\n# Space: O(n*k)\n\n# Test Cases\nif __name__ == \"__main__\":\n    solution = Solution()\n    assert solution.kInversePairs(3, 0) == 1\n    assert solution.kInversePairs(3, 1) == 2\n\n# Explanation:\n# This problem can be solved using dynamic programming.\n# dp[i][j] represents the number of different arrays consist of numbers from 1 to i such that there are exactly j inverse pairs.\n# The transition function is dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - i] if j - i >= 0 else dp[i][j] = dp[i][j - 1] + dp[i - 1][j].\n# The result is dp[n][k].\n# The time complexity is O(n*k) and the space complexity is O(n*k).\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10^9 + 7 to prevent overflow.\n# The result is modulo 10", "runtimes": [0.108489990234375, 0.11166048049926758, 0.11201953887939453, 0.14506125450134277, 0.14602923393249512, 0.15845203399658203, 0.16930508613586426, 0.19072437286376953, 0.20940184593200684, 0.2251722812652588, 0.23598170280456543, 0.3026621341705322, 0.30571794509887695, 0.3841567039489746, 0.4292449951171875, 0.43761420249938965, 0.62223219871521, 0.712439775466919, 0.795917272567749], "beyond_p": 0.818351952759341}], "swap-nodes-in-pairs": [{"slug_name": "swap-nodes-in-pairs", "status": {"result": "passed", "runtime": 0.0005321502685546875, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        first_node = head\n        second_node = head.next\n        \n        first_node.next = self.swapPairs(second_node.next)\n        second_node.next = first_node\n        \n        return second_node", "runtimes": [0.0005190372467041016, 0.0005209445953369141, 0.0005209445953369141, 0.0005221366882324219, 0.0005235671997070312, 0.0005254745483398438, 0.0005261898040771484, 0.0005261898040771484, 0.0005271434783935547, 0.0005283355712890625, 0.0005288124084472656, 0.0005292892456054688, 0.000530242919921875, 0.0005307197570800781, 0.0005314350128173828, 0.0005328655242919922, 0.0005333423614501953, 0.0005347728729248047, 0.0005347728729248047, 0.0005376338958740234, 0.0005395412445068359, 0.0005407333374023438, 0.0005424022674560547, 0.0005445480346679688, 0.0005450248718261719, 0.0005457401275634766, 0.0005466938018798828, 0.00055694580078125, 0.0005590915679931641, 0.0007145404815673828, 0.0007424354553222656], "beyond_p": 0.9413020277481323}], "path-sum": [{"slug_name": "path-sum", "status": {"result": "passed", "runtime": 0.0007412433624267578, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        \n        targetSum -= root.val\n        \n        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)", "runtimes": [0.0007228851318359375, 0.0007340908050537109, 0.0007364749908447266, 0.0007371902465820312, 0.0007376670837402344, 0.0007381439208984375, 0.0007393360137939453, 0.0007472038269042969, 0.0007519721984863281, 0.0007519721984863281, 0.0007545948028564453, 0.000762939453125, 0.0007636547088623047, 0.0007767677307128906, 0.0007812976837158203, 0.0007832050323486328, 0.0007841587066650391, 0.0008218288421630859, 0.0009336471557617188, 0.0018458366394042969], "beyond_p": 0.983651804670913}], "partition-list": [{"slug_name": "partition-list", "status": {"result": "passed", "runtime": 0.0008873939514160156, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Create two dummy nodes for two lists\n        before = before_head = ListNode(0)\n        after = after_head = ListNode(0)\n        \n        # Traverse the given list\n        while head:\n            # If the current node's value is less than x, append it to the before list\n            if head.val < x:\n                before.next = head\n                before = before.next\n            # If the current node's value is greater or equal to x, append it to the after list\n            else:\n                after.next = head\n                after = after.next\n            # Move to the next node\n            head = head.next\n        \n        # End the after list\n        after.next = None\n        # Combine the two lists\n        before.next = after_head.next\n        \n        return before_head.next\n\n# Time complexity: O(n), where n is the number of nodes in the given list.\n# Space complexity: O(1), as we are not using any extra space.\n\n# Test cases:\n# head = [1,4,3,2,5,2], x = 3\n# head = [2,1], x = 2\n# head = [], x = 0\n# head = [1,1,1,1,1,1], x = 1\n# head = [2,2,2,2,2,2], x = 1\n# head = [1,2,3,4,5,6], x = 3\n# head = [6,5,4,3,2,1], x = 3\n# head = [1,2,3,4,5,6], x = 7\n# head = [6,5,4,3,2,1], x = 0\n# head = [1,1,1,1,1,1], x = 0\n# head = [2,2,2,2,2,2], x = 2\n# head = [1,2,3,4,5,6], x = 0\n# head = [6,5,4,3,2,1], x = 7\n# head = [1,2,3,4,5,6], x = 4\n# head = [6,5,4,3,2,1], x = 4\n# head = [1,2,3,4,5,6], x = 5\n# head = [6,5,4,3,2,1], x = 5\n# head = [1,2,3,4,5,6], x = 6\n# head = [6,5,4,3,2,1], x = 6\n# head = [1,2,3,4,5,6], x = 7\n# head = [6,5,4,3,2,1], x = 7\n# head = [1,2,3,4,5,6], x = 8\n# head = [6,5,4,3,2,1], x = 8\n# head = [1,2,3,4,5,6], x = 9\n# head = [6,5,4,3,2,1], x = 9\n# head = [1,2,3,4,5,6], x = 10\n# head = [6,5,4,3,2,1], x = 10\n# head = [1,2,3,4,5,6], x = 11\n# head = [6,5,4,3,2,1], x = 11\n# head = [1,2,3,4,5,6], x = 12\n# head = [6,5,4,3,2,1], x = 12\n# head = [1,2,3,4,5,6], x = 13\n# head = [6,5,4,3,2,1], x = 13\n# head = [1,2,3,4,5,6], x = 14\n# head = [6,5,4,3,2,1], x = 14\n# head = [1,2,3,4,5,6], x = 15\n# head = [6,5,4,3,2,1], x = 15\n# head = [1,2,3,4,5,6], x = 16\n# head = [6,5,4,3,2,1], x = 16\n# head = [1,2", "runtimes": [0.0008447170257568359, 0.0008571147918701172, 0.0008666515350341797, 0.0008666515350341797, 0.000873565673828125, 0.0008742809295654297, 0.0008766651153564453, 0.0008788108825683594, 0.0008838176727294922, 0.0008938312530517578, 0.0008955001831054688, 0.0009021759033203125, 0.0009064674377441406, 0.0009157657623291016, 0.0010955333709716797, 0.0011029243469238281], "beyond_p": 0.8347183748845799}], "redundant-connection-ii": [{"slug_name": "redundant-connection-ii", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [0] * (n + 1)\n        candidates = []\n        for edge in edges:\n            if parent[edge[1]] == 0:\n                parent[edge[1]] = edge[0]\n            else:\n                candidates.append([parent[edge[1]], edge[1]])\n                candidates.append(edge)\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        def union(x, y):\n            parent[find(x)] = find(y)\n        for i in range(1, n + 1):\n            parent[i] = i\n        for edge in edges:\n            if [edge[0], edge[1]] != candidates[1]:\n                if find(edge[0]) == find(edge[1]):\n                    if candidates[0] == []:\n                        return edge\n                    return candidates[0]\n                union(edge[0], edge[1])\n        return candidates[1]", "runtimes": [0.0013475418090820312, 0.0028581619262695312, 0.0032858848571777344, 0.0033223628997802734, 0.003560304641723633, 0.004286050796508789, 0.00443720817565918, 0.004534244537353516, 0.005108356475830078, 0.005148649215698242, 0.04450106620788574, 0.16016721725463867, 0.16188740730285645, 0.16900277137756348, 0.19779038429260254, 0.31722378730773926, 0.33400607109069824, 2.7634379863739014], "beyond_p": 0.0}], "permutations-ii": [{"slug_name": "permutations-ii", "status": {"result": "passed", "runtime": 0.0004513263702392578, "index": 0}, "solution": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(nums, path, res):\n            if not nums:\n                res.append(path)\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\n        \n        nums.sort()\n        res = []\n        dfs(nums, [], res)\n        return res", "runtimes": [0.0003209114074707031, 0.0003371238708496094, 0.000339508056640625, 0.00034999847412109375, 0.0003502368927001953, 0.00035381317138671875, 0.0003604888916015625, 0.00036334991455078125, 0.0003714561462402344, 0.00038695335388183594, 0.00039696693420410156, 0.00043702125549316406, 0.00044918060302734375, 0.00046133995056152344, 0.0004944801330566406, 0.0005040168762207031, 0.0005431175231933594, 0.000560760498046875, 0.0005640983581542969, 0.0005698204040527344, 0.0005934238433837891, 0.0008027553558349609], "beyond_p": 0.7293419099455715}], "add-digits": [{"slug_name": "add-digits", "status": {"result": "passed", "runtime": 0.0002636909484863281, "index": 0}, "solution": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num >= 10:\n            num = sum(map(int, str(num)))\n        return num", "runtimes": [0.00023698806762695312, 0.000240325927734375, 0.00024080276489257812, 0.00024437904357910156, 0.0002448558807373047, 0.00025153160095214844, 0.0002601146697998047, 0.0003037452697753906, 0.00031375885009765625, 0.0003154277801513672, 0.0003185272216796875, 0.0003261566162109375, 0.0003292560577392578, 0.0003600120544433594], "beyond_p": 0.7829457364341085}], "single-number": [{"slug_name": "single-number", "status": {"result": "passed", "runtime": 0.0004544258117675781, "index": 0}, "solution": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the unique number...\n        uniqNum = 0\n        # For every number in nums...\n        for i in nums:\n            # Update the unique number...\n            uniqNum ^= i\n        return uniqNum      # Return the unique number...", "runtimes": [0.00034046173095703125, 0.0003962516784667969, 0.00043964385986328125, 0.0004584789276123047, 0.0004584789276123047, 0.0004620552062988281, 0.0004792213439941406, 0.0004901885986328125, 0.0004925727844238281, 0.0005567073822021484, 0.0005834102630615234, 0.0006084442138671875, 0.0006453990936279297, 0.0006630420684814453, 0.0006632804870605469, 0.0006673336029052734, 0.0006821155548095703, 0.0006983280181884766, 0.0007028579711914062, 0.0007100105285644531, 0.000713348388671875, 0.000736236572265625, 0.0007379055023193359, 0.000911712646484375], "beyond_p": 0.8005008347245409}], "length-of-last-word": [{"slug_name": "length-of-last-word", "status": {"result": "passed", "runtime": 0.0006318092346191406, "index": 0}, "solution": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.strip().split(' ')[-1])", "runtimes": [0.0002875328063964844, 0.0003643035888671875, 0.0004849433898925781, 0.0004863739013671875, 0.00048732757568359375, 0.0004923343658447266, 0.0004968643188476562, 0.0005013942718505859, 0.0005030632019042969, 0.0005121231079101562, 0.0005638599395751953, 0.0006153583526611328, 0.0006494522094726562, 0.0019295215606689453], "beyond_p": 0.7903296065050094}], "cherry-pickup": [{"slug_name": "cherry-pickup", "status": {"result": "failed@cases", "runtime": 0.012941122055053711, "index": 0}, "solution": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        N = len(grid)\n        dp = [[float('-inf')] * N for _ in range(N)]\n        dp[0][0] = grid[0][0]\n\n        for t in range(1, 2 * N - 1):\n            dp2 = [row[:] for row in dp]\n            for i in range(max(t - (N - 1), 0), min(t + 1, N)):\n                for j in range(max(t - (N - 1), 0), min(t + 1, N)):\n                    if grid[i][t - i] == -1 or grid[j][t - j] == -1:\n                        continue\n                    val = grid[i][t - i]\n                    if i != j: val += grid[j][t - j]\n                    dp2[i][j] = max(dp[pi][pj] + val\n                                   for pi in (i-1, i) for pj in (j-1, j)\n                                   if pi >= 0 and pj >= 0)\n            dp = dp2\n        return max(dp[N-1][N-1], 0)", "runtimes": [0.0010180473327636719, 0.0010399818420410156, 0.0010793209075927734, 0.0012850761413574219, 0.0013537406921386719, 0.0013556480407714844, 0.0013797283172607422, 0.0014548301696777344, 0.0014812946319580078, 0.0016474723815917969, 0.0016558170318603516, 0.0017082691192626953, 0.0019478797912597656, 0.0026073455810546875, 0.002668142318725586, 0.002704620361328125, 0.018138408660888672, 0.022002220153808594, 0.022632837295532227, 0.19229793548583984], "beyond_p": 0.0}], "student-attendance-record-ii": [{"slug_name": "student-attendance-record-ii", "status": {"result": "failed@cases", "runtime": 0.25181007385253906, "index": 0}, "solution": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        if n == 1:\n            return 3\n        if n == 2:\n            return 8\n        if n == 3:\n            return 19\n\n        dp = [1, 2, 4, 7] + [0] * (n - 3)\n        sums = [1, 3, 7, 13] + [0] * (n - 3)\n\n        for i in range(4, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD\n            sums[i] = (sums[i - 1] + dp[i]) % MOD\n\n        result = (dp[n] + MOD) % MOD\n\n        for i in range(n):\n            result += dp[i] * ((dp[n - 1 - i] + MOD - (0 if n - i - 2 < 0 else dp[n - i - 2])) % MOD)\n            result %= MOD\n\n        return result", "runtimes": [0.0069925785064697266, 0.008358478546142578, 0.11251616477966309, 0.20759177207946777, 0.8803191184997559, 0.987525463104248, 1.0358843803405762, 1.038557529449463, 1.2613377571105957, 1.336045742034912, 2.199801445007324, 2.2905852794647217, 2.441685676574707, 2.487722396850586, 2.998396396636963, 3.0943009853363037], "beyond_p": 0.0}], "happy-number": [{"slug_name": "happy-number", "status": {"result": "passed", "runtime": 0.00031304359436035156, "index": 0}, "solution": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n\n        return n == 1", "runtimes": [0.0002684593200683594, 0.0002715587615966797, 0.0003097057342529297, 0.0003104209899902344, 0.0003123283386230469, 0.00031280517578125, 0.0003209114074707031, 0.0003235340118408203, 0.00032830238342285156, 0.0003330707550048828, 0.00033974647521972656, 0.00034117698669433594, 0.00034546852111816406, 0.0003497600555419922, 0.0003502368927001953, 0.00036144256591796875, 0.00036907196044921875, 0.0008275508880615234], "beyond_p": 0.9202558635394457}], "search-insert-position": [{"slug_name": "search-insert-position", "status": {"result": "passed", "runtime": 0.0002689361572265625, "index": 0}, "solution": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left", "runtimes": [0.00026607513427734375, 0.0002663135528564453, 0.0002665519714355469, 0.0002675056457519531, 0.0002689361572265625, 0.0002696514129638672, 0.0002701282501220703, 0.0002701282501220703, 0.000270843505859375, 0.00027108192443847656, 0.00027179718017578125, 0.00027251243591308594, 0.00027489662170410156, 0.0002753734588623047, 0.0002765655517578125, 0.00027680397033691406, 0.00027823448181152344, 0.00027823448181152344, 0.000278472900390625, 0.0002799034118652344, 0.0002830028533935547, 0.0002837181091308594, 0.0003032684326171875, 0.0003261566162109375], "beyond_p": 0.9523809523809523}], "jump-game": [{"slug_name": "jump-game", "status": {"result": "passed", "runtime": 0.0002956390380859375, "index": 0}, "solution": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reachable = 0\n        for i, num in enumerate(nums):\n            if i > max_reachable:\n                return False\n            max_reachable = max(max_reachable, i + num)\n        return True", "runtimes": [0.0002410411834716797, 0.0002510547637939453, 0.00025177001953125, 0.0002548694610595703, 0.00025725364685058594, 0.0002574920654296875, 0.00027060508728027344, 0.00028443336486816406, 0.0002872943878173828, 0.0002913475036621094, 0.00029206275939941406, 0.0002963542938232422, 0.0003123283386230469, 0.00031304359436035156, 0.00031828880310058594, 0.0003197193145751953, 0.0003256797790527344, 0.0003371238708496094, 0.00033855438232421875, 0.00034332275390625, 0.0003814697265625, 0.00039458274841308594], "beyond_p": 0.6444099378881988}], "minimum-path-sum": [{"slug_name": "minimum-path-sum", "status": {"result": "passed", "runtime": 0.0032508373260498047, "index": 0}, "solution": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n            \n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n            \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n                \n        return dp[-1][-1]", "runtimes": [0.0030269622802734375, 0.003041982650756836, 0.0030558109283447266, 0.0030586719512939453, 0.003080129623413086, 0.003377199172973633, 0.0034589767456054688, 0.0035119056701660156, 0.0036156177520751953, 0.00363922119140625, 0.0037870407104492188, 0.003924369812011719, 0.006564617156982422, 0.006681919097900391, 0.006903409957885742, 0.007887601852416992, 0.008049488067626953, 0.010036945343017578, 0.014330148696899414, 0.015843629837036133, 0.01751542091369629], "beyond_p": 0.9845480425875035}], "count-and-say": [{"slug_name": "count-and-say", "status": {"result": "passed", "runtime": 0.0017673969268798828, "index": 0}, "solution": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        def next_number(s):\n            result, i = [], 0\n            \n            while i < len(s):\n                count = 1\n                while i + 1 < len(s) and s[i] == s[i+1]:\n                    i += 1\n                    count += 1\n                result.append(str(count) + s[i])\n                i += 1\n            return ''.join(result)\n        \n        s = '1'\n        for i in range(n-1):\n            s = next_number(s)\n        return s", "runtimes": [0.0008099079132080078, 0.0009176731109619141, 0.0009469985961914062, 0.0009560585021972656, 0.0010037422180175781, 0.001009225845336914, 0.0010938644409179688, 0.0011589527130126953, 0.001216888427734375, 0.0012197494506835938, 0.0012950897216796875, 0.001367330551147461, 0.0014564990997314453, 0.0015268325805664062, 0.0016477108001708984, 0.0016803741455078125, 0.0017175674438476562, 0.0018532276153564453, 0.004172325134277344], "beyond_p": 0.7152378926469546}], "split-array-largest-sum": [{"slug_name": "split-array-largest-sum", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def is_possible(mid):\n            cuts, curr_sum = 0, 0\n            for num in nums:\n                curr_sum += num\n                if curr_sum > mid:\n                    cuts, curr_sum = cuts + 1, num\n            subs = cuts + 1\n            return subs <= k\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if is_possible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.splitArray([7,2,5,10,8], 2))\n    print(s.splitArray([1,2,3,4,5], 2))\n\n# Time complexity: O(nlog(sum(nums)))\n# Space complexity: O(1)# Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n# You may assume that each input would have exactly one solution, and you may not use the same element twice.\n# You can return the answer in any order.\n\n# Example 1:\n# Input: nums = [2,7,11,15], target = 9\n# Output: [0,1]\n# Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n# Example 2:\n# Input: nums = [3,2,4], target = 6\n# Output: [1,2]\n\n# Example 3:\n# Input: nums = [3,3], target = 6\n# Output: [0,1]\n\n# Constraints:\n# 2 <= nums.length <= 104\n# -109 <= nums[i] <= 109\n# -109 <= target <= 109\n# Only one valid answer exists.\n\n# Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\n\nfrom typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashmap = {}\n        for i, num in enumerate(nums):\n            if target - num in hashmap:\n                return [hashmap[target - num], i]\n            hashmap[num] = i\n        return []\n\n# Test cases\ns = Solution()\nprint(s.twoSum([2,7,11,15], 9)) # [0,1]\nprint(s.twoSum([3,2,4], 6)) # [1,2]\nprint(s.twoSum([3,3], 6)) # [0,1]# Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.\n\n# Example 1:\n\n# Input: nums = [4,6,7,7]\n# Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n\n# Example 2:\n\n# Input: nums = [4,4,3,2,1]\n# Output: [[4,4]]\n\n# Constraints:\n\n#     1 <= nums.length <= 15\n#     -100 <= nums[i] <= 100\n\nfrom typing import List\n\nclass Solution:\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        self.dfs(nums, 0, [], res)\n        return res\n\n    def dfs(self, nums, index, path, res):\n        if len(path) >= 2:\n            res.append(path)\n        visited = set()\n        for i in range(index, len(nums)):\n            if (path and nums[i] < path[-1]) or nums[i] in visited:\n                continue\n            visited", "runtimes": [0.004990100860595703, 0.027725696563720703, 0.4413166046142578, 0.45514941215515137, 0.45588088035583496, 0.47921013832092285, 0.5154755115509033, 0.5641591548919678, 0.5674774646759033, 0.5768637657165527, 0.6765806674957275, 0.9646015167236328, 2.733832836151123, 4.040373086929321, 4.6326189041137695, 5.16236686706543, 5.58795428276062, 6.404732704162598, 9.008362531661987, 10.241864681243896, 20.480162382125854], "beyond_p": 0.0}], "search-in-rotated-sorted-array": [{"slug_name": "search-in-rotated-sorted-array", "status": {"result": "passed", "runtime": 0.0003452301025390625, "index": 0}, "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] >= nums[left]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1", "runtimes": [0.0003387928009033203, 0.00034165382385253906, 0.00034308433532714844, 0.00034332275390625, 0.0003457069396972656, 0.0003466606140136719, 0.0003483295440673828, 0.0003490447998046875, 0.0003497600555419922, 0.0003504753112792969, 0.0003514289855957031, 0.0003597736358642578, 0.000377655029296875, 0.0005524158477783203, 0.0006074905395507812, 0.0008907318115234375, 0.0015859603881835938], "beyond_p": 0.9948384630089849}], "letter-combinations-of-a-phone-number": [{"slug_name": "letter-combinations-of-a-phone-number", "status": {"result": "failed@cases", "runtime": 0.0003120899200439453, "index": 0}, "solution": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', \n                   '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        \n        result = ['']\n        \n        for digit in digits:\n            temp = []\n            for char in mapping[digit]:\n                for str in result:\n                    temp.append(str + char)\n            result = temp\n        \n        return result", "runtimes": [0.0003147125244140625, 0.0003218650817871094, 0.0003247261047363281, 0.00033736228942871094, 0.0003387928009033203, 0.0003421306610107422, 0.00034499168395996094, 0.0003459453582763672, 0.00034618377685546875, 0.0003464221954345703, 0.0003490447998046875, 0.0003528594970703125, 0.0003533363342285156, 0.0003540515899658203, 0.0003590583801269531, 0.0003628730773925781, 0.0003631114959716797, 0.0003635883331298828, 0.0003647804260253906, 0.0003726482391357422, 0.0003781318664550781, 0.0003800392150878906, 0.00038552284240722656, 0.00041985511779785156, 0.0005054473876953125, 0.0005393028259277344], "beyond_p": 0.0}], "combination-sum": [{"slug_name": "combination-sum", "status": {"result": "failed@cases", "runtime": 0.0011315345764160156, "index": 0}, "solution": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, start, path, res):\n            if target < 0:\n                return \n            if target == 0:\n                return res.append(path)\n            for i in range(start, len(candidates)):\n                dfs(candidates, target-candidates[i], i, path+[candidates[i]], res)\n        \n        res = []\n        candidates.sort()\n        dfs(candidates, target, 0, [], res)\n        return res", "runtimes": [0.0005636215209960938, 0.0005669593811035156, 0.0008945465087890625, 0.0010221004486083984, 0.001222372055053711, 0.0013422966003417969, 0.0016090869903564453, 0.004095315933227539, 0.005171298980712891], "beyond_p": 0.0}], "find-the-closest-palindrome": [{"slug_name": "find-the-closest-palindrome", "status": {"result": "passed", "runtime": 0.0003216266632080078, "index": 0}, "solution": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        length = len(n)\n        candidates = set((str(10**l + d) for l in (length - 1, length) for d in (-1, 1)))\n        prefix = int(n[:(length + 1)//2])\n        for start in map(str, (prefix - 1, prefix, prefix + 1)):\n            candidates.add(start + (start[:-1] if length%2 else start)[::-1])\n        candidates.discard(n)\n        return min(candidates, key=lambda x: (abs(int(x) - int(n)), int(x)))", "runtimes": [0.0002639293670654297, 0.0002713203430175781, 0.0002739429473876953, 0.0002789497375488281, 0.0002841949462890625, 0.0002911090850830078, 0.00029277801513671875, 0.0002949237823486328, 0.00029778480529785156, 0.00030159950256347656, 0.0003101825714111328, 0.00031447410583496094, 0.0003216266632080078, 0.0003249645233154297, 0.000335693359375, 0.00033855438232421875, 0.00040459632873535156], "beyond_p": 0.5898305084745763}], "spiral-matrix-ii": [{"slug_name": "spiral-matrix-ii", "status": {"result": "passed", "runtime": 0.0003025531768798828, "index": 0}, "solution": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0]*n for _ in range(n)]\n        dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]\n        x, y, c = 0, 0, 0\n        for i in range(1, n*n+1):\n            matrix[x][y] = i\n            nx, ny = x + dx[c], y + dy[c]\n            if nx < 0 or nx == n or ny < 0 or ny == n or matrix[nx][ny] != 0:\n                c = (c + 1) % 4\n                nx, ny = x + dx[c], y + dy[c]\n            x, y = nx, ny\n        return matrix", "runtimes": [0.0002677440643310547, 0.00027823448181152344, 0.0002791881561279297, 0.00028014183044433594, 0.0002830028533935547, 0.0002853870391845703, 0.000286102294921875, 0.0002865791320800781, 0.0002875328063964844, 0.00032067298889160156, 0.0003376007080078125, 0.0006239414215087891], "beyond_p": 0.9022757697456493}], "reverse-integer": [{"slug_name": "reverse-integer", "status": {"result": "passed", "runtime": 0.00028228759765625, "index": 0}, "solution": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = int(str(x)[:0:-1]) * -1\n        else:\n            x = int(str(x)[::-1])\n        \n        if x not in range(-2**31, 2**31):\n            return 0\n        else:\n            return x", "runtimes": [0.00026488304138183594, 0.00026679039001464844, 0.00026726722717285156, 0.00026917457580566406, 0.00027179718017578125, 0.0002722740173339844, 0.00027370452880859375, 0.00028705596923828125, 0.0002884864807128906, 0.0002892017364501953, 0.00029087066650390625, 0.0002925395965576172, 0.0002956390380859375, 0.00033402442932128906, 0.0003368854522705078, 0.0003390312194824219], "beyond_p": 0.7652733118971061}], "rotate-image": [{"slug_name": "rotate-image", "status": {"result": "passed", "runtime": 0.0004134178161621094, "index": 0}, "solution": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i]\n\n        for i in range(n):\n            matrix[i].reverse()", "runtimes": [0.00039267539978027344, 0.0003998279571533203, 0.0004055500030517578, 0.00040721893310546875, 0.0004119873046875, 0.0004131793975830078, 0.0004177093505859375, 0.0004203319549560547, 0.00043129920959472656, 0.00043320655822753906, 0.00048232078552246094, 0.0004849433898925781, 0.0005216598510742188, 0.0005495548248291016, 0.0006172657012939453, 0.0009417533874511719], "beyond_p": 0.9622231871471993}], "maximum-product-subarray": [{"slug_name": "maximum-product-subarray", "status": {"result": "passed", "runtime": 0.0005154609680175781, "index": 0}, "solution": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            \n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            \n            result = max(result, max_product)\n        \n        return result\n    \n\ndef _test():\n    import time\n    start = time.time()\n    print(Solution().maxProduct([2,3,-2,4]))\n    print(Solution().maxProduct([-2,0,-1]))\n    print(\"Time elapsed: \", time.time() - start)", "runtimes": [0.0004088878631591797, 0.00041103363037109375, 0.00041413307189941406, 0.0004210472106933594, 0.0004215240478515625, 0.0004222393035888672, 0.0004239082336425781, 0.00042510032653808594, 0.00042629241943359375, 0.0004265308380126953, 0.00042724609375, 0.0004298686981201172, 0.0004382133483886719, 0.0004401206970214844, 0.00045800209045410156, 0.0005071163177490234, 0.0005083084106445312, 0.0005140304565429688, 0.0005171298980712891, 0.0005173683166503906, 0.0005221366882324219, 0.0005314350128173828, 0.0005753040313720703], "beyond_p": 0.35959885386819485}], "frog-jump": [{"slug_name": "frog-jump", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if stones[1] != 1:\n            return False\n        \n        dp = [set() for _ in range(len(stones))]\n        dp[1].add(1)\n        \n        stone_set = set(stones)\n        \n        for i in range(2, len(stones)):\n            for j in range(i):\n                diff = stones[i] - stones[j]\n                if diff - 1 in dp[j] or diff in dp[j] or diff + 1 in dp[j]:\n                    dp[i].add(diff)\n        \n        return len(dp[-1]) > 0\n    \n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        if stones[1] != 1:\n            return False\n        dp = [set() for _ in range(len(stones))]\n        dp[1].add(1)\n        stone_set = set(stones)\n        for i in range(2, len(stones)):\n            for j in range(i):\n                diff = stones[i] - stones[j]\n                if diff - 1 in dp[j] or diff in dp[j] or diff + 1 in dp[j]:\n                    dp[i].add(diff)\n        return len(dp[-1]) > 0\n    \n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        if stones[1] != 1:\n            return False\n        dp = [set() for _ in range(len(stones))]\n        dp[1].add(1)\n        stone_set = set(stones)\n        for i in range(2, len(stones)):\n            for j in range(i):\n                diff = stones[i] - stones[j]\n                if diff - 1 in dp[j] or diff in dp[j] or diff + 1 in dp[j]:\n                    dp[i].add(diff)\n        return len(dp[-1]) > 0\n    \n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        if stones[1] != 1:\n            return False\n        dp = [set() for _ in range(len(stones))]\n        dp[1].add(1)\n        stone_set = set(stones)\n        for i in range(2, len(stones)):\n            for j in range(i):\n                diff = stones[i] - stones[j]\n                if diff - 1 in dp[j] or diff in dp[j] or diff + 1 in dp[j]:\n                    dp[i].add(diff)\n        return len(dp[-1]) > 0\n    \n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        if stones[1] != 1:\n            return False\n        dp = [set() for _ in range(len(stones))]\n        dp[1].add(1)\n        stone_set = set(stones)\n        for i in range(2, len(stones)):\n            for j in range(i):\n                diff = stones[i] - stones[j]\n                if diff - 1 in dp[j] or diff in dp[j] or diff + 1 in dp[j]:\n                    dp[i].add(diff)\n        return len(dp[-1]) > 0\n    \n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        if stones[1] != 1:\n            return False\n        dp = [set() for _ in range(len(stones))]\n        dp[1].add(1)\n        stone_set = set(stones)\n        for i in range(2, len(stones)):\n            for j in range(i):\n                diff = stones[i] - stones[j]\n                if diff - 1 in dp[j] or diff in dp[", "runtimes": [0.0002529621124267578, 0.0002579689025878906, 0.0002605915069580078, 0.0002856254577636719, 0.00030231475830078125, 0.00031256675720214844, 0.00031256675720214844, 0.0003414154052734375, 0.0003681182861328125, 0.0003781318664550781, 0.0004799365997314453, 0.00048470497131347656, 0.0005903244018554688, 0.0007009506225585938, 0.0008921623229980469, 0.0014052391052246094, 0.011700153350830078, 0.05357646942138672, 0.06013798713684082, 0.06207084655761719, 0.06980657577514648, 0.11706662178039551, 0.12302541732788086], "beyond_p": 0.0}], "relative-ranks": [{"slug_name": "relative-ranks", "status": {"result": "passed", "runtime": 0.0003733634948730469, "index": 0}, "solution": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        medals = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"] + [str(i) for i in range(4, len(score) + 1)]\n        score_sorted = sorted(score, reverse=True)\n        score_dict = dict(zip(score_sorted, medals))\n        return [score_dict[i] for i in score]", "runtimes": [0.00036907196044921875, 0.0004813671112060547, 0.0005159378051757812, 0.0005173683166503906, 0.0005180835723876953, 0.0005230903625488281, 0.00052642822265625, 0.0005326271057128906, 0.0005347728729248047, 0.0005364418029785156, 0.0005419254302978516, 0.0005433559417724609, 0.0005486011505126953, 0.0005629062652587891, 0.0006151199340820312, 0.0006203651428222656, 0.0006248950958251953, 0.0013129711151123047], "beyond_p": 0.9954533973225562}], "longest-substring-without-repeating-characters": [{"slug_name": "longest-substring-without-repeating-characters", "status": {"result": "passed", "runtime": 0.00033473968505859375, "index": 0}, "solution": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        max_len = 0\n        start = 0\n        char_dict = {}\n        for i in range(len(s)):\n            if s[i] in char_dict and char_dict[s[i]] >= start:\n                start = char_dict[s[i]] + 1\n            else:\n                max_len = max(max_len, i - start + 1)\n            char_dict[s[i]] = i\n        return max_len", "runtimes": [0.00031495094299316406, 0.00033354759216308594, 0.00034880638122558594, 0.0003604888916015625, 0.00036525726318359375, 0.0004029273986816406, 0.00040340423583984375, 0.00042176246643066406, 0.0004379749298095703, 0.0004520416259765625, 0.00045871734619140625, 0.00049591064453125, 0.0005025863647460938, 0.0005271434783935547, 0.0005321502685546875, 0.0005390644073486328, 0.0006093978881835938, 0.0006649494171142578, 0.0006926059722900391, 0.0007357597351074219], "beyond_p": 0.9529745042492918}], "substring-with-concatenation-of-all-words": [{"slug_name": "substring-with-concatenation-of-all-words", "status": {"result": "passed", "runtime": 0.0011088848114013672, "index": 0}, "solution": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        from collections import Counter\n        if not s or not words:\n            return []\n        wordBag = Counter(words)  \n        wordLen, numWords = len(words[0]), len(words)\n        totalLen, res = wordLen*numWords, []\n        for i in range(len(s)-totalLen+1):\n            if Counter(self.fetchWords(s, i, wordLen, numWords)) == wordBag:\n                res.append(i)\n        return res\n\n    def fetchWords(self, s, start, wordLen, numWords):\n        return [s[start+i*wordLen:start+(i+1)*wordLen] for i in range(numWords)]", "runtimes": [0.0003528594970703125, 0.00035500526428222656, 0.0003731250762939453, 0.0004372596740722656, 0.0004374980926513672, 0.00044226646423339844, 0.00048041343688964844, 0.0005269050598144531, 0.00057220458984375, 0.0006024837493896484, 0.0006232261657714844, 0.0006284713745117188, 0.0006287097930908203, 0.0006382465362548828, 0.0006792545318603516, 0.000762939453125, 0.0008349418640136719, 0.0009126663208007812, 0.0009214878082275391, 0.0013325214385986328, 0.0013976097106933594], "beyond_p": 0.2763578274760383}], "max-chunks-to-make-sorted-ii": [{"slug_name": "max-chunks-to-make-sorted-ii", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_ = arr[0]\n        cnt = 0\n        for i, num in enumerate(arr):\n            max_ = max(max_, num)\n            if max_ == i:\n                cnt += 1\n        return cnt\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.maxChunksToSorted([5,4,3,2,1]))\n    print(s.maxChunksToSorted([2,1,3,4,4]))\n\n# Time complexity: O(n)\n# Space complexity: O(1)class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_ = arr[0]\n        cnt = 0\n        for i, num in enumerate(arr):\n            max_ = max(max_, num)\n            if max_ == i:\n                cnt += 1\n        return cnt\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.maxChunksToSorted([5,4,3,2,1]))\n    print(s.maxChunksToSorted([2,1,3,4,4]))\n\n# Time complexity: O(n)\n# Space complexity: O(1)class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_ = arr[0]\n        cnt = 0\n        for i, num in enumerate(arr):\n            max_ = max(max_, num)\n            if max_ == i:\n                cnt += 1\n        return cnt\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.maxChunksToSorted([5,4,3,2,1]))\n    print(s.maxChunksToSorted([2,1,3,4,4]))\n\n# Time complexity: O(n)\n# Space complexity: O(1)class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_ = arr[0]\n        cnt = 0\n        for i, num in enumerate(arr):\n            max_ = max(max_, num)\n            if max_ == i:\n                cnt += 1\n        return cnt\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.maxChunksToSorted([5,4,3,2,1]))\n    print(s.maxChunksToSorted([2,1,3,4,4]))\n\n# Time complexity: O(n)\n# Space complexity: O(1)class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_ = arr[0]\n        cnt = 0\n        for i, num in enumerate(arr):\n            max_ = max(max_, num)\n            if max_ == i:\n                cnt += 1\n        return cnt\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.maxChunksToSorted([5,4,3,2,1]))\n    print(s.maxChunksToSorted([2,1,3,4,4]))\n\n# Time complexity: O(n)\n# Space complexity: O(1)class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_ = arr[0]\n        cnt = 0\n        for i, num in enumerate(arr):\n            max_ = max(max_, num)\n            if max_ == i:\n                cnt += 1\n        return cnt\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.maxChunksToSorted([5,4,3,2,1]))\n    print(s.maxChunksToSorted([2,1,3,4,4]))\n\n# Time complexity: O(n)\n# Space complexity: O(1)class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int", "runtimes": [0.0011076927185058594, 0.001142740249633789, 0.0011899471282958984, 0.0015497207641601562, 0.0018494129180908203, 0.0021982192993164062, 0.002230405807495117, 0.0023238658905029297, 0.002517223358154297, 0.0026047229766845703, 0.0031909942626953125, 0.0032265186309814453, 0.0041086673736572266, 0.010168313980102539, 0.028174161911010742], "beyond_p": 0.0}], "insertion-sort-list": [{"slug_name": "insertion-sort-list", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        prev = None\n        \n        while curr and curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                if prev and prev.val > curr.next.val:\n                    prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = curr.next.next\n                temp.next = prev.next\n                prev.next = temp\n                \n        return dummy.next", "runtimes": [0.003062009811401367, 0.037143707275390625, 0.037445068359375, 0.03747963905334473, 0.039264678955078125, 0.04067039489746094, 0.0407252311706543, 0.04077267646789551, 0.044969797134399414, 0.045941829681396484, 0.046623945236206055, 0.049425601959228516, 0.04946732521057129, 0.049483299255371094, 0.04953575134277344, 0.04953908920288086, 0.04963254928588867, 0.051667213439941406, 0.06369709968566895, 0.06379294395446777, 0.07012295722961426, 0.07944178581237793, 0.09621787071228027, 0.1907205581665039], "beyond_p": 0.0}], "remove-duplicates-from-sorted-list-ii": [{"slug_name": "remove-duplicates-from-sorted-list-ii", "status": {"result": "passed", "runtime": 0.0009570121765136719, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                curr = curr.next\n                prev.next = curr\n            else:\n                prev = prev.next\n                curr = curr.next\n        return dummy.next\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\n# Explanation:\n# We create a dummy node and set its next to head. Then we initialize two pointers, prev and curr, to the dummy node and the head of the list respectively.\n# We then enter a while loop that continues until curr is None or curr.next is None.\n# Inside the loop, we check if the current node and the next node have the same value. If they do, we enter another while loop that continues until curr.next is None or the values of curr and curr.next are different.\n# We then set curr to curr.next and set the next of prev to curr.\n# If the values of curr and curr.next are different, we simply set prev to curr and curr to curr.next.\n# Finally, we return dummy.next which is the new head of the list.\n\n# Test:\n# Input: [1,1,2,3,3]\n# Output: [2]\n# Explanation: The nodes with values 1 and 3 are removed because they are duplicates.\n\n# Input: [1,1,2,3,3,4,4,5]\n# Output: [2,5]\n# Explanation: The nodes with values 1 and 4 are removed because they are duplicates.\n\n# Input: []\n# Output: []\n# Explanation: The list is empty, so the output is also an empty list.\n\n# Input: [1,2,3]\n# Output: [1,2,3]\n# Explanation: There are no duplicates in the list, so the output is the same as the input.\n\n# Input: [1,1,1]\n# Output: []\n# Explanation: All nodes have the same value, so they are all removed.\n\n# Input: [1,2,2,3,3,4,4,5,5]\n# Output: [1]\n# Explanation: The nodes with values 2, 3, and 4 are removed because they are duplicates.\n\n# Input: [1,1,1,2,2,2,3,3,3]\n# Output: []\n# Explanation: All nodes have the same value, so they are all removed.\n\n# Input: [1,2,3,4,5,6,7,8,9]\n# Output: [1,2,3,4,5,6,7,8,9]\n# Explanation: There are no duplicates in the list, so the output is the same as the input.\n\n# Input: [1,1,2,2,3,3,4,4,5,5]\n# Output: []\n# Explanation: All nodes have the same value, so they are all removed.\n\n# Input: [1,2,3,4,5,6,7,8,9,9]\n# Output: [1,2,3,4,5,6,7,8]\n# Explanation: The node with value 9 is removed because it is a duplicate.\n\n# Input: [1,1,1,1,1,1,1,1,1,1]\n# Output: []\n# Explanation: All nodes have the same value, so they are all removed.\n\n# Input: [1,2,3,4,5,6,7,8,9,10]\n# Output: [1,2,3,4,5,6,7,8,9,10]\n# Explanation: There are no duplicates in the list, so the output is the same as the input.\n\n# Input: [1,1,1,1,1,1,1,1,1,2]\n# Output: [2]\n# Explanation", "runtimes": [0.0008885860443115234, 0.0009300708770751953, 0.0009319782257080078, 0.0009357929229736328, 0.0009443759918212891, 0.0009458065032958984, 0.0009586811065673828, 0.0009717941284179688, 0.0009877681732177734, 0.000988006591796875, 0.001107931137084961, 0.0011448860168457031, 0.0011599063873291016, 0.0011730194091796875, 0.002481698989868164], "beyond_p": 0.9570487877880874}], "3sum": [{"slug_name": "3sum", "status": {"result": "failed@cases", "runtime": 0.0005431175231933594, "index": 0}, "solution": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l +=1 \n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append((nums[i], nums[l], nums[r]))\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1; r -= 1\n        return res", "runtimes": [0.0004832744598388672, 0.0005366802215576172, 0.0006425380706787109, 0.0006735324859619141, 0.0006842613220214844, 0.0007722377777099609], "beyond_p": 0.0}], "edit-distance": [{"slug_name": "edit-distance", "status": {"result": "passed", "runtime": 0.12832951545715332, "index": 0}, "solution": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n\n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n\n        return dp[m][n]", "runtimes": [0.11287450790405273, 0.11370849609375, 0.11463069915771484, 0.11502361297607422, 0.12129950523376465, 0.12215662002563477, 0.12818598747253418, 0.12956619262695312, 0.1306743621826172, 0.1307373046875, 0.134613037109375, 0.13733339309692383, 0.1427154541015625, 0.1429588794708252, 0.16519594192504883, 0.27599167823791504, 0.2842898368835449, 0.3167593479156494, 0.3184812068939209, 0.35665440559387207, 0.43323707580566406, 0.6195278167724609, 0.6846308708190918, 0.7569961547851562, 1.6293702125549316], "beyond_p": 0.6594149900544661}], "hamming-distance": [{"slug_name": "hamming-distance", "status": {"result": "passed", "runtime": 0.0002422332763671875, "index": 0}, "solution": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        return bin(x ^ y).count('1')", "runtimes": [0.00023555755615234375, 0.00023794174194335938, 0.0002415180206298828, 0.0002422332763671875, 0.0002448558807373047, 0.00024509429931640625, 0.00026226043701171875, 0.0002627372741699219, 0.00026488304138183594, 0.0002651214599609375, 0.0002720355987548828, 0.0004260540008544922], "beyond_p": 0.9649561952440551}], "binary-tree-paths": [{"slug_name": "binary-tree-paths", "status": {"result": "passed", "runtime": 0.0007004737854003906, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if root:\n                path += str(root.val)\n                if not root.left and not root.right:  # if reach a leaf\n                    paths.append(path)  # update paths\n                else:\n                    path += '->'  # extend the current path\n                    dfs(root.left, path)\n                    dfs(root.right, path)\n\n        paths = []\n        dfs(root, '')\n        return paths\n\n# Time: O(N)\n# Space: O(N)\n\n# Test Cases\n# [1,2,3,null,5]\n# [1]\n# [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n# [1,2,3,null,5,null,6]\n# [1,2,3,4,5,null,7,8,9,10,11,12,13,14,15]\n# [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]\n# [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,1", "runtimes": [0.0005803108215332031, 0.0006852149963378906, 0.0006854534149169922, 0.0006966590881347656, 0.0007135868072509766, 0.0007266998291015625, 0.0007312297821044922, 0.0007774829864501953, 0.0008046627044677734, 0.0008144378662109375], "beyond_p": 0.48676171079429736}], "reverse-pairs": [{"slug_name": "reverse-pairs", "status": {"result": "passed", "runtime": 0.006539583206176758, "index": 0}, "solution": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def mergeSort(l, r):\n            if l >= r: return 0\n            mid = (l + r) // 2\n            count = mergeSort(l, mid) + mergeSort(mid + 1, r)\n            j = mid + 1\n            for i in range(l, mid + 1):\n                while j <= r and nums[i] > 2 * nums[j]: j += 1\n                count += j - (mid + 1)\n            nums[l:r+1] = sorted(nums[l:r+1])\n            return count\n        \n        return mergeSort(0, len(nums) - 1)", "runtimes": [0.0023093223571777344, 0.0024254322052001953, 0.006506443023681641, 0.006705284118652344, 0.007315397262573242, 0.008768796920776367, 0.009372949600219727, 0.009713411331176758, 0.010246992111206055, 0.01063394546508789, 0.01089167594909668, 0.01094675064086914, 0.011111021041870117, 0.011406183242797852, 0.01153254508972168, 0.012058258056640625, 0.01274871826171875, 0.01307535171508789, 0.013510465621948242, 0.02437567710876465], "beyond_p": 0.8082936263546292}], "reaching-points": [{"slug_name": "reaching-points", "status": {"result": "passed", "runtime": 0.0002701282501220703, "index": 0}, "solution": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while sx < tx and sy < ty:\n            if tx < ty:\n                ty %= tx\n            else:\n                tx %= ty\n        return sx == tx and sy <= ty and (ty - sy) % sx == 0 or \\\n               sy == ty and sx <= tx and (tx - sx) % sy == 0", "runtimes": [0.0002593994140625, 0.0002598762512207031, 0.0002608299255371094, 0.0002608299255371094, 0.000263214111328125, 0.0002658367156982422, 0.0002684593200683594, 0.0002720355987548828, 0.0002760887145996094, 0.00027871131896972656, 0.00042510032653808594], "beyond_p": 0.935251798561151}], "compare-version-numbers": [{"slug_name": "compare-version-numbers", "status": {"result": "passed", "runtime": 0.0003247261047363281, "index": 0}, "solution": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = list(map(int, version1.split('.')))\n        v2 = list(map(int, version2.split('.')))\n        \n        while v1 and v1[-1] == 0:\n            v1.pop()\n        while v2 and v2[-1] == 0:\n            v2.pop()\n        \n        for i in range(min(len(v1), len(v2))):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        \n        if len(v1) > len(v2):\n            return 1\n        elif len(v1) < len(v2):\n            return -1\n        else:\n            return 0", "runtimes": [0.00029087066650390625, 0.0002918243408203125, 0.00029206275939941406, 0.0002956390380859375, 0.0003020763397216797, 0.0003025531768798828, 0.00031280517578125, 0.0003247261047363281, 0.0003304481506347656, 0.00035881996154785156, 0.0003781318664550781, 0.0004608631134033203, 0.00046539306640625], "beyond_p": 0.8060109289617486}], "best-time-to-buy-and-sell-stock-ii": [{"slug_name": "best-time-to-buy-and-sell-stock-ii", "status": {"result": "passed", "runtime": 0.0015039443969726562, "index": 0}, "solution": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i-1]:\n                max_profit += prices[i] - prices[i-1]\n        return max_profit", "runtimes": [0.0014715194702148438, 0.0014748573303222656, 0.0014827251434326172, 0.0014955997467041016, 0.0015065670013427734, 0.0015153884887695312, 0.0015218257904052734, 0.0015399456024169922, 0.0016121864318847656, 0.0016891956329345703, 0.0017025470733642578, 0.0017161369323730469, 0.002122640609741211, 0.0025136470794677734, 0.0027704238891601562, 0.0028579235076904297, 0.0029785633087158203, 0.003419637680053711, 0.0035529136657714844, 0.0035953521728515625, 0.0052490234375, 0.007367134094238281, 0.011256933212280273, 0.16639351844787598, 0.814753532409668], "beyond_p": 0.9999601307710709}], "course-schedule-iii": [{"slug_name": "course-schedule-iii", "status": {"result": "passed", "runtime": 0.0004792213439941406, "index": 0}, "solution": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        heap = []\n        start = 0\n        for t, end in sorted(courses, key = lambda t: t[1]):\n            start += t\n            heapq.heappush(heap, -t)\n            while start > end:\n                start += heapq.heappop(heap)\n        return len(heap)", "runtimes": [0.0003826618194580078, 0.0003924369812011719, 0.000400543212890625, 0.00040411949157714844, 0.00041675567626953125, 0.00043487548828125, 0.00043892860412597656, 0.00044655799865722656, 0.00045561790466308594, 0.0004563331604003906, 0.00046253204345703125, 0.0004818439483642578, 0.0006072521209716797, 0.0006823539733886719, 0.0008227825164794922], "beyond_p": 0.7806067172264355}], "reverse-nodes-in-k-group": [{"slug_name": "reverse-nodes-in-k-group", "status": {"result": "passed", "runtime": 0.0013387203216552734, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        def reverse(node, k):\n            prev = None\n            while k:\n                nxt = node.next\n                node.next = prev\n                prev = node\n                node = nxt\n                k -= 1\n            return prev\n        \n        node = head\n        ktail = None\n        new_head = None\n        \n        while node:\n            count = 0\n            node = head\n            while count < k and node:\n                node = node.next\n                count += 1\n            if count == k:\n                revHead = reverse(head, k)\n                if not new_head:\n                    new_head = revHead\n                if ktail:\n                    ktail.next = revHead\n                ktail = head\n                head = node\n        if ktail:\n            ktail.next = head\n        return new_head if new_head else head\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\n# Test cases:\n# [1,2,3,4,5], k = 2\n# [1,2,3,4,5], k = 3\n# [1,2,3,4,5], k = 1\n# [1], k = 1\n# [], k = 1\n# [1,2,3,4,5], k = 5\n# [1,2,3,4,5], k = 6\n# [1,2,3,4,5], k = 0\n# [1,2,3,4,5], k = 7\n# [1,2,3,4,5], k = -1\n# [1,2,3,4,5], k = 4\n# [1,2,3,4,5], k = 3\n# [1,2,3,4,5], k = 2\n# [1,2,3,4,5], k = 1\n# [1,2,3,4,5], k = 0\n# [1,2,3,4,5], k = -1\n# [1,2,3,4,5], k = -2\n# [1,2,3,4,5], k = -3\n# [1,2,3,4,5], k = -4\n# [1,2,3,4,5], k = -5\n# [1,2,3,4,5], k = -6\n# [1,2,3,4,5], k = -7\n# [1,2,3,4,5], k = -8\n# [1,2,3,4,5], k = -9\n# [1,2,3,4,5], k = -10\n# [1,2,3,4,5], k = -11\n# [1,2,3,4,5], k = -12\n# [1,2,3,4,5], k = -13\n# [1,2,3,4,5], k = -14\n# [1,2,3,4,5], k = -15\n# [1,2,3,4,5], k = -16\n# [1,2,3,4,5], k = -17\n# [1,2,3,4,5], k = -18\n# [1,2,3,4,5], k = -19\n# [1,2,3,4,5], k = -20\n# [1,2,3,4,5], k = -21\n# [1,2,3,4,5], k = -22\n# [1,2,3,4,5], k = -23\n# [1,2,3,4,5], k = -24\n# [1,2,3,4,5], k = -25\n# [1,2,3,4,5], k = -26\n# [1,2,3,4,5], k = -27\n# [1,2,3,4,5], k = -28\n# [1,2,3,4,5], k = -29\n# [1,2,3,4,5], k = -30\n# [1,2,3,4,5], k = -31\n# [1,2,3,4,5], k = -32\n# [1,2,3,4,", "runtimes": [0.0010628700256347656, 0.0010726451873779297, 0.0010728836059570312, 0.0010764598846435547, 0.0010793209075927734, 0.0010805130004882812, 0.001085519790649414, 0.0011138916015625, 0.001123666763305664, 0.0011272430419921875, 0.001140594482421875, 0.0011646747589111328, 0.00118255615234375, 0.0013244152069091797, 0.001367807388305664, 0.0014297962188720703, 0.0014491081237792969, 0.0015497207641601562, 0.001583099365234375], "beyond_p": 0.4697525206232814}], "repeated-substring-pattern": [{"slug_name": "repeated-substring-pattern", "status": {"result": "passed", "runtime": 0.00027561187744140625, "index": 0}, "solution": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        size = len(s)\n        for i in range(1, size//2 + 1):\n            if size % i:\n                continue\n            if s[:i] * (size // i) == s:\n                return True\n        return False\n\n# Time complexity: O(n^2)\n# Space complexity: O(n)\n\n# Test cases\n# \"abab\" -> True\n# \"aba\" -> False\n# \"abcabcabcabc\" -> True\n# \"bb\" -> True\n# \"abcdabcdabcdabcd\" -> True\n# \"a\" -> False\n# \"abcd\" -> False\n# \"ababab\" -> True\n# \"abcabcabc\" -> True\n# \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc", "runtimes": [0.00027251243591308594, 0.0002827644348144531, 0.0002944469451904297, 0.0002961158752441406, 0.0002963542938232422, 0.0002963542938232422, 0.0002963542938232422, 0.0002989768981933594, 0.0003018379211425781, 0.00030422210693359375, 0.0003046989440917969, 0.000308990478515625, 0.00030922889709472656, 0.0003159046173095703, 0.0003228187561035156, 0.0003399848937988281, 0.0003452301025390625, 0.0003724098205566406, 0.0003910064697265625, 0.0004074573516845703], "beyond_p": 0.9770318021201413}], "unique-binary-search-trees": [{"slug_name": "unique-binary-search-trees", "status": {"result": "passed", "runtime": 0.0003199577331542969, "index": 0}, "solution": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        G = [0]*(n+1)\n        G[0], G[1] = 1, 1\n\n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                G[i] += G[j-1] * G[i-j]\n\n        return G[n]", "runtimes": [0.00022554397583007812, 0.000293731689453125, 0.00030541419982910156, 0.0003104209899902344, 0.0003135204315185547, 0.0003142356872558594, 0.0003142356872558594, 0.0003154277801513672, 0.00031566619873046875, 0.0003204345703125, 0.00032067298889160156, 0.0003299713134765625, 0.00034236907958984375, 0.0005540847778320312], "beyond_p": 0.7126269956458636}], "single-number-ii": [{"slug_name": "single-number-ii", "status": {"result": "passed", "runtime": 0.0006821155548095703, "index": 0}, "solution": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ones = 0\n        twos = 0\n        for num in nums:\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n        return ones\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.singleNumber([2,2,3,2]))\n    print(s.singleNumber([0,1,0,1,0,1,99]))", "runtimes": [0.0003876686096191406, 0.0004284381866455078, 0.0005052089691162109, 0.0005128383636474609, 0.0005891323089599609, 0.0006165504455566406, 0.000644683837890625, 0.0006566047668457031, 0.00067138671875, 0.0006811618804931641, 0.0008578300476074219, 0.0008645057678222656, 0.0010581016540527344, 0.0010600090026855469, 0.0011110305786132812, 0.0011146068572998047, 0.00112152099609375, 0.0011415481567382812, 0.0018868446350097656, 0.0030508041381835938, 0.003381013870239258, 0.009853839874267578], "beyond_p": 0.9688948216804352}], "stickers-to-spell-word": [{"slug_name": "stickers-to-spell-word", "status": {"result": "failed@cases", "runtime": 1.6537652015686035, "index": 0}, "solution": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(target)\n        N = 1 << n\n        dp = [0] + [float('inf')] * N\n        for i in range(N):\n            if dp[i] != float('inf'):\n                for sticker in stickers:\n                    now = i\n                    for c in sticker:\n                        for r in range(n):\n                            if ((now >> r) & 1) == 0 and target[r] == c:\n                                now |= 1 << r\n                                break\n                    dp[now] = min(dp[now], dp[i] + 1)\n        return dp[-1] if dp[-1] != float('inf') else -1", "runtimes": [0.0010480880737304688, 0.007496833801269531, 0.012735128402709961, 0.017253398895263672, 0.017899274826049805, 0.04110455513000488, 0.08909392356872559, 0.24704241752624512, 0.2881948947906494, 0.39820408821105957, 0.5217561721801758, 0.6474950313568115, 0.6772594451904297, 0.9036870002746582, 0.921494722366333], "beyond_p": 0.0}], "strange-printer": [{"slug_name": "strange-printer", "status": {"result": "failed@cases", "runtime": 0.0011866092681884766, "index": 0}, "solution": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = ''.join(sorted(set(s)))\n        n = len(s)\n        dp = [[0]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for l in range(2, n+1):\n            for i in range(n-l+1):\n                j = i+l-1\n                dp[i][j] = dp[i+1][j] + 1\n                for k in range(i+1, j+1):\n                    if s[k] == s[i]:\n                        dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])\n        return dp[0][n-1]", "runtimes": [0.007204771041870117, 0.007788419723510742, 0.008801460266113281, 0.011336326599121094, 0.011451244354248047, 0.011610269546508789, 0.014888525009155273, 0.015388727188110352, 0.02383899688720703, 0.02463817596435547, 0.03741812705993652, 0.05022096633911133, 0.05381202697753906, 0.05407309532165527, 0.07398462295532227, 0.07476639747619629, 0.08756375312805176, 0.08863949775695801], "beyond_p": 0.0}], "sqrtx": [{"slug_name": "sqrtx", "status": {"result": "passed", "runtime": 0.00025963783264160156, "index": 0}, "solution": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0 or x == 1:\n            return x\n        \n        start = 1\n        end = x\n        while start <= end:\n            mid = (start + end) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                start = mid + 1\n                ans = mid\n            else:\n                end = mid - 1\n        return ans", "runtimes": [0.00024890899658203125, 0.0003104209899902344, 0.0003285408020019531, 0.0008733272552490234, 0.0023632049560546875, 0.0027713775634765625, 0.003264188766479492, 0.004074573516845703, 0.005662202835083008, 0.005688190460205078, 0.006383419036865234, 0.00672602653503418, 0.006989717483520508, 0.007726192474365234, 0.008366584777832031, 0.008400201797485352, 0.008903980255126953, 0.010036706924438477, 0.010919332504272461, 0.012297868728637695, 0.015420913696289062, 0.015602588653564453, 0.01769113540649414, 0.06811857223510742], "beyond_p": 0.9998419200044965}], "roman-to-integer": [{"slug_name": "roman-to-integer", "status": {"result": "passed", "runtime": 0.00028014183044433594, "index": 0}, "solution": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        res = 0\n        for i in range(len(s)):\n            if i+1 < len(s) and roman[s[i]] < roman[s[i+1]]:\n                res -= roman[s[i]]\n            else:\n                res += roman[s[i]]\n        return res", "runtimes": [0.00027942657470703125, 0.0002803802490234375, 0.0002810955047607422, 0.0002815723419189453, 0.00028228759765625, 0.00028252601623535156, 0.0002830028533935547, 0.0002834796905517578, 0.0002837181091308594, 0.00028443336486816406, 0.0002849102020263672, 0.00028896331787109375, 0.00029087066650390625, 0.0003032684326171875, 0.00030875205993652344, 0.00031447410583496094], "beyond_p": 0.9795918367346939}], "contains-duplicate": [{"slug_name": "contains-duplicate", "status": {"result": "passed", "runtime": 0.0003609657287597656, "index": 0}, "solution": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))", "runtimes": [0.0003688335418701172, 0.0003695487976074219, 0.00037097930908203125, 0.00038504600524902344, 0.00038552284240722656, 0.0003859996795654297, 0.0003886222839355469, 0.00039076805114746094, 0.00039124488830566406, 0.0003914833068847656, 0.000396728515625, 0.0003972053527832031, 0.00041103363037109375, 0.00042939186096191406, 0.0004420280456542969, 0.00044536590576171875, 0.0004947185516357422, 0.0005629062652587891, 0.0006546974182128906], "beyond_p": 1.0275229357798166}], "sliding-window-maximum": [{"slug_name": "sliding-window-maximum", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums: return []\n        if k == 1: return nums\n        \n        deque = collections.deque()\n        result = []\n        \n        for i in range(len(nums)):\n            while deque and nums[i] > nums[deque[-1]]:\n                deque.pop()\n            deque.append(i)\n            \n            if i >= k - 1:\n                result.append(nums[deque[0]])\n                if deque[0] == i - k + 1:\n                    deque.popleft()\n        \n        return result\n    \n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums: return []\n        if k == 1: return nums\n        \n        deque = collections.deque()\n        result = []\n        \n        for i in range(len(nums)):\n            while deque and nums[i] > nums[deque[-1]]:\n                deque.pop()\n            deque.append(i)\n            \n            if i >= k - 1:\n                result.append(nums[deque[0]])\n                if deque[0] == i - k + 1:\n                    deque.popleft()\n        \n        return result\n    \n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums: return []\n        if k == 1: return nums\n        \n        deque = collections.deque()\n        result = []\n        \n        for i in range(len(nums)):\n            while deque and nums[i] > nums[deque[-1]]:\n                deque.pop()\n            deque.append(i)\n            \n            if i >= k - 1:\n                result.append(nums[deque[0]])\n                if deque[0] == i - k + 1:\n                    deque.popleft()\n        \n        return result\n    \n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums: return []\n        if k == 1: return nums\n        \n        deque = collections.deque()\n        result = []\n        \n        for i in range(len(nums)):\n            while deque and nums[i] > nums[deque[-1]]:\n                deque.pop()\n            deque.append(i)\n            \n            if i >= k - 1:\n                result.append(nums[deque[0]])\n                if deque[0] == i - k + 1:\n                    deque.popleft()\n        \n        return result\n    \n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums: return []\n        if k == 1: return nums\n        \n        deque = collections.deque()\n        result = []\n        \n        for i in range(len(nums)):\n            while deque and nums[i] > nums[deque[-1]]:\n                deque.pop()\n            deque.append(i)\n            \n            if i >= k - 1:\n                result.append(nums[deque[0]])\n                if deque[0] == i - k + 1:\n                    deque.popleft()\n        \n        return result\n    \n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums: return []\n        if k == 1: return nums\n        \n        deque = collections.deque()\n        result = []\n        \n        for i in range(", "runtimes": [0.0010704994201660156, 0.0010824203491210938, 0.0011086463928222656, 0.0011103153228759766, 0.00112152099609375, 0.0012102127075195312, 0.001226186752319336, 0.0012466907501220703, 0.001260995864868164, 0.001312255859375, 0.0013294219970703125, 0.0013511180877685547, 0.0013804435729980469, 0.0013816356658935547, 0.0015103816986083984, 0.0015263557434082031, 0.0015642642974853516, 0.0016727447509765625, 0.0016906261444091797, 0.0017299652099609375, 0.002262592315673828, 0.002465486526489258, 0.0034034252166748047], "beyond_p": 0.0}], "median-of-two-sorted-arrays": [{"slug_name": "median-of-two-sorted-arrays", "status": {"result": "passed", "runtime": 0.0004532337188720703, "index": 0}, "solution": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums = nums1 + nums2\n        nums.sort()\n        if len(nums) % 2 == 0:\n            return (nums[len(nums)//2] + nums[len(nums)//2 - 1]) / 2.0\n        else:\n            return nums[len(nums)//2]", "runtimes": [0.0003254413604736328, 0.0003349781036376953, 0.00034809112548828125, 0.00036406517028808594, 0.0004639625549316406, 0.0004820823669433594, 0.0004858970642089844, 0.0005130767822265625, 0.0005161762237548828, 0.0005168914794921875, 0.000530242919921875, 0.0005922317504882812, 0.0006680488586425781, 0.001081705093383789, 0.0012149810791015625, 0.0012416839599609375, 0.0012655258178710938, 0.0022230148315429688, 0.0031888484954833984], "beyond_p": 0.9553705245628643}], "find-minimum-in-rotated-sorted-array": [{"slug_name": "find-minimum-in-rotated-sorted-array", "status": {"result": "passed", "runtime": 0.00027680397033691406, "index": 0}, "solution": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]", "runtimes": [0.0002739429473876953, 0.0002772808074951172, 0.0002772808074951172, 0.0002777576446533203, 0.00028014183044433594, 0.00028204917907714844, 0.0002830028533935547, 0.0002849102020263672, 0.0002865791320800781, 0.00029206275939941406, 0.00029349327087402344, 0.0002949237823486328, 0.0002999305725097656, 0.0003046989440917969, 0.0003437995910644531, 0.0003752708435058594, 0.0006477832794189453], "beyond_p": 0.9923469387755102}], "pascals-triangle-ii": [{"slug_name": "pascals-triangle-ii", "status": {"result": "passed", "runtime": 0.0003845691680908203, "index": 0}, "solution": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1, 1]\n        \n        prev_row = [1, 1]\n        for i in range(2, rowIndex+1):\n            curr_row = [1] * (i+1)\n            for j in range(1, i):\n                curr_row[j] = prev_row[j-1] + prev_row[j]\n            prev_row = curr_row\n        \n        return prev_row", "runtimes": [0.0003879070281982422, 0.0003898143768310547, 0.0003972053527832031, 0.000408172607421875, 0.0004215240478515625, 0.0004315376281738281, 0.0004341602325439453, 0.0004520416259765625, 0.0004546642303466797, 0.0004572868347167969, 0.0005018711090087891, 0.0005092620849609375, 0.0005481243133544922], "beyond_p": 1.0208333333333333}], "path-sum-ii": [{"slug_name": "path-sum-ii", "status": {"result": "passed", "runtime": 0.0007054805755615234, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, path, target):\n            if not node:\n                return\n            path.append(node.val)\n            if not node.left and not node.right and sum(path) == target:\n                res.append(path)\n            dfs(node.left, path[:], target)\n            dfs(node.right, path[:], target)\n        \n        res = []\n        dfs(root, [], targetSum)\n        return res\n    \n\n# Time complexity: O(n^2)\n# Space complexity: O(n)\n\n# Bug Class: Time Limit Exceeded\n# Description: The time complexity of this solution is O(n^2) because for each node, we are copying the path list which takes O(n) time. This is done for each node in the tree, hence the overall time complexity is O(n^2).\n\n# Solution:\n# The solution is to use a single list and modify it in-place. This will reduce the time complexity to O(n).\n\n# Modified Solution:\n\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, path, target):\n            if not node:\n                return\n            path.append(node.val)\n            if not node.left and not node.right and sum(path) == target:\n                res.append(path[:])\n            dfs(node.left, path, target)\n            dfs(node.right, path, target)\n            path.pop()\n        \n        res = []\n        dfs(root, [], targetSum)\n        return res\n    \n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Bug Class: Wrong Answer\n# Description: The bug is in the condition for adding the path to the result. The condition should be if the node is a leaf node and the sum of the path is equal to the target.\n\n# Solution:\n# The solution is to add the condition node.left is None and node.right is None to the if statement.\n\n# Modified Solution:\n\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, path, target):\n            if not node:\n                return\n            path.append(node.val)\n            if node.left is None and node.right is None and sum(path) == target:\n                res.append(path[:])\n            dfs(node.left, path, target)\n            dfs(node.right, path, target)\n            path.pop()\n        \n        res = []\n        dfs(root, [], targetSum)\n        return res\n    \n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Bug Class: Time Limit Exceeded\n# Description: The time complexity of this solution is O(n) because we are only copying the path list when we add it to the result. The path list is copied only once for each node in the tree, hence the overall time complexity is O(n).\n\n# Solution:\n# The solution is to use a single list and modify it in-place. This will reduce the time complexity to O(n).\n\n# Modified Solution:\n\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, path, target):\n            if not node:\n                return\n            path.append(node.val)\n            if node.left is None and node.right is None and sum(path) == target:\n                res.append(path[:])\n            dfs(node.left, path, target)\n            dfs(node.right, path, target)\n            path.pop()\n        \n        res = []\n        dfs(root, [], targetSum)\n        return res\n    \n\n# Time complexity: O(n)\n# Space complexity: O(n", "runtimes": [0.0006883144378662109, 0.0006918907165527344, 0.0007016658782958984, 0.000705718994140625, 0.0007090568542480469, 0.0007107257843017578, 0.0007107257843017578, 0.0007112026214599609, 0.0007131099700927734, 0.0007140636444091797, 0.0007195472717285156, 0.0007252693176269531, 0.0007328987121582031, 0.0007491111755371094, 0.0007700920104980469], "beyond_p": 0.7900874635568513}], "construct-the-rectangle": [{"slug_name": "construct-the-rectangle", "status": {"result": "passed", "runtime": 0.0008792877197265625, "index": 0}, "solution": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(int(math.sqrt(area)), 0, -1):\n            if area % i == 0:\n                return [area // i, i]", "runtimes": [0.0006902217864990234, 0.021677732467651367, 0.021686553955078125, 0.022156238555908203, 0.022190093994140625, 0.043557167053222656, 0.043590545654296875, 0.0946345329284668, 0.38684511184692383, 0.3870522975921631, 0.4982478618621826, 0.770380973815918, 0.7730329036712646, 0.7750513553619385, 0.7891757488250732, 0.7938485145568848, 0.8074417114257812], "beyond_p": 0.9997656453868935}], "word-ladder-ii": [{"slug_name": "word-ladder-ii", "status": {"result": "passed", "runtime": 0.006412982940673828, "index": 0}, "solution": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        wordList = set(wordList)\n        res = []\n        layer = {}\n        layer[beginWord] = [[beginWord]]\n\n        while layer:\n            newlayer = collections.defaultdict(list)\n            for w in layer:\n                if w == endWord: \n                    res.extend(k for k in layer[w])\n                else:\n                    for i in range(len(w)):\n                        for c in 'abcdefghijklmnopqrstuvwxyz':\n                            neww = w[:i]+c+w[i+1:]\n                            if neww in wordList:\n                                newlayer[neww]+=[j+[neww] for j in layer[w]]\n\n            wordList -= set(newlayer.keys())\n            layer = newlayer\n\n        return res", "runtimes": [0.0003528594970703125, 0.0003871917724609375, 0.0003936290740966797, 0.0004096031188964844, 0.0004105567932128906, 0.0004172325134277344, 0.0004303455352783203, 0.0004436969757080078, 0.00047278404235839844, 0.0005142688751220703, 0.0005571842193603516, 0.0005764961242675781, 0.0016331672668457031, 0.0016379356384277344, 0.007601261138916016, 0.007700204849243164], "beyond_p": 0.17519550897232047}], "balanced-binary-tree": [{"slug_name": "balanced-binary-tree", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            return max(height(root.left), height(root.right)) + 1\n        \n        if not root:\n            return True\n        left_height = height(root.left)\n        right_height = height(root.right)\n        \n        return abs(left_height - right_height) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def dfs(root):\n            if not root:\n                return [True, 0]\n            left, right = dfs(root.left), dfs(root.right)\n            balanced = (left[0] and right[0] and abs(left[1] - right[1]) <= 1)\n            return [balanced, 1 + max(left[1], right[1])]\n        return dfs(root)[0]\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def dfs(root):\n            if not root:\n                return [True, 0]\n            left, right = dfs(root.left), dfs(root.right)\n            balanced = (left[0] and right[0] and abs(left[1] - right[1]) <= 1)\n            return [balanced, 1 + max(left[1], right[1])]\n        return dfs(root)[0]\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def dfs(root):\n            if not root:\n                return [True, 0]\n            left, right = dfs(root.left), dfs(root.right)\n            balanced = (left[0] and right[0] and abs(left[1] - right[1]) <= 1)\n            return [balanced, 1 + max(left[1], right[1])]\n        return dfs(root)[0]\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def dfs(root):\n            if not root:\n                return [True, 0]\n            left, right = dfs(root.left), dfs(root.right)\n            balanced = (left[0] and right[0] and abs(left[1] - right[1]) <= 1)\n            return [balanced, 1 + max(left[1], right[1])]\n        return dfs(root)[0]\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode", "runtimes": [0.0007472038269042969, 0.00079345703125, 0.0008032321929931641, 0.0008058547973632812, 0.0008113384246826172, 0.0008442401885986328, 0.0008475780487060547, 0.0008542537689208984, 0.0008647441864013672, 0.0008673667907714844, 0.0008966922760009766, 0.0009174346923828125, 0.0009202957153320312, 0.0009214878082275391, 0.0009617805480957031, 0.0009670257568359375, 0.000980377197265625, 0.0009832382202148438, 0.0009925365447998047, 0.001012563705444336, 0.001035928726196289, 0.0010924339294433594, 0.0011012554168701172], "beyond_p": 0.0}], "power-of-two": [{"slug_name": "power-of-two", "status": {"result": "passed", "runtime": 0.00036787986755371094, "index": 0}, "solution": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        while n % 2 == 0:\n            n /= 2\n        return n == 1", "runtimes": [0.00028061866760253906, 0.0003209114074707031, 0.00032138824462890625, 0.00032448768615722656, 0.0003273487091064453, 0.00032782554626464844, 0.00032973289489746094, 0.00033020973205566406, 0.00033211708068847656, 0.0003364086151123047, 0.0003368854522705078, 0.00034499168395996094, 0.0004317760467529297], "beyond_p": 0.4227129337539432}], "subsets-ii": [{"slug_name": "subsets-ii", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(nums, index, path, res):\n            res.append(path)\n            for i in range(index, len(nums)):\n                if i > index and nums[i] == nums[i-1]:\n                    continue\n                dfs(nums, i+1, path+[nums[i]], res)\n        \n        nums.sort()\n        res = []\n        dfs(nums, 0, [], res)\n        return res\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.subsetsWithDup([1,2,2]))\n    print(s.subsetsWithDup([0]))\n\n#Time complexity: O(N*2^N)\n#Space complexity: O(N*2^N)class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        nums = sorted(nums1 + nums2)\n        if len(nums) % 2 == 0:\n            return (nums[len(nums) // 2] + nums[len(nums) // 2 - 1]) / 2\n        else:\n            return nums[len(nums) // 2]\n\n#Time complexity: O(nlogn)\n#Space complexity: O(n)class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        if n == 0:\n            raise ValueError\n        imin, imax, half_len = 0, m, (m + n + 1) // 2\n        while imin <= imax:\n            i = (imin + imax) // 2\n            j = half_len - i\n            if i < m and nums2[j-1] > nums1[i]:\n                imin = i + 1\n            elif i > 0 and nums1[i-1] > nums2[j]:\n                imax = i - 1\n            else:\n                if i == 0: max_of_left = nums2[j-1]\n                elif j == 0: max_of_left = nums1[i-1]\n                else: max_of_left = max(nums1[i-1], nums2[j-1])\n                if (m + n) % 2 == 1:\n                    return max_of_left\n                if i == m: min_of_right = nums2[j]\n                elif j == n: min_of_right = nums1[i]\n                else: min_of_right = min(nums1[i], nums2[j])\n                return (max_of_left + min_of_right) / 2.0\n\n#Time complexity: O(log(min(m,n)))\n#Space complexity: O(1)class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        imin, imax, half_len = 0, m, (m + n + 1) // 2\n        while imin <= imax:\n            i = (imin + imax) // 2\n            j = half_len - i\n            if i < m and nums2[j-1] > nums1[i]:\n                imin = i + 1\n            elif i > 0 and nums1[i-1] > nums2[j]:\n                imax = i - 1\n            else:\n                if i == 0: max_of_left = nums2[j-1]\n                elif j == 0: max_of_left = nums1[i-1]\n                else: max_of_left =", "runtimes": [0.0015883445739746094, 0.0016474723815917969, 0.0016796588897705078, 0.00182342529296875, 0.0019335746765136719, 0.0020079612731933594, 0.002079010009765625, 0.0020999908447265625, 0.0021088123321533203, 0.002120494842529297, 0.0021333694458007812, 0.0022423267364501953, 0.0022695064544677734, 0.002347230911254883, 0.005498409271240234, 0.006928682327270508, 0.0071566104888916016, 0.0071947574615478516], "beyond_p": 0.0}], "largest-rectangle-in-histogram": [{"slug_name": "largest-rectangle-in-histogram", "status": {"result": "passed", "runtime": 0.0019664764404296875, "index": 0}, "solution": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        maxArea = 0\n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                maxArea = max(maxArea, height * (i - index))\n                start = index\n            stack.append((start, h))\n\n        for i, h in stack:\n            maxArea = max(maxArea, h * (len(heights) - i))\n        return maxArea", "runtimes": [0.0014948844909667969, 0.001592874526977539, 0.0016350746154785156, 0.0016520023345947266, 0.0017137527465820312, 0.001733541488647461, 0.0018620491027832031, 0.0018658638000488281, 0.001874685287475586, 0.0019118785858154297, 0.0019273757934570312, 0.00194549560546875, 0.0020284652709960938, 0.002032041549682617, 0.002276897430419922, 0.0023317337036132812, 0.002377748489379883, 0.0024352073669433594, 0.0024437904357910156, 0.0024466514587402344, 0.0024645328521728516, 0.002731800079345703, 0.0027697086334228516, 0.0028302669525146484, 0.003066539764404297, 0.0032434463500976562, 0.003893136978149414, 0.003950834274291992, 0.007226467132568359], "beyond_p": 0.9177204658901831}], "evaluate-reverse-polish-notation": [{"slug_name": "evaluate-reverse-polish-notation", "status": {"result": "passed", "runtime": 0.0003066062927246094, "index": 0}, "solution": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in ['+', '-', '*', '/']:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == '+':\n                    stack.append(num1 + num2)\n                elif token == '-':\n                    stack.append(num1 - num2)\n                elif token == '*':\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(float(num1) / num2))\n            else:\n                stack.append(int(token))\n        return stack[0]", "runtimes": [0.00030517578125, 0.00030541419982910156, 0.00030541419982910156, 0.0003058910369873047, 0.0003066062927246094, 0.00030684471130371094, 0.0003082752227783203, 0.0003085136413574219, 0.0003101825714111328, 0.00031065940856933594, 0.00031113624572753906, 0.0003116130828857422, 0.00032138824462890625, 0.0003287792205810547, 0.0003311634063720703, 0.0003333091735839844, 0.0003364086151123047, 0.0004856586456298828, 0.0005004405975341797], "beyond_p": 0.9926739926739927}], "perfect-rectangle": [{"slug_name": "perfect-rectangle", "status": {"result": "failed@cases", "runtime": 0.0003712177276611328, "index": 0}, "solution": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        area = 0\n        corners = set()\n        a = lambda: (Y-y) * (X-x)\n        x, y, X, Y = min(x for x, y, X, Y in rectangles), min(y for x, y, X, Y in rectangles), max(X for x, y, X, Y in rectangles), max(Y for x, y, X, Y in rectangles)\n        for xi, yi, Xi, Yi in rectangles:\n            area += a()\n            corners ^= {(xi, yi), (xi, Yi), (Xi, yi), (Xi, Yi)}\n        return area == a() and corners == {(x, y), (x, Y), (X, y), (X, Y)}", "runtimes": [0.00039458274841308594, 0.0004062652587890625, 0.0004227161407470703, 0.00043654441833496094, 0.0004534721374511719, 0.0005848407745361328, 0.0006554126739501953, 0.0006711483001708984], "beyond_p": 0.0}], "excel-sheet-column-title": [{"slug_name": "excel-sheet-column-title", "status": {"result": "passed", "runtime": 0.00028896331787109375, "index": 0}, "solution": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        result = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            result = chr(columnNumber % 26 + ord('A')) + result\n            columnNumber //= 26\n        return result", "runtimes": [0.0002760887145996094, 0.00027751922607421875, 0.0002791881561279297, 0.00028252601623535156, 0.00028634071350097656, 0.0002911090850830078, 0.00029587745666503906, 0.0002968311309814453, 0.00029850006103515625, 0.0002999305725097656, 0.0002999305725097656, 0.00030303001403808594, 0.000308990478515625, 0.00032067298889160156], "beyond_p": 0.7112299465240641}], "maximum-subarray": [{"slug_name": "maximum-subarray", "status": {"result": "passed", "runtime": 0.0009195804595947266, "index": 0}, "solution": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = float('-inf')\n        curr_sum = 0\n        \n        for num in nums:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum", "runtimes": [0.0004489421844482422, 0.00047659873962402344, 0.0004904270172119141, 0.0004928112030029297, 0.0005021095275878906, 0.0005097389221191406, 0.00058746337890625, 0.0006258487701416016, 0.0006730556488037109, 0.0006806850433349609, 0.0006976127624511719, 0.0007092952728271484, 0.0007371902465820312, 0.0007674694061279297, 0.0007686614990234375, 0.0009229183197021484, 0.0009570121765136719, 0.0010521411895751953, 0.0010797977447509766, 0.00135040283203125], "beyond_p": 0.4779158952658027}], "sliding-puzzle": [{"slug_name": "sliding-puzzle", "status": {"result": "passed", "runtime": 0.003050565719604492, "index": 0}, "solution": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        moves, used, cnt = {0: {1, 3}, 1:{0, 2, 4}, 2:{1, 5}, 3:{0, 4}, 4:{1, 3, 5}, 5:{2, 4}}, set(), 0\n        state = \"\".join(str(c) for row in board for c in row)\n        q = [(state, state.index(\"0\"))]\n\n        while q:\n            new = []\n            for state, i in q:\n                if state == \"123450\":\n                    return cnt\n                for j in moves[i]:\n                    _state = [c for c in state]\n                    _state[i], _state[j] = _state[j], _state[i]\n                    newstate = \"\".join(_state)\n                    if newstate not in used:\n                        new.append((newstate, j))\n                        used.add(newstate)\n            cnt, q = cnt + 1, new\n        return -1\n\n# Time: O(1)\n# Space: O(1)\n\n# Time complexity: O(1) because the board size is fixed.\n# Space complexity: O(1) because the board size is fixed.\n\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is O(1) because the board size is fixed.\n# The time complexity is O(1) because the board size is fixed. The space complexity is", "runtimes": [0.002493619918823242, 0.002546072006225586, 0.0026721954345703125, 0.0027666091918945312, 0.0028486251831054688, 0.0037300586700439453, 0.0037708282470703125, 0.004131793975830078, 0.004982948303222656, 0.005147457122802734, 0.009511470794677734, 0.011794805526733398, 0.014117956161499023, 0.016241073608398438, 0.026125192642211914, 0.03718090057373047, 0.03960895538330078], "beyond_p": 0.9849941865320254}], "isomorphic-strings": [{"slug_name": "isomorphic-strings", "status": {"result": "passed", "runtime": 0.00028967857360839844, "index": 0}, "solution": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n                return False\n            if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n                return False\n            \n            s_to_t[s[i]] = t[i]\n            t_to_s[t[i]] = s[i]\n        \n        return True", "runtimes": [0.00027561187744140625, 0.00028586387634277344, 0.00029206275939941406, 0.0002923011779785156, 0.0002923011779785156, 0.0002970695495605469, 0.00030541419982910156, 0.0003139972686767578, 0.00032901763916015625, 0.0003364086151123047, 0.00041961669921875, 0.0004801750183105469, 0.0005245208740234375, 0.0013141632080078125, 0.0013275146484375, 0.001466512680053711, 0.003389120101928711, 0.003412961959838867, 0.0037560462951660156, 0.0037648677825927734], "beyond_p": 0.9959685685001708}], "search-in-rotated-sorted-array-ii": [{"slug_name": "search-in-rotated-sorted-array-ii", "status": {"result": "passed", "runtime": 0.00031185150146484375, "index": 0}, "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            while left < mid and nums[left] == nums[mid]: # tricky part\n                left += 1\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]: \n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False", "runtimes": [0.0002956390380859375, 0.0002999305725097656, 0.0003006458282470703, 0.000301361083984375, 0.0003018379211425781, 0.0003066062927246094, 0.0003085136413574219, 0.0003097057342529297, 0.0003104209899902344, 0.00031185150146484375, 0.0003120899200439453, 0.0003197193145751953, 0.0003237724304199219, 0.0003287792205810547, 0.00033974647521972656, 0.0004646778106689453], "beyond_p": 0.9040902679830748}], "unique-paths-ii": [{"slug_name": "unique-paths-ii", "status": {"result": "passed", "runtime": 0.0013272762298583984, "index": 0}, "solution": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0]*n for _ in range(m)]\n        for i in range(m):\n            if obstacleGrid[i][0] == 1:\n                break\n            dp[i][0] = 1\n        for j in range(n):\n            if obstacleGrid[0][j] == 1:\n                break\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    continue\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[-1][-1]", "runtimes": [0.00029969215393066406, 0.0003132820129394531, 0.0003256797790527344, 0.0009140968322753906, 0.0009968280792236328, 0.0010008811950683594, 0.0011684894561767578, 0.0011763572692871094, 0.0012042522430419922, 0.0012054443359375, 0.0014307498931884766, 0.001522064208984375, 0.001577138900756836, 0.0018923282623291016, 0.001956462860107422, 0.001978158950805664, 0.002271413803100586, 0.002283334732055664, 0.0023038387298583984, 0.16273260116577148], "beyond_p": 0.993673793800905}], "decode-ways-ii": [{"slug_name": "decode-ways-ii", "status": {"result": "passed", "runtime": 0.0011882781982421875, "index": 0}, "solution": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        e0, e1, e2 = 1, 0, 0\n        for c in s:\n            if c == '*':\n                f0 = 9*e0 + 9*e1 + 6*e2\n                f1 = e0\n                f2 = e0\n            else:\n                f0 = (c > '0')*e0 + e1 + (c <= '6')*e2\n                f1 = (c == '1')*e0\n                f2 = (c == '2')*e0\n            e0, e1, e2 = f0 % MOD, f1, f2\n        return e0\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.numDecodings(\"*\"))\n    print(s.numDecodings(\"1*\"))\n    print(s.numDecodings(\"2*\"))", "runtimes": [0.00027871131896972656, 0.0003337860107421875, 0.0003566741943359375, 0.0003757476806640625, 0.0004935264587402344, 0.0005233287811279297, 0.0006177425384521484, 0.0010726451873779297, 0.0017671585083007812, 0.0020825862884521484, 0.002176046371459961, 0.0021941661834716797, 0.003187417984008789, 0.007563591003417969, 0.009151458740234375, 0.0094146728515625, 0.013689279556274414], "beyond_p": 0.9321753662352439}], "3sum-closest": [{"slug_name": "3sum-closest", "status": {"result": "passed", "runtime": 0.07817459106445312, "index": 0}, "solution": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        result = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums) - 1\n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                if sum == target:\n                    return sum\n                if abs(sum - target) < abs(result - target):\n                    result = sum\n                if sum < target:\n                    l += 1\n                elif sum > target:\n                    r -= 1\n        return result\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.threeSumClosest([-1,2,1,-4], 1))\n    print(s.threeSumClosest([0,0,0], 1))\n\n# Time complexity: O(n^2)\n# Space complexity: O(logn) to O(n), depending on the implementation of the sorting algorithm.\n\n# Explanation:\n# The solution is based on the two pointers technique. We first sort the array. Then, for each number in the array, we use two pointers to find the closest sum to the target. If the sum is equal to the target, we return the sum. If the sum is less than the target, we move the left pointer to the right. If the sum is greater than the target, we move the right pointer to the left. We keep track of the closest sum and return it at the end.\n\n# Note:\n# The time complexity is O(n^2) because for each number in the array, we use two pointers to find the closest sum to the target. The space complexity is O(logn) to O(n), depending on the implementation of the sorting algorithm.\n\n# Tags:\n# Array, Two Pointers, Sorting\n\n# Similar Questions:\n# 3Sum, 3Sum Smaller\n\n# What I learned:\n# I learned how to use the two pointers technique to solve a problem. I also learned how to use the sort function in Python.\n\n# What could be improved:\n# I could improve the space complexity by not using the sort function. I could use a different algorithm to sort the array. I could also improve the time complexity by using a different algorithm to find the closest sum.\n\n# What I struggled with:\n# I struggled with the two pointers technique. I had to look at the solution to understand how to use it. I also struggled with the time complexity. I had to look at the solution to understand how to calculate it.\n\n# What I liked:\n# I liked the problem because it is a good example of how to use the two pointers technique. I also liked the problem because it is a good example of how to use the sort function.\n\n# Conclusion:\n# This problem is a good example of how to use the two pointers technique and the sort function. It is also a good example of how to use the binary search algorithm. I learned a lot from this problem. I will use this technique in the future.\n\n# Solution:\n# The solution is based on the two pointers technique. We first sort the array. Then, for each number in the array, we use two pointers to find the closest sum to the target. If the sum is equal to the target, we return the sum. If the sum is less than the target, we move the left pointer to the right. If the sum is greater than the target, we move the right pointer to the left. We keep track of the closest sum and return it at the end.\n\n# Time complexity: O(n^2)\n# Space complexity: O(logn) to O(n), depending on the implementation of the sorting algorithm.\n\n# Code:\n# ```python\n# class Solution(object):\n#     def threeSumClosest(self, nums, target):\n#         \"\"\"\n#         :type nums: List[int]\n#         :type target: int\n#         :rtype: int\n#         \"\"\"\n#         nums.sort()\n#         result = nums[0] + nums[1] + nums[2]\n#         for i in range(len(nums) - 2):\n#             if i > 0 and nums[", "runtimes": [0.0004482269287109375, 0.0005164146423339844, 0.02630615234375, 0.034757375717163086, 0.06538748741149902, 0.06845378875732422, 0.07541418075561523, 0.07874178886413574, 0.08570718765258789, 0.08590102195739746, 0.08602070808410645, 0.08606672286987305, 0.08860230445861816, 0.08928537368774414, 0.09014773368835449, 0.09121155738830566, 0.10040926933288574, 0.10562610626220703, 0.10775923728942871, 0.11189508438110352, 0.11330056190490723, 0.11586713790893555, 0.1227116584777832, 0.205596923828125, 0.22733712196350098, 0.26176905632019043], "beyond_p": 0.7025634568942001}], "maximum-depth-of-binary-tree": [{"slug_name": "maximum-depth-of-binary-tree", "status": {"result": "passed", "runtime": 0.0005586147308349609, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            left_height = self.maxDepth(root.left)\n            right_height = self.maxDepth(root.right)\n            return max(left_height, right_height) + 1\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Breadth-first search (BFS)\n\nfrom collections import deque\n\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        \n        queue = deque([(root, 1)])\n        max_depth = 0\n        \n        while queue:\n            node, depth = queue.popleft()\n            max_depth = max(max_depth, depth)\n            \n            if node.left:\n                queue.append((node.left, depth + 1))\n            if node.right:\n                queue.append((node.right, depth + 1))\n        \n        return max_depth\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Iterative depth-first search (DFS)\n\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        \n        stack = [(root, 1)]\n        max_depth = 0\n        \n        while stack:\n            node, depth = stack.pop()\n            max_depth = max(max_depth, depth)\n            \n            if node.left:\n                stack.append((node.left, depth + 1))\n            if node.right:\n                stack.append((node.right, depth + 1))\n        \n        return max_depth\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Iterative depth-first search (DFS) with explicit stack\n\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        \n        stack = [(root, 1)]\n        max_depth = 0\n        \n        while stack:\n            node, depth = stack.pop()\n            max_depth = max(max_depth, depth)\n            \n            if node.left:\n                stack.append((node.left, depth + 1))\n            if node.right:\n                stack.append((node.right, depth + 1))\n        \n        return max_depth\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Iterative depth-first search (DFS) with explicit stack and depth tracking\n\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        \n        stack = [(root, 1)]\n        max_depth = 0\n        \n        while stack:\n            node, depth = stack.pop()\n            max_depth = max(max_depth, depth)\n            \n            if node.left:\n                stack.append((node.left, depth + 1))\n            if node.right:\n                stack.append((node.right, depth + 1))\n        \n        return max_depth\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Iterative depth-first search (DFS) with explicit stack and depth tracking\n\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        \n        stack = [(root, 1)]\n        max_depth = 0\n        \n        while stack:\n            node, depth = stack.pop()\n            max_depth = max(max_depth, depth)\n            \n            if node.left:\n                stack.append((node.left, depth + 1))\n            if node.right:\n                stack.append((node.right, depth + 1))\n        \n        return max_depth\n\n# Time complexity: O", "runtimes": [0.00038170814514160156, 0.0003859996795654297, 0.0003871917724609375, 0.00039005279541015625, 0.00039267539978027344, 0.0003941059112548828, 0.0003943443298339844, 0.0003960132598876953, 0.00039696693420410156, 0.00039768218994140625, 0.0004057884216308594, 0.0004067420959472656, 0.0004405975341796875, 0.0005319118499755859, 0.0005490779876708984, 0.0005545616149902344, 0.0005562305450439453, 0.0005888938903808594], "beyond_p": 0.14614499424626007}], "intersection-of-two-arrays-ii": [{"slug_name": "intersection-of-two-arrays-ii", "status": {"result": "passed", "runtime": 0.0014126300811767578, "index": 0}, "solution": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res", "runtimes": [0.0006875991821289062, 0.0007712841033935547, 0.0008268356323242188, 0.000881195068359375, 0.0008838176727294922, 0.0009043216705322266, 0.0009152889251708984, 0.0009822845458984375, 0.0010294914245605469, 0.0013980865478515625, 0.0014748573303222656, 0.0029625892639160156, 0.0032324790954589844, 0.003399372100830078, 0.004729032516479492, 0.00710606575012207, 0.01172494888305664, 0.014452695846557617], "beyond_p": 0.9473283103836494}], "minimum-absolute-difference-in-bst": [{"slug_name": "minimum-absolute-difference-in-bst", "status": {"result": "passed", "runtime": 0.0006666183471679688, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(node):\n            if node:\n                return inorder(node.left) + [node.val] + inorder(node.right)\n            else:\n                return []\n        \n        lst = inorder(root)\n        return min(abs(a - b) for a, b in zip(lst, lst[1:]))\n\n# Time: O(n log n)\n# Space: O(n)\n\n# Test Cases\nif __name__ == \"__main__\":\n    solution = Solution()\n    root = TreeNode(4)\n    root.left = TreeNode(2)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(3)\n    print(solution.getMinimumDifference(root))\n\n    root = TreeNode(1)\n    root.left = TreeNode(0)\n    root.right = TreeNode(48)\n    root.right.left = TreeNode(12)\n    root.right.right = TreeNode(49)\n    print(solution.getMinimumDifference(root))\n\n# Expected Output:\n# 1\n# 1\n\n# Solution:\n# This problem can be solved by using inorder traversal of the BST. Inorder traversal of a BST gives a sorted list of nodes. We can then find the minimum difference between any two consecutive nodes in the list.\n# The time complexity is O(n log n) because we are sorting the list of nodes. The space complexity is O(n) because we are storing the list of nodes.\n# The zip function is used to get pairs of consecutive nodes. The min function is used to find the minimum difference.\n# The abs function is used to get the absolute difference between two numbers.\n# The inorder function is a recursive function that returns the inorder traversal of the BST.\n# The getMinimumDifference function returns the minimum difference.\n# The test cases are given in the main function. The first test case is a BST with 5 nodes and the second test case is a BST with 5 nodes. The output is the minimum difference between any two different nodes in the BST.\n# The expected output is 1 for both test cases.\n# The solution is correct because it uses the inorder traversal of the BST to get the sorted list of nodes and then finds the minimum difference between any two consecutive nodes in the list.\n# The time complexity is O(n log n) because we are sorting the list of nodes. The space complexity is O(n) because we are storing the list of nodes.\n# The zip function is used to get pairs of consecutive nodes. The min function is used to find the minimum difference.\n# The abs function is used to get the absolute difference between two numbers.\n# The inorder function is a recursive function that returns the inorder traversal of the BST.\n# The getMinimumDifference function returns the minimum difference.\n# The test cases are given in the main function. The first test case is a BST with 5 nodes and the second test case is a BST with 5 nodes. The output is the minimum difference between any two different nodes in the BST.\n# The expected output is 1 for both test cases.\n# The solution is correct because it uses the inorder traversal of the BST to get the sorted list of nodes and then finds the minimum difference between any two consecutive nodes in the list.\n# The time complexity is O(n log n) because we are sorting the list of nodes. The space complexity is O(n) because we are storing the list of nodes.\n# The zip function is used to get pairs of consecutive nodes. The min function is used to find the minimum difference.\n# The abs function is used to get the absolute difference between two numbers.\n# The inorder function is a recursive function that returns the inorder traversal of the BST.\n# The getMinimumDifference function returns the minimum difference.\n# The test cases are given in the main function. The first test case is a BST with 5 nodes and the second test case is a BST with 5 nodes. The output is the minimum difference between any two different nodes in the BST.\n# The expected output is 1 for both test cases.\n# The solution is correct because it uses the inorder traversal of the BST to get the sorted list of nodes and then finds the minimum difference between any two consecutive nodes in the list.", "runtimes": [0.0006465911865234375, 0.0006501674652099609, 0.0006530284881591797, 0.0006649494171142578, 0.0006678104400634766, 0.0006728172302246094, 0.0006747245788574219, 0.0006756782531738281, 0.0006804466247558594, 0.0006811618804931641, 0.0006814002990722656, 0.0006899833679199219, 0.0006916522979736328, 0.0006918907165527344, 0.0006940364837646484, 0.0006988048553466797, 0.0007002353668212891, 0.0007066726684570312, 0.0007233619689941406, 0.0007314682006835938, 0.0007436275482177734, 0.0022962093353271484], "beyond_p": 0.987859517271282}], "find-mode-in-binary-search-tree": [{"slug_name": "find-mode-in-binary-search-tree", "status": {"result": "passed", "runtime": 0.0009963512420654297, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(node):\n            if node:\n                yield from inorder(node.left)\n                yield node.val\n                yield from inorder(node.right)\n        \n        max_count = float('-inf')\n        count = collections.Counter()\n        modes = []\n        prev = None\n        \n        for val in inorder(root):\n            if val != prev:\n                prev = val\n                count[val] = 1\n            else:\n                count[val] += 1\n            \n            if count[val] > max_count:\n                max_count = count[val]\n                modes = [val]\n            elif count[val] == max_count:\n                modes.append(val)\n        \n        return modes\n    \n\n# Time: O(n)\n# Space: O(n)\n# n is the number of nodes in the tree.\n# We visit each node exactly once.\n# We use a counter to keep track of the frequency of each value.\n# We use a list to keep track of the modes.\n# We use a variable to keep track of the maximum count.\n# We use a variable to keep track of the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a list to store the modes.\n# We use a variable to store the maximum count.\n# We use a variable to store the previous value.\n# We use a generator to traverse the tree in order.\n# We use a", "runtimes": [0.0006411075592041016, 0.0006682872772216797, 0.0006692409515380859, 0.0006859302520751953, 0.0006916522979736328, 0.0006966590881347656, 0.0007116794586181641, 0.0007307529449462891, 0.000759124755859375, 0.0008943080902099609, 0.0009467601776123047, 0.0014421939849853516, 0.011593818664550781], "beyond_p": 0.9675656849300159}], "find-the-index-of-the-first-occurrence-in-a-string": [{"slug_name": "find-the-index-of-the-first-occurrence-in-a-string", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        if len(needle) > len(haystack):\n            return -1\n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1\n\n# Time complexity: O(n*m)\n# Space complexity: O(1)\n\n# Test cases\ns = Solution()\nprint(s.strStr(\"sadbutsad\", \"sad\")) # 0\nprint(s.strStr(\"leetcode\", \"leeto\")) # -1\nprint(s.strStr(\"hello\", \"ll\")) # 2\nprint(s.strStr(\"aaaaa\", \"bba\")) # -1\nprint(s.strStr(\"\", \"\")) # 0\nprint(s.strStr(\"a\", \"a\")) # 0\nprint(s.strStr(\"abc\", \"c\")) # 2\nprint(s.strStr(\"mississippi\", \"issip\")) # 4\nprint(s.strStr(\"mississippi\", \"pi\")) # 9\nprint(s.strStr(\"aabaaabaaac\", \"aabaaac\")) # 4\nprint(s.strStr(\"abxabcabcaby\", \"abcaby\")) # 6\nprint(s.strStr(\"abcabcabcaby\", \"abcaby\")) # 6\nprint(s.strStr(\"abcabcabcaby\", \"abcabyx\")) # -1\nprint(s.strStr(\"abcabcabcaby\", \"x\")) # -1\nprint(s.strStr(\"abcabcabcaby\", \"\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcabyx\")) # -1\nprint(s.strStr(\"abcabcabcaby\", \"xabcabcabcaby\")) # -1\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(s.strStr(\"abcabcabcaby\", \"abcabcabcaby\")) # 0\nprint(", "runtimes": [0.00024199485778808594, 0.00024271011352539062, 0.00024700164794921875, 0.000247955322265625, 0.00025177001953125, 0.0002593994140625, 0.0003097057342529297, 0.0006098747253417969, 0.0007102489471435547, 0.0007190704345703125, 0.0007293224334716797, 0.0008440017700195312, 0.0008709430694580078, 0.0012226104736328125, 0.0015201568603515625, 0.008667469024658203, 0.023054122924804688, 0.20263290405273438], "beyond_p": 0.0}], "strong-password-checker": [{"slug_name": "strong-password-checker", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        def check(s):\n            lower = upper = digit = False\n            for i in range(len(s)):\n                if s[i].islower():\n                    lower = True\n                elif s[i].isupper():\n                    upper = True\n                elif s[i].isdigit():\n                    digit = True\n                if i > 0 and i < len(s) - 1 and s[i-1] == s[i] == s[i+1]:\n                    return False\n            return lower and upper and digit\n        \n        def count(s):\n            lower = upper = digit = 1\n            for i in range(len(s)):\n                if s[i].islower():\n                    lower = 0\n                elif s[i].isupper():\n                    upper = 0\n                elif s[i].isdigit():\n                    digit = 0\n            return lower + upper + digit\n        \n        if len(password) < 6:\n            return max(6 - len(password), count(password))\n        elif len(password) > 20:\n            return max(len(password) - 20, count(password[:20]))\n        elif not check(password):\n            return count(password)\n        else:\n            return 0\n\n# Time: O(n)\n# Space: O(1)\n\n# Test Cases\nif __name__ == \"__main__\":\n    solution = Solution()\n    assert solution.strongPasswordChecker(\"a\") == 5\n    assert solution.strongPasswordChecker(\"aA1\") == 3\n    assert solution.strongPasswordChecker(\"1337C0d3\") == 0\n    assert solution.strongPasswordChecker(\"aaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 2\n    assert solution.strongPasswordChecker(\"aaaaaaaaaaaaaaaa", "runtimes": [0.00033736228942871094, 0.00035381317138671875, 0.00039315223693847656, 0.0004172325134277344, 0.00042557716369628906, 0.00044226646423339844, 0.0004456043243408203, 0.0007014274597167969, 0.00091552734375, 0.0012323856353759766], "beyond_p": 0.0}], "factorial-trailing-zeroes": [{"slug_name": "factorial-trailing-zeroes", "status": {"result": "passed", "runtime": 0.0002579689025878906, "index": 0}, "solution": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count", "runtimes": [0.0002651214599609375, 0.00027060508728027344, 0.007231712341308594, 0.009531497955322266, 0.010767936706542969, 0.015803098678588867, 0.02141094207763672, 0.021557331085205078, 0.03769040107727051, 0.03775501251220703, 0.04267740249633789, 0.05017852783203125, 0.05576515197753906, 0.059191226959228516, 0.07479524612426758, 0.07503938674926758, 0.09013223648071289, 0.09120631217956543, 0.09150147438049316], "beyond_p": 1.00007839591505}], "zigzag-conversion": [{"slug_name": "zigzag-conversion", "status": {"result": "passed", "runtime": 0.0006470680236816406, "index": 0}, "solution": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1 or numRows >= len(s):\n            return s\n        \n        L = [''] * numRows\n        index, step = 0, 1\n        \n        for x in s:\n            L[index] += x\n            if index == 0:\n                step = 1\n            elif index == numRows -1:\n                step = -1\n            index += step\n        \n        return ''.join(L)", "runtimes": [0.0006434917449951172, 0.0010142326354980469, 0.0011630058288574219, 0.001196146011352539, 0.0012586116790771484, 0.002017498016357422, 0.007500886917114258, 0.00768280029296875, 0.008523702621459961, 0.009473562240600586, 0.00966334342956543, 0.010149478912353516, 0.010879278182983398, 0.01739645004272461, 0.018187284469604492, 0.024074792861938477, 0.024444580078125, 0.028736114501953125, 0.0317537784576416, 0.032006263732910156, 0.07009267807006836], "beyond_p": 0.9999485051031443}], "trapping-rain-water": [{"slug_name": "trapping-rain-water", "status": {"result": "passed", "runtime": 0.00043201446533203125, "index": 0}, "solution": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not height:\n            return 0\n        \n        left_max = [0]*len(height)\n        right_max = [0]*len(height)\n        \n        left_max[0] = height[0]\n        for i in range(1, len(height)):\n            left_max[i] = max(height[i], left_max[i-1])\n            \n        right_max[-1] = height[-1]\n        for i in range(len(height)-2, -1, -1):\n            right_max[i] = max(height[i], right_max[i+1])\n            \n        ans = 0\n        for i in range(1, len(height)-1):\n            ans += min(left_max[i], right_max[i]) - height[i]\n            \n        return ans", "runtimes": [0.0003139972686767578, 0.0003209114074707031, 0.0003228187561035156, 0.0003807544708251953, 0.0003914833068847656, 0.00044608116149902344, 0.0004515647888183594, 0.00046634674072265625, 0.0004992485046386719, 0.0005002021789550781, 0.0005102157592773438, 0.0005254745483398438, 0.0005519390106201172, 0.0005543231964111328, 0.0005843639373779297, 0.0005993843078613281, 0.0006086826324462891, 0.0006093978881835938, 0.0006809234619140625, 0.0007376670837402344, 0.0009067058563232422], "beyond_p": 0.8008849557522124}], "find-all-numbers-disappeared-in-an-array": [{"slug_name": "find-all-numbers-disappeared-in-an-array", "status": {"result": "passed", "runtime": 0.00032591819763183594, "index": 0}, "solution": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        res = []\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                res.append(i+1)\n        return res", "runtimes": [0.00026988983154296875, 0.0002701282501220703, 0.00027251243591308594, 0.0002758502960205078, 0.0002760887145996094, 0.00027680397033691406, 0.00027823448181152344, 0.0002791881561279297, 0.0002846717834472656, 0.00030612945556640625, 0.00031065940856933594, 0.0003204345703125, 0.00032067298889160156, 0.00032210350036621094, 0.00032591819763183594, 0.0003261566162109375, 0.00032782554626464844, 0.00033020973205566406, 0.00033283233642578125, 0.000335693359375, 0.0003399848937988281, 0.0003559589385986328, 0.0003731250762939453], "beyond_p": 0.45727482678983833}], "count-of-smaller-numbers-after-self": [{"slug_name": "count-of-smaller-numbers-after-self", "status": {"result": "passed", "runtime": 0.0008175373077392578, "index": 0}, "solution": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(enum):\n            half = len(enum) // 2\n            if half:\n                left, right = mergeSort(enum[:half]), mergeSort(enum[half:])\n                for i in range(len(enum))[::-1]:\n                    if not right or left and left[-1][1] > right[-1][1]:\n                        smaller[left[-1][0]] += len(right)\n                        enum[i] = left.pop()\n                    else:\n                        enum[i] = right.pop()\n            return enum\n        smaller = [0] * len(nums)\n        mergeSort(list(enumerate(nums)))\n        return smaller", "runtimes": [0.0003840923309326172, 0.0003879070281982422, 0.00039386749267578125, 0.00041747093200683594, 0.0007750988006591797, 0.0008099079132080078, 0.0009047985076904297, 0.0010395050048828125, 0.0011124610900878906, 0.0011153221130371094, 0.0011796951293945312, 0.0012006759643554688, 0.001714468002319336, 0.0018916130065917969, 0.001912832260131836, 0.0023615360260009766, 0.005064249038696289, 0.00547337532043457, 0.0070989131927490234, 0.013012886047363281], "beyond_p": 0.9656780380977553}], "set-intersection-size-at-least-two": [{"slug_name": "set-intersection-size-at-least-two", "status": {"result": "passed", "runtime": 0.002028226852416992, "index": 0}, "solution": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        cur = [intervals[0][1]-1, intervals[0][1]]\n        res = 2\n        for interval in intervals[1:]:\n            if cur[0] < interval[0] and interval[0] <= cur[1]:\n                if interval[1] > cur[1]:\n                    cur = [cur[1], interval[1]]\n                    res += 1\n                else:\n                    cur = [cur[0], cur[1]-1]\n                    res += 1\n            elif cur[1] < interval[0]:\n                cur = [interval[1]-1, interval[1]]\n                res += 2\n        return res", "runtimes": [0.0012464523315429688, 0.0013055801391601562, 0.0015518665313720703, 0.0021855831146240234, 0.0033495426177978516, 0.003840923309326172, 0.004646778106689453, 0.00482177734375, 0.005417823791503906, 0.0069179534912109375, 0.0074651241302490234], "beyond_p": 0.8742859333665606}], "symmetric-tree": [{"slug_name": "symmetric-tree", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(t1, t2):\n            if t1 is None and t2 is None: return True\n            if t1 is None or t2 is None: return False\n            return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)\n\n        return isMirror(root, root)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n\n        stack = [[root.left, root.right]]\n\n        while len(stack) > 0:\n            pair = stack.pop(0)\n            left = pair[0]\n            right = pair[1]\n\n            if left is None and right is None:\n                continue\n            if left is None or right is None:\n                return False\n            if left.val == right.val:\n                stack.insert(0, [left.left, right.right])\n\n                stack.insert(0, [left.right, right.left])\n            else:\n                return False\n\n        return True\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n\n        def isSym(L,R):\n            if L and R and L.val == R.val: \n                return isSym(L.left, R.right) and isSym(L.right, R.left)\n            return L == R\n\n        return isSym(root.left, root.right)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n\n        def isSym(L,R):\n            if L and R and L.val == R.val: \n                return isSym(L.left, R.right) and isSym(L.right, R.left)\n            return L == R\n\n        return isSym(root.left, root.right)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n\n        def isSym(L,R):\n            if L and R and L.val == R.val: \n                return isSym(L.left, R.right) and isSym(L.right, R.left)\n            return L == R\n\n        return isSym(root.left, root.right)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n\n        def isSym(L,R):\n            if L and R and L.val == R.val: \n                return isSym(L.left, R.right", "runtimes": [0.00035953521728515625, 0.0003597736358642578, 0.0003616809844970703, 0.00036215782165527344, 0.0003628730773925781, 0.0003695487976074219, 0.000370025634765625, 0.0003726482391357422, 0.00038242340087890625, 0.00038552284240722656, 0.00043272972106933594, 0.00048661231994628906, 0.0005326271057128906, 0.0005900859832763672, 0.00063323974609375], "beyond_p": 0.0}], "number-of-atoms": [{"slug_name": "number-of-atoms", "status": {"result": "failed@eval", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula, i):\n            counts = collections.defaultdict(int)\n            while i < len(formula):\n                if formula[i] == '(':\n                    sub_counts, i = parse(formula, i + 1)\n                    count = self.parse_num(formula, i)\n                    for atom, v in sub_counts.iteritems():\n                        counts[atom] += v * count\n                elif formula[i] == ')':\n                    i += 1\n                    return counts, i\n                else:\n                    atom = self.parse_atom(formula, i)\n                    i += len(atom)\n                    count = self.parse_num(formula, i)\n                    counts[atom] += count\n            return counts, i\n\n        def parse_atom(formula, i):\n            j = i + 1\n            while j < len(formula) and formula[j].islower():\n                j += 1\n            return formula[i:j]\n\n        def parse_num(formula, i):\n            j = i\n            while j < len(formula) and formula[j].isdigit():\n                j += 1\n            return int(formula[i:j] or 1)\n\n        counts, _ = parse(formula, 0)\n        return ''.join(atom + (str(count) if count > 1 else '') for atom, count in sorted(counts.items()))", "runtimes": [0.0018305778503417969, 0.010750055313110352, 0.010802745819091797], "beyond_p": 0.0}], "binary-tree-preorder-traversal": [{"slug_name": "binary-tree-preorder-traversal", "status": {"result": "failed@cases", "runtime": 0.0003485679626464844, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack, output = [root, ], []\n        \n        while stack:\n            root = stack.pop()\n            output.append(root.val)\n            if root.right is not None:\n                stack.append(root.right)\n            if root.left is not None:\n                stack.append(root.left)\n                \n        return output\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n        \n        stack, output = [root, ], []\n        \n        while stack:\n            root = stack.pop()\n            output.append(root.val)\n            if root.right is not None:\n                stack.append(root.right)\n            if root.left is not None:\n                stack.append(root.left)\n                \n        return output\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n        \n        stack, output = [root, ], []\n        \n        while stack:\n            root = stack.pop()\n            output.append(root.val)\n            if root.right is not None:\n                stack.append(root.right)\n            if root.left is not None:\n                stack.append(root.left)\n                \n        return output\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n        \n        stack, output = [root, ], []\n        \n        while stack:\n            root = stack.pop()\n            output.append(root.val)\n            if root.right is not None:\n                stack.append(root.right)\n            if root.left is not None:\n                stack.append(root.left)\n                \n        return output\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n        \n        stack, output = [root, ], []\n        \n        while stack:\n            root = stack.pop()\n            output.append(root.val)\n            if root.right is not None:\n                stack.append(root.right)\n            if root.left is not None:\n                stack.append(root.left)\n                \n        return output\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []", "runtimes": [0.00039315223693847656, 0.0003972053527832031, 0.0003972053527832031, 0.00040030479431152344, 0.00040221214294433594, 0.00040411949157714844, 0.0004134178161621094, 0.0004189014434814453, 0.0004191398620605469, 0.0004298686981201172, 0.0004525184631347656, 0.0005893707275390625], "beyond_p": 0.0}], "power-of-four": [{"slug_name": "power-of-four", "status": {"result": "passed", "runtime": 0.00028204917907714844, "index": 0}, "solution": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n < 1:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1", "runtimes": [0.0002567768096923828, 0.000270843505859375, 0.0002777576446533203, 0.0002810955047607422, 0.00028228759765625, 0.0002903938293457031, 0.00029277801513671875, 0.0002963542938232422, 0.00029659271240234375, 0.000301361083984375, 0.0003044605255126953, 0.0004591941833496094], "beyond_p": 0.8751472320376914}], "invert-binary-tree": [{"slug_name": "invert-binary-tree", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root\n\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.", "runtimes": [0.0004782676696777344, 0.00047898292541503906, 0.0004825592041015625, 0.0004901885986328125, 0.0004916191101074219, 0.0004923343658447266, 0.0004961490631103516, 0.0004971027374267578, 0.0004987716674804688, 0.0004987716674804688, 0.0005004405975341797, 0.0005006790161132812, 0.0005030632019042969, 0.0005042552947998047], "beyond_p": 0.0}], "generate-parentheses": [{"slug_name": "generate-parentheses", "status": {"result": "passed", "runtime": 0.00039696693420410156, "index": 0}, "solution": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(s = '', left = 0, right = 0):\n            if len(s) == 2 * n:\n                ans.append(s)\n                return\n            if left < n:\n                backtrack(s+'(', left+1, right)\n            if right < left:\n                backtrack(s+')', left, right+1)\n\n        ans = []\n        backtrack()\n        return ans", "runtimes": [0.0003654956817626953, 0.0003733634948730469, 0.00037670135498046875, 0.0003807544708251953, 0.00038933753967285156, 0.00039696693420410156, 0.00040030479431152344, 0.00040340423583984375, 0.0004220008850097656, 0.00042438507080078125, 0.00043654441833496094, 0.00043845176696777344, 0.000446319580078125, 0.000461578369140625, 0.0006387233734130859, 0.0006620883941650391, 0.0007359981536865234, 0.0009853839874267578, 0.0011458396911621094], "beyond_p": 0.9596700274977086}], "patching-array": [{"slug_name": "patching-array", "status": {"result": "passed", "runtime": 0.0006759166717529297, "index": 0}, "solution": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        patch, miss, i = 0, 1, 0\n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                patch += 1\n        return patch", "runtimes": [0.00048351287841796875, 0.0006396770477294922, 0.0006747245788574219, 0.0006759166717529297, 0.0006809234619140625, 0.0007178783416748047, 0.000720977783203125, 0.000728607177734375, 0.0008409023284912109, 0.007605552673339844], "beyond_p": 0.9729847348687735}], "longest-valid-parentheses": [{"slug_name": "longest-valid-parentheses", "status": {"result": "passed", "runtime": 0.0009279251098632812, "index": 0}, "solution": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = [-1]\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len", "runtimes": [0.0005896091461181641, 0.0006697177886962891, 0.0007085800170898438, 0.0007190704345703125, 0.0007212162017822266, 0.0007259845733642578, 0.0007307529449462891, 0.0007309913635253906, 0.0007450580596923828, 0.0007452964782714844, 0.0007517337799072266, 0.0007538795471191406, 0.000919342041015625, 0.0009562969207763672, 0.0009846687316894531, 0.0009958744049072266, 0.0013413429260253906], "beyond_p": 0.5499524262607041}], "fraction-to-recurring-decimal": [{"slug_name": "fraction-to-recurring-decimal", "status": {"result": "failed@cases", "runtime": 0.00047969818115234375, "index": 0}, "solution": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        \n        sign = '' if numerator * denominator >= 0 else '-'\n        numerator, denominator = abs(numerator), abs(denominator)\n        integer, remainder = divmod(numerator, denominator)\n        remainder *= 10\n        digits = []\n        seen = {}\n        \n        while remainder not in seen:\n            seen[remainder] = len(digits)\n            \n            div, remainder = divmod(remainder, denominator)\n            digits.append(str(div))\n            \n            remainder *= 10\n        \n        idx = seen.get(remainder)\n        repeating = ''.join(digits[idx:])\n        non_repeating = ''.join(digits[:idx])\n        \n        return '{}{}.{}({})'.format(sign, integer, non_repeating, repeating) if idx else '{}{}.{}'.format(sign, integer, ''.join(digits))", "runtimes": [0.000446319580078125, 0.000453948974609375, 0.00045418739318847656, 0.00045561790466308594, 0.00045680999755859375, 0.00045871734619140625, 0.0004596710205078125, 0.0004627704620361328, 0.00046372413635253906, 0.00046372413635253906, 0.00046372413635253906], "beyond_p": 0.0}], "sort-list": [{"slug_name": "sort-list", "status": {"result": "passed", "runtime": 0.004820346832275391, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        prev, slow, fast = None, head, head\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        prev.next = None\n        \n        return self.merge(*map(self.sortList, (head, slow)))\n    \n    def merge(self, h1, h2):\n        dummy = tail = ListNode(None)\n        while h1 and h2:\n            if h1.val < h2.val:\n                tail.next, tail, h1 = h1, h1, h1.next\n            else:\n                tail.next, tail, h2 = h2, h2, h2.next\n    \n        tail.next = h1 or h2\n        return dummy.next\n    \n\n# Time: O(n log n)\n# Space: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n# Time complexity: O(n log n)\n# Space complexity: O(1)\n\n#", "runtimes": [0.0016179084777832031, 0.001695871353149414, 0.0018219947814941406, 0.001859903335571289, 0.0024619102478027344, 0.002557039260864258, 0.003860950469970703, 0.00418400764465332, 0.004315853118896484, 0.004416704177856445, 0.004546403884887695, 0.0045621395111083984, 0.004698276519775391, 0.004736423492431641, 0.004802703857421875, 0.0049703121185302734, 0.005062103271484375, 0.0051860809326171875, 0.005480051040649414, 0.005589723587036133, 0.0059375762939453125, 0.0059986114501953125, 0.006226539611816406], "beyond_p": 0.30512157268494566}], "russian-doll-envelopes": [{"slug_name": "russian-doll-envelopes", "status": {"result": "passed", "runtime": 0.0017671585083007812, "index": 0}, "solution": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for _, height in envelopes:\n            left = bisect_left(dp, height)\n            if left == len(dp): dp.append(height)\n            else: dp[left] = height\n        return len(dp)", "runtimes": [0.0017125606536865234, 0.0017390251159667969, 0.001772165298461914, 0.0018346309661865234, 0.0019185543060302734, 0.0019376277923583984, 0.001968860626220703, 0.0023202896118164062, 0.002445697784423828, 0.002526521682739258, 0.002740621566772461, 0.002817869186401367, 0.004019975662231445, 0.004145383834838867, 0.004168272018432617, 0.004797935485839844, 0.005261421203613281, 0.0067403316497802734, 0.017925739288330078, 0.02175426483154297], "beyond_p": 0.9972757878207492}], "set-matrix-zeroes": [{"slug_name": "set-matrix-zeroes", "status": {"result": "passed", "runtime": 0.0003688335418701172, "index": 0}, "solution": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        first_row_has_zero = not all(matrix[0])\n        first_col_has_zero = not all(matrix[i][0] for i in range(m))\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = matrix[0][j] = 0\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if first_row_has_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n        \n        if first_col_has_zero:\n            for i in range(m):\n                matrix[i][0] = 0", "runtimes": [0.00031185150146484375, 0.00031447410583496094, 0.0003151893615722656, 0.0003161430358886719, 0.00031757354736328125, 0.0003190040588378906, 0.0003247261047363281, 0.00032520294189453125, 0.00032639503479003906, 0.0003349781036376953, 0.0003380775451660156, 0.0003437995910644531, 0.0003485679626464844, 0.0003509521484375, 0.0003521442413330078, 0.00035452842712402344, 0.00035762786865234375, 0.0003631114959716797, 0.00037097930908203125, 0.00037097930908203125, 0.0003790855407714844, 0.0004038810729980469, 0.00044274330139160156, 0.0005309581756591797, 0.0006375312805175781, 0.0006651878356933594, 0.0008997917175292969], "beyond_p": 0.9030819140308192}], "remove-nth-node-from-end-of-list": [{"slug_name": "remove-nth-node-from-end-of-list", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n        \n        for i in range(n+1):\n            first = first.next\n            \n        while first is not None:\n            first = first.next\n            second = second.next\n            \n        second.next = second.next.next\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n        for i in range(n+1):\n            first = first.next\n        while first is not None:\n            first = first.next\n            second = second.next\n        second.next = second.next.next\n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n        for i in range(n+1):\n            first = first.next\n        while first is not None:\n            first = first.next\n            second = second.next\n        second.next = second.next.next\n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n        for i in range(n+1):\n            first = first.next\n        while first is not None:\n            first = first.next\n            second = second.next\n        second.next = second.next.next\n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n        for i in range(n+1):\n            first = first.next\n        while first is not None:\n            first = first.next\n            second = second.next\n        second.next = second.next.next\n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n        for i in range(n+1):\n            first = first.next\n        while first is not None:\n            first = first.", "runtimes": [0.00033092498779296875, 0.0003323554992675781, 0.0003325939178466797, 0.0003330707550048828, 0.00033402442932128906, 0.000335693359375, 0.0003361701965332031, 0.00033664703369140625, 0.0003371238708496094, 0.0003371238708496094, 0.00033736228942871094, 0.0003383159637451172, 0.00033855438232421875, 0.0003390312194824219, 0.0003390312194824219, 0.000339508056640625, 0.0003399848937988281, 0.00034046173095703125, 0.0003407001495361328, 0.0003409385681152344, 0.00034117698669433594, 0.00034117698669433594, 0.00034117698669433594, 0.0003426074981689453, 0.00034427642822265625, 0.00034689903259277344, 0.0003483295440673828, 0.0003490447998046875, 0.00034999847412109375, 0.00035071372985839844, 0.00035452842712402344, 0.00035762786865234375], "beyond_p": 0.0}], "intersection-of-two-arrays": [{"slug_name": "intersection-of-two-arrays", "status": {"result": "passed", "runtime": 0.0006947517395019531, "index": 0}, "solution": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))", "runtimes": [0.0006868839263916016, 0.0006902217864990234, 0.0006997585296630859, 0.0006999969482421875, 0.0007009506225585938, 0.0007042884826660156, 0.0007047653198242188, 0.0007114410400390625, 0.0007162094116210938, 0.000827789306640625, 0.00092315673828125, 0.001068115234375, 0.0016064643859863281, 0.0016095638275146484, 0.0023088455200195312, 0.007371664047241211, 0.007669925689697266, 0.015440225601196289, 0.017215728759765625, 0.03631901741027832], "beyond_p": 0.9997791933195943}], "super-washing-machines": [{"slug_name": "super-washing-machines", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total, n = sum(machines), len(machines)\n        if total % n:\n            return -1\n        target, res, toRight = total / n, 0, 0\n        for m in machines:\n            toRight = m + toRight - target\n            res = max(res, abs(toRight), m - target)\n        return res\n    \n\nif __name__ == \"__main__\":\n    machines = [1,0,5]\n    assert Solution().findMinMoves(machines) == 3\n\n    machines = [0,3,0]\n    assert Solution().findMinMoves(machines) == 2\n\n    machines = [0,2,0]\n    assert Solution().findMinMoves(machines) == -1\n\n    machines = [0,0,11,5]\n    assert Solution().findMinMoves(machines) == 8\n\n    machines = [4,0,0,4]\n    assert Solution().findMinMoves(machines) == 2\n\n    machines = [0,0,0,4]\n    assert Solution().findMinMoves(machines) == -1\n\n    machines = [9,1,8,8,9]\n    assert Solution().findMinMoves(machines) == 4\n\n    machines = [10,0,8,0,12,10,9,11,11]\n    assert Solution().findMinMoves(machines) == 11\n\n    machines = [0,5,0]\n    assert Solution().findMinMoves(machines) == 3\n\n    machines = [1,0,5]\n    assert Solution().findMinMoves(machines) == 3\n\n    machines = [0,0,10]\n    assert Solution().findMinMoves(machines) == 5\n\n    machines = [0,0,10,0,0,0,10]\n    assert Solution().findMinMoves(machines) == 6\n\n    machines = [4,9,8,4,1]\n    assert Solution().findMinMoves(machines) == 7\n\n    machines = [1,2,3,4,5,6,7,8,9,10]\n    assert Solution().findMinMoves(machines) == 9\n\n    machines = [10,9,8,7,6,5,4,3,2,1]\n    assert Solution().findMinMoves(machines) == 9\n\n    machines = [1,1,1,1,1,1,1,1,1,100]\n    assert Solution().findMinMoves(machines) == 50\n\n    machines = [100,1,1,1,1,1,1,1,1,1]\n    assert Solution().findMinMoves(machines) == 50\n\n    machines = [1,0,5]\n    assert Solution().findMinMoves(machines) == 3\n\n    machines = [0,3,0]\n    assert Solution().findMinMoves(machines) == 2\n\n    machines = [0,0,0,4]\n    assert Solution().findMinMoves(machines) == -1\n\n    machines = [0,0,11,5]\n    assert Solution().findMinMoves(machines) == 8\n\n    machines = [4,0,0,4]\n    assert Solution().findMinMoves(machines) == 2\n\n    machines = [0,0,0,4]\n    assert Solution().findMinMoves(machines) == -1\n\n    machines = [9,1,8,8,9]\n    assert Solution().findMinMoves(machines) == 4\n\n    machines = [10,0,8,0,12,10,9,11,11]\n    assert Solution().findMinMoves(machines) == 11\n\n    machines = [0,5,0]\n    assert Solution().findMinMoves(machines) == 3\n\n    machines = [1,0,5]\n    assert Solution().findMinMoves(machines) ==", "runtimes": [0.00034546852111816406, 0.0003459453582763672, 0.000347137451171875, 0.00034737586975097656, 0.0003495216369628906, 0.0003497600555419922, 0.00035309791564941406, 0.0003533363342285156, 0.0003535747528076172, 0.0003552436828613281, 0.00035643577575683594, 0.00035953521728515625, 0.0003609657287597656, 0.0003619194030761719, 0.0003685951232910156, 0.0005431175231933594], "beyond_p": 0.0}], "kth-smallest-number-in-multiplication-table": [{"slug_name": "kth-smallest-number-in-multiplication-table", "status": {"result": "failed@cases", "runtime": 0.7081742286682129, "index": 0}, "solution": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def enough(x):\n            count = 0\n            for i in range(1, m+1):\n                count += min(x // i , n)\n            return count >= k\n\n        lo, hi = 1, m * n + 1\n        while lo < hi:\n            mi = (lo + hi) / 2\n            if not enough(mi):\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.findKthNumber(3, 3, 5))\n    print(s.findKthNumber(2, 3, 6))\n\n# Time complexity: O(m log mn)\n# Space complexity: O(1)class Solution:\n    def findKthNumber(self, m: int, n: int, k: int) -> int:\n        def enough(x):\n            return sum(min(x // i, n) for i in range(1, m + 1)) >= k\n\n        lo, hi = 1, m * n + 1\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if not enough(mi):\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo", "runtimes": [0.073516845703125, 0.11566591262817383, 0.1338036060333252, 0.1593925952911377, 0.20619893074035645, 0.2928133010864258, 0.30565547943115234, 0.32877683639526367, 0.3337996006011963, 0.3369123935699463, 0.33969974517822266, 0.35576295852661133, 0.3695993423461914, 0.3713572025299072, 0.4589993953704834, 0.46896791458129883], "beyond_p": 0.0}], "convert-sorted-list-to-binary-search-tree": [{"slug_name": "convert-sorted-list-to-binary-search-tree", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def findSize(head):\n            ptr = head\n            c = 0\n            while ptr:\n                ptr = ptr.next  \n                c += 1\n            return c\n        \n        def convertListToBST(l, r):\n            nonlocal head\n            \n            if l > r:\n                return None\n            \n            mid = (l + r) // 2\n            \n            left = convertListToBST(l, mid - 1)\n            \n            node = TreeNode(head.val)   \n            node.left = left\n            \n            head = head.next\n            \n            node.right = convertListToBST(mid + 1, r)\n            return node\n        \n        size = findSize(head)\n        \n        return convertListToBST(0, size - 1)\n      \n      \n# Time complexity: O(NlogN)\n# Space complexity: O(logN)\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not head:\n            return \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow, fast = head, head.next.next\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        tmp = slow.next\n        slow.next = None\n        root = TreeNode(tmp.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(tmp.next)\n        \n        return root\n      \n# Time complexity: O(NlogN)\n# Space complexity: O(logN)\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        slow, fast = head, head.next\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow.next\n        slow.next = None\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root\n      \n# Time complexity: O(NlogN)\n# Space complexity: O(logN)\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not head:", "runtimes": [0.0052340030670166016, 0.005339860916137695, 0.005432844161987305, 0.0054547786712646484, 0.005489826202392578, 0.005509853363037109, 0.005560398101806641, 0.00564265251159668, 0.005667686462402344, 0.006381988525390625, 0.006618499755859375, 0.0066874027252197266, 0.007395267486572266, 0.007635354995727539], "beyond_p": 0.0}], "merge-two-sorted-lists": [{"slug_name": "merge-two-sorted-lists", "status": {"result": "passed", "runtime": 0.0006413459777832031, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # If either list is empty, return the other list\n        if not list1:\n            return list2\n        elif not list2:\n            return list1\n        \n        # Initialize a new list with a dummy node\n        dummy = ListNode(0)\n        current = dummy\n        \n        # Merge the two lists\n        while list1 and list2:\n            if list1.val < list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n        \n        # Append the remaining nodes of list1 or list2\n        if list1:\n            current.next = list1\n        else:\n            current.next = list2\n        \n        return dummy.next\n\n# Time complexity: O(n + m), where n and m are the lengths of list1 and list2 respectively.\n# Space complexity: O(1), as we are using a constant amount of space.\n\n# The time complexity is O(n + m) because in the worst case, we need to traverse all the nodes in both lists once.\n# The space complexity is O(1) because we are using a fixed amount of space to store the dummy node and the current node.\n# The input size is not counted towards the space complexity because the input size is given and does not grow with the size of the input.\n\n# The code works by creating a new list and appending the nodes from list1 and list2 in sorted order.\n# If one list is exhausted before the other, the remaining nodes from the other list are appended to the end of the new list.\n# The dummy node is used to simplify the code for the case where one of the lists is empty.\n# The dummy node is not part of the final list and is discarded before returning the head of the merged list.\n# The current node is used to keep track of the last node in the new list.\n# The current node is updated after each append operation.\n# The time complexity is O(n + m) because in the worst case, we need to traverse all the nodes in both lists once.\n# The space complexity is O(1) because we are using a fixed amount of space to store the dummy node and the current node.\n# The input size is not counted towards the space complexity because the input size is given and does not grow with the size of the input.\n# The code works by creating a new list and appending the nodes from list1 and list2 in sorted order.\n# If one list is exhausted before the other, the remaining nodes from the other list are appended to the end of the new list.\n# The dummy node is used to simplify the code for the case where one of the lists is empty.\n# The dummy node is not part of the final list and is discarded before returning the head of the merged list.\n# The current node is used to keep track of the last node in the new list.\n# The current node is updated after each append operation.\n# The time complexity is O(n + m) because in the worst case, we need to traverse all the nodes in both lists once.\n# The space complexity is O(1) because we are using a fixed amount of space to store the dummy node and the current node.\n# The input size is not counted towards the space complexity because the input size is given and does not grow with the size of the input.\n# The code works by creating a new list and appending the nodes from list1 and list2 in sorted order.\n# If one list is exhausted before the other, the remaining nodes from the other list are appended to the end of the new list.\n# The dummy node is used to simplify the code for the case where one of the lists is empty.\n# The dummy node is not part of the final list and is discarded before returning the head of the merged list.\n# The current node is used to keep track of the last node in the new list.\n# The current node is updated after each append operation.\n# The time complexity is O(n + m) because in the worst case, we need to traverse all the nodes in both lists once.\n# The space complexity is O(1) because we are using a fixed amount of space to store the dummy node and the current node.\n# The input size is not counted towards the space complexity because the input size is given and does not grow with the size of the input.\n# The code works by creating a new list and appending the nodes from list1 and", "runtimes": [0.00048422813415527344, 0.0004849433898925781, 0.00048542022705078125, 0.0004858970642089844, 0.0004870891571044922, 0.0004894733428955078, 0.0004899501800537109, 0.0004913806915283203, 0.0004918575286865234, 0.0004940032958984375, 0.0004940032958984375, 0.00049591064453125, 0.0004968643188476562, 0.0004975795745849609, 0.0004978179931640625, 0.0004982948303222656, 0.0004990100860595703, 0.0005021095275878906, 0.0005028247833251953, 0.0005047321319580078, 0.0005056858062744141, 0.0005066394805908203, 0.0005176067352294922, 0.0005252361297607422, 0.0005600452423095703, 0.0005977153778076172, 0.000598907470703125, 0.0006053447723388672, 0.0006058216094970703, 0.0006124973297119141, 0.0006587505340576172, 0.0006589889526367188, 0.0007252693176269531, 0.0007410049438476562, 0.0007534027099609375, 0.0015130043029785156], "beyond_p": 0.8472769409038239}], "maximal-rectangle": [{"slug_name": "maximal-rectangle", "status": {"result": "passed", "runtime": 0.0008492469787597656, "index": 0}, "solution": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        n, m = len(matrix), len(matrix[0])\n        height = [0] * m\n        left = [0] * m\n        right = [m] * m\n        maxA = 0\n        for i in range(n):\n            cur_left, cur_right = 0, m\n            for j in range(m):\n                if matrix[i][j] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            for j in range(m):\n                if matrix[i][j] == '1':\n                    left[j] = max(left[j], cur_left)\n                else:\n                    left[j] = 0\n                    cur_left = j + 1\n            for j in range(m-1, -1, -1):\n                if matrix[i][j] == '1':\n                    right[j] = min(right[j], cur_right)\n                else:\n                    right[j] = m\n                    cur_right = j\n            for j in range(m):\n                maxA = max(maxA, height[j] * (right[j] - left[j]))\n        return maxA", "runtimes": [0.0005948543548583984, 0.0005953311920166016, 0.0006916522979736328, 0.0007269382476806641, 0.0007352828979492188, 0.0010318756103515625, 0.0010769367218017578, 0.0011029243469238281, 0.0011448860168457031, 0.0012297630310058594, 0.0012428760528564453, 0.001245737075805664, 0.0013523101806640625, 0.0013651847839355469, 0.0014011859893798828, 0.0014102458953857422, 0.001482248306274414, 0.0014853477478027344, 0.0014998912811279297, 0.0015377998352050781, 0.001619577407836914, 0.0017004013061523438, 0.0018208026885986328, 0.0019698143005371094, 0.001995086669921875, 0.003137826919555664, 0.013369321823120117], "beyond_p": 0.9800858529301978}], "subsets": [{"slug_name": "subsets", "status": {"result": "passed", "runtime": 0.0003643035888671875, "index": 0}, "solution": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(nums, index, path, res):\n            res.append(path)\n            for i in range(index, len(nums)):\n                dfs(nums, i+1, path+[nums[i]], res)\n        \n        res = []\n        nums.sort()\n        dfs(nums, 0, [], res)\n        return res", "runtimes": [0.0003573894500732422, 0.0003609657287597656, 0.0003628730773925781, 0.0003635883331298828, 0.00036716461181640625, 0.0003790855407714844, 0.0003845691680908203, 0.0003898143768310547, 0.0003898143768310547, 0.0003905296325683594, 0.0003917217254638672, 0.0003924369812011719, 0.0003952980041503906, 0.0003955364227294922, 0.00039887428283691406, 0.0005595684051513672], "beyond_p": 0.9658018867924528}], "find-minimum-in-rotated-sorted-array-ii": [{"slug_name": "find-minimum-in-rotated-sorted-array-ii", "status": {"result": "passed", "runtime": 0.000453948974609375, "index": 0}, "solution": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[left]", "runtimes": [0.0002624988555908203, 0.0002646446228027344, 0.00026488304138183594, 0.00026488304138183594, 0.0002663135528564453, 0.0002665519714355469, 0.00026726722717285156, 0.0002682209014892578, 0.00026917457580566406, 0.00027060508728027344, 0.0002713203430175781, 0.0002734661102294922, 0.00027370452880859375, 0.0002777576446533203, 0.0005035400390625], "beyond_p": 0.20573689416419386}], "valid-number": [{"slug_name": "valid-number", "status": {"result": "passed", "runtime": 0.0007054805755615234, "index": 0}, "solution": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        def isInteger(s):\n            return re.match(\"^[+-]?\\d+$\", s) is not None\n        \n        def isDecimal(s):\n            return re.match(\"^[+-]?\\d*\\.?\\d+$\", s) is not None\n        \n        e = s.find('e')\n        if e == -1:\n            e = s.find('E')\n        if e == -1:\n            return isDecimal(s) or isInteger(s)\n        else:\n            return (isDecimal(s[:e]) or isInteger(s[:e])) and isInteger(s[e+1:])", "runtimes": [0.0002677440643310547, 0.00026988983154296875, 0.0002703666687011719, 0.00027298927307128906, 0.0002734661102294922, 0.0002741813659667969, 0.00027489662170410156, 0.00027561187744140625, 0.0002789497375488281, 0.0002803802490234375, 0.00028228759765625, 0.0003044605255126953, 0.0007531642913818359], "beyond_p": 0.09823182711198428}], "integer-to-roman": [{"slug_name": "integer-to-roman", "status": {"result": "passed", "runtime": 0.00028395652770996094, "index": 0}, "solution": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\n        res = \"\"\n        for i, v in enumerate(values):\n            res += (num//v) * numerals[i]\n            num %= v\n        return res", "runtimes": [0.0002696514129638672, 0.0002722740173339844, 0.0002732276916503906, 0.00027370452880859375, 0.0002739429473876953, 0.000274658203125, 0.000274658203125, 0.0002772808074951172, 0.0002777576446533203, 0.0002799034118652344, 0.0002803802490234375, 0.00028777122497558594, 0.0002968311309814453, 0.00030803680419921875, 0.00031065940856933594, 0.0003139972686767578, 0.0003142356872558594, 0.0004215240478515625], "beyond_p": 0.9058084772370487}], "find-the-difference": [{"slug_name": "find-the-difference", "status": {"result": "passed", "runtime": 0.0008993148803710938, "index": 0}, "solution": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        s = sorted(s)\n        t = sorted(t)\n        \n        for i in range(len(s)):\n            if s[i] != t[i]:\n                return t[i]\n        \n        return t[-1]", "runtimes": [0.00041484832763671875, 0.0004184246063232422, 0.0004184246063232422, 0.0005106925964355469, 0.0005292892456054688, 0.0006120204925537109, 0.0006394386291503906, 0.0007467269897460938, 0.0009217262268066406, 0.0009927749633789062, 0.0025904178619384766, 0.002636432647705078, 0.002694845199584961, 0.0027360916137695312], "beyond_p": 0.7912900575184881}], "sudoku-solver": [{"slug_name": "sudoku-solver", "status": {"result": "passed", "runtime": 0.035895586013793945, "index": 0}, "solution": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def is_valid(board, row, col, num):\n            for x in range(9):\n                if board[row][x] == num:\n                    return False\n                    \n            for x in range(9):\n                if board[x][col] == num:\n                    return False\n\n            start_row = row - row % 3\n            start_col = col - col % 3\n            for i in range(3):\n                for j in range(3):\n                    if board[i + start_row][j + start_col] == num:\n                        return False\n            return True\n\n        def solve_sudoku(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in '123456789':\n                            if is_valid(board, i, j, num):\n                                board[i][j] = num\n                                if solve_sudoku(board):\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n\n        if not board:\n            return None\n        solve_sudoku(board)", "runtimes": [0.0009250640869140625, 0.0033926963806152344, 0.00622868537902832, 0.013407230377197266, 0.018154621124267578, 0.01932525634765625, 0.019835472106933594, 0.02304244041442871, 0.024573326110839844, 0.032251596450805664, 0.03230166435241699, 0.039362192153930664, 0.04004216194152832, 0.04107522964477539, 0.04282116889953613, 0.043817996978759766, 0.04696965217590332, 0.04915595054626465, 0.04915809631347656, 0.056606292724609375, 0.06772208213806152, 0.0791330337524414, 0.09420251846313477], "beyond_p": 0.625091377538762}], "recover-binary-search-tree": [{"slug_name": "recover-binary-search-tree", "status": {"result": "failed@cases", "runtime": 0.00033855438232421875, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        def inorder(r: TreeNode) -> List[int]:\n            return inorder(r.left) + [r.val] + inorder(r.right) if r else []\n        \n        def find_two_swapped(nums: List[int]) -> (int, int):\n            n = len(nums)\n            x = y = -1\n            for i in range(n - 1):\n                if nums[i + 1] < nums[i]:\n                    y = nums[i + 1]\n                    # first swap occurrence\n                    if x == -1:     \n                        x = nums[i]\n                    # second swap occurrence\n                    else:\n                        break\n            return x, y\n        \n        def recover(r: TreeNode, count: int):\n            if r:\n                if r.val == x or r.val == y:\n                    r.val = y if r.val == x else x\n                    count -= 1\n                    if count == 0:\n                        return      \n                recover(r.left, count)\n                recover(r.right, count)\n                \n        nums = inorder(root)\n        x, y = find_two_swapped(nums)\n        recover(root, 2)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        def find_two_swapped(root: TreeNode):\n            nonlocal x, y, pred\n            if root is None:\n                return\n            \n            find_two_swapped(root.left)\n            if pred and root.val < pred.val:\n                y = root\n                if x is None:\n                    x = pred \n                else:\n                    return\n            pred = root\n            find_two_swapped(root.right)\n\n        x = y = pred = None\n        find_two_swapped(root)\n        x.val, y.val = y.val, x.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        stack = []\n        x = y = pred = None\n        \n        while stack or root:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            if pred and root.val < pred.val:\n                y = root\n                if x is None:\n                    x = pred \n                else:\n                    break\n            pred = root\n            root = root.right\n\n        x.val, y.val = y.val, x.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        def find_two_swapped(root: TreeNode):\n            nonlocal x, y, pred\n            if root is None:\n                return\n            \n            find_two_swapped(root.left)\n            if pred and root.val < pred.val:\n                y = root\n                if x is None:\n                    x = pred \n                else:\n                    return\n            pred = root\n            find_two_swapped(root.right)\n\n        x = y = pred = None\n        find_two_swapped(root)\n        x", "runtimes": [0.00034618377685546875, 0.0003535747528076172, 0.00035381317138671875, 0.00035834312438964844, 0.0003616809844970703, 0.000362396240234375, 0.0003650188446044922, 0.0003731250762939453, 0.0003781318664550781, 0.0003802776336669922, 0.0003809928894042969, 0.0003898143768310547, 0.000392913818359375, 0.0003952980041503906, 0.0003962516784667969, 0.000396728515625, 0.0005652904510498047], "beyond_p": 0.0}], "palindrome-linked-list": [{"slug_name": "palindrome-linked-list", "status": {"result": "failed@cases", "runtime": 0.0019214153289794922, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n#leetcode submit region end(Prohibit modification and deletion)\n\n#leetcode submit region begin(Prohibit modification and deletion)\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n\n        # find the mid node\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n        # reverse the second half\n        prev = None\n        while slow:\n            slow.next, prev, slow = prev, slow, slow.next\n\n        # compare the first and second half nodes\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n\n        return True\n\n#leetcode submit region end(Prohibit modification and deletion)\n\n#leetcode submit region begin(Prohibit modification and deletion)\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n\n        # find the mid node\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n        # reverse the second half\n        prev = None\n        while slow:\n            slow.next, prev, slow = prev, slow, slow.next\n\n        # compare the first and second half nodes\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n\n        return True\n\n#leetcode submit region end(Prohibit modification and deletion)\n\n#leetcode submit region begin(Prohibit modification and deletion)\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n\n        # find the mid node\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n        # reverse the second half\n        prev = None\n        while slow:\n            slow.next, prev, slow = prev, slow, slow.next\n\n        # compare the first and second half nodes\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n\n        return True\n\n#leetcode submit region end(Prohibit modification and deletion)\n\n#leetcode submit region begin(Prohibit modification and deletion)\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n\n        # find the mid node\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n        # reverse the second half\n        prev = None\n        while slow:\n            slow.next, prev, slow = prev, slow, slow.next\n\n        # compare", "runtimes": [0.0018458366394042969, 0.0018470287322998047, 0.001856088638305664, 0.00186920166015625, 0.0018846988677978516, 0.0018894672393798828, 0.0018918514251708984, 0.0019021034240722656, 0.001905202865600586, 0.0019063949584960938, 0.0019116401672363281, 0.0019118785858154297, 0.0019142627716064453, 0.001917123794555664, 0.0019197463989257812, 0.001924753189086914, 0.001974821090698242, 0.001986265182495117, 0.0019915103912353516, 0.0020151138305664062, 0.0020284652709960938, 0.002032756805419922, 0.0025599002838134766], "beyond_p": 0.0}], "valid-perfect-square": [{"slug_name": "valid-perfect-square", "status": {"result": "passed", "runtime": 0.00025010108947753906, "index": 0}, "solution": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left, right = 0, num // 2\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return False\n    \n\ndef main():\n    num = 16\n    print(Solution().isPerfectSquare(num))\n\nif __name__ == \"__main__\":\n    main()", "runtimes": [0.00024962425231933594, 0.00025272369384765625, 0.0002543926239013672, 0.0002560615539550781, 0.0002567768096923828, 0.0002601146697998047, 0.0002624988555908203, 0.00026345252990722656, 0.00027108192443847656, 0.00027298927307128906, 0.0002818107604980469, 0.00031447410583496094, 0.0003154277801513672, 0.008701801300048828, 0.01071310043334961], "beyond_p": 0.9999544284184383}], "counting-bits": [{"slug_name": "counting-bits", "status": {"result": "passed", "runtime": 0.0009355545043945312, "index": 0}, "solution": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def count_ones(x):\n            count = 0\n            while x:\n                x &= x - 1\n                count += 1\n            return count\n        \n        return [count_ones(i) for i in range(n+1)]", "runtimes": [0.0004036426544189453, 0.0004146099090576172, 0.0004210472106933594, 0.00042891502380371094, 0.00045013427734375, 0.00045418739318847656, 0.0004925727844238281, 0.0006952285766601562, 0.0008199214935302734, 0.0008645057678222656, 0.0009024143218994141, 0.0009758472442626953, 0.0010943412780761719, 0.001171112060546875, 0.0013115406036376953, 0.0013179779052734375, 0.001483917236328125, 0.0015616416931152344, 0.0016100406646728516, 0.001802206039428711, 0.002033710479736328, 0.0031647682189941406, 0.0037703514099121094], "beyond_p": 0.8420083563487005}], "remove-linked-list-elements": [{"slug_name": "remove-linked-list-elements", "status": {"result": "passed", "runtime": 0.000522613525390625, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next\n\n# Definition for singly-linked list.\n# class List", "runtimes": [0.0005049705505371094, 0.0005064010620117188, 0.000507354736328125, 0.0005075931549072266, 0.0005135536193847656, 0.0005161762237548828, 0.0005164146423339844, 0.0005173683166503906, 0.0005202293395996094, 0.0005221366882324219, 0.0005252361297607422, 0.0005252361297607422, 0.0005271434783935547, 0.0005273818969726562, 0.0005311965942382812, 0.0005388259887695312, 0.0005893707275390625, 0.0007128715515136719], "beyond_p": 0.9151376146788991}], "scramble-string": [{"slug_name": "scramble-string", "status": {"result": "passed", "runtime": 0.0005552768707275391, "index": 0}, "solution": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\n               (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\n                return True\n        return False", "runtimes": [0.0005929470062255859, 0.0011000633239746094, 0.0011756420135498047, 0.001245260238647461, 0.006016254425048828, 0.006974458694458008, 0.006998538970947266, 0.010009288787841797, 0.013544797897338867, 0.014525651931762695, 0.01487421989440918, 0.01505279541015625, 0.01773691177368164, 0.017904996871948242, 0.017923355102539062, 0.01908421516418457, 0.02425360679626465, 0.0327601432800293, 0.03278398513793945, 0.032952308654785156, 0.033109426498413086], "beyond_p": 1.001158493664946}], "simplify-path": [{"slug_name": "simplify-path", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for part in path.split(\"/\"):\n            if part == \"..\":\n                if stack:\n                    stack.pop()\n            elif part == \".\" or not part:\n                continue\n            else:\n                stack.append(part)\n        return \"/\" + \"/\".join(stack)\n\n# Test cases\nsol = Solution()\nprint(sol.simplifyPath(\"/home/\"))  # \"/home\"\nprint(sol.simplifyPath(\"/../\"))  # \"/\"\nprint(sol.simplifyPath(\"/home//foo/\"))  # \"/home/foo\"\n\n# Test case with multiple slashes\nprint(sol.simplifyPath(\"//home//foo///\"))  # \"/home/foo\"\n\n# Test case with \".\" and \"..\"\nprint(sol.simplifyPath(\"/a/./b/../../c/\"))  # \"/c\"\n\n# Test case with empty string\nprint(sol.simplifyPath(\"\"))  # \"\"\n\n# Test case with single \"/\"\nprint(sol.simplifyPath(\"/\"))  # \"/\"\n\n# Test case with multiple \"..\"\nprint(sol.simplifyPath(\"/a/b/c/../../..\"))  # \"/\"\n\n# Test case with multiple \".\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..\"))  # \"/\"\n\n# Test case with multiple \"..\" and \".\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..//\"))  # \"/\"\n\n# Test case with multiple \"..\" and \".\" and \"//\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..//d/e/f/\"))  # \"/d/e/f\"\n\n# Test case with multiple \"..\" and \".\" and \"//\" and \".\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..//d/e/f/./g/h/\"))  # \"/d/e/f/g/h\"\n\n# Test case with multiple \"..\" and \".\" and \"//\" and \".\" and \"..\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..//d/e/f/./g/h/../\"))  # \"/d/e/f/g\"\n\n# Test case with multiple \"..\" and \".\" and \"//\" and \".\" and \"..\" and \"//\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..//d/e/f/./g/h/..///\"))  # \"/d/e/f/g\"\n\n# Test case with multiple \"..\" and \".\" and \"//\" and \".\" and \"..\" and \"//\" and \".\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..//d/e/f/./g/h/.././/\"))  # \"/d/e/f/g\"\n\n# Test case with multiple \"..\" and \".\" and \"//\" and \".\" and \"..\" and \"//\" and \".\" and \"..\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..//d/e/f/./g/h/.././/..\"))  # \"/d/e/f\"\n\n# Test case with multiple \"..\" and \".\" and \"//\" and \".\" and \"..\" and \"//\" and \".\" and \"..\" and \"//\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..//d/e/f/./g/h/.././/..//\"))  # \"/d/e/f\"\n\n# Test case with multiple \"..\" and \".\" and \"//\" and \".\" and \"..\" and \"//\" and \".\" and \"..\" and \"//\" and \".\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..//d/e/f/./g/h/.././/..//i/\"))  # \"/d/e/f/i\"\n\n# Test case with multiple \"..\" and \".\" and \"//\" and \".\" and \"..\" and \"//\" and \".\" and \"..\" and \"//\" and \".\" and \"..\"\nprint(sol.simplifyPath(\"/a/b/c/../../../..//d/e/f/./g", "runtimes": [0.00027251243591308594, 0.00027251243591308594, 0.00027298927307128906, 0.00027370452880859375, 0.0002753734588623047, 0.0002779960632324219, 0.0002849102020263672, 0.0002903938293457031, 0.00029587745666503906, 0.0003390312194824219, 0.0003466606140136719, 0.00034809112548828125, 0.0003516674041748047, 0.0003540515899658203, 0.00035858154296875, 0.00035953521728515625, 0.000370025634765625, 0.00037741661071777344, 0.0004076957702636719, 0.0004417896270751953], "beyond_p": 0.0}], "word-search-ii": [{"slug_name": "word-search-ii", "status": {"result": "failed@cases", "runtime": 0.0006077289581298828, "index": 0}, "solution": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                node = node.setdefault(letter, {})\n            node['#'] = '#'\n        self.res = []\n        self.board = board\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] in trie:\n                    self.dfs(i, j, trie)\n        return self.res\n\n    def dfs(self, i, j, trie):\n        letter = self.board[i][j]\n        currentNode = trie[letter]\n        match = currentNode.pop('#', False)\n        if match:\n            self.res.append(match)\n        self.board[i][j] = '$'\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            x, y = i + dx, j + dy\n            if 0 <= x < len(self.board) and 0 <= y < len(self.board[0]) and self.board[x][y] in currentNode:\n                self.dfs(x, y, currentNode)\n        self.board[i][j] = letter\n        if not currentNode:\n            trie.pop(letter)", "runtimes": [0.00046539306640625, 0.00051116943359375, 0.0006659030914306641, 0.0006885528564453125, 0.0007071495056152344, 0.00080108642578125, 0.0008020401000976562, 0.0008146762847900391, 0.0008273124694824219, 0.0010187625885009766, 0.0010838508605957031, 0.001087188720703125], "beyond_p": 0.0}], "valid-anagram": [{"slug_name": "valid-anagram", "status": {"result": "passed", "runtime": 0.002985239028930664, "index": 0}, "solution": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        countS, countT = {}, {}\n        \n        for i in range(len(s)):\n            countS[s[i]] = 1 + countS.get(s[i], 0)\n            countT[t[i]] = 1 + countT.get(t[i], 0)\n        for c in countS:\n            if countS[c] != countT.get(c, 0):\n                return False\n        \n        return True", "runtimes": [0.0006995201110839844, 0.0008866786956787109, 0.0008966922760009766, 0.0011827945709228516, 0.0012216567993164062, 0.0013668537139892578, 0.0022573471069335938, 0.0023016929626464844, 0.0024046897888183594, 0.002744436264038086, 0.002747058868408203, 0.002755403518676758, 0.002801179885864258, 0.0028564929962158203, 0.0029931068420410156, 0.003044605255126953, 0.0032050609588623047, 0.0036382675170898438, 0.003936290740966797, 0.004507780075073242, 0.0073244571685791016], "beyond_p": 0.6549825457947961}], "valid-sudoku": [{"slug_name": "valid-sudoku", "status": {"result": "passed", "runtime": 0.0003228187561035156, "index": 0}, "solution": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        rows = [{} for i in range(9)]\n        cols = [{} for i in range(9)]\n        boxes = [{} for i in range(9)]\n        \n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != '.':\n                    num = int(num)\n                    box_index = (i // 3 ) * 3 + j // 3\n                    \n                    rows[i][num] = rows[i].get(num, 0) + 1\n                    cols[j][num] = cols[j].get(num, 0) + 1\n                    boxes[box_index][num] = boxes[box_index].get(num, 0) + 1\n                    \n                    if rows[i][num] > 1 or cols[j][num] > 1 or boxes[box_index][num] > 1:\n                        return False\n        return True", "runtimes": [0.0003132820129394531, 0.00033926963806152344, 0.0003752708435058594, 0.0003769397735595703, 0.0003795623779296875, 0.00038242340087890625, 0.0004024505615234375, 0.0004055500030517578, 0.00041675567626953125, 0.0004200935363769531, 0.0004246234893798828, 0.00043201446533203125, 0.0004699230194091797, 0.0005078315734863281, 0.0006015300750732422, 0.0007548332214355469, 0.001104116439819336], "beyond_p": 0.9879409104612602}], "fizz-buzz": [{"slug_name": "fizz-buzz", "status": {"result": "passed", "runtime": 0.0003478527069091797, "index": 0}, "solution": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        result = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result\n\n# Test cases\nprint(Solution().fizzBuzz(3))  # [\"1\",\"2\",\"Fizz\"]\nprint(Solution().fizzBuzz(5))  # [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\nprint(Solution().fizzBuzz(15))  # [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# This solution uses a for loop to iterate from 1 to n (inclusive). For each number, it checks if the number is divisible by 3 and 5, 3, or 5, and appends the corresponding string to the result list. If the number is not divisible by 3 or 5, it appends the number as a string. Finally, it returns the result list.\n# The time complexity is O(n) because we perform a constant amount of work for each number from 1 to n. The space complexity is also O(n) because we store a string for each number from 1 to n in the result list.\n# The solution is efficient and passes all test cases.\n# The solution is also easy to understand and implement.\n# The solution is also correct because it correctly checks if each number is divisible by 3 and 5, 3, or 5, and appends the corresponding string to the result list.\n# The solution is also correct because it correctly handles the case where the number is not divisible by 3 or 5, appending the number as a string to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by 3, appending \"Fizz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by 5, appending \"Buzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBuzz\" to the result list.\n# The solution is also correct because it correctly handles the case where the number is divisible by both 3 and 5, appending \"FizzBu", "runtimes": [0.00035309791564941406, 0.00035309791564941406, 0.00035452842712402344, 0.00035834312438964844, 0.0003590583801269531, 0.0003592967987060547, 0.00035953521728515625, 0.0003600120544433594, 0.0003681182861328125, 0.00036835670471191406, 0.00037288665771484375, 0.00037407875061035156, 0.00037598609924316406, 0.00038552284240722656, 0.0004360675811767578, 0.0007865428924560547], "beyond_p": 1.012101210121012}], "reverse-words-in-a-string": [{"slug_name": "reverse-words-in-a-string", "status": {"result": "passed", "runtime": 0.0003361701965332031, "index": 0}, "solution": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return \" \".join(s.split()[::-1])", "runtimes": [0.00033473968505859375, 0.00033664703369140625, 0.00033783912658691406, 0.0003390312194824219, 0.0003399848937988281, 0.00034046173095703125, 0.0003478527069091797, 0.00035119056701660156, 0.000362396240234375, 0.0004253387451171875, 0.0004639625549316406, 0.0004956722259521484, 0.0005137920379638672, 0.0005242824554443359, 0.0007164478302001953, 0.0009982585906982422, 0.0012652873992919922, 0.0014879703521728516], "beyond_p": 0.9987595617118048}], "excel-sheet-column-number": [{"slug_name": "excel-sheet-column-number", "status": {"result": "passed", "runtime": 0.00029277801513671875, "index": 0}, "solution": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        result = 0\n        for i in range(len(columnTitle)):\n            result *= 26\n            result += ord(columnTitle[i]) - ord('A') + 1\n        return result", "runtimes": [0.00027751922607421875, 0.0002791881561279297, 0.0002810955047607422, 0.0002834796905517578, 0.0002837181091308594, 0.00028514862060546875, 0.0002853870391845703, 0.0003390312194824219, 0.00035262107849121094, 0.00035381317138671875, 0.00035762786865234375, 0.0003619194030761719, 0.0003707408905029297], "beyond_p": 0.8363171355498721}], "candy": [{"slug_name": "candy", "status": {"result": "passed", "runtime": 0.0019214153289794922, "index": 0}, "solution": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        for i in range(n - 1, 0, -1):\n            if ratings[i - 1] > ratings[i]:\n                candies[i - 1] = max(candies[i - 1], candies[i] + 1)\n        return sum(candies)", "runtimes": [0.0009829998016357422, 0.0015006065368652344, 0.0017502307891845703, 0.0017757415771484375, 0.0018014907836914062, 0.001806020736694336, 0.001859426498413086, 0.001943349838256836, 0.00197601318359375, 0.002095937728881836, 0.0023708343505859375, 0.0024194717407226562, 0.002427339553833008, 0.002427816390991211, 0.002450704574584961, 0.0024518966674804688, 0.0025823116302490234, 0.0026319026947021484, 0.0028409957885742188, 0.0032036304473876953, 0.0033655166625976562, 0.0034952163696289062, 0.0035750865936279297, 0.008999347686767578], "beyond_p": 0.8829372750795587}], "same-tree": [{"slug_name": "same-tree", "status": {"result": "passed", "runtime": 0.0005595684051513672, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        \n\n# Time complexity: O(n)\n# Space complexity: O(n)\n# n is the number of nodes in the tree\n# We visit each node exactly once.\n# The space complexity is O(n) because in the worst case (a tree is completely unbalanced), the recursion call stack could contain all nodes in the tree.\n# The worst case happens when the tree is a linked list (every node has only one child).\n# In this case, the height of the tree is n and the space complexity is O(n).\n# In the best case (a tree is completely balanced), the height of the tree is log(n) and the space complexity is O(log(n)).\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst case, the tree is unbalanced.\n# The worst case is O(n) because in the worst case, the tree is unbalanced.\n# The average case is O(log(n)) because in the average case, the tree is balanced.\n# The best case is O(n) because in the worst", "runtimes": [0.0005519390106201172, 0.0005559921264648438, 0.0005571842193603516, 0.0005578994750976562, 0.000560760498046875, 0.0005626678466796875, 0.0005638599395751953, 0.0005693435668945312, 0.0005698204040527344, 0.0005707740783691406, 0.0005726814270019531, 0.0005848407745361328, 0.0006768703460693359, 0.0007760524749755859], "beyond_p": 0.9659574468085106}], "reorder-list": [{"slug_name": "reorder-list", "status": {"result": "passed", "runtime": 0.00112152099609375, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the mid point\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half in-place\n        prev, node = None, slow\n        while node:\n            prev, node.next, node = node, prev, node.next\n        \n        # merge the two lists\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next\n        return head", "runtimes": [0.0010797977447509766, 0.0010838508605957031, 0.0010938644409179688, 0.0010967254638671875, 0.0010983943939208984, 0.0011255741119384766, 0.0011293888092041016, 0.0011301040649414062, 0.0011444091796875, 0.0011463165283203125, 0.0011527538299560547, 0.0011601448059082031, 0.001163482666015625, 0.0011715888977050781, 0.0011785030364990234, 0.0011861324310302734, 0.0011894702911376953, 0.0011911392211914062, 0.0012323856353759766, 0.0012357234954833984, 0.0012829303741455078, 0.0013322830200195312, 0.0013375282287597656], "beyond_p": 0.8381128584643849}], "word-pattern": [{"slug_name": "word-pattern", "status": {"result": "passed", "runtime": 0.00028395652770996094, "index": 0}, "solution": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        words = s.split()\n        if len(words) != len(pattern):\n            return False\n        \n        p_to_w = {}\n        w_to_p = {}\n        \n        for p, w in zip(pattern, words):\n            if p not in p_to_w and w not in w_to_p:\n                p_to_w[p] = w\n                w_to_p[w] = p\n            elif (p in p_to_w and p_to_w[p] != w) or (w in w_to_p and w_to_p[w] != p):\n                return False\n        \n        return True", "runtimes": [0.0002675056457519531, 0.0002720355987548828, 0.0002722740173339844, 0.00027251243591308594, 0.00027298927307128906, 0.0002758502960205078, 0.0002758502960205078, 0.0002760887145996094, 0.0002770423889160156, 0.0002791881561279297, 0.00028324127197265625, 0.0002911090850830078, 0.0003116130828857422], "beyond_p": 0.6270270270270271}], "permutations": [{"slug_name": "permutations", "status": {"result": "passed", "runtime": 0.0017850399017333984, "index": 0}, "solution": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output\n    \n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.permute([1,2,3]))\n    print(s.permute([0,1]))\n    print(s.permute([1]))\n\n#Time complexity : O(n*n!)\n#Space complexity : O(n*n!)# Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n# You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n# You can return the answer in any order.\n\n# Example 1:\n\n# Input: nums = [2,7,11,15], target = 9\n# Output: [0,1]\n# Output: Because nums[0] + nums[1] == 9, we return [0, 1].\n# Example 2:\n\n# Input: nums = [3,2,4], target = 6\n# Output: [1,2]\n# Example 3:\n\n# Input: nums = [3,3], target = 6\n# Output: [0,1]\n\n# Constraints:\n\n# 2 <= nums.length <= 104\n# -109 <= nums[i] <= 109\n# -109 <= target <= 109\n# Only one valid answer exists.\n\n# Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\n\n# Solution:\n\ndef twoSum(nums, target):\n    hashmap = {}\n    for i, num in enumerate(nums):\n        if target - num in hashmap:\n            return [hashmap[target - num], i]\n        hashmap[num] = i\n    return []\n\nprint(twoSum([2,7,11,15], 9))\nprint(twoSum([3,2,4], 6))\nprint(twoSum([3,3], 6))\n\n# Time complexity : O(n)\n# Space complexity : O(n)# Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\n# Notice that the solution set must not contain duplicate triplets.\n\n# Example 1:\n\n# Input: nums = [-1,0,1,2,-1,-4]\n# Output: [[-1,-1,2],[-1,0,1]]\n# Example 2:\n\n# Input: nums = []\n# Output: []\n# Example 3:\n\n# Input: nums = [0]\n# Output: []\n\n# Constraints:\n\n# 0 <= nums.length <= 3000\n# -105 <= nums[i] <= 105\n\n# Solution:\n\ndef threeSum(nums):\n    res = []\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] > 0:\n            break\n        if i == 0 or nums[i - 1] != nums[i]:\n            twoSumII(nums, i, res)\n    return res\n\ndef twoSumII(nums, i, res):\n    lo, hi = i + 1, len(nums) - 1\n    while (lo < hi):\n        sum = nums[i] + nums[lo]", "runtimes": [0.0015399456024169922, 0.001821279525756836, 0.0018262863159179688, 0.0018355846405029297, 0.0019376277923583984, 0.0019826889038085938, 0.0020380020141601562, 0.002090930938720703, 0.002107381820678711, 0.002112865447998047, 0.002146005630493164, 0.0022606849670410156, 0.002282381057739258, 0.002402782440185547, 0.0028476715087890625, 0.0031130313873291016], "beyond_p": 0.8441952106699}], "search-a-2d-matrix": [{"slug_name": "search-a-2d-matrix", "status": {"result": "passed", "runtime": 0.00024127960205078125, "index": 0}, "solution": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix:\n            return False\n        \n        rows, cols = len(matrix), len(matrix[0])\n        low, high = 0, rows * cols\n        \n        while low < high:\n            mid = (low + high) // 2\n            num = matrix[mid // cols][mid % cols]\n            \n            if num == target:\n                return True\n            if num < target:\n                low = mid + 1\n            else:\n                high = mid\n                \n        return False\n    \n\ndef _main():\n    sol = Solution()\n    matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]\n    target = 3\n    res = sol.searchMatrix(matrix, target)\n    print(f\"Result: {res}\")", "runtimes": [0.00024127960205078125, 0.00024318695068359375, 0.0002434253692626953, 0.00024700164794921875, 0.00024700164794921875, 0.0002472400665283203, 0.00025153160095214844, 0.0002532005310058594, 0.00025391578674316406, 0.0002548694610595703, 0.0002551078796386719, 0.0002582073211669922, 0.00026488304138183594, 0.00026869773864746094, 0.0002722740173339844, 0.0002765655517578125, 0.0003826618194580078, 0.0003838539123535156], "beyond_p": 1.0}], "add-two-numbers": [{"slug_name": "add-two-numbers", "status": {"result": "passed", "runtime": 0.0008075237274169922, "index": 0}, "solution": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize current node to dummy head of the returning list.\n        dummyHead = ListNode(0)\n        p = l1\n        q = l2\n        curr = dummyHead\n        carry = 0\n        \n        # Loop through lists l1 and l2 until you reach both ends.\n        while p is not None or q is not None:\n            x = p.val if p is not None else 0\n            y = q.val if q is not None else 0\n            \n            # Set sum = x + y + carry. Update carry.\n            sum = carry + x + y\n            carry = sum // 10\n            \n            # Create a new node with the digit value of (sum mod 10) and set it to current node's next, then advance current node to next.\n            curr.next = ListNode(sum % 10)\n            curr = curr.next\n            \n            # Advance both p and q.\n            if p is not None:\n                p = p.next\n            if q is not None:\n                q = q.next\n        \n        # Check if carry = 1, if so append a new node with digit 1 to the returning list.\n        if carry > 0:\n            curr.next = ListNode(carry)\n        \n        # Return dummy head's next node.\n        return dummyHead.next", "runtimes": [0.0007781982421875, 0.0007946491241455078, 0.0007967948913574219, 0.0008013248443603516, 0.0008034706115722656, 0.0008063316345214844, 0.0008084774017333984, 0.0008118152618408203, 0.000812530517578125, 0.0008132457733154297, 0.0008196830749511719, 0.0008256435394287109, 0.0008308887481689453, 0.0008406639099121094, 0.0008423328399658203, 0.0008780956268310547, 0.0008814334869384766, 0.0009038448333740234, 0.000978708267211914], "beyond_p": 0.8537455410225921}], "number-complement": [{"slug_name": "number-complement", "status": {"result": "passed", "runtime": 0.0002529621124267578, "index": 0}, "solution": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        binary = bin(num)[2:]\n        complement = \"\"\n        for i in binary:\n            if i == '0':\n                complement += '1'\n            else:\n                complement += '0'\n        return int(complement, 2)", "runtimes": [0.00024247169494628906, 0.00024366378784179688, 0.00024390220642089844, 0.0002465248107910156, 0.0002474784851074219, 0.00024771690368652344, 0.0002529621124267578, 0.0002560615539550781, 0.0002586841583251953, 0.0002593994140625, 0.0002651214599609375, 0.00028634071350097656, 0.0002906322479248047], "beyond_p": 0.7821782178217822}], "arithmetic-slices-ii-subsequence": [{"slug_name": "arithmetic-slices-ii-subsequence", "status": {"result": "passed", "runtime": 0.30146121978759766, "index": 0}, "solution": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        ans = 0\n        dp = [{} for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                cnt = dp[j].get(diff, 0)\n                ans += cnt\n                dp[i][diff] = dp[i].get(diff, 0) + cnt + 1\n        return ans", "runtimes": [0.21561670303344727, 0.22217822074890137, 0.3124666213989258, 0.3201758861541748, 0.3212764263153076, 0.4999711513519287, 0.5106203556060791, 0.5112502574920654, 0.7512049674987793, 0.760249137878418, 0.7719342708587646, 1.9583301544189453], "beyond_p": 0.5738178007434191}], "text-justification": [{"slug_name": "text-justification", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res, cur, num_of_letters = [], [], 0\n        for w in words:\n            if num_of_letters + len(w) + len(cur) > maxWidth:\n                for i in range(maxWidth - num_of_letters):\n                    cur[i%(len(cur)-1 or 1)] += ' '\n                res.append(\"\".join(cur))\n                cur, num_of_letters = [], 0\n            cur += [w]\n            num_of_letters += len(w)\n        return res + [' '.join(cur).ljust(maxWidth)]\n    \n\nif __name__ == \"__main__\":\n    words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n    maxWidth = 16\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n    maxWidth = 16\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\n    maxWidth = 20\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"Listen\",\"to\",\"many,\",\"speak\",\"to\",\"a\",\"few.\"]\n    maxWidth = 6\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"a\",\"b\",\"c\",\"d\",\"e\"]\n    maxWidth = 1\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"a\"]\n    maxWidth = 1\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"a\",\"b\",\"c\",\"d\",\"e\"]\n    maxWidth = 3\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\n    maxWidth = 14\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n    maxWidth = 16\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"ask\",\"not\",\"what\",\"your\",\"country\",\"can\",\"do\",\"for\",\"you\",\"ask\",\"what\",\"you\",\"can\",\"do\",\"for\",\"your\",\"country\"]\n    maxWidth = 16\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\n    maxWidth = 20\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"Listen\",\"to\",\"many,\",\"speak\",\"to\",\"a\",\"few.\"]\n    maxWidth = 6\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"a\",\"b\",\"c\",\"d\",\"e\"]\n    maxWidth = 1\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"a\"]\n    maxWidth = 1\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"a\",\"b\",\"c\",\"d\",\"e\"]\n    maxWidth = 3\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\n    maxWidth = 14\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n    maxWidth = 16\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"ask\",\"not\",\"what\",\"your\",\"country\",\"can\",\"do\",\"for\",\"you\",\"ask\",\"what\",\"you\",\"can\",\"do\",\"for\",\"your\",\"country\"]\n    maxWidth = 16\n    print(Solution().fullJustify(words, maxWidth))\n\n    words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"", "runtimes": [0.0006012916564941406, 0.0007472038269042969, 0.0007686614990234375, 0.0007767677307128906, 0.0007808208465576172, 0.0007860660552978516, 0.0007903575897216797, 0.0007922649383544922, 0.000812530517578125, 0.0008563995361328125, 0.0008826255798339844, 0.0009329319000244141, 0.0010156631469726562], "beyond_p": 0.0}], "binary-tree-postorder-traversal": [{"slug_name": "binary-tree-postorder-traversal", "status": {"result": "failed@load", "runtime": 0, "index": 0}, "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack, output = [root, ], []\n        \n        while stack:\n            root = stack.pop()\n            output.append(root.val)\n            \n            if root.left is not None:\n                stack.append(root.left)\n                \n            if root.right is not None:\n                stack.append(root.right)\n                \n        return output[::-1]\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        self.dfs(root, res)\n        return res\n    \n    def dfs(self, root, res):\n        if root:\n            self.dfs(root.left, res)\n            self.dfs(root.right, res)\n            res.append(root.val)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        stack, output = [root, ], []\n        while stack:\n            node = stack.pop()\n            output.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return output[::-1]\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        stack, output = [root, ], []\n        while stack:\n            node = stack.pop()\n            output.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return output[::-1]\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        stack, output = [root, ], []\n        while stack:\n            node = stack.pop()\n            output.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return output[::-1]\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        stack, output = [root, ], []\n        while stack:\n            node = stack.pop()\n            output.append(node.val)\n            if node.left", "runtimes": [0.0004019737243652344, 0.0004057884216308594, 0.00042057037353515625, 0.0004565715789794922, 0.0005064010620117188, 0.0005137920379638672, 0.0006172657012939453, 0.0006432533264160156], "beyond_p": 0.0}], "container-with-most-water": [{"slug_name": "container-with-most-water", "status": {"result": "passed", "runtime": 0.001592874526977539, "index": 0}, "solution": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area\n    \n\ndef _test():\n    import time\n    start = time.clock()\n    assert Solution().maxArea([1,8,6,2,5,4,8,3,7]) == 49\n    assert Solution().maxArea([1,1]) == 1\n    print('Tests passed.')\n    end = time.clock()\n    print('Runtime:', end - start, 'seconds.')\n\n#-------------------------------------------------------------------------------\n\nif __name__ == '__main__':\n    _test()\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------\n\n#-------------------------------------------------------------------------------", "runtimes": [0.0005362033843994141, 0.0005865097045898438, 0.0006687641143798828, 0.001024484634399414, 0.001108407974243164, 0.0011222362518310547, 0.0013108253479003906, 0.0013356208801269531, 0.001341104507446289, 0.0013625621795654297, 0.00136566162109375, 0.0013706684112548828, 0.0013806819915771484, 0.0014047622680664062, 0.001439809799194336, 0.0014584064483642578, 0.0016002655029296875, 0.001607656478881836, 0.0016148090362548828, 0.0016236305236816406, 0.002177715301513672, 0.002721071243286133], "beyond_p": 0.5163683980794412}], "concatenated-words": [{"slug_name": "concatenated-words", "status": {"result": "failed@cases", "runtime": 0.0004143714904785156, "index": 0}, "solution": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def canForm(word, wordDict):\n            if word in wordDict:\n                return True\n            for i in range(1, len(word)):\n                if word[:i] in wordDict and canForm(word[i:], wordDict):\n                    return True\n            return False\n\n        wordDict = set(words)\n        return [word for word in words if canForm(word, wordDict)]", "runtimes": [0.0012485980987548828, 0.0012803077697753906, 0.001329183578491211, 0.0014531612396240234, 0.0017998218536376953, 0.0018155574798583984, 0.001819610595703125, 0.002269744873046875, 0.0038275718688964844, 0.005165815353393555, 0.005602598190307617, 0.005728006362915039, 0.006783723831176758, 0.01154327392578125, 0.024548768997192383], "beyond_p": 0.0}], "base-7": [{"slug_name": "base-7", "status": {"result": "passed", "runtime": 0.0002579689025878906, "index": 0}, "solution": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        elif num < 7:\n            return str(num)\n        else:\n            return self.convertToBase7(num // 7) + str(num % 7)\n\n# Test Cases\nif __name__ == \"__main__\":\n    solution = Solution()\n    assert solution.convertToBase7(100) == \"202\"\n    assert solution.convertToBase7(-7) == \"-10\"\n    assert solution.convertToBase7(0) == \"0\"\n    assert solution.convertToBase7(7) == \"10\"\n\n# Time complexity: O(log7(n))\n# Space complexity: O(log7(n))\n# where n is the input numberclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num == 0:\n            return \"0\"\n        res = []\n        n = abs(num)\n        while n:\n            res.append(str(n % 7))\n            n //= 7\n        if num < 0:\n            res.append(\"-\")\n        return \"\".join(res[::-1])\n\n# Test Cases\nif __name__ == \"__main__\":\n    solution = Solution()\n    assert solution.convertToBase7(100) == \"202\"\n    assert solution.convertToBase7(-7) == \"-10\"\n    assert solution.convertToBase7(0) == \"0\"\n    assert solution.convertToBase7(7) == \"10\"\n\n# Time complexity: O(log7(n))\n# Space complexity: O(log7(n))\n# where n is the input numberclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        if num < 7:\n            return str(num)\n        return self.convertToBase7(num // 7) + str(num % 7)\n\n# Test Cases\nif __name__ == \"__main__\":\n    solution = Solution()\n    assert solution.convertToBase7(100) == \"202\"\n    assert solution.convertToBase7(-7) == \"-10\"\n    assert solution.convertToBase7(0) == \"0\"\n    assert solution.convertToBase7(7) == \"10\"\n\n# Time complexity: O(log7(n))\n# Space complexity: O(log7(n))\n# where n is the input numberclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        if num < 7:\n            return str(num)\n        return self.convertToBase7(num // 7) + str(num % 7)\n\n# Test Cases\nif __name__ == \"__main__\":\n    solution = Solution()\n    assert solution.convertToBase7(100) == \"202\"\n    assert solution.convertToBase7(-7) == \"-10\"\n    assert solution.convertToBase7(0) == \"0\"\n    assert solution.convertToBase7(7) == \"10\"\n\n# Time complexity: O(log7(n))\n# Space complexity: O(log7(n))\n# where n is the input numberclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        if num < 7:\n            return str(num)\n        return self.convertToBase7(num // 7) + str(num % 7)\n\n# Test Cases\nif __name__ == \"__main__\":\n    solution = Solution()\n    assert solution.convertToBase7(100) == \"202\"\n    assert solution.convertToBase7(-7) == \"-10\"\n    assert solution.convertToBase7(0) == \"0\"\n    assert solution.convertToBase7(7) == \"10\"\n\n# Time complexity: O(log", "runtimes": [0.0002474784851074219, 0.0003058910369873047, 0.0003066062927246094, 0.00030732154846191406, 0.00030732154846191406, 0.0003094673156738281, 0.0003094673156738281, 0.0003132820129394531, 0.0003180503845214844, 0.0003199577331542969, 0.0003247261047363281, 0.0003306865692138672], "beyond_p": 0.8739255014326648}], "nim-game": [{"slug_name": "nim-game", "status": {"result": "passed", "runtime": 0.0002574920654296875, "index": 0}, "solution": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0", "runtimes": [0.00026035308837890625, 0.0002605915069580078, 0.0002624988555908203, 0.00026345252990722656, 0.00026535987854003906, 0.0002655982971191406, 0.000270843505859375, 0.00035262107849121094], "beyond_p": 1.0310077519379846}], "n-queens-ii": [{"slug_name": "n-queens-ii", "status": {"result": "passed", "runtime": 0.0005340576171875, "index": 0}, "solution": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def DFS(queens, xy_diff, xy_sum):\n            p = len(queens)\n            if p == n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p - q not in xy_diff and p + q not in xy_sum:\n                    DFS(queens + [q], xy_diff + [p - q], xy_sum + [p + q])\n\n        result = []\n        DFS([], [], [])\n        return len(result)", "runtimes": [0.0003032684326171875, 0.0006496906280517578, 0.0008113384246826172, 0.0009093284606933594, 0.0010004043579101562, 0.0011811256408691406, 0.001224517822265625, 0.0013892650604248047, 0.0014438629150390625, 0.0015027523040771484, 0.0015780925750732422, 0.0016100406646728516, 0.0018091201782226562, 0.002834796905517578, 0.0030307769775390625, 0.003238201141357422, 0.0042421817779541016, 0.004242897033691406, 0.008156061172485352], "beyond_p": 0.9706105595530862}], "n-queens": [{"slug_name": "n-queens", "status": {"result": "passed", "runtime": 0.0005965232849121094, "index": 0}, "solution": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def DFS(queens, xy_diff, xy_sum):\n            p = len(queens)\n            if p == n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_diff and p+q not in xy_sum:\n                    DFS(queens+[q], xy_diff+[p-q], xy_sum+[p+q])\n        \n        result = []\n        DFS([], [], [])\n        return [[\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]", "runtimes": [0.0005888938903808594, 0.0005943775177001953, 0.0009553432464599609, 0.0009760856628417969, 0.0010099411010742188, 0.0011551380157470703, 0.0011718273162841797, 0.0014388561248779297, 0.0014407634735107422, 0.002070188522338867, 0.002116680145263672, 0.0025353431701660156, 0.002629995346069336, 0.0026443004608154297, 0.0027761459350585938, 0.002782583236694336, 0.0028409957885742188, 0.002998828887939453, 0.005638837814331055], "beyond_p": 0.9984892120296492}], "word-search": [{"slug_name": "word-search", "status": {"result": "passed", "runtime": 0.000347137451171875, "index": 0}, "solution": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or word[k] != board[i][j]:\n                return False\n            tmp, board[i][j] = board[i][j], '/'\n            res = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\n            board[i][j] = tmp\n            return res\n        \n        return any(dfs(i, j, 0) for i in range(len(board)) for j in range(len(board[0])))", "runtimes": [0.0003173351287841797, 0.0003190040588378906, 0.00032448768615722656, 0.0003275871276855469, 0.00033092498779296875, 0.0003311634063720703, 0.00033211708068847656, 0.00033545494079589844, 0.00033593177795410156, 0.0003371238708496094, 0.00033855438232421875, 0.00034427642822265625, 0.0003464221954345703, 0.0003559589385986328, 0.0003612041473388672, 0.00036263465881347656, 0.00036525726318359375, 0.0003654956817626953, 0.0003745555877685547, 0.00037550926208496094, 0.0004074573516845703, 0.0004177093505859375, 0.00042939186096191406, 0.0005474090576171875], "beyond_p": 0.8704663212435233}], "merge-sorted-array": [{"slug_name": "merge-sorted-array", "status": {"result": "passed", "runtime": 0.0003809928894042969, "index": 0}, "solution": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        while m > 0 and n > 0:\n            if nums1[m-1] > nums2[n-1]:\n                nums1[m+n-1] = nums1[m-1]\n                m -= 1\n            else:\n                nums1[m+n-1] = nums2[n-1]\n                n -= 1\n        if n > 0:\n            nums1[:n] = nums2[:n]", "runtimes": [0.0003197193145751953, 0.0003256797790527344, 0.0003485679626464844, 0.00034928321838378906, 0.0003504753112792969, 0.0003535747528076172, 0.0003542900085449219, 0.0003650188446044922, 0.0003705024719238281, 0.00037407875061035156, 0.00040221214294433594, 0.00041222572326660156, 0.0004260540008544922, 0.0005316734313964844, 0.0005645751953125, 0.0022411346435546875], "beyond_p": 0.9681101873681598}], "third-maximum-number": [{"slug_name": "third-maximum-number", "status": {"result": "passed", "runtime": 0.0008862018585205078, "index": 0}, "solution": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        nums.sort()\n        if len(nums) < 3:\n            return max(nums)\n        else:\n            return nums[-3]", "runtimes": [0.0008513927459716797, 0.0008707046508789062, 0.0008716583251953125, 0.0008788108825683594, 0.0008823871612548828, 0.0008842945098876953, 0.0008940696716308594, 0.0009005069732666016, 0.0009024143218994141, 0.0009245872497558594, 0.0009427070617675781, 0.0009686946868896484, 0.0009722709655761719, 0.0009920597076416016, 0.0011363029479980469, 0.0019259452819824219, 0.0036385059356689453], "beyond_p": 0.9875106928999144}]}